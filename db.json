{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/favicon.ico","path":"favicon.ico","modified":1,"renderable":0},{"_id":"source/images/example.jpg","path":"images/example.jpg","modified":1,"renderable":0},{"_id":"source/images/commonspool.gif","path":"images/commonspool.gif","modified":1,"renderable":0},{"_id":"source/images/commonspoolflow.png","path":"images/commonspoolflow.png","modified":1,"renderable":0},{"_id":"source/images/mesos.png","path":"images/mesos.png","modified":1,"renderable":0},{"_id":"source/images/nb.jpeg","path":"images/nb.jpeg","modified":1,"renderable":0},{"_id":"source/images/jenkins/container.png","path":"images/jenkins/container.png","modified":1,"renderable":0},{"_id":"source/images/jenkins/jobs.png","path":"images/jenkins/jobs.png","modified":1,"renderable":0},{"_id":"source/images/jenkins/pods1.png","path":"images/jenkins/pods1.png","modified":1,"renderable":0},{"_id":"source/images/jenkins/result2.png","path":"images/jenkins/result2.png","modified":1,"renderable":0},{"_id":"source/images/jenkins/success.png","path":"images/jenkins/success.png","modified":1,"renderable":0},{"_id":"source/images/redis/conn1.png","path":"images/redis/conn1.png","modified":1,"renderable":0},{"_id":"source/images/redis/FULLSYNC.png","path":"images/redis/FULLSYNC.png","modified":1,"renderable":0},{"_id":"source/images/redis/incssync.png","path":"images/redis/incssync.png","modified":1,"renderable":0},{"_id":"source/images/redis/prpogate2.png","path":"images/redis/prpogate2.png","modified":1,"renderable":0},{"_id":"source/images/redis/ping.png","path":"images/redis/ping.png","modified":1,"renderable":0},{"_id":"source/images/redis/prpogate2(1).png","path":"images/redis/prpogate2(1).png","modified":1,"renderable":0},{"_id":"source/images/redis/s1.png","path":"images/redis/s1.png","modified":1,"renderable":0},{"_id":"source/images/redis/s2.png","path":"images/redis/s2.png","modified":1,"renderable":0},{"_id":"source/images/redis/s3.png","path":"images/redis/s3.png","modified":1,"renderable":0},{"_id":"source/images/redis/sentinel.png","path":"images/redis/sentinel.png","modified":1,"renderable":0},{"_id":"source/images/redis/s5.png","path":"images/redis/s5.png","modified":1,"renderable":0},{"_id":"source/images/redis/s4.png","path":"images/redis/s4.png","modified":1,"renderable":0},{"_id":"source/images/redis/state.png","path":"images/redis/state.png","modified":1,"renderable":0},{"_id":"source/images/redis/ziplist.png","path":"images/redis/ziplist.png","modified":1,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next-bak.png","path":"images/favicon-16x16-next-bak.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next-bak.png","path":"images/favicon-32x32-next-bak.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/logoNew.gif","path":"images/logoNew.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/qrcode.jpg","path":"images/qrcode.jpg","modified":1,"renderable":1},{"_id":"source/images/jenkins/config.png","path":"images/jenkins/config.png","modified":1,"renderable":0},{"_id":"source/images/jenkins/config1.png","path":"images/jenkins/config1.png","modified":1,"renderable":0},{"_id":"source/images/jenkins/pvlife.png","path":"images/jenkins/pvlife.png","modified":1,"renderable":0},{"_id":"source/images/jenkins/kongzhimianban.png","path":"images/jenkins/kongzhimianban.png","modified":1,"renderable":0},{"_id":"source/images/redis/ht.png","path":"images/redis/ht.png","modified":1,"renderable":0},{"_id":"themes/next/source/images/bg.png","path":"images/bg.png","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"source/images/jenkins/jenkins-arch.png","path":"images/jenkins/jenkins-arch.png","modified":1,"renderable":0},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1},{"_id":"source/images/tencent.png","path":"images/tencent.png","modified":1,"renderable":0}],"Cache":[{"_id":"source/.DS_Store","hash":"d468f8827860c921bc106db1023fd866c984ff73","modified":1609689739128},{"_id":"source/CNAME","hash":"203e0abd9eda2ec14e33340af19482ad6cbe8b86","modified":1554135328430},{"_id":"source/baidu_verify_pzRlBW6eu6.html","hash":"272583530ec2e714bf3b66721bb33351ba02bc87","modified":1495376283511},{"_id":"source/google43dee7d23dee4e5e.html","hash":"e1c96efbc3f46db33ce06b4cb8612f2645550a4a","modified":1495199541000},{"_id":"themes/next/.DS_Store","hash":"e44674cb2f4ebc4579050d2706136997b6688827","modified":1554134889885},{"_id":"source/favicon.ico","hash":"6a3af5eaeff6a96c373b17afcf3caef6f5030437","modified":1543247248149},{"_id":"themes/next/.all-contributorsrc","hash":"e32dc4075e304af04b98d0726d489081bea722c0","modified":1541695892156},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1541695892156},{"_id":"themes/next/.eslintrc.json","hash":"cc5f297f0322672fe3f684f823bc4659e4a54c41","modified":1541695892157},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1541695892156},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1541695892161},{"_id":"themes/next/_config.yml","hash":"776d99e14b81768cf132dc25d3adb1178d7f5af3","modified":1609690407437},{"_id":"themes/next/.travis.yml","hash":"3d1dc928c4a97933e64379cfde749dedf62f252c","modified":1541695892161},{"_id":"themes/next/bower.json","hash":"087eb7b81c0aa77a2b07c2ecf411ceb5ee00386d","modified":1541695892162},{"_id":"themes/next/LICENSE.md","hash":"fc7227c508af3351120181cbf2f9b99dc41f063e","modified":1590074482608},{"_id":"themes/next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1588260965556},{"_id":"themes/next/gulpfile.coffee","hash":"48d2f9fa88a4210308fc41cc7d3f6d53989f71b7","modified":1541695892165},{"_id":"themes/next/README.md","hash":"ee7119baf976616a84d3c9c10fcab567995dc98e","modified":1590074482609},{"_id":"themes/next/package.json","hash":"cf079447c126a9ad760f1457441f31803ef0470b","modified":1590074482646},{"_id":"source/about/index.md","hash":"23f29fde0d7af97e92222ea1996c6067656615b1","modified":1439392505633},{"_id":"source/_posts/.DS_Store","hash":"3d0728386e12be0e9c65ecd945cb1b3d7f854d45","modified":1609689739124},{"_id":"source/_posts/2020年理财总结.md","hash":"a11002e2e441a9abe74e6bab01bdf29807d25c36","modified":1609690310187},{"_id":"source/_posts/ConcurrentLinkedQueue的几个细节问题.md","hash":"ade34b1e7ab32ff8ce7884c8609a355c35387e29","modified":1542817180622},{"_id":"source/_posts/Mesos安装.md","hash":"cdc53625d5b623eabf01e95f0a4452f36741e684","modified":1556985180862},{"_id":"source/_posts/bloomfilter01.md","hash":"153174b6f56827766ac92b94610ff706f2137fb0","modified":1603084321452},{"_id":"source/_posts/MySQL事务隔离性测试.md","hash":"f564e23d0e44ef07977a71ec57584ebe8c94424d","modified":1542818064066},{"_id":"source/_posts/ioc-one.md","hash":"2d93f5e615d53fd3ec9a4c763bdc65ee985653f0","modified":1542817633905},{"_id":"source/_posts/java-annotation.md","hash":"9590b741d59660803c1d07586e4323638c4ee64b","modified":1556983453705},{"_id":"source/_posts/commons-pool.md","hash":"98051df6b8dd2f9a5df9f5f2421fc3a2c85453fa","modified":1556983200701},{"_id":"source/_posts/jenkins on kubernetes实践.md","hash":"0292da0d932ebb43648d82af40ba016a3884b8a2","modified":1556984659590},{"_id":"source/_posts/restlet-示例.md","hash":"b4a3d5fa080acac767b7aca482a780d06ecfe3ec","modified":1564674951522},{"_id":"source/_posts/sendmail.md","hash":"3e56ad5f964aa9b1a27bc6db382e895bb0c02567","modified":1542817444824},{"_id":"source/_posts/shell-in-action-1.md","hash":"b1b870d4debc24cc7182688d8ed410930d53380f","modified":1556985250577},{"_id":"source/_posts/mongodb-使用spring-data处理嵌套文档的实践.md","hash":"f3624c39d9a1754aa1a00c24c51c8dcb5602d917","modified":1552493498018},{"_id":"source/_posts/thrift源码-客户端.md","hash":"663e831733a7222da9079b8f65dbd241041a0de4","modified":1571932061884},{"_id":"source/_posts/thrift源码（三）服务端.md","hash":"2d2197974b365abc4591fca62305164c64123aac","modified":1571935736780},{"_id":"source/_posts/thrift源码（二）异步客户端.md","hash":"448acb2b6559759c2ae9cce8746dba339b57fc78","modified":1571935880204},{"_id":"source/_posts/thrift源码（五）非阻塞服务端其他实现.md","hash":"41049ba42c1d6f09948a3cd5184497afa4761277","modified":1580387643109},{"_id":"source/_posts/thrift源码（四）非阻塞服务端.md","hash":"d8648f473ad8279d13b04e56be77eaba81c4b420","modified":1574090380117},{"_id":"source/_posts/zookeeper,kafka集群安装.md","hash":"ca27b6eea4f66a096fb9fe3699a07b1f43c0d953","modified":1542817470257},{"_id":"source/_posts/为什么Redis使用ziplist能节省内存.md","hash":"96a65521f521a5edf1d973af4d1de355a2bdeef0","modified":1556985374635},{"_id":"source/_posts/为什么别人能把java-gc讲清楚.md","hash":"8b264bd000bd79faa121650502176de93bf4654b","modified":1592716237564},{"_id":"source/_posts/图解redis sentinel.md","hash":"c71e2172ef300ae3692e676e3173c68f3f24b7c5","modified":1556985647392},{"_id":"source/_posts/图解redis主从.md","hash":"d77dd31148e02839879682aeabe42420cae33e4d","modified":1556986189938},{"_id":"source/_posts/理解CMS回收器的preclean阶段.md","hash":"bfb96db8360462c0b93286297b7bcfc34d85e357","modified":1593144432582},{"_id":"source/_posts/用机器学习判断ins内容是否能上热门.md","hash":"45c25131eddd61e92204e4ff3d17ce6d4bcdf19a","modified":1590166223200},{"_id":"source/_posts/量化交易入门.md","hash":"80edaf28c022bf25eb95a1812aaebf492f241555","modified":1590074484733},{"_id":"source/archives/index.md","hash":"ccdbf097fe4213908d3d79defb700a5259c8505d","modified":1439394724564},{"_id":"source/categories/index.md","hash":"34c838833907f61ac0996d1902f88c9168789eec","modified":1542815973620},{"_id":"source/subject/index.md","hash":"ed1bb8e3213f9f2be0e25382f4deafb23a0881b0","modified":1446222412056},{"_id":"source/tags/.DS_Store","hash":"7b25729ebf047f9e7e2472e957300ec1eadcee81","modified":1542815836561},{"_id":"source/tags/index.md","hash":"eb66ba07ce16ea80ce7725e8cc3209ce1b8ac7f0","modified":1542815480346},{"_id":"source/images/example.jpg","hash":"955fef8a3c526a6535af5efe9153a6b2dfb565c3","modified":1556983397896},{"_id":"source/images/.DS_Store","hash":"a31447b99d6ea19b075cd7b62dfa52596e5ef37a","modified":1580556587087},{"_id":"source/images/commonspool.gif","hash":"e5c3d5e3aeb6226442aca1c57df115e0a033b735","modified":1556982653379},{"_id":"source/images/commonspoolflow.png","hash":"f00c04b086983d2031eb85beb6af71fc337b8b70","modified":1556982981898},{"_id":"source/images/mesos.png","hash":"f605c744c3b58bf1841800425098bbe9b8a52323","modified":1556985156557},{"_id":"themes/next/layout/.DS_Store","hash":"e510b47285f045f9b3f303008f9e163a49bc076e","modified":1554134894895},{"_id":"themes/next/layout/_layout.swig","hash":"85de0662a1b136277a72f8d8b4b1425a006f377e","modified":1590074482625},{"_id":"themes/next/layout/category.swig","hash":"5d955284a42f802a48560b4452c80906a5d1da02","modified":1590074482643},{"_id":"themes/next/layout/archive.swig","hash":"2b6450c6b6d2bcbcd123ad9f59922a5e323d77a5","modified":1590074482643},{"_id":"themes/next/layout/index.swig","hash":"c2a3896c64e96790edc10426ef586b6186a87f46","modified":1590074482644},{"_id":"themes/next/layout/post.swig","hash":"318249db246a57e9422875a2457c6acfce974ba5","modified":1590074482645},{"_id":"themes/next/layout/page.swig","hash":"862b361852fb6d7a95bfb6077922410a33cd3126","modified":1590074482644},{"_id":"themes/next/layout/schedule.swig","hash":"3268dd3d90d8b0e142cfa1a2ebb23355baeda148","modified":1541695892194},{"_id":"themes/next/layout/tag.swig","hash":"ba402ce8fd55e80b240e019e8d8c48949b194373","modified":1590074482645},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"141e989844d0b5ae2e09fb162a280715afb39b0d","modified":1590074482611},{"_id":"themes/next/docs/AUTHORS.md","hash":"7b24be2891167bdedb9284a682c2344ec63e50b5","modified":1590074482612},{"_id":"themes/next/docs/DATA-FILES.md","hash":"8e1962dd3e1b700169b3ae5bba43992f100651ce","modified":1590074482612},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1588260965559},{"_id":"themes/next/docs/INSTALLATION.md","hash":"2bbdd6c1751b2b42ce9b9335da420c6026a483e9","modified":1590074482612},{"_id":"themes/next/docs/LICENSE","hash":"fe607fe22fc9308f6434b892a7f2d2c5514b8f0d","modified":1541695892163},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"120750c03ec30ccaa470b113bbe39f3d423c67f0","modified":1590074482613},{"_id":"themes/next/docs/MATH.md","hash":"e6023505dcccaef0b856102543585a13fc6af0b1","modified":1590074482613},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"ad57c168d12ba01cf144a1ea0627b2ffd1847d3e","modified":1590074482614},{"_id":"themes/next/languages/de.yml","hash":"fb478c5040a4e58a4c1ad5fb52a91e5983d65a3a","modified":1590074482619},{"_id":"themes/next/languages/default.yml.bak","hash":"c540c3a0d7db2d4239293c8783881962640b6c34","modified":1590074482620},{"_id":"themes/next/languages/en.yml","hash":"c540c3a0d7db2d4239293c8783881962640b6c34","modified":1590074482620},{"_id":"themes/next/languages/fr.yml","hash":"0162a85ae4175e66882a9ead1249fedb89200467","modified":1590074482620},{"_id":"themes/next/languages/id.yml","hash":"e7fb582e117a0785036dcdbb853a6551263d6aa6","modified":1590074482620},{"_id":"themes/next/languages/it.yml","hash":"62ef41d0a9a3816939cb4d93a524e6930ab9c517","modified":1590074482621},{"_id":"themes/next/languages/ja.yml","hash":"e331b15b1fda0f2285d25853f834682ab8dc3c39","modified":1590074482621},{"_id":"themes/next/languages/ko.yml","hash":"fae155018ae0efdf68669b2c7dd3f959c2e45cc9","modified":1590074482621},{"_id":"themes/next/languages/nl.yml","hash":"bb9ce8adfa5ee94bc6b5fac6ad24ba4605d180d3","modified":1590074482622},{"_id":"themes/next/languages/pt-BR.yml","hash":"bfc80c8a363fa2e8dde38ea2bc85cd19e15ab653","modified":1590074482622},{"_id":"themes/next/languages/pt.yml","hash":"3cb51937d13ff12fcce747f972ccb664840a9ef3","modified":1590074482622},{"_id":"themes/next/languages/ru.yml","hash":"db0644e738d2306ac38567aa183ca3e859a3980f","modified":1590074482623},{"_id":"themes/next/languages/tr.yml","hash":"c5f0c20743b1dd52ccb256050b1397d023e6bcd9","modified":1590074482623},{"_id":"themes/next/languages/vi.yml","hash":"8da921dd8335dd676efce31bf75fdd4af7ce6448","modified":1590074482624},{"_id":"themes/next/languages/zh-CN.yml","hash":"5ae87a3c6a92b85c75a0247be854f2f23e0483e6","modified":1590074482624},{"_id":"themes/next/scripts/helpers.js","hash":"a70bfad3efda76738dab12e28e8b75e3989ee3da","modified":1541695892195},{"_id":"themes/next/scripts/merge-configs.js","hash":"33afe97284d34542015d358a720823feeebef120","modified":1541695892195},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1541695892195},{"_id":"themes/next/languages/zh-HK.yml","hash":"7903b96912c605e630fb695534012501b2fad805","modified":1590074482625},{"_id":"themes/next/languages/zh-TW.yml","hash":"6e6d2cd8f4244cb1b349b94904cb4770935acefd","modified":1590074482625},{"_id":"themes/next/source/.DS_Store","hash":"16b447f5d35397c472d69e2527562c04f54438cb","modified":1543413224304},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1541695892233},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1541695892233},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1541695892233},{"_id":"source/images/nb.jpeg","hash":"ed4ca9118390beaceb8eec1747209fc09b3c76fb","modified":1590516438539},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1541695892219},{"_id":"source/_posts/2020年理财总结/nio.jpeg","hash":"0d410e7c33c69f170e0863d00b5452517d0ca4cc","modified":1609512494599},{"_id":"source/_posts/restlet-示例/message.png","hash":"e4b10c4502ed32658e7c6bb9b2043ab9e38dcc0f","modified":1556988154643},{"_id":"source/_posts/restlet-示例/resource.png","hash":"9d681b59394dbb0569ede3917a91731885d9552a","modified":1556988177757},{"_id":"source/_posts/restlet-示例/service.png","hash":"cb7c4a3e3f599c05e920279661aede5c3f307b9c","modified":1556988189088},{"_id":"source/_posts/restlet-示例/restlet.png","hash":"7d44bad1ef7171f6a13ebdb426c906934de8163d","modified":1556987987298},{"_id":"source/_posts/thrift源码（四）非阻塞服务端/.DS_Store","hash":"8bd2ef61901c5f3e6bd7becfb5747496c7477f62","modified":1571934697852},{"_id":"source/_posts/为什么别人能把java-gc讲清楚/1.png","hash":"cd7ea1cd7a60a879840ec2ca5ec80f9ca35d7a96","modified":1590517131875},{"_id":"source/_posts/为什么别人能把java-gc讲清楚/2.png","hash":"9006cdba8ec1255beb7a5fa86d49fa269c9e5931","modified":1590517235824},{"_id":"source/_posts/为什么别人能把java-gc讲清楚/3.png","hash":"35ee83b653785f88c41d5a7a115ca9a33cff3c32","modified":1590517242407},{"_id":"source/_posts/为什么别人能把java-gc讲清楚/4.png","hash":"9808377356ae475e52f2bf8430c7d5f3020c9c25","modified":1590517248994},{"_id":"source/_posts/为什么别人能把java-gc讲清楚/5.png","hash":"10370fc6cf3d97f98ed7e68465fae9722eb4e231","modified":1590517255408},{"_id":"source/_posts/为什么别人能把java-gc讲清楚/6.png","hash":"937a8d7a08383ef8aeb9cff5c3f0fc6b9de487c4","modified":1590517262944},{"_id":"source/_posts/用机器学习判断ins内容是否能上热门/.DS_Store","hash":"01ce5e3dc08f9e3dd3a6bb6f3c56c63eabbcbf06","modified":1590076598530},{"_id":"source/_posts/用机器学习判断ins内容是否能上热门/gan.jpg","hash":"f92a92bc7153dcc405146210d041d3a8cb00a3ed","modified":1590076748445},{"_id":"source/_posts/用机器学习判断ins内容是否能上热门/heatmap.png","hash":"76f29213b2e33af5291f1505aaf905e18b602a9e","modified":1589902379271},{"_id":"source/_posts/用机器学习判断ins内容是否能上热门/hot.png","hash":"0a75dbc491f61f9bfd4f671b38c833c9594d7a3c","modified":1589812388843},{"_id":"source/_posts/量化交易入门/found.jpeg","hash":"2e7cb1fb6cf0ab4dbd8a20b685e193ca079ef0a2","modified":1580528054536},{"_id":"source/_posts/量化交易入门/james.jpg","hash":"f273a5a9311026b582606d7ba748c985bb393217","modified":1580489833243},{"_id":"source/images/jenkins/container.png","hash":"2923983f9fd6287f6f17eeba6232cc70137ea07e","modified":1556984904186},{"_id":"source/images/jenkins/jobs.png","hash":"1b4dcd87a841f0b59470a5fff54f80f74f0c4fea","modified":1556984904186},{"_id":"source/images/jenkins/pods1.png","hash":"1891c8a0c5c74ed559176265b8e0972462015b2b","modified":1556984904187},{"_id":"source/images/jenkins/result2.png","hash":"878dab745c2b029986375dbaf1ae43f2791ccca2","modified":1556984904188},{"_id":"source/images/jenkins/success.png","hash":"29e3995a294f95ca5c77036e036794224dfbbcbc","modified":1556984718018},{"_id":"source/images/redis/conn1.png","hash":"f6b32d6d5065a27a1237371bd2aa44a9ffddbdb4","modified":1556985862007},{"_id":"source/images/redis/FULLSYNC.png","hash":"2af7eb0a79f5bf0f24abe38aa3e7d155f944d827","modified":1556985870685},{"_id":"source/images/redis/incssync.png","hash":"0b0dc6c782b3b057fa28f930e0906c19b71eaf34","modified":1556985775701},{"_id":"source/images/redis/prpogate2.png","hash":"77d36507fe2ad3afcd5018229937016c6e3113f9","modified":1556985523466},{"_id":"source/images/redis/ping.png","hash":"d39103c98596e5baf64cbce8ebb4180c93913255","modified":1556985897598},{"_id":"source/images/redis/prpogate2(1).png","hash":"77d36507fe2ad3afcd5018229937016c6e3113f9","modified":1556985885251},{"_id":"source/images/redis/s1.png","hash":"88b53fdfbd383ebff6e9914225b8816b314c67c5","modified":1556985510816},{"_id":"source/images/redis/s2.png","hash":"d0e660f74f1b1ab9a5be46bd0324d6ca7d04b7f6","modified":1556985536861},{"_id":"source/images/redis/s3.png","hash":"352dd683378f950106f68c105409ae7802400e18","modified":1556985543772},{"_id":"source/images/redis/sentinel.png","hash":"104d6a2468f2263bfd282b2e7a7d576a836cefd1","modified":1556985640355},{"_id":"source/images/redis/s5.png","hash":"1bbd1e34a82bcf8cfc0b529497e00cba4eeb7309","modified":1556985584460},{"_id":"source/images/redis/s4.png","hash":"fa6589d6857ccc98acf6b93eb7b779e592f77423","modified":1556985569887},{"_id":"source/images/redis/state.png","hash":"4c39c1757a89998a2701d3fbcc0d2a4b4d8cb0d3","modified":1556985596404},{"_id":"source/images/redis/ziplist.png","hash":"141196130413fb06695f728b6b5a5afcb640e6b9","modified":1556985319133},{"_id":"themes/next/layout/_custom/head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1541695892169},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1541695892169},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1541695892169},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1590074482626},{"_id":"themes/next/layout/_macro/post.swig","hash":"5767eccaf3951151e01c61189016932e9516c8b9","modified":1590074482626},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"0790ddbc349508d7ece45a9a4391d0a1cd7263cc","modified":1541695892171},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"1f3121ef66a4698fd78f34bf2594ef79a407c92c","modified":1590074482626},{"_id":"themes/next/layout/_macro/post-related.swig","hash":"08fe30ce8909b920540231e36c97e28cfbce62b6","modified":1541695892172},{"_id":"themes/next/layout/_macro/reward.swig","hash":"bd5778d509c51f4b1d8da3a2bc35462929f08c75","modified":1541695892172},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"a9e1346b83cf99e06bed59a53fc069279751e52a","modified":1541695892172},{"_id":"themes/next/layout/_partials/breadcrumb.swig","hash":"6994d891e064f10607bce23f6e2997db7994010e","modified":1541695892173},{"_id":"themes/next/layout/_partials/comments.swig","hash":"eafff2d623af8991844f34819a60e37ac11ef245","modified":1590074482627},{"_id":"themes/next/layout/_partials/footer.swig","hash":"d15a983de60d4c0bdd23cd31cd49de876ed2310c","modified":1590074482627},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1aaf32bed57b976c4c1913fd801be34d4838cc72","modified":1541695892174},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"dbe321bcf3cf45917cc11a3e3f50d8572bac2c70","modified":1590074482632},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"ac3ad2c0eccdf16edaa48816d111aaf51200a54b","modified":1590074482633},{"_id":"themes/next/layout/_scripts/.DS_Store","hash":"849bd748ac25417ef71a12466541d7dafdca313a","modified":1554134894900},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"0a0129e926c27fffc6e7ef87fe370016bc7a4564","modified":1541695892180},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"6fc63d5da49cb6157b8792f39c7305b55a0d1593","modified":1541695892180},{"_id":"themes/next/layout/_third-party/bookmark.swig","hash":"60001c8e08b21bf3a7afaf029839e1455340e95d","modified":1541695892186},{"_id":"themes/next/layout/_third-party/copy-code.swig","hash":"a8ab2035654dd06d94faf11a35750529e922d719","modified":1541695892189},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"f532ce257fca6108e84b8f35329c53f272c2ce84","modified":1541695892190},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"f380a10c792411eff82204305b097a288ed0b423","modified":1590074482635},{"_id":"themes/next/layout/_third-party/github-banner.swig","hash":"cabd9640dc3027a0b3ac06f5ebce777e50754065","modified":1541695892191},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"927f19160ae14e7030df306fc7114ba777476282","modified":1541695892191},{"_id":"themes/next/layout/_third-party/pangu.swig","hash":"6b75c5fd76ae7cf0a7b04024510bd5221607eab3","modified":1541695892191},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1590074482641},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1541695892192},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"b0ca46e0d1ff4c08cb0a3a8c1994f20d0260cef9","modified":1541695892192},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"d6d20f60f77a76c77f8e65d0c9adbd79d0274557","modified":1590074482614},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"6c5d69e94961c793da156217ecf1179e868d7ba1","modified":1590074482614},{"_id":"themes/next/docs/ru/README.md","hash":"c54e256ed11a84ee38f755d6f35a3e6e29a91dbc","modified":1590074482615},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"b1dd18d9b890b21718883ea1832e7e02a773104a","modified":1590074482615},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"6855402e2ef59aae307e8bd2a990647d3a605eb8","modified":1590074482615},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"a45a791b49954331390d548ac34169d573ea5922","modified":1590074482616},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"bd2c955d9b7b1b45bd74a4536717d547e03fcde3","modified":1590074482616},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"f3eec572a7d83542e2710a7404082014aaa1a5e7","modified":1590074482617},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"b19a6e0ae96eb7c756fb5b1ba03934c7f9cbb3c3","modified":1590074482617},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"24cf2618d164440b047bb9396263de83bee5b993","modified":1590074482617},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"8ac2f5d2a023211d8d8ea626cbf6b8dea67ac201","modified":1590074482618},{"_id":"themes/next/docs/zh-CN/README.md","hash":"aa6808f4f587c1a97205fa9427ba96a366bcb288","modified":1590074482618},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"5da70d7fa0c988a66a469b9795d33d471a4a4433","modified":1590074482619},{"_id":"themes/next/scripts/tags/button.js","hash":"4b12c376bea894d23cca0f9fcb3d6518b6db279d","modified":1590074482646},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"f13430d9d1c9773b390787c2f046bb1f12a79878","modified":1590074482647},{"_id":"themes/next/scripts/tags/exturl.js","hash":"1412ce2ef59fa4137b697a507fd759ff067a2398","modified":1541695892196},{"_id":"themes/next/scripts/tags/full-image.js","hash":"e282bf5a7c70b3d354001e8f66d3bef1a4fbb79e","modified":1541695892196},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"981e01aaf45a1f0f23ce0796d03134f9e437aaca","modified":1590074482647},{"_id":"themes/next/scripts/tags/include-raw.js","hash":"5db59d56f4f4082382bf1c16722e6c383892b0c5","modified":1541695892196},{"_id":"themes/next/scripts/tags/label.js","hash":"f0ecd3b5773b19a6bd93a819dfe0c49ee418e4de","modified":1590074482648},{"_id":"themes/next/scripts/tags/note.js","hash":"adb945ba93ac487d46b969ca4e59d3681b8f8d1c","modified":1590074482649},{"_id":"themes/next/scripts/tags/tabs.js","hash":"e37761253d68a29593fe9ed2fe403f49b6e971de","modified":1590074482649},{"_id":"themes/next/source/css/.DS_Store","hash":"365dc1ee6afc933cee3bfa4611d037b609f43c3d","modified":1543413229311},{"_id":"themes/next/source/css/main.styl","hash":"c26ca6e7b5bd910b9046d6722c8e00be672890e0","modified":1590074482676},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1588260965666},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1588260965668},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1590074482677},{"_id":"themes/next/source/images/.DS_Store","hash":"d0e4b40bd67f91a1e059b11bf43f87dbf2b77d19","modified":1543502696672},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1588260965667},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1588260965671},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1588260965666},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1588260965665},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1588260965671},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1588260965670},{"_id":"themes/next/source/images/favicon-16x16-next-bak.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1541695892221},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"3ec104ac311b4da9f2fcaabfb839ea6fdcf0b514","modified":1590074482678},{"_id":"themes/next/source/images/favicon-32x32-next-bak.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1541695892221},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1588260965666},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1541695892221},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"6a3af5eaeff6a96c373b17afcf3caef6f5030437","modified":1590074482679},{"_id":"themes/next/source/images/logoNew.gif","hash":"02a742e5cdc5c50031ef0a6b664fd312f5cd0c9d","modified":1543247167082},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1588260965672},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1541695892221},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1588260965667},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1588260965670},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1541695892222},{"_id":"themes/next/source/images/qrcode.jpg","hash":"4eec0b5dd07a5a6f89c343c5e0ae5318a97c63a3","modified":1543247827284},{"_id":"source/_posts/2020年理财总结/vix1.jpeg","hash":"fff493b150dd59bd622058b06aae84749b35859f","modified":1609512541091},{"_id":"source/_posts/2020年理财总结/vix0.jpeg","hash":"ef5209e4da8bf516aa227e998de48a4210f873f4","modified":1609512494333},{"_id":"source/_posts/thrift源码-客户端/overview.png","hash":"7f2545aaf7f67a1905a576ff26d9b1a3fcfe4a39","modified":1558541126886},{"_id":"source/_posts/thrift源码（四）非阻塞服务端/FrameBuffer.png","hash":"a154bf6861f819da9027d32f4db09c4f8da22c4e","modified":1571934051629},{"_id":"source/_posts/thrift源码（四）非阻塞服务端/SelectThread.png","hash":"ef9a5d5f7c06ced9d939fce6592a4f425570cadc","modified":1571933535817},{"_id":"source/_posts/理解CMS回收器的preclean阶段/abpreclean.png","hash":"b578c298170baabbb42a510452f48df528bacc6a","modified":1593073246446},{"_id":"source/_posts/理解CMS回收器的preclean阶段/gc.jpg","hash":"4921399042042e3ddd0aad901faae66abd828c05","modified":1592712872229},{"_id":"source/_posts/理解CMS回收器的preclean阶段/gen1.png","hash":"a6663b0bbe30844a25d0770139657cc81103753f","modified":1593072342040},{"_id":"source/_posts/理解CMS回收器的preclean阶段/gen2.png","hash":"a7759f2232936e874ce06cbcc9077f30a6b5e1a9","modified":1593072358350},{"_id":"source/_posts/用机器学习判断ins内容是否能上热门/histogram.png","hash":"c3e6abfebc00c9bfc6280cd62f1a40367347eefb","modified":1589902892407},{"_id":"source/_posts/用机器学习判断ins内容是否能上热门/jike_ad.jpeg","hash":"cee04ccdc5aa9d6278dbd8270406f771b4d25b0f","modified":1590074721410},{"_id":"source/images/jenkins/config.png","hash":"a9d4d971fc29986120ae2231892a3e3b0e6b83c2","modified":1556984904184},{"_id":"source/images/jenkins/config1.png","hash":"3d8a8a803cb9f757765b1a4eef8681019d180a7e","modified":1556984904185},{"_id":"source/images/jenkins/pvlife.png","hash":"278e1b24a092a32aedda6e007c2ab92d143696e8","modified":1556984713782},{"_id":"source/images/jenkins/kongzhimianban.png","hash":"7ca49f03991a6b8dd15c1ca1746b007f2e289d2b","modified":1556984707656},{"_id":"source/images/redis/ht.png","hash":"66c20f88d33ff7072fc20852b9edaa25c93bf2d8","modified":1556985306856},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1590074482634},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1590074482635},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1541695892213},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1541695892213},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1541695892214},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1590074482674},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1541695892219},{"_id":"source/_posts/thrift源码（五）非阻塞服务端其他实现/reactor-pool.png","hash":"f5e6d9ef5f5649a1f2cb88a950ffc93b8258ef55","modified":1574093307434},{"_id":"source/_posts/量化交易入门/run.png","hash":"c2291bbd616d4b1edd3ad8ee9b8ca3c3a338623a","modified":1580535811650},{"_id":"themes/next/layout/_macro/menu/menu-badge.swig","hash":"65c5e585982dae7ae1542cada71858b4ea1f73d6","modified":1541695892170},{"_id":"themes/next/layout/_macro/menu/menu-item.swig","hash":"d1b73c926109145e52605929b75914cc8b60fb89","modified":1541695892171},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1541695892173},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"fd780171713aada5eb4f4ffed8e714617c8ae6be","modified":1590074482629},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"a7e376b087ae77f2e2a61ba6af81cde5af693174","modified":1590074482627},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"00bf33b3c557b8f7e9faf49b226ea6ff7df5cda0","modified":1590074482628},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"2082f5077551123e695e8afec471c9c44b436acb","modified":1590074482630},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"3db735d0cd2d449edf2674310ac1e7c0043cb357","modified":1590074482631},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"88b4b6051592d26bff59788acb76346ce4e398c2","modified":1590074482631},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1590074482633},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"a33b29ccbdc2248aedff23b04e0627f435824406","modified":1590074482632},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1541695892178},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1541695892179},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1541695892179},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1541695892179},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1541695892179},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"cc865af4a3cb6d25a0be171b7fc919ade306bb50","modified":1541695892181},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"ea03fe9c98ddcfcc0ecfdbe5a2b622f9cde3b3a1","modified":1590074482634},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"ea03fe9c98ddcfcc0ecfdbe5a2b622f9cde3b3a1","modified":1590074482635},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1541695892182},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1541695892182},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"07307f1f0e0e9858f2c7143cbdfcb2a9a92149ab","modified":1541695892183},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1590074482636},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1541695892183},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1541695892183},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"fae69a0e1a1d42f7bb44e594a29857d94594698b","modified":1541695892183},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"beb53371c035b62e1a2c7bb76c63afbb595fe6e5","modified":1590074482636},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"438c6f5e6665d72f4ea7ee206011d669246f6102","modified":1590074482637},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"c28f3f4aa31d7f996d26a97df6cd7ffa9bfd2cec","modified":1541695892184},{"_id":"themes/next/layout/_third-party/analytics/growingio.swig","hash":"5dbeb640707a9c91357e373b9063a48c8e78f439","modified":1590074482637},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1541695892185},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1541695892185},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1541695892186},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"03ef008bc95e8e83232e5464a6c63d6157d33a5e","modified":1590074482638},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1590074482638},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"fe8177e4698df764e470354b6acde8292a3515e0","modified":1541695892188},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"03e83f1311faafb7dddc2899042ed1cacd5c995e","modified":1541695892188},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"2c74a96dd314e804d801f8773ac1b2e0a970fce3","modified":1590074482638},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"34421679cae6581697cd3ab7c3729eb220e3e3f5","modified":1590074482639},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"a6fc00ec7f5642aabd66aa1cf51c6acc5b10e012","modified":1590074482639},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"9b9ff4cc6d5474ab03f09835a2be80e0dba9fe89","modified":1590074482640},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"97dbc2035bcb5aa7eafb80a4202dc827cce34983","modified":1590074482640},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1541695892193},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"b15e10abe85b4270860a56c970b559baa258b2a8","modified":1590074482642},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1541695892193},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1541695892193},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1541695892213},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1541695892213},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"59961fb806a39c367fd19ad37268eee112be6729","modified":1541695892214},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"2640a54fa63bdd4c547eab7ce2fc1192cf0ccec8","modified":1541695892213},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"e1f6f59ad6e562dfe640ee4ed5d1ac9b6aba4114","modified":1590074482673},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1590074482674},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"c167eeb6b736f7b021fba98c38c2c21032ee1255","modified":1590074482675},{"_id":"themes/next/source/css/_variables/base.styl","hash":"2247e277e49ee17fd8ff26d3f3a2a3a61bb3870c","modified":1590074482675},{"_id":"themes/next/source/images/bg.png","hash":"8771e8dce8aa6e86874e0188fbf4ec28f56badca","modified":1543415640140},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"1f7f10c579e7703d0f6acb8b73f3d78a07d0c623","modified":1541695892222},{"_id":"themes/next/source/js/src/affix.js","hash":"a2aab233d99297435a5274bf512c3c753fe08e80","modified":1541695892222},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"1c41508b83cb0c4512e64b4d63afa1be954ce8ef","modified":1541695892222},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1541695892223},{"_id":"themes/next/source/js/src/exturl.js","hash":"54825acc8de4793feac415be227b965428f4e97d","modified":1541695892223},{"_id":"themes/next/source/js/src/motion.js","hash":"b45d2c0d48f2c8e6a0621b8063845f76b89476cc","modified":1541695892223},{"_id":"themes/next/source/js/src/post-details.js","hash":"0dde5e6d4547587662a3256317a9d5d1db507692","modified":1541695892223},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1588260965679},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fa3c92968bcdbcb8d95a1729f7659d9753cbd077","modified":1541695892224},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"d07b3776708d4ae79ed2037c4c7391d5c9b06b19","modified":1541695892224},{"_id":"themes/next/source/js/src/utils.js","hash":"66f2ac658d6110f70a86f784d0c5d891a97c14bd","modified":1541695892224},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1588260965680},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1588260965677},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1588260965680},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1588260965679},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1541695892232},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1588260965676},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1588260965676},{"_id":"source/_posts/thrift源码（四）非阻塞服务端/reactor-single.png","hash":"95816bfa0d221ec62d64e5d92e50fa4a4b693d93","modified":1574090174145},{"_id":"source/_posts/量化交易入门/run1.png","hash":"f0d0107b240932bfa5007469af4821488689cb2c","modified":1580535821855},{"_id":"source/images/jenkins/jenkins-arch.png","hash":"c41dbff4241049ec194e4cffb2616673f9f45cde","modified":1556984699835},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1541695892230},{"_id":"source/_posts/thrift源码（五）非阻塞服务端其他实现/reactor-multi.png","hash":"46644fc3f131c92e9c32193c2fb7498a06c0419d","modified":1574095174809},{"_id":"source/_posts/理解CMS回收器的preclean阶段/summary.png","hash":"8c39fc129d427dbb4e9ea0ca06c833f534f833c6","modified":1593073400883},{"_id":"source/_posts/用机器学习判断ins内容是否能上热门/report.png","hash":"eb0df353763c50a1136023e8d3ead7e95b1020b2","modified":1590164870516},{"_id":"source/_posts/量化交易入门/real.png","hash":"524bd073bddbe4825bb6cb0e002e68cc0c95bb85","modified":1580489389843},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"6958a97fde63e03983ec2394a4f8e408860fb42b","modified":1541695892192},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1541695892192},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"b4a2f1d031fe44452cf55ded8211cf018235073a","modified":1590074482650},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1590074482650},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1541695892198},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1541695892197},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1590074482651},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1541695892200},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1541695892205},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1541695892212},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"efc40a32487e0ac7b94b1ca81bdbdcc4ec8f2924","modified":1541695892212},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"aebbd86500d819c4532ab290c62b6f432bc2f878","modified":1590074482660},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1590074482661},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1590074482662},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"b75256fe3768b1a37b6ff6dd7f9f0ff135a42067","modified":1590074482661},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"02d138ed65060e98f20bc5b1dd59a791222b7156","modified":1590074482663},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"665b1813a1d6fbc3c5549a76e4f26cd62a804dde","modified":1590074482664},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"0bef9f0dc134215bc4d0984ba3a16a1a0b6f87ec","modified":1541695892214},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1541695892214},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"b498068ffbc55ada76f3a8a9ba07fa5122513215","modified":1590074482664},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"f43c821ea272f80703862260b140932fe4aa0e1f","modified":1590074482665},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"2212511ae14258d93bec57993c0385e5ffbb382b","modified":1541695892215},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1541695892215},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"5e12572b18846250e016a872a738026478ceef37","modified":1590074482666},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"35f093fe4c1861661ac1542d6e8ea5a9bbfeb659","modified":1590074482667},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1541695892216},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1590074482666},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1541695892216},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"d5e8ea6336bc2e237d501ed0d5bbcbbfe296c832","modified":1590074482668},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1541695892217},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"876b5d99061025cf485a3cac440624ded5734319","modified":1590074482668},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"05a5abf02e84ba8f639b6f9533418359f0ae4ecb","modified":1590074482669},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"41f9cdafa00e256561c50ae0b97ab7fcd7c1d6a2","modified":1590074482670},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"ffa870c3fa37a48b01dc6f967e66f5df508d02bf","modified":1590074482672},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1541695892217},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"5779cc8086b1cfde9bc4f1afdd85223bdc45f0a0","modified":1590074482672},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"89267bd16ecbedd1958af7f0fb3f4f654d24fffa","modified":1541695892223},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1588260965678},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1588260965679},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1541695892230},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1588260965678},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1541695892230},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1588260965681},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1588260965681},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"39dee82d481dd9d44e33658960ec63e47cd0a715","modified":1541695892198},{"_id":"themes/next/source/css/_common/components/header/github-banner.styl","hash":"ee37e6c465b9b2a7e39175fccfcbed14f2db039b","modified":1541695892198},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"7cc3f36222494c9a1325c5347d7eb9ae53755a32","modified":1543413520948},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1541695892198},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1541695892198},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1541695892199},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1541695892198},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1541695892199},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"a6dc3c7eb81ef5117c28fa2245fff1adc02d0292","modified":1541695892199},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1541695892199},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1541695892199},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1590074482652},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"7dd9a0378ccff3e4a2003f486b1a34e74c20dac6","modified":1590074482652},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"fb451dc4cc0355b57849c27d3eb110c73562f794","modified":1590074482653},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1541695892200},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1590074482653},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"f2911a048e5c20ca2a059bd1087d98ac1c51681c","modified":1590074482653},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1541695892201},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1590074482654},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1590074482654},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1590074482655},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"ca89b167d368eac50a4f808fa53ba67e69cbef94","modified":1590074482655},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"417f05ff12a2aaca6ceeac8b7e7eb26e9440c4c3","modified":1541695892201},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1590074482655},{"_id":"themes/next/source/css/_common/components/post/post-reading_progress.styl","hash":"f4e9f870baa56eae423a123062f00e24cc780be1","modified":1541695892202},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"549a8a0b5301d32acd86a97f17340cdfcd46fb63","modified":1590074482656},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1590074482657},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"fcbbf06b546c366d70b7d2ba5880b0be3ca1e8ea","modified":1541695892202},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1590074482657},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1541695892203},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"578bb2d5f24cad39205bbafb4c39c7e9962b9fa9","modified":1590074482658},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"6089cbf4c907fe198b6501e40dc937480d0be175","modified":1590074482658},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"35c0350096921dd8e2222ec41b6c17a4ea6b44f2","modified":1541695892203},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"e18b90c97aaff027e795f5a0cb10476a71bf1c3a","modified":1541695892203},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1541695892204},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1541695892204},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1541695892204},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1541695892204},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"4427ed3250483ed5b7baad74fa93474bd1eda729","modified":1541695892204},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1541695892204},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1541695892205},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"43bc58daa8d35d5d515dc787ceb21dd77633fe49","modified":1541695892204},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1541695892205},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"6ec8ea7b11a146777b6b8da0f71f0cc1dbd129df","modified":1541695892205},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1541695892205},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1541695892206},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1541695892206},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1541695892206},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"5e340ee2407a4e39cd708794cfcc718a5f398d7b","modified":1541695892206},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1541695892206},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"10e9bb3392826a5a8f4cabfc14c6d81645f33fe6","modified":1541695892206},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1541695892207},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1541695892207},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1541695892207},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1541695892207},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1541695892207},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"76937db9702053d772f6758d9cea4088c2a6e2a3","modified":1590074482659},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1c18c91ab3c60169ebe654c80c968fd8458786a3","modified":1590074482660},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1541695892215},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1541695892216},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1541695892216},{"_id":"source/_posts/thrift源码（二）异步客户端/thrift-client-call.png","hash":"19237bbbf1ee0811bce0a768246ca4355c5e487b","modified":1565880673595},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1588260965682},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1541695892232},{"_id":"source/_posts/thrift源码（四）非阻塞服务端/serverflow.png","hash":"04cc50baf21975546bfa76e8f380416036294de6","modified":1571934534530},{"_id":"source/images/tencent.png","hash":"fbf36a5a12e73f47f75a0b686ac673ce95511d5b","modified":1588251307626},{"_id":"source/_posts/thrift源码（二）异步客户端/client-init.png","hash":"e921f71bf46398b9b547f2c2a0f03898e54bf018","modified":1565020069035},{"_id":"source/_posts/thrift源码（四）非阻塞服务端/FrameBufferState.png","hash":"115df79ca97225b70d17e046518b338681814133","modified":1571934297768},{"_id":"source/_posts/量化交易入门/debug.png","hash":"771343836519fdebc9e73e849ff81fe75910925b","modified":1580488891646},{"_id":"source/_posts/用机器学习判断ins内容是否能上热门/ins.png","hash":"a0d15461d68201c3b44ebf27eb44feb932407fe1","modified":1590076380514},{"_id":"public/baidu_verify_pzRlBW6eu6.html","hash":"57c3a2149a73a5ffebf09819d7e27a9adc41c1db","modified":1612426980926},{"_id":"public/google43dee7d23dee4e5e.html","hash":"b93b2a9da8ed306980107f63f71fd02ae4234b27","modified":1612426980926},{"_id":"public/about/index.html","hash":"ada17bb38d133dfe82cc795fb42aa8153ec1f6ed","modified":1612426980926},{"_id":"public/categories/index.html","hash":"94145f325e0a9d0cdfa4d5e3d439587efa1e785a","modified":1612426980926},{"_id":"public/subject/index.html","hash":"ded9c306873bfe3bca262a63a59ea4fe22239555","modified":1612426980926},{"_id":"public/archives/2015/index.html","hash":"15433de91eb9991074ebd312a8efeb49329deee6","modified":1612426980926},{"_id":"public/archives/2015/12/index.html","hash":"9c77deac4797f032a2324f94f5dfe9e21a61d6e0","modified":1612426980926},{"_id":"public/archives/2016/index.html","hash":"ae6f2e6dd938021654e19ac733a167810f40f08e","modified":1612426980927},{"_id":"public/archives/2016/01/index.html","hash":"1e93003df81377bdfd24806b9fb784f35430b89b","modified":1612426980927},{"_id":"public/archives/2016/09/index.html","hash":"e6937d31ad33c3b82db3ffd8661faaa7c13256aa","modified":1612426980927},{"_id":"public/archives/2017/06/index.html","hash":"526b1e30eecd1d8b1fe07d0e780c1d3fc0324f28","modified":1612426980927},{"_id":"public/archives/2017/07/index.html","hash":"04e2425c826e1f0d8c73a0a71893e19c4695bed2","modified":1612426980927},{"_id":"public/archives/2017/08/index.html","hash":"a15ecec902ef92485bcb53ccbd57ec6e86ad2366","modified":1612426980927},{"_id":"public/archives/2017/09/index.html","hash":"af31baa17daa20f5e64a4940e3f60717636c5d23","modified":1612426980927},{"_id":"public/archives/2017/10/index.html","hash":"defc6174ee1404a5c56aa5efc63a69b074c02faa","modified":1612426980927},{"_id":"public/archives/2017/11/index.html","hash":"e1dd9c5814a7fb7e571c6d3b04b678305cfe4db5","modified":1612426980927},{"_id":"public/archives/2017/12/index.html","hash":"6ff8b73cd8371dba70867fd1bdb8afa7bb61c11b","modified":1612426980927},{"_id":"public/archives/2018/index.html","hash":"7f15e01cdbede4e99f681b30fb237b0426fd8300","modified":1612426980927},{"_id":"public/archives/2018/02/index.html","hash":"481d735730e5057b99ead5401b43b573a3eea352","modified":1612426980927},{"_id":"public/archives/2018/06/index.html","hash":"093ad20e14dfd920d280d02533804535319f9070","modified":1612426980927},{"_id":"public/archives/2019/05/index.html","hash":"d99ca00daca51c0c29f8c4f412e84304a56de8a1","modified":1612426980927},{"_id":"public/archives/2019/08/index.html","hash":"ae5887afaad8f8a5da83266bf8d76f6683c8a521","modified":1612426980927},{"_id":"public/archives/2019/10/index.html","hash":"eb11d874bdad21f74c50877337e53dbd33cd2698","modified":1612426980927},{"_id":"public/archives/2019/11/index.html","hash":"b28726a26b293060183e33f9de90dad0f0c524f6","modified":1612426980927},{"_id":"public/archives/2020/01/index.html","hash":"eb63cba25d32c868d73066d81a44d9c214c076c5","modified":1612426980928},{"_id":"public/archives/2020/05/index.html","hash":"50aa388cba791489382e86494bd133bc18a607aa","modified":1612426980928},{"_id":"public/archives/2020/06/index.html","hash":"5806d4c143328989377d8f5534dcea8500097b15","modified":1612426980928},{"_id":"public/archives/2020/08/index.html","hash":"6dc99b2a341783c61da435c74204db77c7f57651","modified":1612426980928},{"_id":"public/archives/2020/12/index.html","hash":"e8f8388e3261e72d8ddeb19eaf1c815c85aacfab","modified":1612426980928},{"_id":"public/tags/java基础/index.html","hash":"9e2f4b6ee379ded2045b759ecf942dbc615be2f3","modified":1612426980928},{"_id":"public/tags/并发/index.html","hash":"fb2a74e4bbbe074f4908c28d0b9d0afd8d821e23","modified":1612426980928},{"_id":"public/tags/mesos/index.html","hash":"74ed59c3690e7fdd18ae5f4cddfee3922a7b89d3","modified":1612426980928},{"_id":"public/tags/mysql/index.html","hash":"bb5c6b23ad81f89958398a838fb29768fea8a64d","modified":1612426980928},{"_id":"public/tags/数据库/index.html","hash":"4aa6ebb003be6e445accc29627ca8bb4e7f7a3a4","modified":1612426980928},{"_id":"public/tags/Spring/index.html","hash":"29c03239cbe67ddcb75393774bb88b2ce63f0b2e","modified":1612426980928},{"_id":"public/tags/注解/index.html","hash":"9d7bf3ef38ba9ab52664f94a0a61a21bdf927c13","modified":1612426980928},{"_id":"public/tags/annotation/index.html","hash":"ce851f7d719c6b8390b60cbc576eff579f11d74a","modified":1612426980928},{"_id":"public/tags/邮件/index.html","hash":"43f922bae38b6fcced9e68e2a0db3a5ad2128dd2","modified":1612426980928},{"_id":"public/tags/shell/index.html","hash":"dbc4374df929d5518a43f41c9d2ad42ed00b40b9","modified":1612426980928},{"_id":"public/tags/Linux/index.html","hash":"c5c727a89372db55960b362f770596b7daf5c0b6","modified":1612426980928},{"_id":"public/tags/thrift/index.html","hash":"5631353b445ac9e31970cbf8ce7b1c213dc62243","modified":1612426980928},{"_id":"public/tags/rpc框架/index.html","hash":"f7364b2ebb12b8703907e22debaee74f6a84862a","modified":1612426980928},{"_id":"public/tags/kafaka/index.html","hash":"d82d647b11a499cf73519b288fdf39c09c13533c","modified":1612426980928},{"_id":"public/tags/zookeeper/index.html","hash":"21cf6821b8d7df51c310e39b0c769a337c8a9a5d","modified":1612426980928},{"_id":"public/tags/集群/index.html","hash":"95b82672c91e75658090f9d5eb5515e964790722","modified":1612426980928},{"_id":"public/tags/redis/index.html","hash":"aef042b28584085ad637c845f125d07c7700fbd2","modified":1612426980928},{"_id":"public/tags/nosql/index.html","hash":"903b6c36f2b3e23313900e0804cb27044d223f49","modified":1612426980928},{"_id":"public/tags/源码/index.html","hash":"153a688a668659a190c639adb5eafe775478926c","modified":1612426980929},{"_id":"public/tags/理财/index.html","hash":"9d94d13363144d8eea078df1a158c5b8e0aa9db7","modified":1612426980929},{"_id":"public/tags/中间件/index.html","hash":"31b6b32e13badb2701b0b581200e3e2b9ebd5fc9","modified":1612426980929},{"_id":"public/tags/jenkins/index.html","hash":"3db4af532b2420a441c025d27ef65eac7af51645","modified":1612426980929},{"_id":"public/tags/docker/index.html","hash":"8525a77056ca37852217e623ede4d44256cb35a1","modified":1612426980929},{"_id":"public/tags/kubernetes/index.html","hash":"f2ccd1f3941d006bc4bd05a9c770bcf1b763d133","modified":1612426980929},{"_id":"public/tags/mongodb/index.html","hash":"8a42009dc49815019efb8723e0fbf4989eed9fed","modified":1612426980929},{"_id":"public/tags/连接池/index.html","hash":"7072d3469faf5d263903489c241f39d44d817c4b","modified":1612426980929},{"_id":"public/tags/springboot/index.html","hash":"7bdfc98cc017ad7c902201f2586d264349404e1c","modified":1612426980929},{"_id":"public/tags/commons-pool/index.html","hash":"881868d1db38fb478fd82bd8ea098ef433144e23","modified":1612426980929},{"_id":"public/tags/算法/index.html","hash":"728c1444532f6e1b4aac62e3fcd6d3354e02c374","modified":1612426980929},{"_id":"public/categories/jdk源码/index.html","hash":"d29eed7a3d24f639ab4dafaee05976b96d10c142","modified":1612426980929},{"_id":"public/categories/容器技术/index.html","hash":"b225cb23e4d1e0448d8bb3915ceee10eebc90cba","modified":1612426980929},{"_id":"public/categories/mysql进阶/index.html","hash":"3063ff4e8d54636a344eb8e2607f734ba31ba299","modified":1612426980929},{"_id":"public/categories/thrift源码/index.html","hash":"a2f063f744c2ff9294066ba57c51cd5d0907d5ee","modified":1612426980929},{"_id":"public/categories/redis进阶/index.html","hash":"04f3338fa890e9407ffe4da1b9a4316a8a6a3d55","modified":1612426980929},{"_id":"public/categories/mongodb/index.html","hash":"a36d3ad0c0d042e6030b7b901ce2f4ee34372c6a","modified":1612426980929},{"_id":"public/categories/开源框架/index.html","hash":"1f6c2cd3055b3775a27ef9847dc03307174f5f16","modified":1612426980929},{"_id":"public/archives/index.html","hash":"d8cceabea658943847bbb9ae0b615e4bd28d12e3","modified":1612426980929},{"_id":"public/tags/index.html","hash":"9a708d008e5d9f48e0476167b1229d7c1a281060","modified":1612426980930},{"_id":"public/2020/12/31/2020年理财总结/index.html","hash":"05e21173a1fafcf6a67b471726b9936102dbecb4","modified":1612426980930},{"_id":"public/2020/08/19/bloomfilter01/index.html","hash":"55cd45e24154cab9e807e7a0fa7c69030147cae4","modified":1612426980930},{"_id":"public/2020/06/21/理解CMS回收器的preclean阶段/index.html","hash":"4ae1afbeabc7c9e1c8c153d621304a8b10528e85","modified":1612426980930},{"_id":"public/2020/05/27/为什么别人能把java-gc讲清楚/index.html","hash":"5cb149bb8b8307d35609211e1686981b625f12f9","modified":1612426980930},{"_id":"public/2020/05/21/用机器学习判断ins内容是否能上热门/index.html","hash":"9fa6627dbb0428238f1d57733c049c8ce1bbc495","modified":1612426980930},{"_id":"public/2020/01/31/量化交易入门/index.html","hash":"635e7efd62b39b1a457db8f35e884f019ec90fbf","modified":1612426980930},{"_id":"public/2019/11/18/thrift源码（五）非阻塞服务端其他实现/index.html","hash":"6a99228cfee453b1a6f4b7c31d1d0efdfe3829c4","modified":1612426980930},{"_id":"public/2019/10/25/thrift源码（四）非阻塞服务端/index.html","hash":"78a529551b10502b04fc68a86efa051e3d39191a","modified":1612426980930},{"_id":"public/2019/10/24/thrift源码（三）服务端/index.html","hash":"88e25dfa63fa626e3c0f77b50242b7d63abd7199","modified":1612426980930},{"_id":"public/2019/08/05/thrift源码（二）异步客户端/index.html","hash":"f2cd01f016415881b184c09d8890f97dd00f963e","modified":1612426980930},{"_id":"public/2019/05/22/thrift源码-客户端/index.html","hash":"4c38d078c337bee952a97088d652e17f5cf76da1","modified":1612426980930},{"_id":"public/2019/05/05/restlet-示例/index.html","hash":"405f52453d9f74793c0527eb816643023d6b6ae5","modified":1612426980930},{"_id":"public/2018/06/12/mongodb-使用spring-data处理嵌套文档的实践/index.html","hash":"835a9d971909369917a645c1f33ef9227dd05ff6","modified":1612426980930},{"_id":"public/2018/02/22/ConcurrentLinkedQueue的几个细节问题/index.html","hash":"fc7eb7b80a591bc2427a5ceaba494d2f092afbf3","modified":1612426980930},{"_id":"public/2018/02/02/MySQL事务隔离性测试/index.html","hash":"3ef46ccbcace21f46c45f031a7c48cebb8bdea3a","modified":1612426980930},{"_id":"public/2017/12/26/Mesos安装/index.html","hash":"d8b6dc2bf856d73932ca569e41953a0b9d67fcd0","modified":1612426980930},{"_id":"public/2017/11/21/图解redis sentinel/index.html","hash":"1a6fad99c08913d558ba6c2fe84814c76ea606c7","modified":1612426980930},{"_id":"public/2017/10/22/图解redis主从/index.html","hash":"865cdaac7e4ce1ae1225034fdaa95b97b3ca4c30","modified":1612426980930},{"_id":"public/2017/09/12/为什么Redis使用ziplist能节省内存/index.html","hash":"d3fd9f7b8781bf8c1eadd4c4ee7ee4015630a46f","modified":1612426980931},{"_id":"public/2017/08/26/jenkins on kubernetes实践/index.html","hash":"f2d9e79610c512bc6ca047e0913aec3e23930eae","modified":1612426980931},{"_id":"public/2017/07/26/zookeeper,kafka集群安装/index.html","hash":"bbc37ac698352a6ee7d185839818f7c73436c9e7","modified":1612426980931},{"_id":"public/2017/06/12/commons-pool/index.html","hash":"e6290b248f95ee324d8825f2f43729abd15649f9","modified":1612426980931},{"_id":"public/2016/09/28/ioc-one/index.html","hash":"18f9085f40a8f5343d737442642aef48576f208d","modified":1612426980931},{"_id":"public/2016/01/26/java-annotation/index.html","hash":"931c9fdb6ba0b6d0a17bb79b764a2a75681f1593","modified":1612426980931},{"_id":"public/2015/12/26/sendmail/index.html","hash":"9577268ba4b6b8ad650e66a9ff7c279021671f8e","modified":1612426980931},{"_id":"public/2015/12/01/shell-in-action-1/index.html","hash":"115e600a5da10bd72ce81c6f34af1990890df7dd","modified":1612426980931},{"_id":"public/index.html","hash":"04fd1c7b684ce4c3f8fbf706d0400cbbaa4649ee","modified":1612426980931},{"_id":"public/page/2/index.html","hash":"407c59e85540615ebe36977aa2179586ab455558","modified":1612426980931},{"_id":"public/page/3/index.html","hash":"bb1f7bee1b1c02001b0408e47751f84dce350471","modified":1612426980931},{"_id":"public/archives/page/2/index.html","hash":"d5276a2eb8663bc03bc340533f12caaa522f09cb","modified":1612426980931},{"_id":"public/archives/page/3/index.html","hash":"f3d68f8ed00b4f621070ac221bec303dad1a8b29","modified":1612426980931},{"_id":"public/archives/2017/index.html","hash":"1530e2ae81ffd1251b84a60d37c76603b780fd99","modified":1612426980931},{"_id":"public/archives/2019/index.html","hash":"90312888c3a082de2f5b2041fb8c73dc27e04654","modified":1612426980932},{"_id":"public/archives/2020/index.html","hash":"1b1f834a7f8cf1d69eef888599c5b46d4ba9c296","modified":1612426980932},{"_id":"public/CNAME","hash":"203e0abd9eda2ec14e33340af19482ad6cbe8b86","modified":1612426980950},{"_id":"public/favicon.ico","hash":"6a3af5eaeff6a96c373b17afcf3caef6f5030437","modified":1612426980950},{"_id":"public/images/example.jpg","hash":"955fef8a3c526a6535af5efe9153a6b2dfb565c3","modified":1612426980950},{"_id":"public/images/commonspool.gif","hash":"e5c3d5e3aeb6226442aca1c57df115e0a033b735","modified":1612426980950},{"_id":"public/images/commonspoolflow.png","hash":"f00c04b086983d2031eb85beb6af71fc337b8b70","modified":1612426980950},{"_id":"public/images/jenkins/container.png","hash":"2923983f9fd6287f6f17eeba6232cc70137ea07e","modified":1612426980950},{"_id":"public/images/jenkins/success.png","hash":"29e3995a294f95ca5c77036e036794224dfbbcbc","modified":1612426980950},{"_id":"public/images/jenkins/result2.png","hash":"878dab745c2b029986375dbaf1ae43f2791ccca2","modified":1612426980950},{"_id":"public/images/jenkins/pods1.png","hash":"1891c8a0c5c74ed559176265b8e0972462015b2b","modified":1612426980950},{"_id":"public/images/redis/FULLSYNC.png","hash":"2af7eb0a79f5bf0f24abe38aa3e7d155f944d827","modified":1612426980950},{"_id":"public/images/redis/prpogate2.png","hash":"77d36507fe2ad3afcd5018229937016c6e3113f9","modified":1612426980950},{"_id":"public/images/redis/incssync.png","hash":"0b0dc6c782b3b057fa28f930e0906c19b71eaf34","modified":1612426980950},{"_id":"public/images/redis/ping.png","hash":"d39103c98596e5baf64cbce8ebb4180c93913255","modified":1612426980950},{"_id":"public/images/redis/conn1.png","hash":"f6b32d6d5065a27a1237371bd2aa44a9ffddbdb4","modified":1612426980950},{"_id":"public/images/redis/s2.png","hash":"d0e660f74f1b1ab9a5be46bd0324d6ca7d04b7f6","modified":1612426980950},{"_id":"public/images/jenkins/jobs.png","hash":"1b4dcd87a841f0b59470a5fff54f80f74f0c4fea","modified":1612426980951},{"_id":"public/images/redis/s1.png","hash":"88b53fdfbd383ebff6e9914225b8816b314c67c5","modified":1612426980951},{"_id":"public/images/redis/prpogate2(1).png","hash":"77d36507fe2ad3afcd5018229937016c6e3113f9","modified":1612426980951},{"_id":"public/images/redis/s3.png","hash":"352dd683378f950106f68c105409ae7802400e18","modified":1612426980951},{"_id":"public/images/redis/sentinel.png","hash":"104d6a2468f2263bfd282b2e7a7d576a836cefd1","modified":1612426980951},{"_id":"public/images/redis/s4.png","hash":"fa6589d6857ccc98acf6b93eb7b779e592f77423","modified":1612426980952},{"_id":"public/images/redis/state.png","hash":"4c39c1757a89998a2701d3fbcc0d2a4b4d8cb0d3","modified":1612426980952},{"_id":"public/images/redis/ziplist.png","hash":"141196130413fb06695f728b6b5a5afcb640e6b9","modified":1612426980952},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1612426980952},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1612426980952},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1612426980952},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1612426980952},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1612426980952},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1612426980952},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1612426980952},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1612426980952},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1612426980952},{"_id":"public/images/favicon-16x16-next-bak.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1612426980952},{"_id":"public/images/favicon-16x16-next.png","hash":"3ec104ac311b4da9f2fcaabfb839ea6fdcf0b514","modified":1612426980952},{"_id":"public/images/favicon-32x32-next-bak.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1612426980952},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1612426980952},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1612426980952},{"_id":"public/images/favicon-32x32-next.png","hash":"6a3af5eaeff6a96c373b17afcf3caef6f5030437","modified":1612426980952},{"_id":"public/images/logoNew.gif","hash":"02a742e5cdc5c50031ef0a6b664fd312f5cd0c9d","modified":1612426980952},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1612426980952},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1612426980952},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1612426980952},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1612426980952},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1612426980952},{"_id":"public/images/qrcode.jpg","hash":"4eec0b5dd07a5a6f89c343c5e0ae5318a97c63a3","modified":1612426980952},{"_id":"public/images/jenkins/config.png","hash":"a9d4d971fc29986120ae2231892a3e3b0e6b83c2","modified":1612426980952},{"_id":"public/images/jenkins/config1.png","hash":"3d8a8a803cb9f757765b1a4eef8681019d180a7e","modified":1612426980952},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1612426980952},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1612426980952},{"_id":"public/2019/05/05/restlet-示例/message.png","hash":"e4b10c4502ed32658e7c6bb9b2043ab9e38dcc0f","modified":1612426980952},{"_id":"public/2019/05/05/restlet-示例/resource.png","hash":"9d681b59394dbb0569ede3917a91731885d9552a","modified":1612426980953},{"_id":"public/2019/05/05/restlet-示例/restlet.png","hash":"7d44bad1ef7171f6a13ebdb426c906934de8163d","modified":1612426980953},{"_id":"public/2019/05/05/restlet-示例/service.png","hash":"cb7c4a3e3f599c05e920279661aede5c3f307b9c","modified":1612426980953},{"_id":"public/2020/05/27/为什么别人能把java-gc讲清楚/1.png","hash":"cd7ea1cd7a60a879840ec2ca5ec80f9ca35d7a96","modified":1612426980953},{"_id":"public/2020/05/27/为什么别人能把java-gc讲清楚/2.png","hash":"9006cdba8ec1255beb7a5fa86d49fa269c9e5931","modified":1612426980953},{"_id":"public/2020/05/27/为什么别人能把java-gc讲清楚/3.png","hash":"35ee83b653785f88c41d5a7a115ca9a33cff3c32","modified":1612426980953},{"_id":"public/2020/05/27/为什么别人能把java-gc讲清楚/4.png","hash":"9808377356ae475e52f2bf8430c7d5f3020c9c25","modified":1612426980953},{"_id":"public/2020/05/27/为什么别人能把java-gc讲清楚/5.png","hash":"10370fc6cf3d97f98ed7e68465fae9722eb4e231","modified":1612426980953},{"_id":"public/2020/05/27/为什么别人能把java-gc讲清楚/6.png","hash":"937a8d7a08383ef8aeb9cff5c3f0fc6b9de487c4","modified":1612426980953},{"_id":"public/2020/01/31/量化交易入门/found.jpeg","hash":"2e7cb1fb6cf0ab4dbd8a20b685e193ca079ef0a2","modified":1612426980953},{"_id":"public/2020/01/31/量化交易入门/james.jpg","hash":"f273a5a9311026b582606d7ba748c985bb393217","modified":1612426980953},{"_id":"public/2020/12/31/2020年理财总结/nio.jpeg","hash":"0d410e7c33c69f170e0863d00b5452517d0ca4cc","modified":1612426980953},{"_id":"public/2019/10/25/thrift源码（四）非阻塞服务端/SelectThread.png","hash":"ef9a5d5f7c06ced9d939fce6592a4f425570cadc","modified":1612426980953},{"_id":"public/2020/06/21/理解CMS回收器的preclean阶段/abpreclean.png","hash":"b578c298170baabbb42a510452f48df528bacc6a","modified":1612426980953},{"_id":"public/2020/06/21/理解CMS回收器的preclean阶段/gc.jpg","hash":"4921399042042e3ddd0aad901faae66abd828c05","modified":1612426980953},{"_id":"public/2020/06/21/理解CMS回收器的preclean阶段/gen1.png","hash":"a6663b0bbe30844a25d0770139657cc81103753f","modified":1612426980953},{"_id":"public/2020/05/21/用机器学习判断ins内容是否能上热门/gan.jpg","hash":"f92a92bc7153dcc405146210d041d3a8cb00a3ed","modified":1612426980953},{"_id":"public/2020/05/21/用机器学习判断ins内容是否能上热门/hot.png","hash":"0a75dbc491f61f9bfd4f671b38c833c9594d7a3c","modified":1612426980953},{"_id":"public/2020/05/21/用机器学习判断ins内容是否能上热门/heatmap.png","hash":"76f29213b2e33af5291f1505aaf905e18b602a9e","modified":1612426980953},{"_id":"public/images/mesos.png","hash":"f605c744c3b58bf1841800425098bbe9b8a52323","modified":1612426980972},{"_id":"public/images/nb.jpeg","hash":"ed4ca9118390beaceb8eec1747209fc09b3c76fb","modified":1612426981443},{"_id":"public/images/redis/s5.png","hash":"1bbd1e34a82bcf8cfc0b529497e00cba4eeb7309","modified":1612426981444},{"_id":"public/images/jenkins/pvlife.png","hash":"278e1b24a092a32aedda6e007c2ab92d143696e8","modified":1612426981445},{"_id":"public/images/jenkins/kongzhimianban.png","hash":"7ca49f03991a6b8dd15c1ca1746b007f2e289d2b","modified":1612426981445},{"_id":"public/images/redis/ht.png","hash":"66c20f88d33ff7072fc20852b9edaa25c93bf2d8","modified":1612426981445},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1612426981445},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1612426981445},{"_id":"public/2019/05/22/thrift源码-客户端/overview.png","hash":"7f2545aaf7f67a1905a576ff26d9b1a3fcfe4a39","modified":1612426981445},{"_id":"public/2020/12/31/2020年理财总结/vix0.jpeg","hash":"ef5209e4da8bf516aa227e998de48a4210f873f4","modified":1612426981448},{"_id":"public/2020/12/31/2020年理财总结/vix1.jpeg","hash":"fff493b150dd59bd622058b06aae84749b35859f","modified":1612426981448},{"_id":"public/2019/10/25/thrift源码（四）非阻塞服务端/FrameBuffer.png","hash":"a154bf6861f819da9027d32f4db09c4f8da22c4e","modified":1612426981448},{"_id":"public/2020/06/21/理解CMS回收器的preclean阶段/gen2.png","hash":"a7759f2232936e874ce06cbcc9077f30a6b5e1a9","modified":1612426981448},{"_id":"public/2020/05/21/用机器学习判断ins内容是否能上热门/histogram.png","hash":"c3e6abfebc00c9bfc6280cd62f1a40367347eefb","modified":1612426981448},{"_id":"public/2020/05/21/用机器学习判断ins内容是否能上热门/jike_ad.jpeg","hash":"cee04ccdc5aa9d6278dbd8270406f771b4d25b0f","modified":1612426981448},{"_id":"public/js/src/algolia-search.js","hash":"1f7f10c579e7703d0f6acb8b73f3d78a07d0c623","modified":1612426981454},{"_id":"public/js/src/affix.js","hash":"a2aab233d99297435a5274bf512c3c753fe08e80","modified":1612426981454},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1612426981455},{"_id":"public/js/src/bootstrap.js","hash":"1c41508b83cb0c4512e64b4d63afa1be954ce8ef","modified":1612426981455},{"_id":"public/js/src/exturl.js","hash":"54825acc8de4793feac415be227b965428f4e97d","modified":1612426981455},{"_id":"public/js/src/post-details.js","hash":"0dde5e6d4547587662a3256317a9d5d1db507692","modified":1612426981455},{"_id":"public/js/src/scrollspy.js","hash":"fa3c92968bcdbcb8d95a1729f7659d9753cbd077","modified":1612426981455},{"_id":"public/js/src/scroll-cookie.js","hash":"d07b3776708d4ae79ed2037c4c7391d5c9b06b19","modified":1612426981455},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1612426981455},{"_id":"public/js/src/schemes/pisces.js","hash":"89267bd16ecbedd1958af7f0fb3f4f654d24fffa","modified":1612426981455},{"_id":"public/css/main.css","hash":"09d77793129cd15bca8190dd88b295739368da30","modified":1612426981455},{"_id":"public/images/bg.png","hash":"8771e8dce8aa6e86874e0188fbf4ec28f56badca","modified":1612426981455},{"_id":"public/images/jenkins/jenkins-arch.png","hash":"c41dbff4241049ec194e4cffb2616673f9f45cde","modified":1612426981455},{"_id":"public/2019/11/18/thrift源码（五）非阻塞服务端其他实现/reactor-pool.png","hash":"f5e6d9ef5f5649a1f2cb88a950ffc93b8258ef55","modified":1612426981455},{"_id":"public/js/src/motion.js","hash":"b45d2c0d48f2c8e6a0621b8063845f76b89476cc","modified":1612426981493},{"_id":"public/js/src/utils.js","hash":"66f2ac658d6110f70a86f784d0c5d891a97c14bd","modified":1612426981493},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1612426981493},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1612426981494},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1612426981494},{"_id":"public/2020/01/31/量化交易入门/run.png","hash":"c2291bbd616d4b1edd3ad8ee9b8ca3c3a338623a","modified":1612426981494},{"_id":"public/2020/01/31/量化交易入门/run1.png","hash":"f0d0107b240932bfa5007469af4821488689cb2c","modified":1612426981494},{"_id":"public/2020/06/21/理解CMS回收器的preclean阶段/summary.png","hash":"8c39fc129d427dbb4e9ea0ca06c833f534f833c6","modified":1612426981494},{"_id":"public/2019/10/25/thrift源码（四）非阻塞服务端/reactor-single.png","hash":"95816bfa0d221ec62d64e5d92e50fa4a4b693d93","modified":1612426981495},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1612426981529},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1612426981529},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1612426981532},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1612426981532},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1612426981532},{"_id":"public/2019/11/18/thrift源码（五）非阻塞服务端其他实现/reactor-multi.png","hash":"46644fc3f131c92e9c32193c2fb7498a06c0419d","modified":1612426981532},{"_id":"public/2020/05/21/用机器学习判断ins内容是否能上热门/report.png","hash":"eb0df353763c50a1136023e8d3ead7e95b1020b2","modified":1612426981532},{"_id":"public/2020/01/31/量化交易入门/real.png","hash":"524bd073bddbe4825bb6cb0e002e68cc0c95bb85","modified":1612426981534},{"_id":"public/2019/10/25/thrift源码（四）非阻塞服务端/FrameBufferState.png","hash":"115df79ca97225b70d17e046518b338681814133","modified":1612426981542},{"_id":"public/2019/08/05/thrift源码（二）异步客户端/thrift-client-call.png","hash":"19237bbbf1ee0811bce0a768246ca4355c5e487b","modified":1612426981542},{"_id":"public/2019/10/25/thrift源码（四）非阻塞服务端/serverflow.png","hash":"04cc50baf21975546bfa76e8f380416036294de6","modified":1612426981543},{"_id":"public/2020/01/31/量化交易入门/debug.png","hash":"771343836519fdebc9e73e849ff81fe75910925b","modified":1612426981545},{"_id":"public/images/tencent.png","hash":"fbf36a5a12e73f47f75a0b686ac673ce95511d5b","modified":1612426981546},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1612426981547},{"_id":"public/2019/08/05/thrift源码（二）异步客户端/client-init.png","hash":"e921f71bf46398b9b547f2c2a0f03898e54bf018","modified":1612426981548},{"_id":"public/2020/05/21/用机器学习判断ins内容是否能上热门/ins.png","hash":"a0d15461d68201c3b44ebf27eb44feb932407fe1","modified":1612426981550},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1612426981552}],"Category":[{"name":"jdk源码","_id":"ckkqle16v0006cynezhoxw33s"},{"name":"容器技术","_id":"ckkqle170000bcyne5reho9c5"},{"name":"mysql进阶","_id":"ckkqle174000gcynesd88zntv"},{"name":"thrift源码","_id":"ckkqle177000qcynenolz7qcb"},{"name":"redis进阶","_id":"ckkqle17d0011cyneb4p6tzkw"},{"name":"mongodb","_id":"ckkqle1cs002ecyne4c484ph6"},{"name":"开源框架","_id":"ckkqle1du003ccyneckv2bojl"}],"Data":[],"Page":[{"_content":"pzRlBW6eu6","source":"baidu_verify_pzRlBW6eu6.html","raw":"pzRlBW6eu6","date":"2019-04-01T16:29:57.090Z","updated":"2017-05-21T14:18:03.511Z","path":"baidu_verify_pzRlBW6eu6.html","title":"","comments":1,"layout":"page","_id":"ckkqle15h0000cynemlnqe2do","content":"pzRlBW6eu6","site":{"data":{}},"excerpt":"","more":"pzRlBW6eu6"},{"_content":"google-site-verification: google43dee7d23dee4e5e.html","source":"google43dee7d23dee4e5e.html","raw":"google-site-verification: google43dee7d23dee4e5e.html","date":"2019-04-01T16:29:57.091Z","updated":"2017-05-19T13:12:21.000Z","path":"google43dee7d23dee4e5e.html","title":"","comments":1,"layout":"page","_id":"ckkqle15j0001cynepy8n2eqt","content":"google-site-verification: google43dee7d23dee4e5e.html","site":{"data":{}},"excerpt":"","more":"google-site-verification: google43dee7d23dee4e5e.html"},{"title":"about","date":"2015-08-12T15:15:05.000Z","_content":"","source":"about/index.md","raw":"title: about\ndate: 2015-08-12 23:15:05\n---\n","updated":"2015-08-12T15:15:05.633Z","path":"about/index.html","comments":1,"layout":"page","_id":"ckkqle16o0002cynex96vewa9","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"archives","date":"2015-08-12T15:52:04.000Z","_content":"","source":"archives/index.md","raw":"title: archives\ndate: 2015-08-12 23:52:04\n---\n","updated":"2015-08-12T15:52:04.564Z","path":"archives/index.html","comments":1,"layout":"page","_id":"ckkqle16s0004cynen2na6taj","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"categories","date":"2018-11-21T15:56:56.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2018-11-21 23:56:56\ntype: \"categories\"\ncomments: false\n---\n","updated":"2018-11-21T15:59:33.620Z","path":"categories/index.html","layout":"page","_id":"ckkqle1ci0024cynersbqzrh0","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"subject","date":"2015-10-30T16:26:52.000Z","_content":"","source":"subject/index.md","raw":"title: subject\ndate: 2015-10-31 00:26:52\n---\n","updated":"2015-10-30T16:26:52.056Z","path":"subject/index.html","comments":1,"layout":"page","_id":"ckkqle1ck0026cyne0fgcekze","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2018-11-21T15:49:28.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2018-11-21 23:49:28\ntype: \"tags\"\ncomments: false\n---\n","updated":"2018-11-21T15:51:20.346Z","path":"tags/index.html","layout":"page","_id":"ckkqle1cn0029cynevdf2kxhy","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"ConcurrentLinkedQueue的几个细节问题","date":"2018-02-22T15:05:46.000Z","_content":"所有的注释和源码都引用自jdk1.7版本的ConcurrentLinkedQueue\n\n### ABA问题\n源码注释中对这个问题的说明\n> Note that like most non-blocking algorithms in this package,this implementation relies on the fact that in garbage collected systems, there is no possibility of ABA problems due to recycled nodes, so there is no need to use \"counted pointers\" or related techniques seen in versions used in non-GC'ed settings.\n\n(ConcurrentLinkedQueue的实现依赖GC操作，因为GC会收节点所以不会出现ABA问题，因此不需要使用非GC(non-GC'ed)中使用的“计数指针”或相关技术）\n\nGC能避免ABA问题，主要是因为GC能保证引用值相同时他们指向的内容一定是一样的，具体说明看这里[这个文章讲的不错][1]\n<!--more-->\n\n### Node的初始化\n\n为了保证可见性，Node的两个属性都是volatile的\n```java\nprivate static class Node<E> {\n        volatile E item;\n        volatile Node<E> next;\n```\n但是初始化是没有直接对volatile变量赋值，初始化Node使用的是unsafe的putObject方法\n```java\nNode(E item) {\n        /**\n        * Constructs a new node.  Uses relaxed write because item can\n         * only be seen after publication via casNext.\n         */\n            UNSAFE.putObject(this, itemOffset, item);\n        }\n```\n源码中对此的说明\n> When constructing a Node (before enqueuing it) we avoid paying for a volatile write to item by using Unsafe.putObject instead of a normal write.  This allows the cost of enqueue to be \"one-and-a-half\" CASes.（避免写volatile操作的开销，使得入队操作的cost相当与1.5个CAS操作）\n\nUNSAFE的putObject相当于对普通变量的写操作（作者称之为relaxed write），因为item是volatile的所以直接对他赋值会触发volatile写（引发缓存一致性操作），使用putObject方法就是为了避免了这一操作。参考[对putObject()方法的说明][2]\n\n我理解的是初始化的Node在执行构造函数后还需要执行casNext()方法才能被其他线程看到，因此使用\"relaxed write\"是安全的。既然node入队操作由初始化和casNext组成（参考offer()源码）,而执行casNext()之后保证了node的可见性，那么减少初始化操作的性能消耗就可以优化入队操作。\ncasNext方法：\n```java\nclass Node{\n    boolean casNext(Node<E> cmp, Node<E> val) {\n            return UNSAFE.compareAndSwapObject(this, nextOffset, cmp, val);\n        }\n}\n```\n### 引申\n对UNSAFE的一点介绍,UNSAFE的赋值操作：\n\n1. **putXXX(long address, XXX value)**: Will place the specified value of type XXX directly at the specified address.(指定地址保存变量)\n2. **putXXXVolatile(Object target, long offset, XXX value)**\nWill place value at target's address at the specified offset and not hit any thread local caches(不会被加载到线程本地缓存，只保存在主存，保证可见性)\n3. **putOrderedXXX(Object target, long offset, XXX value)**: Will place value at target's address at the specified offet and might not hit all thread local caches.(不保证可见性)\n\n### offer()方法\n\njdk1.7中更改了offer的写法，变得更简洁\n```java\npublic boolean offer(E e) {\n        checkNotNull(e);\n        final Node<E> newNode = new Node<E>(e);\n\n        for (Node<E> t = tail, p = t;;) {\n            Node<E> q = p.next;\n            if (q == null) {\n                // p is last node\n                //Node的入队操作\n                if (p.casNext(null, newNode)) {\n                    // Successful CAS is the linearization point\n                    // for e to become an element of this queue,\n                    // and for newNode to become \"live\".\n                    if (p != t) // hop two nodes at a time\n                        casTail(t, newNode);  // Failure is OK.\n                    return true;\n                }\n                // Lost CAS race to another thread; re-read next\n            }\n            else if (p == q)\n                // We have fallen off list.  If tail is unchanged, it\n                // will also be off-list, in which case we need to\n                // jump to head, from which all live nodes are always\n                // reachable.  Else the new tail is a better bet.\n                p = (t != (t = tail)) ? t : head;\n            else\n                // Check for tail updates after two hops.\n                p = (p != t && t != (t = tail)) ? t : q;\n        }\n    }\n```\n对于第24行，(t!=(t=tail))的执行顺序是这样的\n1. t_old=t\n2. t=tail\n3. t_old!=t\n在执行比较之前tail被赋值给t(new)\n\n### 弱一致迭代器导致的GC问题\n\n在LinkedBlockingQueue也有类似描述\n>That would cause two problems:\n      - allow a rogue Iterator to cause unbounded memory retention\n      - cause cross-generational linking of old Nodes to new Nodes if a Node was tenured while live, which generational GCs have a\n hard time dealing with, causing repeated major collections.\nHowever, only non-deleted Nodes need to be reachable from dequeued Nodes, and reachability does not necessarily have to be of the kind understood by the GC.  We use the trick of linking a Node that has just been dequeued to itself.  Such a self-link implicitly means to advance to head.\n\n### 常见的使用错误\n\n#### 谨慎使用addAll()方法\n\n批量操作不保证原子性，执行addlAll方法是并发的迭代操作可能看不到全部添加到队列的元素。\nAdditionally, the bulk operations addAll, removeAll, retainAll, containsAll, equals, and toArray are not guaranteed to be performed atomically. For example, an iterator operating concurrently with an addAll operation might view only some of the added elements.\n\n#### 谨慎使用size()方法\nint size()方法返回的值不一定是准确的，currentlinkedqueue只能通过从头遍历来统计数量，在此期间发生的添加和删除操作不会反应到size()的返回结果中。\n\n#### head和tail的位置\nhead和tail都支持延迟更新（延迟等于或超过两个节点才更新），这样可以减少cas操作，所以head/tail不保证一定指向头结点和尾节点，甚至不保证head和tail之间的相互顺序。\n>Both head and tail are permitted to lag.  In fact, failing to update them every time one could is a significant optimization(fewer CASes). As with LinkedTransferQueue (see the internal documentation for that class), we use a slack threshold of two;\n      that is, we update head/tail when the current pointer appears to be two or more steps away from the first/last node.\n     Since head and tail are updated concurrently and independently, it is possible for tail to lag behind head (why not)?\n     \n     \n  [1]: http://www.cnblogs.com/devos/p/4396773.html\n  [2]: https://stackoverflow.com/questions/46280313/relaxed-write-what-does-it-mean","source":"_posts/ConcurrentLinkedQueue的几个细节问题.md","raw":"title: ConcurrentLinkedQueue的几个细节问题\ndate: 2018-02-22 23:05:46\ncategories: jdk源码\ntags: [java基础,并发]\n\n---\n所有的注释和源码都引用自jdk1.7版本的ConcurrentLinkedQueue\n\n### ABA问题\n源码注释中对这个问题的说明\n> Note that like most non-blocking algorithms in this package,this implementation relies on the fact that in garbage collected systems, there is no possibility of ABA problems due to recycled nodes, so there is no need to use \"counted pointers\" or related techniques seen in versions used in non-GC'ed settings.\n\n(ConcurrentLinkedQueue的实现依赖GC操作，因为GC会收节点所以不会出现ABA问题，因此不需要使用非GC(non-GC'ed)中使用的“计数指针”或相关技术）\n\nGC能避免ABA问题，主要是因为GC能保证引用值相同时他们指向的内容一定是一样的，具体说明看这里[这个文章讲的不错][1]\n<!--more-->\n\n### Node的初始化\n\n为了保证可见性，Node的两个属性都是volatile的\n```java\nprivate static class Node<E> {\n        volatile E item;\n        volatile Node<E> next;\n```\n但是初始化是没有直接对volatile变量赋值，初始化Node使用的是unsafe的putObject方法\n```java\nNode(E item) {\n        /**\n        * Constructs a new node.  Uses relaxed write because item can\n         * only be seen after publication via casNext.\n         */\n            UNSAFE.putObject(this, itemOffset, item);\n        }\n```\n源码中对此的说明\n> When constructing a Node (before enqueuing it) we avoid paying for a volatile write to item by using Unsafe.putObject instead of a normal write.  This allows the cost of enqueue to be \"one-and-a-half\" CASes.（避免写volatile操作的开销，使得入队操作的cost相当与1.5个CAS操作）\n\nUNSAFE的putObject相当于对普通变量的写操作（作者称之为relaxed write），因为item是volatile的所以直接对他赋值会触发volatile写（引发缓存一致性操作），使用putObject方法就是为了避免了这一操作。参考[对putObject()方法的说明][2]\n\n我理解的是初始化的Node在执行构造函数后还需要执行casNext()方法才能被其他线程看到，因此使用\"relaxed write\"是安全的。既然node入队操作由初始化和casNext组成（参考offer()源码）,而执行casNext()之后保证了node的可见性，那么减少初始化操作的性能消耗就可以优化入队操作。\ncasNext方法：\n```java\nclass Node{\n    boolean casNext(Node<E> cmp, Node<E> val) {\n            return UNSAFE.compareAndSwapObject(this, nextOffset, cmp, val);\n        }\n}\n```\n### 引申\n对UNSAFE的一点介绍,UNSAFE的赋值操作：\n\n1. **putXXX(long address, XXX value)**: Will place the specified value of type XXX directly at the specified address.(指定地址保存变量)\n2. **putXXXVolatile(Object target, long offset, XXX value)**\nWill place value at target's address at the specified offset and not hit any thread local caches(不会被加载到线程本地缓存，只保存在主存，保证可见性)\n3. **putOrderedXXX(Object target, long offset, XXX value)**: Will place value at target's address at the specified offet and might not hit all thread local caches.(不保证可见性)\n\n### offer()方法\n\njdk1.7中更改了offer的写法，变得更简洁\n```java\npublic boolean offer(E e) {\n        checkNotNull(e);\n        final Node<E> newNode = new Node<E>(e);\n\n        for (Node<E> t = tail, p = t;;) {\n            Node<E> q = p.next;\n            if (q == null) {\n                // p is last node\n                //Node的入队操作\n                if (p.casNext(null, newNode)) {\n                    // Successful CAS is the linearization point\n                    // for e to become an element of this queue,\n                    // and for newNode to become \"live\".\n                    if (p != t) // hop two nodes at a time\n                        casTail(t, newNode);  // Failure is OK.\n                    return true;\n                }\n                // Lost CAS race to another thread; re-read next\n            }\n            else if (p == q)\n                // We have fallen off list.  If tail is unchanged, it\n                // will also be off-list, in which case we need to\n                // jump to head, from which all live nodes are always\n                // reachable.  Else the new tail is a better bet.\n                p = (t != (t = tail)) ? t : head;\n            else\n                // Check for tail updates after two hops.\n                p = (p != t && t != (t = tail)) ? t : q;\n        }\n    }\n```\n对于第24行，(t!=(t=tail))的执行顺序是这样的\n1. t_old=t\n2. t=tail\n3. t_old!=t\n在执行比较之前tail被赋值给t(new)\n\n### 弱一致迭代器导致的GC问题\n\n在LinkedBlockingQueue也有类似描述\n>That would cause two problems:\n      - allow a rogue Iterator to cause unbounded memory retention\n      - cause cross-generational linking of old Nodes to new Nodes if a Node was tenured while live, which generational GCs have a\n hard time dealing with, causing repeated major collections.\nHowever, only non-deleted Nodes need to be reachable from dequeued Nodes, and reachability does not necessarily have to be of the kind understood by the GC.  We use the trick of linking a Node that has just been dequeued to itself.  Such a self-link implicitly means to advance to head.\n\n### 常见的使用错误\n\n#### 谨慎使用addAll()方法\n\n批量操作不保证原子性，执行addlAll方法是并发的迭代操作可能看不到全部添加到队列的元素。\nAdditionally, the bulk operations addAll, removeAll, retainAll, containsAll, equals, and toArray are not guaranteed to be performed atomically. For example, an iterator operating concurrently with an addAll operation might view only some of the added elements.\n\n#### 谨慎使用size()方法\nint size()方法返回的值不一定是准确的，currentlinkedqueue只能通过从头遍历来统计数量，在此期间发生的添加和删除操作不会反应到size()的返回结果中。\n\n#### head和tail的位置\nhead和tail都支持延迟更新（延迟等于或超过两个节点才更新），这样可以减少cas操作，所以head/tail不保证一定指向头结点和尾节点，甚至不保证head和tail之间的相互顺序。\n>Both head and tail are permitted to lag.  In fact, failing to update them every time one could is a significant optimization(fewer CASes). As with LinkedTransferQueue (see the internal documentation for that class), we use a slack threshold of two;\n      that is, we update head/tail when the current pointer appears to be two or more steps away from the first/last node.\n     Since head and tail are updated concurrently and independently, it is possible for tail to lag behind head (why not)?\n     \n     \n  [1]: http://www.cnblogs.com/devos/p/4396773.html\n  [2]: https://stackoverflow.com/questions/46280313/relaxed-write-what-does-it-mean","slug":"ConcurrentLinkedQueue的几个细节问题","published":1,"updated":"2018-11-21T16:19:40.622Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkqle16p0003cyne9z43op3g","content":"<p>所有的注释和源码都引用自jdk1.7版本的ConcurrentLinkedQueue</p>\n<h3 id=\"ABA问题\"><a href=\"#ABA问题\" class=\"headerlink\" title=\"ABA问题\"></a>ABA问题</h3><p>源码注释中对这个问题的说明</p>\n<blockquote>\n<p>Note that like most non-blocking algorithms in this package,this implementation relies on the fact that in garbage collected systems, there is no possibility of ABA problems due to recycled nodes, so there is no need to use “counted pointers” or related techniques seen in versions used in non-GC’ed settings.</p>\n</blockquote>\n<p>(ConcurrentLinkedQueue的实现依赖GC操作，因为GC会收节点所以不会出现ABA问题，因此不需要使用非GC(non-GC’ed)中使用的“计数指针”或相关技术）</p>\n<p>GC能避免ABA问题，主要是因为GC能保证引用值相同时他们指向的内容一定是一样的，具体说明看这里<a href=\"http://www.cnblogs.com/devos/p/4396773.html\" target=\"_blank\" rel=\"noopener\">这个文章讲的不错</a><br><a id=\"more\"></a></p>\n<h3 id=\"Node的初始化\"><a href=\"#Node的初始化\" class=\"headerlink\" title=\"Node的初始化\"></a>Node的初始化</h3><p>为了保证可见性，Node的两个属性都是volatile的<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">volatile</span> E item;</span><br><span class=\"line\">        <span class=\"keyword\">volatile</span> Node&lt;E&gt; next;</span><br></pre></td></tr></table></figure></p>\n<p>但是初始化是没有直接对volatile变量赋值，初始化Node使用的是unsafe的putObject方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Node(E item) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">        * Constructs a new node.  Uses relaxed write because item can</span></span><br><span class=\"line\"><span class=\"comment\">         * only be seen after publication via casNext.</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">            UNSAFE.putObject(<span class=\"keyword\">this</span>, itemOffset, item);</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure></p>\n<p>源码中对此的说明</p>\n<blockquote>\n<p>When constructing a Node (before enqueuing it) we avoid paying for a volatile write to item by using Unsafe.putObject instead of a normal write.  This allows the cost of enqueue to be “one-and-a-half” CASes.（避免写volatile操作的开销，使得入队操作的cost相当与1.5个CAS操作）</p>\n</blockquote>\n<p>UNSAFE的putObject相当于对普通变量的写操作（作者称之为relaxed write），因为item是volatile的所以直接对他赋值会触发volatile写（引发缓存一致性操作），使用putObject方法就是为了避免了这一操作。参考<a href=\"https://stackoverflow.com/questions/46280313/relaxed-write-what-does-it-mean\" target=\"_blank\" rel=\"noopener\">对putObject()方法的说明</a></p>\n<p>我理解的是初始化的Node在执行构造函数后还需要执行casNext()方法才能被其他线程看到，因此使用”relaxed write”是安全的。既然node入队操作由初始化和casNext组成（参考offer()源码）,而执行casNext()之后保证了node的可见性，那么减少初始化操作的性能消耗就可以优化入队操作。<br>casNext方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">casNext</span><span class=\"params\">(Node&lt;E&gt; cmp, Node&lt;E&gt; val)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> UNSAFE.compareAndSwapObject(<span class=\"keyword\">this</span>, nextOffset, cmp, val);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"引申\"><a href=\"#引申\" class=\"headerlink\" title=\"引申\"></a>引申</h3><p>对UNSAFE的一点介绍,UNSAFE的赋值操作：</p>\n<ol>\n<li><strong>putXXX(long address, XXX value)</strong>: Will place the specified value of type XXX directly at the specified address.(指定地址保存变量)</li>\n<li><strong>putXXXVolatile(Object target, long offset, XXX value)</strong><br>Will place value at target’s address at the specified offset and not hit any thread local caches(不会被加载到线程本地缓存，只保存在主存，保证可见性)</li>\n<li><strong>putOrderedXXX(Object target, long offset, XXX value)</strong>: Will place value at target’s address at the specified offet and might not hit all thread local caches.(不保证可见性)</li>\n</ol>\n<h3 id=\"offer-方法\"><a href=\"#offer-方法\" class=\"headerlink\" title=\"offer()方法\"></a>offer()方法</h3><p>jdk1.7中更改了offer的写法，变得更简洁<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">offer</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">        checkNotNull(e);</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Node&lt;E&gt; newNode = <span class=\"keyword\">new</span> Node&lt;E&gt;(e);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Node&lt;E&gt; t = tail, p = t;;) &#123;</span><br><span class=\"line\">            Node&lt;E&gt; q = p.next;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (q == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// p is last node</span></span><br><span class=\"line\">                <span class=\"comment\">//Node的入队操作</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p.casNext(<span class=\"keyword\">null</span>, newNode)) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// Successful CAS is the linearization point</span></span><br><span class=\"line\">                    <span class=\"comment\">// for e to become an element of this queue,</span></span><br><span class=\"line\">                    <span class=\"comment\">// and for newNode to become \"live\".</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (p != t) <span class=\"comment\">// hop two nodes at a time</span></span><br><span class=\"line\">                        casTail(t, newNode);  <span class=\"comment\">// Failure is OK.</span></span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// Lost CAS race to another thread; re-read next</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p == q)</span><br><span class=\"line\">                <span class=\"comment\">// We have fallen off list.  If tail is unchanged, it</span></span><br><span class=\"line\">                <span class=\"comment\">// will also be off-list, in which case we need to</span></span><br><span class=\"line\">                <span class=\"comment\">// jump to head, from which all live nodes are always</span></span><br><span class=\"line\">                <span class=\"comment\">// reachable.  Else the new tail is a better bet.</span></span><br><span class=\"line\">                p = (t != (t = tail)) ? t : head;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                <span class=\"comment\">// Check for tail updates after two hops.</span></span><br><span class=\"line\">                p = (p != t &amp;&amp; t != (t = tail)) ? t : q;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>对于第24行，(t!=(t=tail))的执行顺序是这样的</p>\n<ol>\n<li>t_old=t</li>\n<li>t=tail</li>\n<li>t_old!=t<br>在执行比较之前tail被赋值给t(new)</li>\n</ol>\n<h3 id=\"弱一致迭代器导致的GC问题\"><a href=\"#弱一致迭代器导致的GC问题\" class=\"headerlink\" title=\"弱一致迭代器导致的GC问题\"></a>弱一致迭代器导致的GC问题</h3><p>在LinkedBlockingQueue也有类似描述</p>\n<blockquote>\n<p>That would cause two problems:</p>\n<pre><code>- allow a rogue Iterator to cause unbounded memory retention\n- cause cross-generational linking of old Nodes to new Nodes if a Node was tenured while live, which generational GCs have a\n</code></pre><p> hard time dealing with, causing repeated major collections.<br>However, only non-deleted Nodes need to be reachable from dequeued Nodes, and reachability does not necessarily have to be of the kind understood by the GC.  We use the trick of linking a Node that has just been dequeued to itself.  Such a self-link implicitly means to advance to head.</p>\n</blockquote>\n<h3 id=\"常见的使用错误\"><a href=\"#常见的使用错误\" class=\"headerlink\" title=\"常见的使用错误\"></a>常见的使用错误</h3><h4 id=\"谨慎使用addAll-方法\"><a href=\"#谨慎使用addAll-方法\" class=\"headerlink\" title=\"谨慎使用addAll()方法\"></a>谨慎使用addAll()方法</h4><p>批量操作不保证原子性，执行addlAll方法是并发的迭代操作可能看不到全部添加到队列的元素。<br>Additionally, the bulk operations addAll, removeAll, retainAll, containsAll, equals, and toArray are not guaranteed to be performed atomically. For example, an iterator operating concurrently with an addAll operation might view only some of the added elements.</p>\n<h4 id=\"谨慎使用size-方法\"><a href=\"#谨慎使用size-方法\" class=\"headerlink\" title=\"谨慎使用size()方法\"></a>谨慎使用size()方法</h4><p>int size()方法返回的值不一定是准确的，currentlinkedqueue只能通过从头遍历来统计数量，在此期间发生的添加和删除操作不会反应到size()的返回结果中。</p>\n<h4 id=\"head和tail的位置\"><a href=\"#head和tail的位置\" class=\"headerlink\" title=\"head和tail的位置\"></a>head和tail的位置</h4><p>head和tail都支持延迟更新（延迟等于或超过两个节点才更新），这样可以减少cas操作，所以head/tail不保证一定指向头结点和尾节点，甚至不保证head和tail之间的相互顺序。</p>\n<blockquote>\n<p>Both head and tail are permitted to lag.  In fact, failing to update them every time one could is a significant optimization(fewer CASes). As with LinkedTransferQueue (see the internal documentation for that class), we use a slack threshold of two;<br>      that is, we update head/tail when the current pointer appears to be two or more steps away from the first/last node.<br>     Since head and tail are updated concurrently and independently, it is possible for tail to lag behind head (why not)?</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>所有的注释和源码都引用自jdk1.7版本的ConcurrentLinkedQueue</p>\n<h3 id=\"ABA问题\"><a href=\"#ABA问题\" class=\"headerlink\" title=\"ABA问题\"></a>ABA问题</h3><p>源码注释中对这个问题的说明</p>\n<blockquote>\n<p>Note that like most non-blocking algorithms in this package,this implementation relies on the fact that in garbage collected systems, there is no possibility of ABA problems due to recycled nodes, so there is no need to use “counted pointers” or related techniques seen in versions used in non-GC’ed settings.</p>\n</blockquote>\n<p>(ConcurrentLinkedQueue的实现依赖GC操作，因为GC会收节点所以不会出现ABA问题，因此不需要使用非GC(non-GC’ed)中使用的“计数指针”或相关技术）</p>\n<p>GC能避免ABA问题，主要是因为GC能保证引用值相同时他们指向的内容一定是一样的，具体说明看这里<a href=\"http://www.cnblogs.com/devos/p/4396773.html\" target=\"_blank\" rel=\"noopener\">这个文章讲的不错</a><br>","more":"</p>\n<h3 id=\"Node的初始化\"><a href=\"#Node的初始化\" class=\"headerlink\" title=\"Node的初始化\"></a>Node的初始化</h3><p>为了保证可见性，Node的两个属性都是volatile的<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">volatile</span> E item;</span><br><span class=\"line\">        <span class=\"keyword\">volatile</span> Node&lt;E&gt; next;</span><br></pre></td></tr></table></figure></p>\n<p>但是初始化是没有直接对volatile变量赋值，初始化Node使用的是unsafe的putObject方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Node(E item) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">        * Constructs a new node.  Uses relaxed write because item can</span></span><br><span class=\"line\"><span class=\"comment\">         * only be seen after publication via casNext.</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">            UNSAFE.putObject(<span class=\"keyword\">this</span>, itemOffset, item);</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure></p>\n<p>源码中对此的说明</p>\n<blockquote>\n<p>When constructing a Node (before enqueuing it) we avoid paying for a volatile write to item by using Unsafe.putObject instead of a normal write.  This allows the cost of enqueue to be “one-and-a-half” CASes.（避免写volatile操作的开销，使得入队操作的cost相当与1.5个CAS操作）</p>\n</blockquote>\n<p>UNSAFE的putObject相当于对普通变量的写操作（作者称之为relaxed write），因为item是volatile的所以直接对他赋值会触发volatile写（引发缓存一致性操作），使用putObject方法就是为了避免了这一操作。参考<a href=\"https://stackoverflow.com/questions/46280313/relaxed-write-what-does-it-mean\" target=\"_blank\" rel=\"noopener\">对putObject()方法的说明</a></p>\n<p>我理解的是初始化的Node在执行构造函数后还需要执行casNext()方法才能被其他线程看到，因此使用”relaxed write”是安全的。既然node入队操作由初始化和casNext组成（参考offer()源码）,而执行casNext()之后保证了node的可见性，那么减少初始化操作的性能消耗就可以优化入队操作。<br>casNext方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">casNext</span><span class=\"params\">(Node&lt;E&gt; cmp, Node&lt;E&gt; val)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> UNSAFE.compareAndSwapObject(<span class=\"keyword\">this</span>, nextOffset, cmp, val);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"引申\"><a href=\"#引申\" class=\"headerlink\" title=\"引申\"></a>引申</h3><p>对UNSAFE的一点介绍,UNSAFE的赋值操作：</p>\n<ol>\n<li><strong>putXXX(long address, XXX value)</strong>: Will place the specified value of type XXX directly at the specified address.(指定地址保存变量)</li>\n<li><strong>putXXXVolatile(Object target, long offset, XXX value)</strong><br>Will place value at target’s address at the specified offset and not hit any thread local caches(不会被加载到线程本地缓存，只保存在主存，保证可见性)</li>\n<li><strong>putOrderedXXX(Object target, long offset, XXX value)</strong>: Will place value at target’s address at the specified offet and might not hit all thread local caches.(不保证可见性)</li>\n</ol>\n<h3 id=\"offer-方法\"><a href=\"#offer-方法\" class=\"headerlink\" title=\"offer()方法\"></a>offer()方法</h3><p>jdk1.7中更改了offer的写法，变得更简洁<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">offer</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">        checkNotNull(e);</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Node&lt;E&gt; newNode = <span class=\"keyword\">new</span> Node&lt;E&gt;(e);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Node&lt;E&gt; t = tail, p = t;;) &#123;</span><br><span class=\"line\">            Node&lt;E&gt; q = p.next;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (q == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// p is last node</span></span><br><span class=\"line\">                <span class=\"comment\">//Node的入队操作</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p.casNext(<span class=\"keyword\">null</span>, newNode)) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// Successful CAS is the linearization point</span></span><br><span class=\"line\">                    <span class=\"comment\">// for e to become an element of this queue,</span></span><br><span class=\"line\">                    <span class=\"comment\">// and for newNode to become \"live\".</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (p != t) <span class=\"comment\">// hop two nodes at a time</span></span><br><span class=\"line\">                        casTail(t, newNode);  <span class=\"comment\">// Failure is OK.</span></span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// Lost CAS race to another thread; re-read next</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p == q)</span><br><span class=\"line\">                <span class=\"comment\">// We have fallen off list.  If tail is unchanged, it</span></span><br><span class=\"line\">                <span class=\"comment\">// will also be off-list, in which case we need to</span></span><br><span class=\"line\">                <span class=\"comment\">// jump to head, from which all live nodes are always</span></span><br><span class=\"line\">                <span class=\"comment\">// reachable.  Else the new tail is a better bet.</span></span><br><span class=\"line\">                p = (t != (t = tail)) ? t : head;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                <span class=\"comment\">// Check for tail updates after two hops.</span></span><br><span class=\"line\">                p = (p != t &amp;&amp; t != (t = tail)) ? t : q;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>对于第24行，(t!=(t=tail))的执行顺序是这样的</p>\n<ol>\n<li>t_old=t</li>\n<li>t=tail</li>\n<li>t_old!=t<br>在执行比较之前tail被赋值给t(new)</li>\n</ol>\n<h3 id=\"弱一致迭代器导致的GC问题\"><a href=\"#弱一致迭代器导致的GC问题\" class=\"headerlink\" title=\"弱一致迭代器导致的GC问题\"></a>弱一致迭代器导致的GC问题</h3><p>在LinkedBlockingQueue也有类似描述</p>\n<blockquote>\n<p>That would cause two problems:</p>\n<pre><code>- allow a rogue Iterator to cause unbounded memory retention\n- cause cross-generational linking of old Nodes to new Nodes if a Node was tenured while live, which generational GCs have a\n</code></pre><p> hard time dealing with, causing repeated major collections.<br>However, only non-deleted Nodes need to be reachable from dequeued Nodes, and reachability does not necessarily have to be of the kind understood by the GC.  We use the trick of linking a Node that has just been dequeued to itself.  Such a self-link implicitly means to advance to head.</p>\n</blockquote>\n<h3 id=\"常见的使用错误\"><a href=\"#常见的使用错误\" class=\"headerlink\" title=\"常见的使用错误\"></a>常见的使用错误</h3><h4 id=\"谨慎使用addAll-方法\"><a href=\"#谨慎使用addAll-方法\" class=\"headerlink\" title=\"谨慎使用addAll()方法\"></a>谨慎使用addAll()方法</h4><p>批量操作不保证原子性，执行addlAll方法是并发的迭代操作可能看不到全部添加到队列的元素。<br>Additionally, the bulk operations addAll, removeAll, retainAll, containsAll, equals, and toArray are not guaranteed to be performed atomically. For example, an iterator operating concurrently with an addAll operation might view only some of the added elements.</p>\n<h4 id=\"谨慎使用size-方法\"><a href=\"#谨慎使用size-方法\" class=\"headerlink\" title=\"谨慎使用size()方法\"></a>谨慎使用size()方法</h4><p>int size()方法返回的值不一定是准确的，currentlinkedqueue只能通过从头遍历来统计数量，在此期间发生的添加和删除操作不会反应到size()的返回结果中。</p>\n<h4 id=\"head和tail的位置\"><a href=\"#head和tail的位置\" class=\"headerlink\" title=\"head和tail的位置\"></a>head和tail的位置</h4><p>head和tail都支持延迟更新（延迟等于或超过两个节点才更新），这样可以减少cas操作，所以head/tail不保证一定指向头结点和尾节点，甚至不保证head和tail之间的相互顺序。</p>\n<blockquote>\n<p>Both head and tail are permitted to lag.  In fact, failing to update them every time one could is a significant optimization(fewer CASes). As with LinkedTransferQueue (see the internal documentation for that class), we use a slack threshold of two;<br>      that is, we update head/tail when the current pointer appears to be two or more steps away from the first/last node.<br>     Since head and tail are updated concurrently and independently, it is possible for tail to lag behind head (why not)?</p>\n</blockquote>"},{"title":"Mesos安装","date":"2017-12-26T12:05:46.000Z","_content":"\n系统环境：CentOS 6.6 java7\n\nmesos安装\n\n按官网教程下载&编译\nhttp://mesos.apache.org/documentation/latest/building/\n\n借助mussh同时操作多个机器（需要先建立互信）\n\n示例：`./mussh -H iplist -c 'hostname -i'`;\n-H 指定ip\n-c 指定执行的命令\niplist 一行一个ip\ncat iplist \n10.9.19.xx\n10.9.19.xx\n10.9.19.xx\n<!--more-->\n\n问题\n1.执行configure时\nconfigure: error: cannot find libcurl\n-------------------------------------------------------------------\nlibcurl is required for mesos to build.\n-------------------------------------------------------------------\n `yum install libcurl-devel `\n2.libsubversion-1 is required for mesos to build.\n\n` yum install -y subversion-devel`\n这两个都是之前命令中安装的东西但是到了这里又需要重新安装，应该是yum安装失败的问题\n编译过程太慢了\n\n3.执行make时出现错误\n>Building mesos-1.4.0.jar ...\nException in thread \"main\" java.lang.UnsupportedClassVersionError: org/apache/maven/cli/MavenCli : Unsupported major.minor version 51.0\n\n这个主要是因为你的java环境低于1.7造成的，可以尝试升级jdk版本，\n但是**我在升级之后明明java  -version提示的1.7，编译还是失败**，后来查看Makefile文件发现，文件中已经写死了jdk路径，比如这种：\n`CONFIGURE_ARGS =  'JAVA_HOME=/opt/soft/jdk/jdk1.6.0_45`\n最后通过修改(注意有好几个Makefile文件)\n`vim build/src/Makefile`\n`1,$s/jdk1.6.0_45/jdk1.7.0_79/g`（执行替换）\n\n配置有两种\n一个是 在通过命令行启动时添加选项 eg:--option_name=value\n一个是 通过设置环境变量 eg:MESOS_XXX(XXX就是OPTION_NAME）\n\nmesos master配置\n必填项\n--work_dir=/var/lib/mesos/master\n这两个在单master时是不需要的\n--zk=\n--quorum==\n\n我们使用环境变量来配置\necho 'export MESOS_work_dir=/var/lib/mesos'>>/etc/profile\nsource /etc/profile\n进入build目录\n执行`./bin/mesos-master.sh --ip=127.0.0.1 >/dev/null &`\n启动master\n\nmesos agent配置\n必填项\n--master=\nhost:port \nzk://host1:port1,host2:port2,.../path zk://username:password@host1:port1,host2:port2,.../path file:///path/to/file (where file contains one of the above)\n--work_dir=VALUE \n\n`./mussh -H iplist3 -c 'echo \"export MESOS_master=10.252.81.25:5050\">>/etc/profile'`\n`./mussh -H iplist3 -c 'echo \"export MESOS_work_dir=/var/lib/mesos/agent\">>/etc/profile'\n`\n`./mussh -H iplist3 -c 'source /etc/profile'`（mussh执行source无效，还是要逐个刷新）\n`./bin/mesos-agent.sh`启动agent\n\nagent启动报错，无法在master注册\nXX exited event for master XX\n这时要检查master的hostname是不是配置的ip地址，如果不一致使用hostname \"name\"命令设置为对应ip\n\n在master访问http://127.0.0.1:5050/#/agents\n就能看到启动的agents\n![启动成功][1]\n\n\n  [1]: /images/mesos.png","source":"_posts/Mesos安装.md","raw":"title: Mesos安装\ndate: 2017-12-26 20:05:46\ncategories: 容器技术\ntags: [mesos]\n\n---\n\n系统环境：CentOS 6.6 java7\n\nmesos安装\n\n按官网教程下载&编译\nhttp://mesos.apache.org/documentation/latest/building/\n\n借助mussh同时操作多个机器（需要先建立互信）\n\n示例：`./mussh -H iplist -c 'hostname -i'`;\n-H 指定ip\n-c 指定执行的命令\niplist 一行一个ip\ncat iplist \n10.9.19.xx\n10.9.19.xx\n10.9.19.xx\n<!--more-->\n\n问题\n1.执行configure时\nconfigure: error: cannot find libcurl\n-------------------------------------------------------------------\nlibcurl is required for mesos to build.\n-------------------------------------------------------------------\n `yum install libcurl-devel `\n2.libsubversion-1 is required for mesos to build.\n\n` yum install -y subversion-devel`\n这两个都是之前命令中安装的东西但是到了这里又需要重新安装，应该是yum安装失败的问题\n编译过程太慢了\n\n3.执行make时出现错误\n>Building mesos-1.4.0.jar ...\nException in thread \"main\" java.lang.UnsupportedClassVersionError: org/apache/maven/cli/MavenCli : Unsupported major.minor version 51.0\n\n这个主要是因为你的java环境低于1.7造成的，可以尝试升级jdk版本，\n但是**我在升级之后明明java  -version提示的1.7，编译还是失败**，后来查看Makefile文件发现，文件中已经写死了jdk路径，比如这种：\n`CONFIGURE_ARGS =  'JAVA_HOME=/opt/soft/jdk/jdk1.6.0_45`\n最后通过修改(注意有好几个Makefile文件)\n`vim build/src/Makefile`\n`1,$s/jdk1.6.0_45/jdk1.7.0_79/g`（执行替换）\n\n配置有两种\n一个是 在通过命令行启动时添加选项 eg:--option_name=value\n一个是 通过设置环境变量 eg:MESOS_XXX(XXX就是OPTION_NAME）\n\nmesos master配置\n必填项\n--work_dir=/var/lib/mesos/master\n这两个在单master时是不需要的\n--zk=\n--quorum==\n\n我们使用环境变量来配置\necho 'export MESOS_work_dir=/var/lib/mesos'>>/etc/profile\nsource /etc/profile\n进入build目录\n执行`./bin/mesos-master.sh --ip=127.0.0.1 >/dev/null &`\n启动master\n\nmesos agent配置\n必填项\n--master=\nhost:port \nzk://host1:port1,host2:port2,.../path zk://username:password@host1:port1,host2:port2,.../path file:///path/to/file (where file contains one of the above)\n--work_dir=VALUE \n\n`./mussh -H iplist3 -c 'echo \"export MESOS_master=10.252.81.25:5050\">>/etc/profile'`\n`./mussh -H iplist3 -c 'echo \"export MESOS_work_dir=/var/lib/mesos/agent\">>/etc/profile'\n`\n`./mussh -H iplist3 -c 'source /etc/profile'`（mussh执行source无效，还是要逐个刷新）\n`./bin/mesos-agent.sh`启动agent\n\nagent启动报错，无法在master注册\nXX exited event for master XX\n这时要检查master的hostname是不是配置的ip地址，如果不一致使用hostname \"name\"命令设置为对应ip\n\n在master访问http://127.0.0.1:5050/#/agents\n就能看到启动的agents\n![启动成功][1]\n\n\n  [1]: /images/mesos.png","slug":"Mesos安装","published":1,"updated":"2019-05-04T15:53:00.862Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkqle16t0005cyneudvrr3qy","content":"<p>系统环境：CentOS 6.6 java7</p>\n<p>mesos安装</p>\n<p>按官网教程下载&amp;编译<br><a href=\"http://mesos.apache.org/documentation/latest/building/\" target=\"_blank\" rel=\"noopener\">http://mesos.apache.org/documentation/latest/building/</a></p>\n<p>借助mussh同时操作多个机器（需要先建立互信）</p>\n<p>示例：<code>./mussh -H iplist -c &#39;hostname -i&#39;</code>;<br>-H 指定ip<br>-c 指定执行的命令<br>iplist 一行一个ip<br>cat iplist<br>10.9.19.xx<br>10.9.19.xx<br>10.9.19.xx<br><a id=\"more\"></a></p>\n<p>问题<br>1.执行configure时</p>\n<h2 id=\"configure-error-cannot-find-libcurl\"><a href=\"#configure-error-cannot-find-libcurl\" class=\"headerlink\" title=\"configure: error: cannot find libcurl\"></a>configure: error: cannot find libcurl</h2><h2 id=\"libcurl-is-required-for-mesos-to-build\"><a href=\"#libcurl-is-required-for-mesos-to-build\" class=\"headerlink\" title=\"libcurl is required for mesos to build.\"></a>libcurl is required for mesos to build.</h2><p> <code>yum install libcurl-devel</code><br>2.libsubversion-1 is required for mesos to build.</p>\n<p><code>yum install -y subversion-devel</code><br>这两个都是之前命令中安装的东西但是到了这里又需要重新安装，应该是yum安装失败的问题<br>编译过程太慢了</p>\n<p>3.执行make时出现错误</p>\n<blockquote>\n<p>Building mesos-1.4.0.jar …<br>Exception in thread “main” java.lang.UnsupportedClassVersionError: org/apache/maven/cli/MavenCli : Unsupported major.minor version 51.0</p>\n</blockquote>\n<p>这个主要是因为你的java环境低于1.7造成的，可以尝试升级jdk版本，<br>但是<strong>我在升级之后明明java  -version提示的1.7，编译还是失败</strong>，后来查看Makefile文件发现，文件中已经写死了jdk路径，比如这种：<br><code>CONFIGURE_ARGS =  &#39;JAVA_HOME=/opt/soft/jdk/jdk1.6.0_45</code><br>最后通过修改(注意有好几个Makefile文件)<br><code>vim build/src/Makefile</code><br><code>1,$s/jdk1.6.0_45/jdk1.7.0_79/g</code>（执行替换）</p>\n<p>配置有两种<br>一个是 在通过命令行启动时添加选项 eg:–option_name=value<br>一个是 通过设置环境变量 eg:MESOS_XXX(XXX就是OPTION_NAME）</p>\n<p>mesos master配置<br>必填项<br>–work_dir=/var/lib/mesos/master<br>这两个在单master时是不需要的<br>–zk=<br>–quorum==</p>\n<p>我们使用环境变量来配置<br>echo ‘export MESOS_work_dir=/var/lib/mesos’&gt;&gt;/etc/profile<br>source /etc/profile<br>进入build目录<br>执行<code>./bin/mesos-master.sh --ip=127.0.0.1 &gt;/dev/null &amp;</code><br>启动master</p>\n<p>mesos agent配置<br>必填项<br>–master=<br>host:port<br>zk://host1:port1,host2:port2,…/path zk://username:password@host1:port1,host2:port2,…/path file:///path/to/file (where file contains one of the above)<br>–work_dir=VALUE </p>\n<p><code>./mussh -H iplist3 -c &#39;echo &quot;export MESOS_master=10.252.81.25:5050&quot;&gt;&gt;/etc/profile&#39;</code><br><code>./mussh -H iplist3 -c &#39;echo &quot;export MESOS_work_dir=/var/lib/mesos/agent&quot;&gt;&gt;/etc/profile&#39;</code><br><code>./mussh -H iplist3 -c &#39;source /etc/profile&#39;</code>（mussh执行source无效，还是要逐个刷新）<br><code>./bin/mesos-agent.sh</code>启动agent</p>\n<p>agent启动报错，无法在master注册<br>XX exited event for master XX<br>这时要检查master的hostname是不是配置的ip地址，如果不一致使用hostname “name”命令设置为对应ip</p>\n<p>在master访问<a href=\"http://127.0.0.1:5050/#/agents\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:5050/#/agents</a><br>就能看到启动的agents<br><img src=\"/images/mesos.png\" alt=\"启动成功\"></p>\n","site":{"data":{}},"excerpt":"<p>系统环境：CentOS 6.6 java7</p>\n<p>mesos安装</p>\n<p>按官网教程下载&amp;编译<br><a href=\"http://mesos.apache.org/documentation/latest/building/\" target=\"_blank\" rel=\"noopener\">http://mesos.apache.org/documentation/latest/building/</a></p>\n<p>借助mussh同时操作多个机器（需要先建立互信）</p>\n<p>示例：<code>./mussh -H iplist -c &#39;hostname -i&#39;</code>;<br>-H 指定ip<br>-c 指定执行的命令<br>iplist 一行一个ip<br>cat iplist<br>10.9.19.xx<br>10.9.19.xx<br>10.9.19.xx<br>","more":"</p>\n<p>问题<br>1.执行configure时</p>\n<h2 id=\"configure-error-cannot-find-libcurl\"><a href=\"#configure-error-cannot-find-libcurl\" class=\"headerlink\" title=\"configure: error: cannot find libcurl\"></a>configure: error: cannot find libcurl</h2><h2 id=\"libcurl-is-required-for-mesos-to-build\"><a href=\"#libcurl-is-required-for-mesos-to-build\" class=\"headerlink\" title=\"libcurl is required for mesos to build.\"></a>libcurl is required for mesos to build.</h2><p> <code>yum install libcurl-devel</code><br>2.libsubversion-1 is required for mesos to build.</p>\n<p><code>yum install -y subversion-devel</code><br>这两个都是之前命令中安装的东西但是到了这里又需要重新安装，应该是yum安装失败的问题<br>编译过程太慢了</p>\n<p>3.执行make时出现错误</p>\n<blockquote>\n<p>Building mesos-1.4.0.jar …<br>Exception in thread “main” java.lang.UnsupportedClassVersionError: org/apache/maven/cli/MavenCli : Unsupported major.minor version 51.0</p>\n</blockquote>\n<p>这个主要是因为你的java环境低于1.7造成的，可以尝试升级jdk版本，<br>但是<strong>我在升级之后明明java  -version提示的1.7，编译还是失败</strong>，后来查看Makefile文件发现，文件中已经写死了jdk路径，比如这种：<br><code>CONFIGURE_ARGS =  &#39;JAVA_HOME=/opt/soft/jdk/jdk1.6.0_45</code><br>最后通过修改(注意有好几个Makefile文件)<br><code>vim build/src/Makefile</code><br><code>1,$s/jdk1.6.0_45/jdk1.7.0_79/g</code>（执行替换）</p>\n<p>配置有两种<br>一个是 在通过命令行启动时添加选项 eg:–option_name=value<br>一个是 通过设置环境变量 eg:MESOS_XXX(XXX就是OPTION_NAME）</p>\n<p>mesos master配置<br>必填项<br>–work_dir=/var/lib/mesos/master<br>这两个在单master时是不需要的<br>–zk=<br>–quorum==</p>\n<p>我们使用环境变量来配置<br>echo ‘export MESOS_work_dir=/var/lib/mesos’&gt;&gt;/etc/profile<br>source /etc/profile<br>进入build目录<br>执行<code>./bin/mesos-master.sh --ip=127.0.0.1 &gt;/dev/null &amp;</code><br>启动master</p>\n<p>mesos agent配置<br>必填项<br>–master=<br>host:port<br>zk://host1:port1,host2:port2,…/path zk://username:password@host1:port1,host2:port2,…/path file:///path/to/file (where file contains one of the above)<br>–work_dir=VALUE </p>\n<p><code>./mussh -H iplist3 -c &#39;echo &quot;export MESOS_master=10.252.81.25:5050&quot;&gt;&gt;/etc/profile&#39;</code><br><code>./mussh -H iplist3 -c &#39;echo &quot;export MESOS_work_dir=/var/lib/mesos/agent&quot;&gt;&gt;/etc/profile&#39;</code><br><code>./mussh -H iplist3 -c &#39;source /etc/profile&#39;</code>（mussh执行source无效，还是要逐个刷新）<br><code>./bin/mesos-agent.sh</code>启动agent</p>\n<p>agent启动报错，无法在master注册<br>XX exited event for master XX<br>这时要检查master的hostname是不是配置的ip地址，如果不一致使用hostname “name”命令设置为对应ip</p>\n<p>在master访问<a href=\"http://127.0.0.1:5050/#/agents\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:5050/#/agents</a><br>就能看到启动的agents<br><img src=\"/images/mesos.png\" alt=\"启动成功\"></p>"},{"title":"MySQL事务隔离性测试","date":"2018-02-02T05:25:46.000Z","_content":"### 环境准备\nMySQL版本 5.5.35-rel33.0-log Percona Server with XtraDB (GPL), Release rel33.0, Revision 611\n引擎 InnoDB\n*(才发现公司用的MySQL是Percona这个公司开发的一个版本，Percona Server [产品介绍][1])*\n```\nmysql> select version();\n+--------------------+\n| version()          |\n+--------------------+\n| 5.5.35-rel33.0-log |\n+--------------------+\n\nmysql> show engines \\G;\n*************************** 6. row ***************************\n      Engine: InnoDB\n     Support: DEFAULT\n     Comment: Percona-XtraDB, Supports transactions, row-level locking, and foreign keys\nTransactions: YES\n          XA: YES\n  Savepoints: YES\n\n```\n<!--more-->\n\n### 基本概念\n隔离性：事务的操作何时对其他事务可见\n脏读/不可重复读/幻读\n\n\n### 建表\n```\nCREATE TABLE `test` (\n  `id` bigint(20) NOT NULL AUTO_INCREMENT,\n  `name` varchar(45) DEFAULT NULL,\n  `age` int(11) DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8\n```\n初始数据如下：\n```\nmysql> select * from test;\n+----+------+------+\n| id | name | age  |\n+----+------+------+\n|  1 | Tom  |   20 |\n|  2 | Jack |   22 |\n|  3 | Rose |   24 |\n|  4 | Bob  |   26 |\n+----+------+------+\n```\n### Repeatable Read 隔离级别测试\n\n**可重复读测试**\n\n启动两个客户端连接，连接一执行事务A，连接二执行事务B。\n\n1.事务A 执行查询操作：\n```\nmysql> begin;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> select * from test;\n+----+------+------+\n| id | name | age  |\n+----+------+------+\n|  1 | Tom  |   20 |\n|  2 | Jack |   22 |\n|  3 | Rose |   24 |\n|  4 | Bob  |   26 |\n+----+------+------+\n4 rows in set (0.01 sec)\n```\n2.事务B 更新数据：\n```\nmysql> begin;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> update test set age=10 where id=1;\nQuery OK, 1 row affected (0.00 sec)\nRows matched: 1  Changed: 1  Warnings: 0\n\n```\n3.事务A 再执行查询：\n```\nmysql> select * from test;\n+----+------+------+\n| id | name | age  |\n+----+------+------+\n|  1 | Tom  |   20 |\n|  2 | Jack |   22 |\n|  3 | Rose |   24 |\n|  4 | Bob  |   26 |\n+----+------+------+\n4 rows in set (0.00 sec)\n```\n4.事务B 提交：\n```\nmysql> commit;\nQuery OK, 0 rows affected (0.00 sec)\n```\n5.事务A 再次执行查询并提交，然后执行一次查询：\n```\nmysql> select * from test;\n+----+------+------+\n| id | name | age  |\n+----+------+------+\n|  1 | Tom  |   20 |\n|  2 | Jack |   22 |\n|  3 | Rose |   24 |\n|  4 | Bob  |   26 |\n+----+------+------+\n\nmysql> commit;\n\nmysql> select * from test;\n+----+------+------+\n| id | name | age  |\n+----+------+------+\n|  1 | Tom  |   10 |\n|  2 | Jack |   22 |\n|  3 | Rose |   24 |\n|  4 | Bob  |   26 |\n+----+------+------+\n```\n测试结果结果说明在RR级别下，尽管事务A执行结束前，事务B修改了数据，但是事务A中的几次查询（1,3,5）返回的结果是一致的，这样就保证了可重复读，AB事务的操作时序如下：\n|----A----|----B----|\n|--begin--|-------------|\n|--select--| begin |\n|-------------| update|\n|-------------| commit|\n|--select--|-------------|\n|commit|-------------|\n\n**幻读测试**\n1.事务A 开始并查询数据：\n```\nmysql> begin;\nmysql> select * from test where age<25;\n+----+------+------+\n| id | name | age  |\n+----+------+------+\n|  1 | Tom  |   20 |\n|  2 | Jack |   22 |\n|  3 | Rose |   24 |\n+----+------+------+\n```\n2.事务B 插入一条新纪录并提交:\n```\nmysql> begin;\nmysql> select * from test;\n+----+------+------+\n| id | name | age  |\n+----+------+------+\n|  1 | Tom  |   20 |\n|  2 | Jack |   22 |\n|  3 | Rose |   24 |\n|  4 | Bob  |   26 |\n+----+------+------+\nmysql> insert test(name,age) values(\"Tony\",18);\nmysql> commit;\n```\n此时新纪录“Tony”也满足A的查询条件\n3.事务A 再次查询：\n返回结果和上次一致，没有新纪录。\n```\nmysql> select * from test where age<25;\n+----+------+------+\n| id | name | age  |\n+----+------+------+\n|  1 | Tom  |   20 |\n|  2 | Jack |   22 |\n|  3 | Rose |   24 |\n+----+------+------+\n```\n4.事务A提交 然后执行新查询：\n事务提交后，查询返回了新纪录\"Tony\"。\n```\nmysql> commit;\nmysql> select * from test where age<25;\n+----+------+------+\n| id | name | age  |\n+----+------+------+\n|  1 | Tom  |   20 |\n|  2 | Jack |   22 |\n|  3 | Rose |   24 |\n|  5 | Tony |   18 |\n+----+------+------+\n```\n\n### Read Commit 隔离级别测试\n原本的默认级别是RR需要修改一下，只修改当前会话的事务隔离级别：\n```\nmysql> set session transaction isolation level read committed;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> select @@global.tx_isolation,@@session.tx_isolation;\n+-----------------------+------------------------+\n| @@global.tx_isolation | @@session.tx_isolation |\n+-----------------------+------------------------+\n| REPEATABLE-READ       | READ-COMMITTED         |\n+-----------------------+------------------------+\n```\n**可重复读测试：**\n和之前类似，事务A执行查询，事务B在A尚未完成时修改数据。\n1.事务A 查询:\n```\nmysql> begin;\nmysql> select * from test;\n+----+------+------+\n| id | name | age  |\n+----+------+------+\n|  1 | Tom  |   20 |\n|  2 | Jack |   22 |\n|  3 | Rose |   24 |\n|  4 | Bob  |   26 |\n+----+------+------+\n```\n2.事务B修改数据：\n```\nmysql> begin;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> update test set age=10 where id=1;\nQuery OK, 1 row affected (0.01 sec)\nRows matched: 1  Changed: 1  Warnings: 0\n```\n3.事务A 再次查询：\n此时结果还是和上次一致的，这说明并未发生\"脏读\"\n```\nmysql> select * from test;\n+----+------+------+\n| id | name | age  |\n+----+------+------+\n|  1 | Tom  |   20 |\n|  2 | Jack |   22 |\n|  3 | Rose |   24 |\n|  4 | Bob  |   26 |\n+----+------+------+\n```\n4.事务B 提交：\n```\nmysql> commit;\n```\n5.事务A 查询：\n在B提交之后A读到了B修改的数据，和之前结果不一致\n```\nmysql> select * from test;\n+----+------+------+\n| id | name | age  |\n+----+------+------+\n|  1 | Tom  |   10 |\n|  2 | Jack |   22 |\n|  3 | Rose |   24 |\n|  4 | Bob  |   26 |\n+----+------+------+\nmysql> commit;\n```\n**幻读测试**\n既然发生了不可重复读，那么幻读也会发生。\n1.事务A 查询：\n```\nmysql> begin;\nmysql> select * from test;\n+----+------+------+\n| id | name | age  |\n+----+------+------+\n|  1 | Tom  |   10 |\n|  2 | Jack |   22 |\n|  3 | Rose |   24 |\n|  4 | Bob  |   26 |\n+----+------+------+\n```\n2.事务B 新增记录&提：\n```\nmysql> begin;\nmysql> insert test(name,age) values(\"Tony\",18);\nmysql> commit;\n```\n3.事务A 再查询：\n```\nmysql> select * from test;\n+----+------+------+\n| id | name | age  |\n+----+------+------+\n|  1 | Tom  |   10 |\n|  2 | Jack |   22 |\n|  3 | Rose |   24 |\n|  4 | Bob  |   26 |\n|  6 | Tony |   18 |\n+----+------+------+\n```\n\n\n\n  [1]: https://www.percona.com/software/mysql-database/percona-server","source":"_posts/MySQL事务隔离性测试.md","raw":"title: MySQL事务隔离性测试\ndate: 2018-02-02 13:25:46\ncategories: mysql进阶\ntags: [mysql,数据库]\n---\n### 环境准备\nMySQL版本 5.5.35-rel33.0-log Percona Server with XtraDB (GPL), Release rel33.0, Revision 611\n引擎 InnoDB\n*(才发现公司用的MySQL是Percona这个公司开发的一个版本，Percona Server [产品介绍][1])*\n```\nmysql> select version();\n+--------------------+\n| version()          |\n+--------------------+\n| 5.5.35-rel33.0-log |\n+--------------------+\n\nmysql> show engines \\G;\n*************************** 6. row ***************************\n      Engine: InnoDB\n     Support: DEFAULT\n     Comment: Percona-XtraDB, Supports transactions, row-level locking, and foreign keys\nTransactions: YES\n          XA: YES\n  Savepoints: YES\n\n```\n<!--more-->\n\n### 基本概念\n隔离性：事务的操作何时对其他事务可见\n脏读/不可重复读/幻读\n\n\n### 建表\n```\nCREATE TABLE `test` (\n  `id` bigint(20) NOT NULL AUTO_INCREMENT,\n  `name` varchar(45) DEFAULT NULL,\n  `age` int(11) DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8\n```\n初始数据如下：\n```\nmysql> select * from test;\n+----+------+------+\n| id | name | age  |\n+----+------+------+\n|  1 | Tom  |   20 |\n|  2 | Jack |   22 |\n|  3 | Rose |   24 |\n|  4 | Bob  |   26 |\n+----+------+------+\n```\n### Repeatable Read 隔离级别测试\n\n**可重复读测试**\n\n启动两个客户端连接，连接一执行事务A，连接二执行事务B。\n\n1.事务A 执行查询操作：\n```\nmysql> begin;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> select * from test;\n+----+------+------+\n| id | name | age  |\n+----+------+------+\n|  1 | Tom  |   20 |\n|  2 | Jack |   22 |\n|  3 | Rose |   24 |\n|  4 | Bob  |   26 |\n+----+------+------+\n4 rows in set (0.01 sec)\n```\n2.事务B 更新数据：\n```\nmysql> begin;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> update test set age=10 where id=1;\nQuery OK, 1 row affected (0.00 sec)\nRows matched: 1  Changed: 1  Warnings: 0\n\n```\n3.事务A 再执行查询：\n```\nmysql> select * from test;\n+----+------+------+\n| id | name | age  |\n+----+------+------+\n|  1 | Tom  |   20 |\n|  2 | Jack |   22 |\n|  3 | Rose |   24 |\n|  4 | Bob  |   26 |\n+----+------+------+\n4 rows in set (0.00 sec)\n```\n4.事务B 提交：\n```\nmysql> commit;\nQuery OK, 0 rows affected (0.00 sec)\n```\n5.事务A 再次执行查询并提交，然后执行一次查询：\n```\nmysql> select * from test;\n+----+------+------+\n| id | name | age  |\n+----+------+------+\n|  1 | Tom  |   20 |\n|  2 | Jack |   22 |\n|  3 | Rose |   24 |\n|  4 | Bob  |   26 |\n+----+------+------+\n\nmysql> commit;\n\nmysql> select * from test;\n+----+------+------+\n| id | name | age  |\n+----+------+------+\n|  1 | Tom  |   10 |\n|  2 | Jack |   22 |\n|  3 | Rose |   24 |\n|  4 | Bob  |   26 |\n+----+------+------+\n```\n测试结果结果说明在RR级别下，尽管事务A执行结束前，事务B修改了数据，但是事务A中的几次查询（1,3,5）返回的结果是一致的，这样就保证了可重复读，AB事务的操作时序如下：\n|----A----|----B----|\n|--begin--|-------------|\n|--select--| begin |\n|-------------| update|\n|-------------| commit|\n|--select--|-------------|\n|commit|-------------|\n\n**幻读测试**\n1.事务A 开始并查询数据：\n```\nmysql> begin;\nmysql> select * from test where age<25;\n+----+------+------+\n| id | name | age  |\n+----+------+------+\n|  1 | Tom  |   20 |\n|  2 | Jack |   22 |\n|  3 | Rose |   24 |\n+----+------+------+\n```\n2.事务B 插入一条新纪录并提交:\n```\nmysql> begin;\nmysql> select * from test;\n+----+------+------+\n| id | name | age  |\n+----+------+------+\n|  1 | Tom  |   20 |\n|  2 | Jack |   22 |\n|  3 | Rose |   24 |\n|  4 | Bob  |   26 |\n+----+------+------+\nmysql> insert test(name,age) values(\"Tony\",18);\nmysql> commit;\n```\n此时新纪录“Tony”也满足A的查询条件\n3.事务A 再次查询：\n返回结果和上次一致，没有新纪录。\n```\nmysql> select * from test where age<25;\n+----+------+------+\n| id | name | age  |\n+----+------+------+\n|  1 | Tom  |   20 |\n|  2 | Jack |   22 |\n|  3 | Rose |   24 |\n+----+------+------+\n```\n4.事务A提交 然后执行新查询：\n事务提交后，查询返回了新纪录\"Tony\"。\n```\nmysql> commit;\nmysql> select * from test where age<25;\n+----+------+------+\n| id | name | age  |\n+----+------+------+\n|  1 | Tom  |   20 |\n|  2 | Jack |   22 |\n|  3 | Rose |   24 |\n|  5 | Tony |   18 |\n+----+------+------+\n```\n\n### Read Commit 隔离级别测试\n原本的默认级别是RR需要修改一下，只修改当前会话的事务隔离级别：\n```\nmysql> set session transaction isolation level read committed;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> select @@global.tx_isolation,@@session.tx_isolation;\n+-----------------------+------------------------+\n| @@global.tx_isolation | @@session.tx_isolation |\n+-----------------------+------------------------+\n| REPEATABLE-READ       | READ-COMMITTED         |\n+-----------------------+------------------------+\n```\n**可重复读测试：**\n和之前类似，事务A执行查询，事务B在A尚未完成时修改数据。\n1.事务A 查询:\n```\nmysql> begin;\nmysql> select * from test;\n+----+------+------+\n| id | name | age  |\n+----+------+------+\n|  1 | Tom  |   20 |\n|  2 | Jack |   22 |\n|  3 | Rose |   24 |\n|  4 | Bob  |   26 |\n+----+------+------+\n```\n2.事务B修改数据：\n```\nmysql> begin;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> update test set age=10 where id=1;\nQuery OK, 1 row affected (0.01 sec)\nRows matched: 1  Changed: 1  Warnings: 0\n```\n3.事务A 再次查询：\n此时结果还是和上次一致的，这说明并未发生\"脏读\"\n```\nmysql> select * from test;\n+----+------+------+\n| id | name | age  |\n+----+------+------+\n|  1 | Tom  |   20 |\n|  2 | Jack |   22 |\n|  3 | Rose |   24 |\n|  4 | Bob  |   26 |\n+----+------+------+\n```\n4.事务B 提交：\n```\nmysql> commit;\n```\n5.事务A 查询：\n在B提交之后A读到了B修改的数据，和之前结果不一致\n```\nmysql> select * from test;\n+----+------+------+\n| id | name | age  |\n+----+------+------+\n|  1 | Tom  |   10 |\n|  2 | Jack |   22 |\n|  3 | Rose |   24 |\n|  4 | Bob  |   26 |\n+----+------+------+\nmysql> commit;\n```\n**幻读测试**\n既然发生了不可重复读，那么幻读也会发生。\n1.事务A 查询：\n```\nmysql> begin;\nmysql> select * from test;\n+----+------+------+\n| id | name | age  |\n+----+------+------+\n|  1 | Tom  |   10 |\n|  2 | Jack |   22 |\n|  3 | Rose |   24 |\n|  4 | Bob  |   26 |\n+----+------+------+\n```\n2.事务B 新增记录&提：\n```\nmysql> begin;\nmysql> insert test(name,age) values(\"Tony\",18);\nmysql> commit;\n```\n3.事务A 再查询：\n```\nmysql> select * from test;\n+----+------+------+\n| id | name | age  |\n+----+------+------+\n|  1 | Tom  |   10 |\n|  2 | Jack |   22 |\n|  3 | Rose |   24 |\n|  4 | Bob  |   26 |\n|  6 | Tony |   18 |\n+----+------+------+\n```\n\n\n\n  [1]: https://www.percona.com/software/mysql-database/percona-server","slug":"MySQL事务隔离性测试","published":1,"updated":"2018-11-21T16:34:24.066Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkqle16w0008cynek4195akh","content":"<h3 id=\"环境准备\"><a href=\"#环境准备\" class=\"headerlink\" title=\"环境准备\"></a>环境准备</h3><p>MySQL版本 5.5.35-rel33.0-log Percona Server with XtraDB (GPL), Release rel33.0, Revision 611<br>引擎 InnoDB<br><em>(才发现公司用的MySQL是Percona这个公司开发的一个版本，Percona Server <a href=\"https://www.percona.com/software/mysql-database/percona-server\" target=\"_blank\" rel=\"noopener\">产品介绍</a>)</em><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; select version();</span><br><span class=\"line\">+--------------------+</span><br><span class=\"line\">| version()          |</span><br><span class=\"line\">+--------------------+</span><br><span class=\"line\">| 5.5.35-rel33.0-log |</span><br><span class=\"line\">+--------------------+</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; show engines \\G;</span><br><span class=\"line\">*************************** 6. row ***************************</span><br><span class=\"line\">      Engine: InnoDB</span><br><span class=\"line\">     Support: DEFAULT</span><br><span class=\"line\">     Comment: Percona-XtraDB, Supports transactions, row-level locking, and foreign keys</span><br><span class=\"line\">Transactions: YES</span><br><span class=\"line\">          XA: YES</span><br><span class=\"line\">  Savepoints: YES</span><br></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><p>隔离性：事务的操作何时对其他事务可见<br>脏读/不可重复读/幻读</p>\n<h3 id=\"建表\"><a href=\"#建表\" class=\"headerlink\" title=\"建表\"></a>建表</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CREATE TABLE `test` (</span><br><span class=\"line\">  `id` bigint(20) NOT NULL AUTO_INCREMENT,</span><br><span class=\"line\">  `name` varchar(45) DEFAULT NULL,</span><br><span class=\"line\">  `age` int(11) DEFAULT NULL,</span><br><span class=\"line\">  PRIMARY KEY (`id`)</span><br><span class=\"line\">) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8</span><br></pre></td></tr></table></figure>\n<p>初始数据如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; select * from test;</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">| id | name | age  |</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">|  1 | Tom  |   20 |</span><br><span class=\"line\">|  2 | Jack |   22 |</span><br><span class=\"line\">|  3 | Rose |   24 |</span><br><span class=\"line\">|  4 | Bob  |   26 |</span><br><span class=\"line\">+----+------+------+</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Repeatable-Read-隔离级别测试\"><a href=\"#Repeatable-Read-隔离级别测试\" class=\"headerlink\" title=\"Repeatable Read 隔离级别测试\"></a>Repeatable Read 隔离级别测试</h3><p><strong>可重复读测试</strong></p>\n<p>启动两个客户端连接，连接一执行事务A，连接二执行事务B。</p>\n<p>1.事务A 执行查询操作：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; begin;</span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; select * from test;</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">| id | name | age  |</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">|  1 | Tom  |   20 |</span><br><span class=\"line\">|  2 | Jack |   22 |</span><br><span class=\"line\">|  3 | Rose |   24 |</span><br><span class=\"line\">|  4 | Bob  |   26 |</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">4 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure></p>\n<p>2.事务B 更新数据：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; begin;</span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; update test set age=10 where id=1;</span><br><span class=\"line\">Query OK, 1 row affected (0.00 sec)</span><br><span class=\"line\">Rows matched: 1  Changed: 1  Warnings: 0</span><br></pre></td></tr></table></figure></p>\n<p>3.事务A 再执行查询：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; select * from test;</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">| id | name | age  |</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">|  1 | Tom  |   20 |</span><br><span class=\"line\">|  2 | Jack |   22 |</span><br><span class=\"line\">|  3 | Rose |   24 |</span><br><span class=\"line\">|  4 | Bob  |   26 |</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></p>\n<p>4.事务B 提交：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; commit;</span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure></p>\n<p>5.事务A 再次执行查询并提交，然后执行一次查询：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; select * from test;</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">| id | name | age  |</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">|  1 | Tom  |   20 |</span><br><span class=\"line\">|  2 | Jack |   22 |</span><br><span class=\"line\">|  3 | Rose |   24 |</span><br><span class=\"line\">|  4 | Bob  |   26 |</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; commit;</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; select * from test;</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">| id | name | age  |</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">|  1 | Tom  |   10 |</span><br><span class=\"line\">|  2 | Jack |   22 |</span><br><span class=\"line\">|  3 | Rose |   24 |</span><br><span class=\"line\">|  4 | Bob  |   26 |</span><br><span class=\"line\">+----+------+------+</span><br></pre></td></tr></table></figure></p>\n<p>测试结果结果说明在RR级别下，尽管事务A执行结束前，事务B修改了数据，但是事务A中的几次查询（1,3,5）返回的结果是一致的，这样就保证了可重复读，AB事务的操作时序如下：<br>|—-A—-|—-B—-|<br>|–begin–|————-|<br>|–select–| begin |<br>|————-| update|<br>|————-| commit|<br>|–select–|————-|<br>|commit|————-|</p>\n<p><strong>幻读测试</strong><br>1.事务A 开始并查询数据：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; begin;</span><br><span class=\"line\">mysql&gt; select * from test where age&lt;25;</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">| id | name | age  |</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">|  1 | Tom  |   20 |</span><br><span class=\"line\">|  2 | Jack |   22 |</span><br><span class=\"line\">|  3 | Rose |   24 |</span><br><span class=\"line\">+----+------+------+</span><br></pre></td></tr></table></figure></p>\n<p>2.事务B 插入一条新纪录并提交:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; begin;</span><br><span class=\"line\">mysql&gt; select * from test;</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">| id | name | age  |</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">|  1 | Tom  |   20 |</span><br><span class=\"line\">|  2 | Jack |   22 |</span><br><span class=\"line\">|  3 | Rose |   24 |</span><br><span class=\"line\">|  4 | Bob  |   26 |</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">mysql&gt; insert test(name,age) values(&quot;Tony&quot;,18);</span><br><span class=\"line\">mysql&gt; commit;</span><br></pre></td></tr></table></figure></p>\n<p>此时新纪录“Tony”也满足A的查询条件<br>3.事务A 再次查询：<br>返回结果和上次一致，没有新纪录。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; select * from test where age&lt;25;</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">| id | name | age  |</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">|  1 | Tom  |   20 |</span><br><span class=\"line\">|  2 | Jack |   22 |</span><br><span class=\"line\">|  3 | Rose |   24 |</span><br><span class=\"line\">+----+------+------+</span><br></pre></td></tr></table></figure></p>\n<p>4.事务A提交 然后执行新查询：<br>事务提交后，查询返回了新纪录”Tony”。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; commit;</span><br><span class=\"line\">mysql&gt; select * from test where age&lt;25;</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">| id | name | age  |</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">|  1 | Tom  |   20 |</span><br><span class=\"line\">|  2 | Jack |   22 |</span><br><span class=\"line\">|  3 | Rose |   24 |</span><br><span class=\"line\">|  5 | Tony |   18 |</span><br><span class=\"line\">+----+------+------+</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Read-Commit-隔离级别测试\"><a href=\"#Read-Commit-隔离级别测试\" class=\"headerlink\" title=\"Read Commit 隔离级别测试\"></a>Read Commit 隔离级别测试</h3><p>原本的默认级别是RR需要修改一下，只修改当前会话的事务隔离级别：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; set session transaction isolation level read committed;</span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; select @@global.tx_isolation,@@session.tx_isolation;</span><br><span class=\"line\">+-----------------------+------------------------+</span><br><span class=\"line\">| @@global.tx_isolation | @@session.tx_isolation |</span><br><span class=\"line\">+-----------------------+------------------------+</span><br><span class=\"line\">| REPEATABLE-READ       | READ-COMMITTED         |</span><br><span class=\"line\">+-----------------------+------------------------+</span><br></pre></td></tr></table></figure></p>\n<p><strong>可重复读测试：</strong><br>和之前类似，事务A执行查询，事务B在A尚未完成时修改数据。<br>1.事务A 查询:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; begin;</span><br><span class=\"line\">mysql&gt; select * from test;</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">| id | name | age  |</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">|  1 | Tom  |   20 |</span><br><span class=\"line\">|  2 | Jack |   22 |</span><br><span class=\"line\">|  3 | Rose |   24 |</span><br><span class=\"line\">|  4 | Bob  |   26 |</span><br><span class=\"line\">+----+------+------+</span><br></pre></td></tr></table></figure></p>\n<p>2.事务B修改数据：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; begin;</span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; update test set age=10 where id=1;</span><br><span class=\"line\">Query OK, 1 row affected (0.01 sec)</span><br><span class=\"line\">Rows matched: 1  Changed: 1  Warnings: 0</span><br></pre></td></tr></table></figure></p>\n<p>3.事务A 再次查询：<br>此时结果还是和上次一致的，这说明并未发生”脏读”<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; select * from test;</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">| id | name | age  |</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">|  1 | Tom  |   20 |</span><br><span class=\"line\">|  2 | Jack |   22 |</span><br><span class=\"line\">|  3 | Rose |   24 |</span><br><span class=\"line\">|  4 | Bob  |   26 |</span><br><span class=\"line\">+----+------+------+</span><br></pre></td></tr></table></figure></p>\n<p>4.事务B 提交：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; commit;</span><br></pre></td></tr></table></figure></p>\n<p>5.事务A 查询：<br>在B提交之后A读到了B修改的数据，和之前结果不一致<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; select * from test;</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">| id | name | age  |</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">|  1 | Tom  |   10 |</span><br><span class=\"line\">|  2 | Jack |   22 |</span><br><span class=\"line\">|  3 | Rose |   24 |</span><br><span class=\"line\">|  4 | Bob  |   26 |</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">mysql&gt; commit;</span><br></pre></td></tr></table></figure></p>\n<p><strong>幻读测试</strong><br>既然发生了不可重复读，那么幻读也会发生。<br>1.事务A 查询：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; begin;</span><br><span class=\"line\">mysql&gt; select * from test;</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">| id | name | age  |</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">|  1 | Tom  |   10 |</span><br><span class=\"line\">|  2 | Jack |   22 |</span><br><span class=\"line\">|  3 | Rose |   24 |</span><br><span class=\"line\">|  4 | Bob  |   26 |</span><br><span class=\"line\">+----+------+------+</span><br></pre></td></tr></table></figure></p>\n<p>2.事务B 新增记录&amp;提：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; begin;</span><br><span class=\"line\">mysql&gt; insert test(name,age) values(&quot;Tony&quot;,18);</span><br><span class=\"line\">mysql&gt; commit;</span><br></pre></td></tr></table></figure></p>\n<p>3.事务A 再查询：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; select * from test;</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">| id | name | age  |</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">|  1 | Tom  |   10 |</span><br><span class=\"line\">|  2 | Jack |   22 |</span><br><span class=\"line\">|  3 | Rose |   24 |</span><br><span class=\"line\">|  4 | Bob  |   26 |</span><br><span class=\"line\">|  6 | Tony |   18 |</span><br><span class=\"line\">+----+------+------+</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"环境准备\"><a href=\"#环境准备\" class=\"headerlink\" title=\"环境准备\"></a>环境准备</h3><p>MySQL版本 5.5.35-rel33.0-log Percona Server with XtraDB (GPL), Release rel33.0, Revision 611<br>引擎 InnoDB<br><em>(才发现公司用的MySQL是Percona这个公司开发的一个版本，Percona Server <a href=\"https://www.percona.com/software/mysql-database/percona-server\" target=\"_blank\" rel=\"noopener\">产品介绍</a>)</em><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; select version();</span><br><span class=\"line\">+--------------------+</span><br><span class=\"line\">| version()          |</span><br><span class=\"line\">+--------------------+</span><br><span class=\"line\">| 5.5.35-rel33.0-log |</span><br><span class=\"line\">+--------------------+</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; show engines \\G;</span><br><span class=\"line\">*************************** 6. row ***************************</span><br><span class=\"line\">      Engine: InnoDB</span><br><span class=\"line\">     Support: DEFAULT</span><br><span class=\"line\">     Comment: Percona-XtraDB, Supports transactions, row-level locking, and foreign keys</span><br><span class=\"line\">Transactions: YES</span><br><span class=\"line\">          XA: YES</span><br><span class=\"line\">  Savepoints: YES</span><br></pre></td></tr></table></figure></p>","more":"<h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><p>隔离性：事务的操作何时对其他事务可见<br>脏读/不可重复读/幻读</p>\n<h3 id=\"建表\"><a href=\"#建表\" class=\"headerlink\" title=\"建表\"></a>建表</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CREATE TABLE `test` (</span><br><span class=\"line\">  `id` bigint(20) NOT NULL AUTO_INCREMENT,</span><br><span class=\"line\">  `name` varchar(45) DEFAULT NULL,</span><br><span class=\"line\">  `age` int(11) DEFAULT NULL,</span><br><span class=\"line\">  PRIMARY KEY (`id`)</span><br><span class=\"line\">) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8</span><br></pre></td></tr></table></figure>\n<p>初始数据如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; select * from test;</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">| id | name | age  |</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">|  1 | Tom  |   20 |</span><br><span class=\"line\">|  2 | Jack |   22 |</span><br><span class=\"line\">|  3 | Rose |   24 |</span><br><span class=\"line\">|  4 | Bob  |   26 |</span><br><span class=\"line\">+----+------+------+</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Repeatable-Read-隔离级别测试\"><a href=\"#Repeatable-Read-隔离级别测试\" class=\"headerlink\" title=\"Repeatable Read 隔离级别测试\"></a>Repeatable Read 隔离级别测试</h3><p><strong>可重复读测试</strong></p>\n<p>启动两个客户端连接，连接一执行事务A，连接二执行事务B。</p>\n<p>1.事务A 执行查询操作：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; begin;</span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; select * from test;</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">| id | name | age  |</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">|  1 | Tom  |   20 |</span><br><span class=\"line\">|  2 | Jack |   22 |</span><br><span class=\"line\">|  3 | Rose |   24 |</span><br><span class=\"line\">|  4 | Bob  |   26 |</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">4 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure></p>\n<p>2.事务B 更新数据：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; begin;</span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; update test set age=10 where id=1;</span><br><span class=\"line\">Query OK, 1 row affected (0.00 sec)</span><br><span class=\"line\">Rows matched: 1  Changed: 1  Warnings: 0</span><br></pre></td></tr></table></figure></p>\n<p>3.事务A 再执行查询：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; select * from test;</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">| id | name | age  |</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">|  1 | Tom  |   20 |</span><br><span class=\"line\">|  2 | Jack |   22 |</span><br><span class=\"line\">|  3 | Rose |   24 |</span><br><span class=\"line\">|  4 | Bob  |   26 |</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></p>\n<p>4.事务B 提交：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; commit;</span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure></p>\n<p>5.事务A 再次执行查询并提交，然后执行一次查询：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; select * from test;</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">| id | name | age  |</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">|  1 | Tom  |   20 |</span><br><span class=\"line\">|  2 | Jack |   22 |</span><br><span class=\"line\">|  3 | Rose |   24 |</span><br><span class=\"line\">|  4 | Bob  |   26 |</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; commit;</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; select * from test;</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">| id | name | age  |</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">|  1 | Tom  |   10 |</span><br><span class=\"line\">|  2 | Jack |   22 |</span><br><span class=\"line\">|  3 | Rose |   24 |</span><br><span class=\"line\">|  4 | Bob  |   26 |</span><br><span class=\"line\">+----+------+------+</span><br></pre></td></tr></table></figure></p>\n<p>测试结果结果说明在RR级别下，尽管事务A执行结束前，事务B修改了数据，但是事务A中的几次查询（1,3,5）返回的结果是一致的，这样就保证了可重复读，AB事务的操作时序如下：<br>|—-A—-|—-B—-|<br>|–begin–|————-|<br>|–select–| begin |<br>|————-| update|<br>|————-| commit|<br>|–select–|————-|<br>|commit|————-|</p>\n<p><strong>幻读测试</strong><br>1.事务A 开始并查询数据：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; begin;</span><br><span class=\"line\">mysql&gt; select * from test where age&lt;25;</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">| id | name | age  |</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">|  1 | Tom  |   20 |</span><br><span class=\"line\">|  2 | Jack |   22 |</span><br><span class=\"line\">|  3 | Rose |   24 |</span><br><span class=\"line\">+----+------+------+</span><br></pre></td></tr></table></figure></p>\n<p>2.事务B 插入一条新纪录并提交:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; begin;</span><br><span class=\"line\">mysql&gt; select * from test;</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">| id | name | age  |</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">|  1 | Tom  |   20 |</span><br><span class=\"line\">|  2 | Jack |   22 |</span><br><span class=\"line\">|  3 | Rose |   24 |</span><br><span class=\"line\">|  4 | Bob  |   26 |</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">mysql&gt; insert test(name,age) values(&quot;Tony&quot;,18);</span><br><span class=\"line\">mysql&gt; commit;</span><br></pre></td></tr></table></figure></p>\n<p>此时新纪录“Tony”也满足A的查询条件<br>3.事务A 再次查询：<br>返回结果和上次一致，没有新纪录。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; select * from test where age&lt;25;</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">| id | name | age  |</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">|  1 | Tom  |   20 |</span><br><span class=\"line\">|  2 | Jack |   22 |</span><br><span class=\"line\">|  3 | Rose |   24 |</span><br><span class=\"line\">+----+------+------+</span><br></pre></td></tr></table></figure></p>\n<p>4.事务A提交 然后执行新查询：<br>事务提交后，查询返回了新纪录”Tony”。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; commit;</span><br><span class=\"line\">mysql&gt; select * from test where age&lt;25;</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">| id | name | age  |</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">|  1 | Tom  |   20 |</span><br><span class=\"line\">|  2 | Jack |   22 |</span><br><span class=\"line\">|  3 | Rose |   24 |</span><br><span class=\"line\">|  5 | Tony |   18 |</span><br><span class=\"line\">+----+------+------+</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Read-Commit-隔离级别测试\"><a href=\"#Read-Commit-隔离级别测试\" class=\"headerlink\" title=\"Read Commit 隔离级别测试\"></a>Read Commit 隔离级别测试</h3><p>原本的默认级别是RR需要修改一下，只修改当前会话的事务隔离级别：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; set session transaction isolation level read committed;</span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; select @@global.tx_isolation,@@session.tx_isolation;</span><br><span class=\"line\">+-----------------------+------------------------+</span><br><span class=\"line\">| @@global.tx_isolation | @@session.tx_isolation |</span><br><span class=\"line\">+-----------------------+------------------------+</span><br><span class=\"line\">| REPEATABLE-READ       | READ-COMMITTED         |</span><br><span class=\"line\">+-----------------------+------------------------+</span><br></pre></td></tr></table></figure></p>\n<p><strong>可重复读测试：</strong><br>和之前类似，事务A执行查询，事务B在A尚未完成时修改数据。<br>1.事务A 查询:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; begin;</span><br><span class=\"line\">mysql&gt; select * from test;</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">| id | name | age  |</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">|  1 | Tom  |   20 |</span><br><span class=\"line\">|  2 | Jack |   22 |</span><br><span class=\"line\">|  3 | Rose |   24 |</span><br><span class=\"line\">|  4 | Bob  |   26 |</span><br><span class=\"line\">+----+------+------+</span><br></pre></td></tr></table></figure></p>\n<p>2.事务B修改数据：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; begin;</span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; update test set age=10 where id=1;</span><br><span class=\"line\">Query OK, 1 row affected (0.01 sec)</span><br><span class=\"line\">Rows matched: 1  Changed: 1  Warnings: 0</span><br></pre></td></tr></table></figure></p>\n<p>3.事务A 再次查询：<br>此时结果还是和上次一致的，这说明并未发生”脏读”<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; select * from test;</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">| id | name | age  |</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">|  1 | Tom  |   20 |</span><br><span class=\"line\">|  2 | Jack |   22 |</span><br><span class=\"line\">|  3 | Rose |   24 |</span><br><span class=\"line\">|  4 | Bob  |   26 |</span><br><span class=\"line\">+----+------+------+</span><br></pre></td></tr></table></figure></p>\n<p>4.事务B 提交：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; commit;</span><br></pre></td></tr></table></figure></p>\n<p>5.事务A 查询：<br>在B提交之后A读到了B修改的数据，和之前结果不一致<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; select * from test;</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">| id | name | age  |</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">|  1 | Tom  |   10 |</span><br><span class=\"line\">|  2 | Jack |   22 |</span><br><span class=\"line\">|  3 | Rose |   24 |</span><br><span class=\"line\">|  4 | Bob  |   26 |</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">mysql&gt; commit;</span><br></pre></td></tr></table></figure></p>\n<p><strong>幻读测试</strong><br>既然发生了不可重复读，那么幻读也会发生。<br>1.事务A 查询：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; begin;</span><br><span class=\"line\">mysql&gt; select * from test;</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">| id | name | age  |</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">|  1 | Tom  |   10 |</span><br><span class=\"line\">|  2 | Jack |   22 |</span><br><span class=\"line\">|  3 | Rose |   24 |</span><br><span class=\"line\">|  4 | Bob  |   26 |</span><br><span class=\"line\">+----+------+------+</span><br></pre></td></tr></table></figure></p>\n<p>2.事务B 新增记录&amp;提：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; begin;</span><br><span class=\"line\">mysql&gt; insert test(name,age) values(&quot;Tony&quot;,18);</span><br><span class=\"line\">mysql&gt; commit;</span><br></pre></td></tr></table></figure></p>\n<p>3.事务A 再查询：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; select * from test;</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">| id | name | age  |</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">|  1 | Tom  |   10 |</span><br><span class=\"line\">|  2 | Jack |   22 |</span><br><span class=\"line\">|  3 | Rose |   24 |</span><br><span class=\"line\">|  4 | Bob  |   26 |</span><br><span class=\"line\">|  6 | Tony |   18 |</span><br><span class=\"line\">+----+------+------+</span><br></pre></td></tr></table></figure></p>"},{"title":"动手编写一个IOC容器","date":"2016-09-28T15:30:55.000Z","_content":"\n### 什么是IOC\n 所谓的IOC(Inversion of control)控制反转，实际是引入一个管理资源的第三方来统一管理分配资源，来代替各个资源持有者,使用者相互依赖的情况。\n\n 以打牌为例，之前玩家需要自己摸牌，现在改成由发牌人为所有玩家发牌，这个过程就叫做“控制反转”，发牌人就是IOC容器，发牌人给玩家发牌的过程就被称为“依赖注入(Dependency Injection)”。\n\n``` java\n//不使用IOC Player自己负责实例化Card\npublic Class PlayerA{\n    private Card myCard=new Card();\n    ...\n}\npublic Class PlayerB{\n    private Card myCard=new Card();\n    ...\n}\n\n\n//实例化在IOC容器（Dealer）中进行\npublic Class Dealer{\n    private Card card=new Card();\n    ...\n}\n//Player感知不到Dealer存在\npublic Class Player{\n    @Inject\n    private Card myCard;\n}\n```\n\n\n在实际的j2ee项目中，使用依赖注入有这样几个好处： <!--more-->\n1.使用IOC容器可以把加载Bean的工作集中进行，使用者不再负责资源的初始化，在编译期将资源和使用者解耦；\n2.在使用单例模式的情况下可以避免重复的创建相同对象，减少资源占用；\n\n### IOC容器工作过程\n\n那么IOC容器怎么来实现依赖注入呢，这里提供一个基于注解的简单的IOC实现方案：\n第一步：\n我们将所有被IOC容器管理的类称为Bean，在项目启动时需要扫描当前所有的java Bean并放入到一个BeanMap中，并且将他们实例化，BeanMap保存BeanClass和Bean实例的对应关系。\n第二步：\n遍历BeanMap中的Bean，逐个判断Bean的成员变量中是否有@Inject注解，如果有，就从BeanMap中取出这个成员变量类对应的对象，注入给这个Bean。\n\n\n\n### 编写代码\n根据上面的流程我们需要定义这几个工具类：\n**ClassUtil**：扫描项目package下的所有Class\n**ClassHelper**: 调用ClassUtil，并返回需要的Bean\n**ReflectionUtil**: 返回对象实例，调用Settter方法实现注入\n**BeanHelper**: 初始化BeanMap\n>代码参考《架构探险》一书\n\n*ClassUtil:*\n需要通过ClassLoader获得项目的所有资源，分别查找文件和jar包中的类\n得到这个ClassSet之后，我们可以根据已经定义的注解来过滤出不同的Bean\n``` java\npublic static Set<Class<?>> getClassSet(String packageName) {\n        Set<Class<?>> classSet = new HashSet<Class<?>>();\n        try {\n            Enumeration<URL> urls = getClassLoader().getResources(\n                    packageName.replace(\".\", \"/\"));\n            while (urls.hasMoreElements()) {\n                URL url = urls.nextElement();\n                if (url != null) {\n                    String protocol = url.getProtocol();\n                    if (protocol.equals(\"file\")) {\n                        String packagePath = url.getPath().replaceAll(\"%20\", \" \");\n                        addClassFromFile(classSet, packagePath, packageName);\n                    } else if (protocol.equals(\"jar\")) {\n                        addClassFromJar(classSet, url);\n                    }\n                }\n            }\n        } catch (Exception e) {\n            log.error(\"get class set failed\", e);\n            throw new RuntimeException(e);\n        }\n        return classSet;\n    }\n```\n*BeanHelper:*\n在初始化时立即将所有bean实例化，放入BeanMap中\n``` java\nprivate static final Map<Class<?>,Object> BEAN_MAP=new HashMap<Class<?>, Object>();\n    static {\n        Set<Class<?>> beanClass=ClassHelper.getBeanClassSet();\n        for(Class<?> cls:beanClass){\n            //通过反射获取对象实例\n            Object obj=ReflectionUtil.getInstance(cls);\n            BEAN_MAP.put(cls,obj);\n        }\n    }\n```\n之后就可以在IOCHelper中实现依赖注入了。\n``` java\npublic class IOCHelper {\n    static{\n        Map<Class<?>,Object> beanMap=BeanHelper.getBeanMap();\n\n        if(!CollectionsUtil.isEmpty(beanMap)){\n            for(Map.Entry<Class<?>,Object> beanEntry:beanMap.entrySet()){\n                //实例化对象由容器统一管理\n                Class<?> beanClass=beanEntry.getKey();\n                Object beanInstance=beanEntry.getValue();\n                Field[] fields=beanClass.getDeclaredFields();\n                if(fields.length!=0){\n                    for(Field beanField:fields){\n                    //判断是否需要注入\n                        if(beanField.isAnnotationPresent(Inject.class)){\n                            Class<?> beanFieldClass=beanField.getType();\n                            Object beanFieldInstance=beanMap.get(beanFieldClass);\n                            if(beanFieldInstance!=null){\n                                ReflectionUtil.setField(beanInstance,beanField,beanFieldInstance);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n```\n**测试：**\n定义一个Service\n``` java\n@Service\npublic class LoginService {\n    public LoginService(){}\n    public void login(){\n        System.out.println(\"login...\");\n    }\n}\n```\n再定义一个Controller，依赖于Service\n``` java\n@Controller\npublic class IndexController {\n    @Inject\n    private LoginService loginService;\n    public void login(){\n        System.out.println(\"call login method\");\n        loginService.login();\n    }\n\n}\n```\n测试IOCHelper,是否注入了Service(@service,@Controller标记的类会被装配成Bean)\n``` java\n\npublic class Start {\n\n    public static void main(String[] arg){\n        ClassUtil.loadClass(IOCHelper.class.getName(), true);\n        IndexController controller= BeanHelper.getBean(IndexController.class);\n        controller.login();\n    }\n}\n```\n\n### 总结\n到这里相信你已经了解了IOC容器的大概工作方式，这里的IOCHelper还存在很多问题：\n1. 只支持Bean的setter注入，没有支持构造器注入。\n2. BeanMap中所有的Class都是单例的，每次getBean得到的都是同一实例。\n3. 不支持集合类型的对象注入\n4. 这里BeanMap不支持并发访问\n\n\n[完整代码地址][1]\n\n\n  [1]: https://github.com/xianfengsong/concise-framework/tree/master/src/main/java/com/throwsnew/conciseframework","source":"_posts/ioc-one.md","raw":"# 动手编写一个IOC容器#\n\ntitle: 动手编写一个IOC容器\ndate: 2016-09-28 23:30:55\ncategories: \ntags: [Spring]\n---\n\n### 什么是IOC\n 所谓的IOC(Inversion of control)控制反转，实际是引入一个管理资源的第三方来统一管理分配资源，来代替各个资源持有者,使用者相互依赖的情况。\n\n 以打牌为例，之前玩家需要自己摸牌，现在改成由发牌人为所有玩家发牌，这个过程就叫做“控制反转”，发牌人就是IOC容器，发牌人给玩家发牌的过程就被称为“依赖注入(Dependency Injection)”。\n\n``` java\n//不使用IOC Player自己负责实例化Card\npublic Class PlayerA{\n    private Card myCard=new Card();\n    ...\n}\npublic Class PlayerB{\n    private Card myCard=new Card();\n    ...\n}\n\n\n//实例化在IOC容器（Dealer）中进行\npublic Class Dealer{\n    private Card card=new Card();\n    ...\n}\n//Player感知不到Dealer存在\npublic Class Player{\n    @Inject\n    private Card myCard;\n}\n```\n\n\n在实际的j2ee项目中，使用依赖注入有这样几个好处： <!--more-->\n1.使用IOC容器可以把加载Bean的工作集中进行，使用者不再负责资源的初始化，在编译期将资源和使用者解耦；\n2.在使用单例模式的情况下可以避免重复的创建相同对象，减少资源占用；\n\n### IOC容器工作过程\n\n那么IOC容器怎么来实现依赖注入呢，这里提供一个基于注解的简单的IOC实现方案：\n第一步：\n我们将所有被IOC容器管理的类称为Bean，在项目启动时需要扫描当前所有的java Bean并放入到一个BeanMap中，并且将他们实例化，BeanMap保存BeanClass和Bean实例的对应关系。\n第二步：\n遍历BeanMap中的Bean，逐个判断Bean的成员变量中是否有@Inject注解，如果有，就从BeanMap中取出这个成员变量类对应的对象，注入给这个Bean。\n\n\n\n### 编写代码\n根据上面的流程我们需要定义这几个工具类：\n**ClassUtil**：扫描项目package下的所有Class\n**ClassHelper**: 调用ClassUtil，并返回需要的Bean\n**ReflectionUtil**: 返回对象实例，调用Settter方法实现注入\n**BeanHelper**: 初始化BeanMap\n>代码参考《架构探险》一书\n\n*ClassUtil:*\n需要通过ClassLoader获得项目的所有资源，分别查找文件和jar包中的类\n得到这个ClassSet之后，我们可以根据已经定义的注解来过滤出不同的Bean\n``` java\npublic static Set<Class<?>> getClassSet(String packageName) {\n        Set<Class<?>> classSet = new HashSet<Class<?>>();\n        try {\n            Enumeration<URL> urls = getClassLoader().getResources(\n                    packageName.replace(\".\", \"/\"));\n            while (urls.hasMoreElements()) {\n                URL url = urls.nextElement();\n                if (url != null) {\n                    String protocol = url.getProtocol();\n                    if (protocol.equals(\"file\")) {\n                        String packagePath = url.getPath().replaceAll(\"%20\", \" \");\n                        addClassFromFile(classSet, packagePath, packageName);\n                    } else if (protocol.equals(\"jar\")) {\n                        addClassFromJar(classSet, url);\n                    }\n                }\n            }\n        } catch (Exception e) {\n            log.error(\"get class set failed\", e);\n            throw new RuntimeException(e);\n        }\n        return classSet;\n    }\n```\n*BeanHelper:*\n在初始化时立即将所有bean实例化，放入BeanMap中\n``` java\nprivate static final Map<Class<?>,Object> BEAN_MAP=new HashMap<Class<?>, Object>();\n    static {\n        Set<Class<?>> beanClass=ClassHelper.getBeanClassSet();\n        for(Class<?> cls:beanClass){\n            //通过反射获取对象实例\n            Object obj=ReflectionUtil.getInstance(cls);\n            BEAN_MAP.put(cls,obj);\n        }\n    }\n```\n之后就可以在IOCHelper中实现依赖注入了。\n``` java\npublic class IOCHelper {\n    static{\n        Map<Class<?>,Object> beanMap=BeanHelper.getBeanMap();\n\n        if(!CollectionsUtil.isEmpty(beanMap)){\n            for(Map.Entry<Class<?>,Object> beanEntry:beanMap.entrySet()){\n                //实例化对象由容器统一管理\n                Class<?> beanClass=beanEntry.getKey();\n                Object beanInstance=beanEntry.getValue();\n                Field[] fields=beanClass.getDeclaredFields();\n                if(fields.length!=0){\n                    for(Field beanField:fields){\n                    //判断是否需要注入\n                        if(beanField.isAnnotationPresent(Inject.class)){\n                            Class<?> beanFieldClass=beanField.getType();\n                            Object beanFieldInstance=beanMap.get(beanFieldClass);\n                            if(beanFieldInstance!=null){\n                                ReflectionUtil.setField(beanInstance,beanField,beanFieldInstance);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n```\n**测试：**\n定义一个Service\n``` java\n@Service\npublic class LoginService {\n    public LoginService(){}\n    public void login(){\n        System.out.println(\"login...\");\n    }\n}\n```\n再定义一个Controller，依赖于Service\n``` java\n@Controller\npublic class IndexController {\n    @Inject\n    private LoginService loginService;\n    public void login(){\n        System.out.println(\"call login method\");\n        loginService.login();\n    }\n\n}\n```\n测试IOCHelper,是否注入了Service(@service,@Controller标记的类会被装配成Bean)\n``` java\n\npublic class Start {\n\n    public static void main(String[] arg){\n        ClassUtil.loadClass(IOCHelper.class.getName(), true);\n        IndexController controller= BeanHelper.getBean(IndexController.class);\n        controller.login();\n    }\n}\n```\n\n### 总结\n到这里相信你已经了解了IOC容器的大概工作方式，这里的IOCHelper还存在很多问题：\n1. 只支持Bean的setter注入，没有支持构造器注入。\n2. BeanMap中所有的Class都是单例的，每次getBean得到的都是同一实例。\n3. 不支持集合类型的对象注入\n4. 这里BeanMap不支持并发访问\n\n\n[完整代码地址][1]\n\n\n  [1]: https://github.com/xianfengsong/concise-framework/tree/master/src/main/java/com/throwsnew/conciseframework","slug":"ioc-one","published":1,"updated":"2018-11-21T16:27:13.905Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkqle16x0009cynepl2gsd9q","content":"<h3 id=\"什么是IOC\"><a href=\"#什么是IOC\" class=\"headerlink\" title=\"什么是IOC\"></a>什么是IOC</h3><p> 所谓的IOC(Inversion of control)控制反转，实际是引入一个管理资源的第三方来统一管理分配资源，来代替各个资源持有者,使用者相互依赖的情况。</p>\n<p> 以打牌为例，之前玩家需要自己摸牌，现在改成由发牌人为所有玩家发牌，这个过程就叫做“控制反转”，发牌人就是IOC容器，发牌人给玩家发牌的过程就被称为“依赖注入(Dependency Injection)”。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//不使用IOC Player自己负责实例化Card</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Class PlayerA&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Card myCard=<span class=\"keyword\">new</span> Card();</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> Class PlayerB&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Card myCard=<span class=\"keyword\">new</span> Card();</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//实例化在IOC容器（Dealer）中进行</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Class Dealer&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Card card=<span class=\"keyword\">new</span> Card();</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//Player感知不到Dealer存在</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Class Player&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Inject</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Card myCard;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在实际的j2ee项目中，使用依赖注入有这样几个好处： <a id=\"more\"></a><br>1.使用IOC容器可以把加载Bean的工作集中进行，使用者不再负责资源的初始化，在编译期将资源和使用者解耦；<br>2.在使用单例模式的情况下可以避免重复的创建相同对象，减少资源占用；</p>\n<h3 id=\"IOC容器工作过程\"><a href=\"#IOC容器工作过程\" class=\"headerlink\" title=\"IOC容器工作过程\"></a>IOC容器工作过程</h3><p>那么IOC容器怎么来实现依赖注入呢，这里提供一个基于注解的简单的IOC实现方案：<br>第一步：<br>我们将所有被IOC容器管理的类称为Bean，在项目启动时需要扫描当前所有的java Bean并放入到一个BeanMap中，并且将他们实例化，BeanMap保存BeanClass和Bean实例的对应关系。<br>第二步：<br>遍历BeanMap中的Bean，逐个判断Bean的成员变量中是否有@Inject注解，如果有，就从BeanMap中取出这个成员变量类对应的对象，注入给这个Bean。</p>\n<h3 id=\"编写代码\"><a href=\"#编写代码\" class=\"headerlink\" title=\"编写代码\"></a>编写代码</h3><p>根据上面的流程我们需要定义这几个工具类：<br><strong>ClassUtil</strong>：扫描项目package下的所有Class<br><strong>ClassHelper</strong>: 调用ClassUtil，并返回需要的Bean<br><strong>ReflectionUtil</strong>: 返回对象实例，调用Settter方法实现注入<br><strong>BeanHelper</strong>: 初始化BeanMap</p>\n<blockquote>\n<p>代码参考《架构探险》一书</p>\n</blockquote>\n<p><em>ClassUtil:</em><br>需要通过ClassLoader获得项目的所有资源，分别查找文件和jar包中的类<br>得到这个ClassSet之后，我们可以根据已经定义的注解来过滤出不同的Bean<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Set&lt;Class&lt;?&gt;&gt; getClassSet(String packageName) &#123;</span><br><span class=\"line\">        Set&lt;Class&lt;?&gt;&gt; classSet = <span class=\"keyword\">new</span> HashSet&lt;Class&lt;?&gt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Enumeration&lt;URL&gt; urls = getClassLoader().getResources(</span><br><span class=\"line\">                    packageName.replace(<span class=\"string\">\".\"</span>, <span class=\"string\">\"/\"</span>));</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (urls.hasMoreElements()) &#123;</span><br><span class=\"line\">                URL url = urls.nextElement();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (url != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    String protocol = url.getProtocol();</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (protocol.equals(<span class=\"string\">\"file\"</span>)) &#123;</span><br><span class=\"line\">                        String packagePath = url.getPath().replaceAll(<span class=\"string\">\"%20\"</span>, <span class=\"string\">\" \"</span>);</span><br><span class=\"line\">                        addClassFromFile(classSet, packagePath, packageName);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (protocol.equals(<span class=\"string\">\"jar\"</span>)) &#123;</span><br><span class=\"line\">                        addClassFromJar(classSet, url);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            log.error(<span class=\"string\">\"get class set failed\"</span>, e);</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> classSet;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p><em>BeanHelper:</em><br>在初始化时立即将所有bean实例化，放入BeanMap中<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Map&lt;Class&lt;?&gt;,Object&gt; BEAN_MAP=<span class=\"keyword\">new</span> HashMap&lt;Class&lt;?&gt;, Object&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        Set&lt;Class&lt;?&gt;&gt; beanClass=ClassHelper.getBeanClassSet();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(Class&lt;?&gt; cls:beanClass)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//通过反射获取对象实例</span></span><br><span class=\"line\">            Object obj=ReflectionUtil.getInstance(cls);</span><br><span class=\"line\">            BEAN_MAP.put(cls,obj);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>之后就可以在IOCHelper中实现依赖注入了。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IOCHelper</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span>&#123;</span><br><span class=\"line\">        Map&lt;Class&lt;?&gt;,Object&gt; beanMap=BeanHelper.getBeanMap();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!CollectionsUtil.isEmpty(beanMap))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(Map.Entry&lt;Class&lt;?&gt;,Object&gt; beanEntry:beanMap.entrySet())&#123;</span><br><span class=\"line\">                <span class=\"comment\">//实例化对象由容器统一管理</span></span><br><span class=\"line\">                Class&lt;?&gt; beanClass=beanEntry.getKey();</span><br><span class=\"line\">                Object beanInstance=beanEntry.getValue();</span><br><span class=\"line\">                Field[] fields=beanClass.getDeclaredFields();</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(fields.length!=<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">for</span>(Field beanField:fields)&#123;</span><br><span class=\"line\">                    <span class=\"comment\">//判断是否需要注入</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span>(beanField.isAnnotationPresent(Inject.class))&#123;</span><br><span class=\"line\">                            Class&lt;?&gt; beanFieldClass=beanField.getType();</span><br><span class=\"line\">                            Object beanFieldInstance=beanMap.get(beanFieldClass);</span><br><span class=\"line\">                            <span class=\"keyword\">if</span>(beanFieldInstance!=<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                                ReflectionUtil.setField(beanInstance,beanField,beanFieldInstance);</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>测试：</strong><br>定义一个Service<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LoginService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LoginService</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">login</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"login...\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>再定义一个Controller，依赖于Service<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Controller</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IndexController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Inject</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> LoginService loginService;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">login</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"call login method\"</span>);</span><br><span class=\"line\">        loginService.login();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>测试IOCHelper,是否注入了Service(@service,@Controller标记的类会被装配成Bean)<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Start</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] arg)</span></span>&#123;</span><br><span class=\"line\">        ClassUtil.loadClass(IOCHelper.class.getName(), <span class=\"keyword\">true</span>);</span><br><span class=\"line\">        IndexController controller= BeanHelper.getBean(IndexController.class);</span><br><span class=\"line\">        controller.login();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>到这里相信你已经了解了IOC容器的大概工作方式，这里的IOCHelper还存在很多问题：</p>\n<ol>\n<li>只支持Bean的setter注入，没有支持构造器注入。</li>\n<li>BeanMap中所有的Class都是单例的，每次getBean得到的都是同一实例。</li>\n<li>不支持集合类型的对象注入</li>\n<li>这里BeanMap不支持并发访问</li>\n</ol>\n<p><a href=\"https://github.com/xianfengsong/concise-framework/tree/master/src/main/java/com/throwsnew/conciseframework\" target=\"_blank\" rel=\"noopener\">完整代码地址</a></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"什么是IOC\"><a href=\"#什么是IOC\" class=\"headerlink\" title=\"什么是IOC\"></a>什么是IOC</h3><p> 所谓的IOC(Inversion of control)控制反转，实际是引入一个管理资源的第三方来统一管理分配资源，来代替各个资源持有者,使用者相互依赖的情况。</p>\n<p> 以打牌为例，之前玩家需要自己摸牌，现在改成由发牌人为所有玩家发牌，这个过程就叫做“控制反转”，发牌人就是IOC容器，发牌人给玩家发牌的过程就被称为“依赖注入(Dependency Injection)”。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//不使用IOC Player自己负责实例化Card</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Class PlayerA&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Card myCard=<span class=\"keyword\">new</span> Card();</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> Class PlayerB&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Card myCard=<span class=\"keyword\">new</span> Card();</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//实例化在IOC容器（Dealer）中进行</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Class Dealer&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Card card=<span class=\"keyword\">new</span> Card();</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//Player感知不到Dealer存在</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Class Player&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Inject</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Card myCard;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在实际的j2ee项目中，使用依赖注入有这样几个好处：","more":"<br>1.使用IOC容器可以把加载Bean的工作集中进行，使用者不再负责资源的初始化，在编译期将资源和使用者解耦；<br>2.在使用单例模式的情况下可以避免重复的创建相同对象，减少资源占用；</p>\n<h3 id=\"IOC容器工作过程\"><a href=\"#IOC容器工作过程\" class=\"headerlink\" title=\"IOC容器工作过程\"></a>IOC容器工作过程</h3><p>那么IOC容器怎么来实现依赖注入呢，这里提供一个基于注解的简单的IOC实现方案：<br>第一步：<br>我们将所有被IOC容器管理的类称为Bean，在项目启动时需要扫描当前所有的java Bean并放入到一个BeanMap中，并且将他们实例化，BeanMap保存BeanClass和Bean实例的对应关系。<br>第二步：<br>遍历BeanMap中的Bean，逐个判断Bean的成员变量中是否有@Inject注解，如果有，就从BeanMap中取出这个成员变量类对应的对象，注入给这个Bean。</p>\n<h3 id=\"编写代码\"><a href=\"#编写代码\" class=\"headerlink\" title=\"编写代码\"></a>编写代码</h3><p>根据上面的流程我们需要定义这几个工具类：<br><strong>ClassUtil</strong>：扫描项目package下的所有Class<br><strong>ClassHelper</strong>: 调用ClassUtil，并返回需要的Bean<br><strong>ReflectionUtil</strong>: 返回对象实例，调用Settter方法实现注入<br><strong>BeanHelper</strong>: 初始化BeanMap</p>\n<blockquote>\n<p>代码参考《架构探险》一书</p>\n</blockquote>\n<p><em>ClassUtil:</em><br>需要通过ClassLoader获得项目的所有资源，分别查找文件和jar包中的类<br>得到这个ClassSet之后，我们可以根据已经定义的注解来过滤出不同的Bean<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Set&lt;Class&lt;?&gt;&gt; getClassSet(String packageName) &#123;</span><br><span class=\"line\">        Set&lt;Class&lt;?&gt;&gt; classSet = <span class=\"keyword\">new</span> HashSet&lt;Class&lt;?&gt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Enumeration&lt;URL&gt; urls = getClassLoader().getResources(</span><br><span class=\"line\">                    packageName.replace(<span class=\"string\">\".\"</span>, <span class=\"string\">\"/\"</span>));</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (urls.hasMoreElements()) &#123;</span><br><span class=\"line\">                URL url = urls.nextElement();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (url != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    String protocol = url.getProtocol();</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (protocol.equals(<span class=\"string\">\"file\"</span>)) &#123;</span><br><span class=\"line\">                        String packagePath = url.getPath().replaceAll(<span class=\"string\">\"%20\"</span>, <span class=\"string\">\" \"</span>);</span><br><span class=\"line\">                        addClassFromFile(classSet, packagePath, packageName);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (protocol.equals(<span class=\"string\">\"jar\"</span>)) &#123;</span><br><span class=\"line\">                        addClassFromJar(classSet, url);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            log.error(<span class=\"string\">\"get class set failed\"</span>, e);</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> classSet;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p><em>BeanHelper:</em><br>在初始化时立即将所有bean实例化，放入BeanMap中<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Map&lt;Class&lt;?&gt;,Object&gt; BEAN_MAP=<span class=\"keyword\">new</span> HashMap&lt;Class&lt;?&gt;, Object&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        Set&lt;Class&lt;?&gt;&gt; beanClass=ClassHelper.getBeanClassSet();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(Class&lt;?&gt; cls:beanClass)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//通过反射获取对象实例</span></span><br><span class=\"line\">            Object obj=ReflectionUtil.getInstance(cls);</span><br><span class=\"line\">            BEAN_MAP.put(cls,obj);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>之后就可以在IOCHelper中实现依赖注入了。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IOCHelper</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span>&#123;</span><br><span class=\"line\">        Map&lt;Class&lt;?&gt;,Object&gt; beanMap=BeanHelper.getBeanMap();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!CollectionsUtil.isEmpty(beanMap))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(Map.Entry&lt;Class&lt;?&gt;,Object&gt; beanEntry:beanMap.entrySet())&#123;</span><br><span class=\"line\">                <span class=\"comment\">//实例化对象由容器统一管理</span></span><br><span class=\"line\">                Class&lt;?&gt; beanClass=beanEntry.getKey();</span><br><span class=\"line\">                Object beanInstance=beanEntry.getValue();</span><br><span class=\"line\">                Field[] fields=beanClass.getDeclaredFields();</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(fields.length!=<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">for</span>(Field beanField:fields)&#123;</span><br><span class=\"line\">                    <span class=\"comment\">//判断是否需要注入</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span>(beanField.isAnnotationPresent(Inject.class))&#123;</span><br><span class=\"line\">                            Class&lt;?&gt; beanFieldClass=beanField.getType();</span><br><span class=\"line\">                            Object beanFieldInstance=beanMap.get(beanFieldClass);</span><br><span class=\"line\">                            <span class=\"keyword\">if</span>(beanFieldInstance!=<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                                ReflectionUtil.setField(beanInstance,beanField,beanFieldInstance);</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>测试：</strong><br>定义一个Service<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LoginService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LoginService</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">login</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"login...\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>再定义一个Controller，依赖于Service<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Controller</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IndexController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Inject</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> LoginService loginService;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">login</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"call login method\"</span>);</span><br><span class=\"line\">        loginService.login();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>测试IOCHelper,是否注入了Service(@service,@Controller标记的类会被装配成Bean)<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Start</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] arg)</span></span>&#123;</span><br><span class=\"line\">        ClassUtil.loadClass(IOCHelper.class.getName(), <span class=\"keyword\">true</span>);</span><br><span class=\"line\">        IndexController controller= BeanHelper.getBean(IndexController.class);</span><br><span class=\"line\">        controller.login();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>到这里相信你已经了解了IOC容器的大概工作方式，这里的IOCHelper还存在很多问题：</p>\n<ol>\n<li>只支持Bean的setter注入，没有支持构造器注入。</li>\n<li>BeanMap中所有的Class都是单例的，每次getBean得到的都是同一实例。</li>\n<li>不支持集合类型的对象注入</li>\n<li>这里BeanMap不支持并发访问</li>\n</ol>\n<p><a href=\"https://github.com/xianfengsong/concise-framework/tree/master/src/main/java/com/throwsnew/conciseframework\" target=\"_blank\" rel=\"noopener\">完整代码地址</a></p>"},{"title":"JAVA基础————两分钟看懂注解Annotation","date":"2016-01-25T16:05:46.000Z","_content":"## 什么是注解\n\n**注解是一种描述程序的[元数据][q1]，我们可以把他当做一种特殊的注释**　  \n> [官方文档][q2] : *Annotations, a form of metadata, provide data about a program that is not part of the program itself.*　\n\n+ 注解可以为编译器提供信息，如@Override，@SuppressWarnings\n+ 可以代替xml等文件，为程序保存所需的配置\n+ 可以在程序运行时根据注解执行一些操作，如Spring中的@Autowired\n\n<!--more-->\n\n## 注解的语法\n### 声明注解\n注解的定义与接口类似，也可以为注解添加属性。在实现注解时，方法名是对象属性名，返回值是属性值的类型。如 @Override的定义：\n```java\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.SOURCE)\npublic @interface Override{}\n```\n自定义并实例化注解：\n```java\n@interface Developer{\n  String [] name();\n  int level() default 0;\n}\n//一个注解对象\n@Developer(name={\"j\",\"p\"},level=2)\n```\n### 内置注解\njava提供几个内置注解来描述自定义的注解 \n **@Target**：应用到什么对象\n\n| 名称        | 定义   |\n| -------- | :-----  |\n| ElementType.ANNOTATION_TYPE| 应用于注解 |\n| ElementType.FIELD        |   属性    |\n| ElementType.METHOD        |     方法   |\n| ElementType.TYPE       |    类的任何元素   |\n|[...更多内容][更多]|[...更多内容][更多]|\n\n\n **@Retention**：注解存储的位置\n\n| 名称|定义|\n|--|--|\n|RetentionPolicy.SOURCE|保留在源码阶段，被编译器忽略|\n|RetentionPolicy.CLASS|保留至编译阶段，被JVM忽略|\n|RetentionPolicy.RUNTIME|保留至JVM可以在运行时使用|\n**@Inherited**：\n类的注解默认不会被继承给子类，如果需要应该在定义时指定@Inherited（只适用于一个类的注解）\n\n **@Document** : \n\n如果定义注解时指定@Document那么注解会被添加到用用对象的javadoc文档中\n\n## 使用注解\n\n我们已经了解了注解的基本语法，那么应该怎么在程序中处理注解呢？\n\n![举个例子](/images/example.jpg)\n\n\n&#160; &#160; &#160;假设公司办公楼里有不同类型的一些房间，而每天都会有各种身份的人来公司，如何让程序来控制这些人对不同房间的访问权限呢？\n\n----------\n&#160; &#160; &#160;\n通常我们会将权限关系保存在xml等文件中，但同时也可以使用注解来保存各类房间允许进入的人员信息，并在程序中根据注解作出处理。\n\n1.定义房间：\n\n```java\npublic class Room {\n    public void open(String name){\n        System.out.println(name+\" came in\");}\n    }\n}\n```\n\n2.创建注解时选择RETENTION.RUNTIME，这样我们可以通过反射获取注解信息：\n```java\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\npublic @interface Accessible {\n    //保存允许进入房间的人员\n    String [] value ();\n}\n```\n3.创建WashRoom,MeetingRoom,BossRoom，并在open方法上添加注解：\n```java\n//例：洗手间 任何人都可以进入\npublic class WashRoom extends Room {\n    @Accessible({\"Boss\",\"Staff\",\"Visitor\"})\n    @Override\n    public void open(String name){\n        System.out.println(\"this is washroom\");\n        super.open(name);\n    }\n}\n```\n4.处理注解：\n```java\n//初始化房间和人员\nRoom[] rooms = {new WashRoom(), new MeetingRoom(), new BossRoom()};\nString[] persons = {\"Boss\", \"Staff\", \"Visitor\"};\n\nfor (String person : persons) {\n    for (Room room : rooms) {\n\n        Method[] methods = room.getClass().getMethods();\n\n            for (Method method : methods) {\n                //用反射获取带有注解的方法\n                if (method.isAnnotationPresent(Accessible.class)) {\n                    Accessible accessAnnotation = method.getAnnotation(Accessible.class);\n                    //获得注解内容\n                    List<String> nameList = Arrays.asList(accessAnnotation.value());\n                    if (nameList.contains(person)) {\n                        try {\n                            method.invoke(room, person);\n                        } catch (Exception e) {\n                            e.printStackTrace();\n                        }\n                    } else {\n                            System.out.println(\"forbidden！\");\n                        }\n                    }\n                }\n            }\n        }\n```\n# 全文完～\n### 参考\noracle java文档：https://docs.oracle.com/javase/tutorial/java/annotations/index.html\nJava深度历险（六）——Java注解 http://www.infoq.com/cn/articles/cf-java-annotation\n\n\n  [img]:  http://7xl4v5.com1.z0.glb.clouddn.com/example.jpg\n  [更多]: https://docs.oracle.com/javase/tutorial/java/annotations/predefined.html\n  \n[q1]: http://www.ruanyifeng.com/blog/2007/03/metadata.html\n\n[q2]: https://docs.oracle.com/javase/tutorial/java/annotations/index.html\n\n\n","source":"_posts/java-annotation.md","raw":"# JAVA基础————两分钟学会注解Annotation\n\ntitle: JAVA基础————两分钟看懂注解Annotation\ndate: 2016-01-26 00:05:46\ncategories: \ntags: [java基础,注解,annotation]\n\n---\n## 什么是注解\n\n**注解是一种描述程序的[元数据][q1]，我们可以把他当做一种特殊的注释**　  \n> [官方文档][q2] : *Annotations, a form of metadata, provide data about a program that is not part of the program itself.*　\n\n+ 注解可以为编译器提供信息，如@Override，@SuppressWarnings\n+ 可以代替xml等文件，为程序保存所需的配置\n+ 可以在程序运行时根据注解执行一些操作，如Spring中的@Autowired\n\n<!--more-->\n\n## 注解的语法\n### 声明注解\n注解的定义与接口类似，也可以为注解添加属性。在实现注解时，方法名是对象属性名，返回值是属性值的类型。如 @Override的定义：\n```java\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.SOURCE)\npublic @interface Override{}\n```\n自定义并实例化注解：\n```java\n@interface Developer{\n  String [] name();\n  int level() default 0;\n}\n//一个注解对象\n@Developer(name={\"j\",\"p\"},level=2)\n```\n### 内置注解\njava提供几个内置注解来描述自定义的注解 \n **@Target**：应用到什么对象\n\n| 名称        | 定义   |\n| -------- | :-----  |\n| ElementType.ANNOTATION_TYPE| 应用于注解 |\n| ElementType.FIELD        |   属性    |\n| ElementType.METHOD        |     方法   |\n| ElementType.TYPE       |    类的任何元素   |\n|[...更多内容][更多]|[...更多内容][更多]|\n\n\n **@Retention**：注解存储的位置\n\n| 名称|定义|\n|--|--|\n|RetentionPolicy.SOURCE|保留在源码阶段，被编译器忽略|\n|RetentionPolicy.CLASS|保留至编译阶段，被JVM忽略|\n|RetentionPolicy.RUNTIME|保留至JVM可以在运行时使用|\n**@Inherited**：\n类的注解默认不会被继承给子类，如果需要应该在定义时指定@Inherited（只适用于一个类的注解）\n\n **@Document** : \n\n如果定义注解时指定@Document那么注解会被添加到用用对象的javadoc文档中\n\n## 使用注解\n\n我们已经了解了注解的基本语法，那么应该怎么在程序中处理注解呢？\n\n![举个例子](/images/example.jpg)\n\n\n&#160; &#160; &#160;假设公司办公楼里有不同类型的一些房间，而每天都会有各种身份的人来公司，如何让程序来控制这些人对不同房间的访问权限呢？\n\n----------\n&#160; &#160; &#160;\n通常我们会将权限关系保存在xml等文件中，但同时也可以使用注解来保存各类房间允许进入的人员信息，并在程序中根据注解作出处理。\n\n1.定义房间：\n\n```java\npublic class Room {\n    public void open(String name){\n        System.out.println(name+\" came in\");}\n    }\n}\n```\n\n2.创建注解时选择RETENTION.RUNTIME，这样我们可以通过反射获取注解信息：\n```java\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\npublic @interface Accessible {\n    //保存允许进入房间的人员\n    String [] value ();\n}\n```\n3.创建WashRoom,MeetingRoom,BossRoom，并在open方法上添加注解：\n```java\n//例：洗手间 任何人都可以进入\npublic class WashRoom extends Room {\n    @Accessible({\"Boss\",\"Staff\",\"Visitor\"})\n    @Override\n    public void open(String name){\n        System.out.println(\"this is washroom\");\n        super.open(name);\n    }\n}\n```\n4.处理注解：\n```java\n//初始化房间和人员\nRoom[] rooms = {new WashRoom(), new MeetingRoom(), new BossRoom()};\nString[] persons = {\"Boss\", \"Staff\", \"Visitor\"};\n\nfor (String person : persons) {\n    for (Room room : rooms) {\n\n        Method[] methods = room.getClass().getMethods();\n\n            for (Method method : methods) {\n                //用反射获取带有注解的方法\n                if (method.isAnnotationPresent(Accessible.class)) {\n                    Accessible accessAnnotation = method.getAnnotation(Accessible.class);\n                    //获得注解内容\n                    List<String> nameList = Arrays.asList(accessAnnotation.value());\n                    if (nameList.contains(person)) {\n                        try {\n                            method.invoke(room, person);\n                        } catch (Exception e) {\n                            e.printStackTrace();\n                        }\n                    } else {\n                            System.out.println(\"forbidden！\");\n                        }\n                    }\n                }\n            }\n        }\n```\n# 全文完～\n### 参考\noracle java文档：https://docs.oracle.com/javase/tutorial/java/annotations/index.html\nJava深度历险（六）——Java注解 http://www.infoq.com/cn/articles/cf-java-annotation\n\n\n  [img]:  http://7xl4v5.com1.z0.glb.clouddn.com/example.jpg\n  [更多]: https://docs.oracle.com/javase/tutorial/java/annotations/predefined.html\n  \n[q1]: http://www.ruanyifeng.com/blog/2007/03/metadata.html\n\n[q2]: https://docs.oracle.com/javase/tutorial/java/annotations/index.html\n\n\n","slug":"java-annotation","published":1,"updated":"2019-05-04T15:24:13.705Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkqle16z000acynexf5w9zph","content":"<h2 id=\"什么是注解\"><a href=\"#什么是注解\" class=\"headerlink\" title=\"什么是注解\"></a>什么是注解</h2><p><strong>注解是一种描述程序的<a href=\"http://www.ruanyifeng.com/blog/2007/03/metadata.html\" target=\"_blank\" rel=\"noopener\">元数据</a>，我们可以把他当做一种特殊的注释</strong>　  </p>\n<blockquote>\n<p><a href=\"https://docs.oracle.com/javase/tutorial/java/annotations/index.html\" target=\"_blank\" rel=\"noopener\">官方文档</a> : <em>Annotations, a form of metadata, provide data about a program that is not part of the program itself.</em>　</p>\n</blockquote>\n<ul>\n<li>注解可以为编译器提供信息，如@Override，@SuppressWarnings</li>\n<li>可以代替xml等文件，为程序保存所需的配置</li>\n<li>可以在程序运行时根据注解执行一些操作，如Spring中的@Autowired</li>\n</ul>\n<a id=\"more\"></a>\n<h2 id=\"注解的语法\"><a href=\"#注解的语法\" class=\"headerlink\" title=\"注解的语法\"></a>注解的语法</h2><h3 id=\"声明注解\"><a href=\"#声明注解\" class=\"headerlink\" title=\"声明注解\"></a>声明注解</h3><p>注解的定义与接口类似，也可以为注解添加属性。在实现注解时，方法名是对象属性名，返回值是属性值的类型。如 @Override的定义：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target</span>(ElementType.METHOD)</span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Override&#123;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>自定义并实例化注解：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@interface</span> Developer&#123;</span><br><span class=\"line\">  String [] name();</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">level</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> 0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//一个注解对象</span></span><br><span class=\"line\"><span class=\"meta\">@Developer</span>(name=&#123;<span class=\"string\">\"j\"</span>,<span class=\"string\">\"p\"</span>&#125;,level=<span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"内置注解\"><a href=\"#内置注解\" class=\"headerlink\" title=\"内置注解\"></a>内置注解</h3><p>java提供几个内置注解来描述自定义的注解<br> <strong>@Target</strong>：应用到什么对象</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th style=\"text-align:left\">定义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ElementType.ANNOTATION_TYPE</td>\n<td style=\"text-align:left\">应用于注解</td>\n</tr>\n<tr>\n<td>ElementType.FIELD</td>\n<td style=\"text-align:left\">属性</td>\n</tr>\n<tr>\n<td>ElementType.METHOD</td>\n<td style=\"text-align:left\">方法</td>\n</tr>\n<tr>\n<td>ElementType.TYPE</td>\n<td style=\"text-align:left\">类的任何元素</td>\n</tr>\n<tr>\n<td><a href=\"https://docs.oracle.com/javase/tutorial/java/annotations/predefined.html\" target=\"_blank\" rel=\"noopener\">…更多内容</a></td>\n<td style=\"text-align:left\"><a href=\"https://docs.oracle.com/javase/tutorial/java/annotations/predefined.html\" target=\"_blank\" rel=\"noopener\">…更多内容</a></td>\n</tr>\n</tbody>\n</table>\n<p> <strong>@Retention</strong>：注解存储的位置</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>定义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>RetentionPolicy.SOURCE</td>\n<td>保留在源码阶段，被编译器忽略</td>\n</tr>\n<tr>\n<td>RetentionPolicy.CLASS</td>\n<td>保留至编译阶段，被JVM忽略</td>\n</tr>\n<tr>\n<td>RetentionPolicy.RUNTIME</td>\n<td>保留至JVM可以在运行时使用</td>\n</tr>\n</tbody>\n</table>\n<p><strong>@Inherited</strong>：<br>类的注解默认不会被继承给子类，如果需要应该在定义时指定@Inherited（只适用于一个类的注解）</p>\n<p> <strong>@Document</strong> : </p>\n<p>如果定义注解时指定@Document那么注解会被添加到用用对象的javadoc文档中</p>\n<h2 id=\"使用注解\"><a href=\"#使用注解\" class=\"headerlink\" title=\"使用注解\"></a>使用注解</h2><p>我们已经了解了注解的基本语法，那么应该怎么在程序中处理注解呢？</p>\n<p><img src=\"/images/example.jpg\" alt=\"举个例子\"></p>\n<p>&#160; &#160; &#160;假设公司办公楼里有不同类型的一些房间，而每天都会有各种身份的人来公司，如何让程序来控制这些人对不同房间的访问权限呢？</p>\n<hr>\n<p>&#160; &#160; &#160;<br>通常我们会将权限关系保存在xml等文件中，但同时也可以使用注解来保存各类房间允许进入的人员信息，并在程序中根据注解作出处理。</p>\n<p>1.定义房间：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Room</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">open</span><span class=\"params\">(String name)</span></span>&#123;</span><br><span class=\"line\">        System.out.println(name+<span class=\"string\">\" came in\"</span>);&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2.创建注解时选择RETENTION.RUNTIME，这样我们可以通过反射获取注解信息：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class=\"line\"><span class=\"meta\">@Target</span>(ElementType.METHOD)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Accessible &#123;</span><br><span class=\"line\">    <span class=\"comment\">//保存允许进入房间的人员</span></span><br><span class=\"line\">    String [] value ();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>3.创建WashRoom,MeetingRoom,BossRoom，并在open方法上添加注解：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//例：洗手间 任何人都可以进入</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WashRoom</span> <span class=\"keyword\">extends</span> <span class=\"title\">Room</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Accessible</span>(&#123;<span class=\"string\">\"Boss\"</span>,<span class=\"string\">\"Staff\"</span>,<span class=\"string\">\"Visitor\"</span>&#125;)</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">open</span><span class=\"params\">(String name)</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"this is washroom\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.open(name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>4.处理注解：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//初始化房间和人员</span></span><br><span class=\"line\">Room[] rooms = &#123;<span class=\"keyword\">new</span> WashRoom(), <span class=\"keyword\">new</span> MeetingRoom(), <span class=\"keyword\">new</span> BossRoom()&#125;;</span><br><span class=\"line\">String[] persons = &#123;<span class=\"string\">\"Boss\"</span>, <span class=\"string\">\"Staff\"</span>, <span class=\"string\">\"Visitor\"</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (String person : persons) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Room room : rooms) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Method[] methods = room.getClass().getMethods();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Method method : methods) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//用反射获取带有注解的方法</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (method.isAnnotationPresent(Accessible.class)) &#123;</span><br><span class=\"line\">                    Accessible accessAnnotation = method.getAnnotation(Accessible.class);</span><br><span class=\"line\">                    <span class=\"comment\">//获得注解内容</span></span><br><span class=\"line\">                    List&lt;String&gt; nameList = Arrays.asList(accessAnnotation.value());</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (nameList.contains(person)) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                            method.invoke(room, person);</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                            e.printStackTrace();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                            System.out.println(<span class=\"string\">\"forbidden！\"</span>);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"全文完～\"><a href=\"#全文完～\" class=\"headerlink\" title=\"全文完～\"></a>全文完～</h1><h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p>oracle java文档：<a href=\"https://docs.oracle.com/javase/tutorial/java/annotations/index.html\" target=\"_blank\" rel=\"noopener\">https://docs.oracle.com/javase/tutorial/java/annotations/index.html</a><br>Java深度历险（六）——Java注解 <a href=\"http://www.infoq.com/cn/articles/cf-java-annotation\" target=\"_blank\" rel=\"noopener\">http://www.infoq.com/cn/articles/cf-java-annotation</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"什么是注解\"><a href=\"#什么是注解\" class=\"headerlink\" title=\"什么是注解\"></a>什么是注解</h2><p><strong>注解是一种描述程序的<a href=\"http://www.ruanyifeng.com/blog/2007/03/metadata.html\" target=\"_blank\" rel=\"noopener\">元数据</a>，我们可以把他当做一种特殊的注释</strong>　  </p>\n<blockquote>\n<p><a href=\"https://docs.oracle.com/javase/tutorial/java/annotations/index.html\" target=\"_blank\" rel=\"noopener\">官方文档</a> : <em>Annotations, a form of metadata, provide data about a program that is not part of the program itself.</em>　</p>\n</blockquote>\n<ul>\n<li>注解可以为编译器提供信息，如@Override，@SuppressWarnings</li>\n<li>可以代替xml等文件，为程序保存所需的配置</li>\n<li>可以在程序运行时根据注解执行一些操作，如Spring中的@Autowired</li>\n</ul>","more":"<h2 id=\"注解的语法\"><a href=\"#注解的语法\" class=\"headerlink\" title=\"注解的语法\"></a>注解的语法</h2><h3 id=\"声明注解\"><a href=\"#声明注解\" class=\"headerlink\" title=\"声明注解\"></a>声明注解</h3><p>注解的定义与接口类似，也可以为注解添加属性。在实现注解时，方法名是对象属性名，返回值是属性值的类型。如 @Override的定义：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target</span>(ElementType.METHOD)</span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Override&#123;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>自定义并实例化注解：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@interface</span> Developer&#123;</span><br><span class=\"line\">  String [] name();</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">level</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> 0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//一个注解对象</span></span><br><span class=\"line\"><span class=\"meta\">@Developer</span>(name=&#123;<span class=\"string\">\"j\"</span>,<span class=\"string\">\"p\"</span>&#125;,level=<span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"内置注解\"><a href=\"#内置注解\" class=\"headerlink\" title=\"内置注解\"></a>内置注解</h3><p>java提供几个内置注解来描述自定义的注解<br> <strong>@Target</strong>：应用到什么对象</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th style=\"text-align:left\">定义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ElementType.ANNOTATION_TYPE</td>\n<td style=\"text-align:left\">应用于注解</td>\n</tr>\n<tr>\n<td>ElementType.FIELD</td>\n<td style=\"text-align:left\">属性</td>\n</tr>\n<tr>\n<td>ElementType.METHOD</td>\n<td style=\"text-align:left\">方法</td>\n</tr>\n<tr>\n<td>ElementType.TYPE</td>\n<td style=\"text-align:left\">类的任何元素</td>\n</tr>\n<tr>\n<td><a href=\"https://docs.oracle.com/javase/tutorial/java/annotations/predefined.html\" target=\"_blank\" rel=\"noopener\">…更多内容</a></td>\n<td style=\"text-align:left\"><a href=\"https://docs.oracle.com/javase/tutorial/java/annotations/predefined.html\" target=\"_blank\" rel=\"noopener\">…更多内容</a></td>\n</tr>\n</tbody>\n</table>\n<p> <strong>@Retention</strong>：注解存储的位置</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>定义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>RetentionPolicy.SOURCE</td>\n<td>保留在源码阶段，被编译器忽略</td>\n</tr>\n<tr>\n<td>RetentionPolicy.CLASS</td>\n<td>保留至编译阶段，被JVM忽略</td>\n</tr>\n<tr>\n<td>RetentionPolicy.RUNTIME</td>\n<td>保留至JVM可以在运行时使用</td>\n</tr>\n</tbody>\n</table>\n<p><strong>@Inherited</strong>：<br>类的注解默认不会被继承给子类，如果需要应该在定义时指定@Inherited（只适用于一个类的注解）</p>\n<p> <strong>@Document</strong> : </p>\n<p>如果定义注解时指定@Document那么注解会被添加到用用对象的javadoc文档中</p>\n<h2 id=\"使用注解\"><a href=\"#使用注解\" class=\"headerlink\" title=\"使用注解\"></a>使用注解</h2><p>我们已经了解了注解的基本语法，那么应该怎么在程序中处理注解呢？</p>\n<p><img src=\"/images/example.jpg\" alt=\"举个例子\"></p>\n<p>&#160; &#160; &#160;假设公司办公楼里有不同类型的一些房间，而每天都会有各种身份的人来公司，如何让程序来控制这些人对不同房间的访问权限呢？</p>\n<hr>\n<p>&#160; &#160; &#160;<br>通常我们会将权限关系保存在xml等文件中，但同时也可以使用注解来保存各类房间允许进入的人员信息，并在程序中根据注解作出处理。</p>\n<p>1.定义房间：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Room</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">open</span><span class=\"params\">(String name)</span></span>&#123;</span><br><span class=\"line\">        System.out.println(name+<span class=\"string\">\" came in\"</span>);&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2.创建注解时选择RETENTION.RUNTIME，这样我们可以通过反射获取注解信息：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class=\"line\"><span class=\"meta\">@Target</span>(ElementType.METHOD)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Accessible &#123;</span><br><span class=\"line\">    <span class=\"comment\">//保存允许进入房间的人员</span></span><br><span class=\"line\">    String [] value ();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>3.创建WashRoom,MeetingRoom,BossRoom，并在open方法上添加注解：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//例：洗手间 任何人都可以进入</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WashRoom</span> <span class=\"keyword\">extends</span> <span class=\"title\">Room</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Accessible</span>(&#123;<span class=\"string\">\"Boss\"</span>,<span class=\"string\">\"Staff\"</span>,<span class=\"string\">\"Visitor\"</span>&#125;)</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">open</span><span class=\"params\">(String name)</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"this is washroom\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.open(name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>4.处理注解：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//初始化房间和人员</span></span><br><span class=\"line\">Room[] rooms = &#123;<span class=\"keyword\">new</span> WashRoom(), <span class=\"keyword\">new</span> MeetingRoom(), <span class=\"keyword\">new</span> BossRoom()&#125;;</span><br><span class=\"line\">String[] persons = &#123;<span class=\"string\">\"Boss\"</span>, <span class=\"string\">\"Staff\"</span>, <span class=\"string\">\"Visitor\"</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (String person : persons) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Room room : rooms) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Method[] methods = room.getClass().getMethods();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Method method : methods) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//用反射获取带有注解的方法</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (method.isAnnotationPresent(Accessible.class)) &#123;</span><br><span class=\"line\">                    Accessible accessAnnotation = method.getAnnotation(Accessible.class);</span><br><span class=\"line\">                    <span class=\"comment\">//获得注解内容</span></span><br><span class=\"line\">                    List&lt;String&gt; nameList = Arrays.asList(accessAnnotation.value());</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (nameList.contains(person)) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                            method.invoke(room, person);</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                            e.printStackTrace();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                            System.out.println(<span class=\"string\">\"forbidden！\"</span>);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"全文完～\"><a href=\"#全文完～\" class=\"headerlink\" title=\"全文完～\"></a>全文完～</h1><h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p>oracle java文档：<a href=\"https://docs.oracle.com/javase/tutorial/java/annotations/index.html\" target=\"_blank\" rel=\"noopener\">https://docs.oracle.com/javase/tutorial/java/annotations/index.html</a><br>Java深度历险（六）——Java注解 <a href=\"http://www.infoq.com/cn/articles/cf-java-annotation\" target=\"_blank\" rel=\"noopener\">http://www.infoq.com/cn/articles/cf-java-annotation</a></p>"},{"title":"restlet 示例","date":"2019-05-04T16:34:58.000Z","_content":"\n### 背景介绍\n#### [restlet][1]\n是一个REST设计规范下的框架，让我们简单快速的开发RESTful应用。同类型的框架还有[Jersey][2]等，restlet在同类框架中是诞生比较早的一个（2005年），本文使用的是2.3.10版本是2017年发布的。\n<!--more-->\n\n#### [REST][3]\n全称 Representational State Transfer（表现层状态转换 ），由Roy Thomas Fielding博士于2000年在他的博士论文中提出，是一种软件架构风格，它基于HTTP定义了一组约束和属性来表述一个WebService。同类的WebService规范还有SOAP等。\n主要特征：\n1.以资源为基础，每个资源都由URI定义\n2.对资源的操作包括获取、创建、修改和删除资源，这些操作正好对应HTTP协议提供的GET、POST、PUT和DELETE方法。\n3.Client-Server客户服务器分离模式，任何一个客户端与服务器都是可替换的\n4.Stateless 服务端不会为客户端的请求保存context,好处是“通讯本身的无状态性可以让不同的服务器的处理一系列请求中的不同请求，提高服务器的扩展性”\n5.Cacheability Responses被设计为可缓存的，并负责缓存的一致性\n\n### 整体视图\n1. restlet框架结构 \n框架分为api和engine两部分，都被设计为可拓展的，API暴露给应用程序实现交互。\n![framework][4]\n2. 一个基于restlet的服务架构图\n每个大方块代表一个组件Component(代表一类服务、应用的集合)，每个Component既可以是客户端也可以是服务端；\n每个小方块是一个connector,方块之间的连线表示一个client-server的连接；restlet不仅支持http协议，也支持SMTP,FTP等类似协议。\n![app][5]\n3.一个简化的restfule服务结构图\n除了上面那种比较标准的架构，restlet还支持使用一个component代理多个应用（用单一jvm运行）,使用virtual host组件同时表示多个主机，并且同时启动多个connector\n![component][6]\n\n### 核心概念和类图\n#### 概念解释对比mvc\n**controller ==** Restlet(包含Filters, Routers, Finders等)\n**model ==** Resource 和 Domain Objects（DO可以在resource初始化时加载）\n**view ==** Representation可以是json文档，或velocity模板等等\n\n**Uniform** \n一个通用接口，只有一个方法`    void handle(Request request, Response response);`\n>以下几个类实例化后都会被并发访问，因此属性大多是final、violate修饰的\n\n**Restlet**\n抽象类，除了实现Uniform.handle()方法，还添加了对自身生命周期的管理和对context的维护。restlet实例不是线程安全的。\n{% asset_img restlet.png image %}如图，万物都是restlet\n**Connector**\n连接器，提供component之间的通信接口，对上层隐藏了资源和通信机制的具体实现。restlet框架提供了jetty,nio,servlet,jdbc,javaMail,solr等多种connector。\n**Client&Server**\n分别对应服务端和客户端的connector，他们内部使用RestletEngine提供的Connection Helper处理请求，当然Server多了地址和端口属性(还有个next属性，啥用？)。\n**Router**\nRouter是一个Restlet，它有助于将URI与Restlet或Resource相关联，以便处理对此URI发出的所有请求;\n请注意，Router附加了Restlet子类的实例，而Resource通过它们的类来附加。 原因是Resources的设计是为了处理单个请求，因此实例是通过它们的类在运行时生成的。\n在匹配URI地址时，有Template.MODE_EQUALS  和 Template.MODE_STARTS_WITH匹配策略；在选择处理URI的对象时，有几种算法：\n>Best match\nFirst match (default)\nLast match\nRandom match\nRound robin\nCustom\n\n**Application**\n管理一套连贯的Resource和Service，可以作为应用的根restlet也可以作为某一个restlet绑定到一个VirtualHost上。\napplication使用的service是框架来初始化的，我们可以主动禁用某个服务或者设置启用自定义的Service子类。\n可以重写createInboundRoot()/createOutboundRoot()方法处理所有请求。\n**Service**\nService是restlet框架提供的给Component和Application使用多种服务（比如connectorService可以控制connector的传输协议），他的生命周期和关联的Application或component紧紧绑定,service内部依赖context\n{% asset_img service.png image %}\n\n\n----------\n\n\n**Message**\ncomponent之间传输的内容，负责维护一些http header之类的消息属性、还有对缓存内容的控制（flush/commit等）。\n{% asset_img message.png image %}\n\n----------\n**Resource**\n相当于MVC模型中的model,最为统一资源封装了与特定目标resource相对应的Context，Request和Response。\n\n\n如图所示，ClientResource和ServerResource分别实现handle()方法（*和restlet不重复？*），Resource与Context,Request,Response是组合关系。\n{% asset_img resource.png image %}\n\n\n- 生命周期:\n`init() - handle() - release() ` *（由子类具体定义）*\n- 提供的在生命周期中插入自定义行为的函数：\n`doInit() doRelease() doCatch()`\n- 线程安全：\n和restlet不同，resource不会被并发访问，每次调用被handle创建一个resource实例，并且只由一个线程访问*（一个请求一个单线程？）*\n- resource使用的方法注解：\n>@Get\n@Put     类似replace操作\n@Delete \n@Post\n@Patch  类似update操作，不是幂等的\n@Options 测试服务器性能，获得服务端支持的Method等信息\n@Status 用于异常处理方法\n\n```\n//注解的value定义了返回结果的格式，或者请求的参数，以@Post为例：\n\n   @Post\n   public MyOutputBean accept(MyInputBean input);\n   \n   @Post(\"json\")\n   public String acceptJson(String value);\n   \n   @Post(\"xml|json:xml|json\")\n   public Representation accept(Representation xmlValue);\n   \n   @Post(\"json?param=val\")\n   public Representation acceptWithParam(String value);\n   \n   @Post(\"json?param\")\n   public Representation acceptWithParam(String value);\n   \n   @Post(\"?param\")\n   public Representation acceptWithParam(String value);\n```\n\n\n\n### 代码示例\n\n\n\n  [1]: https://restlet.com/open-source/\n  [2]: https://jersey.github.io/\n  [3]: https://zh.wikipedia.org/wiki/%E8%A1%A8%E7%8E%B0%E5%B1%82%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2\n  [4]: https://restlet.com/static/tech-doc/restlet-framework/tutorial/2.3/images/tutorial01.png\n  [5]: https://restlet.com/static/tech-doc/restlet-framework/tutorial/2.3/images/tutorial04.png\n  [6]: https://restlet.com/static/tech-doc/restlet-framework/tutorial/2.3/images/tutorial05.png\n  [8]: http://7xl4v5.com1.z0.glb.clouddn.com/restlet/service.png\n  [9]: http://7xl4v5.com1.z0.glb.clouddn.com/restlet/message.png\n  [10]: http://7xl4v5.com1.z0.glb.clouddn.com/restlet/resource.png\n","source":"_posts/restlet-示例.md","raw":"title: restlet 示例\ndate: 2019-05-05 00:34:58\ncategories: \ntags:\n\n---\n\n### 背景介绍\n#### [restlet][1]\n是一个REST设计规范下的框架，让我们简单快速的开发RESTful应用。同类型的框架还有[Jersey][2]等，restlet在同类框架中是诞生比较早的一个（2005年），本文使用的是2.3.10版本是2017年发布的。\n<!--more-->\n\n#### [REST][3]\n全称 Representational State Transfer（表现层状态转换 ），由Roy Thomas Fielding博士于2000年在他的博士论文中提出，是一种软件架构风格，它基于HTTP定义了一组约束和属性来表述一个WebService。同类的WebService规范还有SOAP等。\n主要特征：\n1.以资源为基础，每个资源都由URI定义\n2.对资源的操作包括获取、创建、修改和删除资源，这些操作正好对应HTTP协议提供的GET、POST、PUT和DELETE方法。\n3.Client-Server客户服务器分离模式，任何一个客户端与服务器都是可替换的\n4.Stateless 服务端不会为客户端的请求保存context,好处是“通讯本身的无状态性可以让不同的服务器的处理一系列请求中的不同请求，提高服务器的扩展性”\n5.Cacheability Responses被设计为可缓存的，并负责缓存的一致性\n\n### 整体视图\n1. restlet框架结构 \n框架分为api和engine两部分，都被设计为可拓展的，API暴露给应用程序实现交互。\n![framework][4]\n2. 一个基于restlet的服务架构图\n每个大方块代表一个组件Component(代表一类服务、应用的集合)，每个Component既可以是客户端也可以是服务端；\n每个小方块是一个connector,方块之间的连线表示一个client-server的连接；restlet不仅支持http协议，也支持SMTP,FTP等类似协议。\n![app][5]\n3.一个简化的restfule服务结构图\n除了上面那种比较标准的架构，restlet还支持使用一个component代理多个应用（用单一jvm运行）,使用virtual host组件同时表示多个主机，并且同时启动多个connector\n![component][6]\n\n### 核心概念和类图\n#### 概念解释对比mvc\n**controller ==** Restlet(包含Filters, Routers, Finders等)\n**model ==** Resource 和 Domain Objects（DO可以在resource初始化时加载）\n**view ==** Representation可以是json文档，或velocity模板等等\n\n**Uniform** \n一个通用接口，只有一个方法`    void handle(Request request, Response response);`\n>以下几个类实例化后都会被并发访问，因此属性大多是final、violate修饰的\n\n**Restlet**\n抽象类，除了实现Uniform.handle()方法，还添加了对自身生命周期的管理和对context的维护。restlet实例不是线程安全的。\n{% asset_img restlet.png image %}如图，万物都是restlet\n**Connector**\n连接器，提供component之间的通信接口，对上层隐藏了资源和通信机制的具体实现。restlet框架提供了jetty,nio,servlet,jdbc,javaMail,solr等多种connector。\n**Client&Server**\n分别对应服务端和客户端的connector，他们内部使用RestletEngine提供的Connection Helper处理请求，当然Server多了地址和端口属性(还有个next属性，啥用？)。\n**Router**\nRouter是一个Restlet，它有助于将URI与Restlet或Resource相关联，以便处理对此URI发出的所有请求;\n请注意，Router附加了Restlet子类的实例，而Resource通过它们的类来附加。 原因是Resources的设计是为了处理单个请求，因此实例是通过它们的类在运行时生成的。\n在匹配URI地址时，有Template.MODE_EQUALS  和 Template.MODE_STARTS_WITH匹配策略；在选择处理URI的对象时，有几种算法：\n>Best match\nFirst match (default)\nLast match\nRandom match\nRound robin\nCustom\n\n**Application**\n管理一套连贯的Resource和Service，可以作为应用的根restlet也可以作为某一个restlet绑定到一个VirtualHost上。\napplication使用的service是框架来初始化的，我们可以主动禁用某个服务或者设置启用自定义的Service子类。\n可以重写createInboundRoot()/createOutboundRoot()方法处理所有请求。\n**Service**\nService是restlet框架提供的给Component和Application使用多种服务（比如connectorService可以控制connector的传输协议），他的生命周期和关联的Application或component紧紧绑定,service内部依赖context\n{% asset_img service.png image %}\n\n\n----------\n\n\n**Message**\ncomponent之间传输的内容，负责维护一些http header之类的消息属性、还有对缓存内容的控制（flush/commit等）。\n{% asset_img message.png image %}\n\n----------\n**Resource**\n相当于MVC模型中的model,最为统一资源封装了与特定目标resource相对应的Context，Request和Response。\n\n\n如图所示，ClientResource和ServerResource分别实现handle()方法（*和restlet不重复？*），Resource与Context,Request,Response是组合关系。\n{% asset_img resource.png image %}\n\n\n- 生命周期:\n`init() - handle() - release() ` *（由子类具体定义）*\n- 提供的在生命周期中插入自定义行为的函数：\n`doInit() doRelease() doCatch()`\n- 线程安全：\n和restlet不同，resource不会被并发访问，每次调用被handle创建一个resource实例，并且只由一个线程访问*（一个请求一个单线程？）*\n- resource使用的方法注解：\n>@Get\n@Put     类似replace操作\n@Delete \n@Post\n@Patch  类似update操作，不是幂等的\n@Options 测试服务器性能，获得服务端支持的Method等信息\n@Status 用于异常处理方法\n\n```\n//注解的value定义了返回结果的格式，或者请求的参数，以@Post为例：\n\n   @Post\n   public MyOutputBean accept(MyInputBean input);\n   \n   @Post(\"json\")\n   public String acceptJson(String value);\n   \n   @Post(\"xml|json:xml|json\")\n   public Representation accept(Representation xmlValue);\n   \n   @Post(\"json?param=val\")\n   public Representation acceptWithParam(String value);\n   \n   @Post(\"json?param\")\n   public Representation acceptWithParam(String value);\n   \n   @Post(\"?param\")\n   public Representation acceptWithParam(String value);\n```\n\n\n\n### 代码示例\n\n\n\n  [1]: https://restlet.com/open-source/\n  [2]: https://jersey.github.io/\n  [3]: https://zh.wikipedia.org/wiki/%E8%A1%A8%E7%8E%B0%E5%B1%82%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2\n  [4]: https://restlet.com/static/tech-doc/restlet-framework/tutorial/2.3/images/tutorial01.png\n  [5]: https://restlet.com/static/tech-doc/restlet-framework/tutorial/2.3/images/tutorial04.png\n  [6]: https://restlet.com/static/tech-doc/restlet-framework/tutorial/2.3/images/tutorial05.png\n  [8]: http://7xl4v5.com1.z0.glb.clouddn.com/restlet/service.png\n  [9]: http://7xl4v5.com1.z0.glb.clouddn.com/restlet/message.png\n  [10]: http://7xl4v5.com1.z0.glb.clouddn.com/restlet/resource.png\n","slug":"restlet-示例","published":1,"updated":"2019-08-01T15:55:51.522Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkqle171000dcynedrsk6ucn","content":"<h3 id=\"背景介绍\"><a href=\"#背景介绍\" class=\"headerlink\" title=\"背景介绍\"></a>背景介绍</h3><h4 id=\"restlet\"><a href=\"#restlet\" class=\"headerlink\" title=\"restlet\"></a><a href=\"https://restlet.com/open-source/\" target=\"_blank\" rel=\"noopener\">restlet</a></h4><p>是一个REST设计规范下的框架，让我们简单快速的开发RESTful应用。同类型的框架还有<a href=\"https://jersey.github.io/\" target=\"_blank\" rel=\"noopener\">Jersey</a>等，restlet在同类框架中是诞生比较早的一个（2005年），本文使用的是2.3.10版本是2017年发布的。<br><a id=\"more\"></a></p>\n<h4 id=\"REST\"><a href=\"#REST\" class=\"headerlink\" title=\"REST\"></a><a href=\"https://zh.wikipedia.org/wiki/%E8%A1%A8%E7%8E%B0%E5%B1%82%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2\" target=\"_blank\" rel=\"noopener\">REST</a></h4><p>全称 Representational State Transfer（表现层状态转换 ），由Roy Thomas Fielding博士于2000年在他的博士论文中提出，是一种软件架构风格，它基于HTTP定义了一组约束和属性来表述一个WebService。同类的WebService规范还有SOAP等。<br>主要特征：<br>1.以资源为基础，每个资源都由URI定义<br>2.对资源的操作包括获取、创建、修改和删除资源，这些操作正好对应HTTP协议提供的GET、POST、PUT和DELETE方法。<br>3.Client-Server客户服务器分离模式，任何一个客户端与服务器都是可替换的<br>4.Stateless 服务端不会为客户端的请求保存context,好处是“通讯本身的无状态性可以让不同的服务器的处理一系列请求中的不同请求，提高服务器的扩展性”<br>5.Cacheability Responses被设计为可缓存的，并负责缓存的一致性</p>\n<h3 id=\"整体视图\"><a href=\"#整体视图\" class=\"headerlink\" title=\"整体视图\"></a>整体视图</h3><ol>\n<li>restlet框架结构<br>框架分为api和engine两部分，都被设计为可拓展的，API暴露给应用程序实现交互。<br><img src=\"https://restlet.com/static/tech-doc/restlet-framework/tutorial/2.3/images/tutorial01.png\" alt=\"framework\"></li>\n<li>一个基于restlet的服务架构图<br>每个大方块代表一个组件Component(代表一类服务、应用的集合)，每个Component既可以是客户端也可以是服务端；<br>每个小方块是一个connector,方块之间的连线表示一个client-server的连接；restlet不仅支持http协议，也支持SMTP,FTP等类似协议。<br><img src=\"https://restlet.com/static/tech-doc/restlet-framework/tutorial/2.3/images/tutorial04.png\" alt=\"app\"><br>3.一个简化的restfule服务结构图<br>除了上面那种比较标准的架构，restlet还支持使用一个component代理多个应用（用单一jvm运行）,使用virtual host组件同时表示多个主机，并且同时启动多个connector<br><img src=\"https://restlet.com/static/tech-doc/restlet-framework/tutorial/2.3/images/tutorial05.png\" alt=\"component\"></li>\n</ol>\n<h3 id=\"核心概念和类图\"><a href=\"#核心概念和类图\" class=\"headerlink\" title=\"核心概念和类图\"></a>核心概念和类图</h3><h4 id=\"概念解释对比mvc\"><a href=\"#概念解释对比mvc\" class=\"headerlink\" title=\"概念解释对比mvc\"></a>概念解释对比mvc</h4><p><strong>controller ==</strong> Restlet(包含Filters, Routers, Finders等)<br><strong>model ==</strong> Resource 和 Domain Objects（DO可以在resource初始化时加载）<br><strong>view ==</strong> Representation可以是json文档，或velocity模板等等</p>\n<p><strong>Uniform</strong><br>一个通用接口，只有一个方法<code>void handle(Request request, Response response);</code></p>\n<blockquote>\n<p>以下几个类实例化后都会被并发访问，因此属性大多是final、violate修饰的</p>\n</blockquote>\n<p><strong>Restlet</strong><br>抽象类，除了实现Uniform.handle()方法，还添加了对自身生命周期的管理和对context的维护。restlet实例不是线程安全的。<br><img src=\"/2019/05/05/restlet-示例/restlet.png\" title=\"image\">如图，万物都是restlet<br><strong>Connector</strong><br>连接器，提供component之间的通信接口，对上层隐藏了资源和通信机制的具体实现。restlet框架提供了jetty,nio,servlet,jdbc,javaMail,solr等多种connector。<br><strong>Client&amp;Server</strong><br>分别对应服务端和客户端的connector，他们内部使用RestletEngine提供的Connection Helper处理请求，当然Server多了地址和端口属性(还有个next属性，啥用？)。<br><strong>Router</strong><br>Router是一个Restlet，它有助于将URI与Restlet或Resource相关联，以便处理对此URI发出的所有请求;<br>请注意，Router附加了Restlet子类的实例，而Resource通过它们的类来附加。 原因是Resources的设计是为了处理单个请求，因此实例是通过它们的类在运行时生成的。<br>在匹配URI地址时，有Template.MODE_EQUALS  和 Template.MODE_STARTS_WITH匹配策略；在选择处理URI的对象时，有几种算法：</p>\n<blockquote>\n<p>Best match<br>First match (default)<br>Last match<br>Random match<br>Round robin<br>Custom</p>\n</blockquote>\n<p><strong>Application</strong><br>管理一套连贯的Resource和Service，可以作为应用的根restlet也可以作为某一个restlet绑定到一个VirtualHost上。<br>application使用的service是框架来初始化的，我们可以主动禁用某个服务或者设置启用自定义的Service子类。<br>可以重写createInboundRoot()/createOutboundRoot()方法处理所有请求。<br><strong>Service</strong><br>Service是restlet框架提供的给Component和Application使用多种服务（比如connectorService可以控制connector的传输协议），他的生命周期和关联的Application或component紧紧绑定,service内部依赖context<br><img src=\"/2019/05/05/restlet-示例/service.png\" title=\"image\"></p>\n<hr>\n<p><strong>Message</strong><br>component之间传输的内容，负责维护一些http header之类的消息属性、还有对缓存内容的控制（flush/commit等）。<br><img src=\"/2019/05/05/restlet-示例/message.png\" title=\"image\"></p>\n<hr>\n<p><strong>Resource</strong><br>相当于MVC模型中的model,最为统一资源封装了与特定目标resource相对应的Context，Request和Response。</p>\n<p>如图所示，ClientResource和ServerResource分别实现handle()方法（<em>和restlet不重复？</em>），Resource与Context,Request,Response是组合关系。<br><img src=\"/2019/05/05/restlet-示例/resource.png\" title=\"image\"></p>\n<ul>\n<li>生命周期:<br><code>init() - handle() - release()</code> <em>（由子类具体定义）</em></li>\n<li>提供的在生命周期中插入自定义行为的函数：<br><code>doInit() doRelease() doCatch()</code></li>\n<li>线程安全：<br>和restlet不同，resource不会被并发访问，每次调用被handle创建一个resource实例，并且只由一个线程访问<em>（一个请求一个单线程？）</em></li>\n<li>resource使用的方法注解：<blockquote>\n<p>@Get<br>@Put     类似replace操作<br>@Delete<br>@Post<br>@Patch  类似update操作，不是幂等的<br>@Options 测试服务器性能，获得服务端支持的Method等信息<br>@Status 用于异常处理方法</p>\n</blockquote>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//注解的value定义了返回结果的格式，或者请求的参数，以@Post为例：</span><br><span class=\"line\"></span><br><span class=\"line\">   @Post</span><br><span class=\"line\">   public MyOutputBean accept(MyInputBean input);</span><br><span class=\"line\">   </span><br><span class=\"line\">   @Post(&quot;json&quot;)</span><br><span class=\"line\">   public String acceptJson(String value);</span><br><span class=\"line\">   </span><br><span class=\"line\">   @Post(&quot;xml|json:xml|json&quot;)</span><br><span class=\"line\">   public Representation accept(Representation xmlValue);</span><br><span class=\"line\">   </span><br><span class=\"line\">   @Post(&quot;json?param=val&quot;)</span><br><span class=\"line\">   public Representation acceptWithParam(String value);</span><br><span class=\"line\">   </span><br><span class=\"line\">   @Post(&quot;json?param&quot;)</span><br><span class=\"line\">   public Representation acceptWithParam(String value);</span><br><span class=\"line\">   </span><br><span class=\"line\">   @Post(&quot;?param&quot;)</span><br><span class=\"line\">   public Representation acceptWithParam(String value);</span><br></pre></td></tr></table></figure>\n<h3 id=\"代码示例\"><a href=\"#代码示例\" class=\"headerlink\" title=\"代码示例\"></a>代码示例</h3>","site":{"data":{}},"excerpt":"<h3 id=\"背景介绍\"><a href=\"#背景介绍\" class=\"headerlink\" title=\"背景介绍\"></a>背景介绍</h3><h4 id=\"restlet\"><a href=\"#restlet\" class=\"headerlink\" title=\"restlet\"></a><a href=\"https://restlet.com/open-source/\" target=\"_blank\" rel=\"noopener\">restlet</a></h4><p>是一个REST设计规范下的框架，让我们简单快速的开发RESTful应用。同类型的框架还有<a href=\"https://jersey.github.io/\" target=\"_blank\" rel=\"noopener\">Jersey</a>等，restlet在同类框架中是诞生比较早的一个（2005年），本文使用的是2.3.10版本是2017年发布的。<br>","more":"</p>\n<h4 id=\"REST\"><a href=\"#REST\" class=\"headerlink\" title=\"REST\"></a><a href=\"https://zh.wikipedia.org/wiki/%E8%A1%A8%E7%8E%B0%E5%B1%82%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2\" target=\"_blank\" rel=\"noopener\">REST</a></h4><p>全称 Representational State Transfer（表现层状态转换 ），由Roy Thomas Fielding博士于2000年在他的博士论文中提出，是一种软件架构风格，它基于HTTP定义了一组约束和属性来表述一个WebService。同类的WebService规范还有SOAP等。<br>主要特征：<br>1.以资源为基础，每个资源都由URI定义<br>2.对资源的操作包括获取、创建、修改和删除资源，这些操作正好对应HTTP协议提供的GET、POST、PUT和DELETE方法。<br>3.Client-Server客户服务器分离模式，任何一个客户端与服务器都是可替换的<br>4.Stateless 服务端不会为客户端的请求保存context,好处是“通讯本身的无状态性可以让不同的服务器的处理一系列请求中的不同请求，提高服务器的扩展性”<br>5.Cacheability Responses被设计为可缓存的，并负责缓存的一致性</p>\n<h3 id=\"整体视图\"><a href=\"#整体视图\" class=\"headerlink\" title=\"整体视图\"></a>整体视图</h3><ol>\n<li>restlet框架结构<br>框架分为api和engine两部分，都被设计为可拓展的，API暴露给应用程序实现交互。<br><img src=\"https://restlet.com/static/tech-doc/restlet-framework/tutorial/2.3/images/tutorial01.png\" alt=\"framework\"></li>\n<li>一个基于restlet的服务架构图<br>每个大方块代表一个组件Component(代表一类服务、应用的集合)，每个Component既可以是客户端也可以是服务端；<br>每个小方块是一个connector,方块之间的连线表示一个client-server的连接；restlet不仅支持http协议，也支持SMTP,FTP等类似协议。<br><img src=\"https://restlet.com/static/tech-doc/restlet-framework/tutorial/2.3/images/tutorial04.png\" alt=\"app\"><br>3.一个简化的restfule服务结构图<br>除了上面那种比较标准的架构，restlet还支持使用一个component代理多个应用（用单一jvm运行）,使用virtual host组件同时表示多个主机，并且同时启动多个connector<br><img src=\"https://restlet.com/static/tech-doc/restlet-framework/tutorial/2.3/images/tutorial05.png\" alt=\"component\"></li>\n</ol>\n<h3 id=\"核心概念和类图\"><a href=\"#核心概念和类图\" class=\"headerlink\" title=\"核心概念和类图\"></a>核心概念和类图</h3><h4 id=\"概念解释对比mvc\"><a href=\"#概念解释对比mvc\" class=\"headerlink\" title=\"概念解释对比mvc\"></a>概念解释对比mvc</h4><p><strong>controller ==</strong> Restlet(包含Filters, Routers, Finders等)<br><strong>model ==</strong> Resource 和 Domain Objects（DO可以在resource初始化时加载）<br><strong>view ==</strong> Representation可以是json文档，或velocity模板等等</p>\n<p><strong>Uniform</strong><br>一个通用接口，只有一个方法<code>void handle(Request request, Response response);</code></p>\n<blockquote>\n<p>以下几个类实例化后都会被并发访问，因此属性大多是final、violate修饰的</p>\n</blockquote>\n<p><strong>Restlet</strong><br>抽象类，除了实现Uniform.handle()方法，还添加了对自身生命周期的管理和对context的维护。restlet实例不是线程安全的。<br><img src=\"/2019/05/05/restlet-示例/restlet.png\" title=\"image\">如图，万物都是restlet<br><strong>Connector</strong><br>连接器，提供component之间的通信接口，对上层隐藏了资源和通信机制的具体实现。restlet框架提供了jetty,nio,servlet,jdbc,javaMail,solr等多种connector。<br><strong>Client&amp;Server</strong><br>分别对应服务端和客户端的connector，他们内部使用RestletEngine提供的Connection Helper处理请求，当然Server多了地址和端口属性(还有个next属性，啥用？)。<br><strong>Router</strong><br>Router是一个Restlet，它有助于将URI与Restlet或Resource相关联，以便处理对此URI发出的所有请求;<br>请注意，Router附加了Restlet子类的实例，而Resource通过它们的类来附加。 原因是Resources的设计是为了处理单个请求，因此实例是通过它们的类在运行时生成的。<br>在匹配URI地址时，有Template.MODE_EQUALS  和 Template.MODE_STARTS_WITH匹配策略；在选择处理URI的对象时，有几种算法：</p>\n<blockquote>\n<p>Best match<br>First match (default)<br>Last match<br>Random match<br>Round robin<br>Custom</p>\n</blockquote>\n<p><strong>Application</strong><br>管理一套连贯的Resource和Service，可以作为应用的根restlet也可以作为某一个restlet绑定到一个VirtualHost上。<br>application使用的service是框架来初始化的，我们可以主动禁用某个服务或者设置启用自定义的Service子类。<br>可以重写createInboundRoot()/createOutboundRoot()方法处理所有请求。<br><strong>Service</strong><br>Service是restlet框架提供的给Component和Application使用多种服务（比如connectorService可以控制connector的传输协议），他的生命周期和关联的Application或component紧紧绑定,service内部依赖context<br><img src=\"/2019/05/05/restlet-示例/service.png\" title=\"image\"></p>\n<hr>\n<p><strong>Message</strong><br>component之间传输的内容，负责维护一些http header之类的消息属性、还有对缓存内容的控制（flush/commit等）。<br><img src=\"/2019/05/05/restlet-示例/message.png\" title=\"image\"></p>\n<hr>\n<p><strong>Resource</strong><br>相当于MVC模型中的model,最为统一资源封装了与特定目标resource相对应的Context，Request和Response。</p>\n<p>如图所示，ClientResource和ServerResource分别实现handle()方法（<em>和restlet不重复？</em>），Resource与Context,Request,Response是组合关系。<br><img src=\"/2019/05/05/restlet-示例/resource.png\" title=\"image\"></p>\n<ul>\n<li>生命周期:<br><code>init() - handle() - release()</code> <em>（由子类具体定义）</em></li>\n<li>提供的在生命周期中插入自定义行为的函数：<br><code>doInit() doRelease() doCatch()</code></li>\n<li>线程安全：<br>和restlet不同，resource不会被并发访问，每次调用被handle创建一个resource实例，并且只由一个线程访问<em>（一个请求一个单线程？）</em></li>\n<li>resource使用的方法注解：<blockquote>\n<p>@Get<br>@Put     类似replace操作<br>@Delete<br>@Post<br>@Patch  类似update操作，不是幂等的<br>@Options 测试服务器性能，获得服务端支持的Method等信息<br>@Status 用于异常处理方法</p>\n</blockquote>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//注解的value定义了返回结果的格式，或者请求的参数，以@Post为例：</span><br><span class=\"line\"></span><br><span class=\"line\">   @Post</span><br><span class=\"line\">   public MyOutputBean accept(MyInputBean input);</span><br><span class=\"line\">   </span><br><span class=\"line\">   @Post(&quot;json&quot;)</span><br><span class=\"line\">   public String acceptJson(String value);</span><br><span class=\"line\">   </span><br><span class=\"line\">   @Post(&quot;xml|json:xml|json&quot;)</span><br><span class=\"line\">   public Representation accept(Representation xmlValue);</span><br><span class=\"line\">   </span><br><span class=\"line\">   @Post(&quot;json?param=val&quot;)</span><br><span class=\"line\">   public Representation acceptWithParam(String value);</span><br><span class=\"line\">   </span><br><span class=\"line\">   @Post(&quot;json?param&quot;)</span><br><span class=\"line\">   public Representation acceptWithParam(String value);</span><br><span class=\"line\">   </span><br><span class=\"line\">   @Post(&quot;?param&quot;)</span><br><span class=\"line\">   public Representation acceptWithParam(String value);</span><br></pre></td></tr></table></figure>\n<h3 id=\"代码示例\"><a href=\"#代码示例\" class=\"headerlink\" title=\"代码示例\"></a>代码示例</h3>"},{"title":"Sendmail的一些坑","date":"2015-12-26T15:05:46.000Z","_content":"## 简介\nSendmail是一个linux邮件服务系统，可以使用它来搭建邮件服务器。\n\n 关于邮件的几个名词：\n>MTA(Mail Transfer Agent)                             邮件传送代理，运行在邮件服务器的程序，负责接收发送邮件  \n\n>MUA(Mail User Agent) 用户端代理，提供查看编辑提交邮件的功能（如foxmail）  \n\n  >MDA(Mail Delivery Agent)主要的功能就是将MTA接收的信件依照信件的流向（送到哪里）将该信件放置到本机账户下的邮件文件中（收件箱），或者再经由MTA将信件送到下个MTA。如果信件的流向是到本机，这个邮件代理的功能就不只是将由MTA传来的邮件放置到每个用户的收件箱，它还可以具有邮件过滤（filtering）与其他相关功能[^foot]。\n\n<!--more-->\n\n## 安装\n我使用的是CentOS6.2 sendmail 8.14.4\n\n```shell\n#安装sendmail和配置工具sendmail-cf\nyum install -y sendmail\nyum install -y sendmail-cf\n#SMTP认证服务\nyum install -y saslauthd\n```\n## 配置sendmail\nsendmail的配置文件主要是XXX.mc文件和XXX.cf文件，mc后缀文件可以看做是配置文件的人类阅读版，通过sendmail-cf工具将它生成为cf后缀的外星人版配置文件   \n>vim /etc/mail/sendmail.mc\n\n具体操作请参考--[传送门](http://www.centoscn.com/CentosServer/lighttpd/2013/0726/650.html)\n\n## 常见问题\n### 1.发出的邮件被其他MTA识别为垃圾\n\n设置域名指向（上节链接），添加spf记录 [操作教程](https://www.renfei.org/blog/introduction-to-spf.html)\n同时注意控制发信频率\n### 2.在哪查看sendmail日志?\n**日志位置**： /var/log/maillog  \n**调整日志级别（详细程度）**： 修改配置文件define(`confLOG_LEVEL', `16')dnl 默认为9\n或者调用命令时指定sendmail -O LogLevel=14\n[日志级别说明](http://www-01.ibm.com/support/knowledgecenter/ssw_aix_71/com.ibm.aix.networkcomm/sendmail_debugflags.htm?lang=zh)\n### 3.sendmail日志都是什么意思?\n**注意sendmail并不保证发出的邮件一定会被发到收件人接收**，所以日志中的信息只是接收端MTA反馈的连接信息。\n具体格式，慢慢读吧-----[sendmail日志格式](http://www.softpanorama.net/Mail/Sendmail/sendmail_logs_format.shtml)\n### 4.sendmail性能参数\nhttp://www.5dmail.net/html/2008-4-27/200842733006.htm  \n### 5.一些相关的网站，文章\nhttp://www.5dmail.net/  \n**sendmail官网**https://www.sendmail.com/sm/open_source/\nhttp://park.jobdeer.com/discussion/19/%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81%E9%82%A3%E7%82%B9%E4%BA%8B\n**看邮件头**http://www.qqexmail.net/tips/st_security_look_head.asp\n\n[^foot]:http://wenku.baidu.com/link?url=iK74BiQS1clzFxTy4B4eBcG6u4gR9EMZ-CY58DwhrNqsJSYt6P9nk-aUzGPqXxgoTM5qAj51J4F-aPUhf3vaidDopNr6SrU3VgwPhWwHws_\n","source":"_posts/sendmail.md","raw":"title: Sendmail的一些坑\ndate: 2015-12-26 23:05:46\ncategories: \ntags: [邮件]\n\n---\n## 简介\nSendmail是一个linux邮件服务系统，可以使用它来搭建邮件服务器。\n\n 关于邮件的几个名词：\n>MTA(Mail Transfer Agent)                             邮件传送代理，运行在邮件服务器的程序，负责接收发送邮件  \n\n>MUA(Mail User Agent) 用户端代理，提供查看编辑提交邮件的功能（如foxmail）  \n\n  >MDA(Mail Delivery Agent)主要的功能就是将MTA接收的信件依照信件的流向（送到哪里）将该信件放置到本机账户下的邮件文件中（收件箱），或者再经由MTA将信件送到下个MTA。如果信件的流向是到本机，这个邮件代理的功能就不只是将由MTA传来的邮件放置到每个用户的收件箱，它还可以具有邮件过滤（filtering）与其他相关功能[^foot]。\n\n<!--more-->\n\n## 安装\n我使用的是CentOS6.2 sendmail 8.14.4\n\n```shell\n#安装sendmail和配置工具sendmail-cf\nyum install -y sendmail\nyum install -y sendmail-cf\n#SMTP认证服务\nyum install -y saslauthd\n```\n## 配置sendmail\nsendmail的配置文件主要是XXX.mc文件和XXX.cf文件，mc后缀文件可以看做是配置文件的人类阅读版，通过sendmail-cf工具将它生成为cf后缀的外星人版配置文件   \n>vim /etc/mail/sendmail.mc\n\n具体操作请参考--[传送门](http://www.centoscn.com/CentosServer/lighttpd/2013/0726/650.html)\n\n## 常见问题\n### 1.发出的邮件被其他MTA识别为垃圾\n\n设置域名指向（上节链接），添加spf记录 [操作教程](https://www.renfei.org/blog/introduction-to-spf.html)\n同时注意控制发信频率\n### 2.在哪查看sendmail日志?\n**日志位置**： /var/log/maillog  \n**调整日志级别（详细程度）**： 修改配置文件define(`confLOG_LEVEL', `16')dnl 默认为9\n或者调用命令时指定sendmail -O LogLevel=14\n[日志级别说明](http://www-01.ibm.com/support/knowledgecenter/ssw_aix_71/com.ibm.aix.networkcomm/sendmail_debugflags.htm?lang=zh)\n### 3.sendmail日志都是什么意思?\n**注意sendmail并不保证发出的邮件一定会被发到收件人接收**，所以日志中的信息只是接收端MTA反馈的连接信息。\n具体格式，慢慢读吧-----[sendmail日志格式](http://www.softpanorama.net/Mail/Sendmail/sendmail_logs_format.shtml)\n### 4.sendmail性能参数\nhttp://www.5dmail.net/html/2008-4-27/200842733006.htm  \n### 5.一些相关的网站，文章\nhttp://www.5dmail.net/  \n**sendmail官网**https://www.sendmail.com/sm/open_source/\nhttp://park.jobdeer.com/discussion/19/%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81%E9%82%A3%E7%82%B9%E4%BA%8B\n**看邮件头**http://www.qqexmail.net/tips/st_security_look_head.asp\n\n[^foot]:http://wenku.baidu.com/link?url=iK74BiQS1clzFxTy4B4eBcG6u4gR9EMZ-CY58DwhrNqsJSYt6P9nk-aUzGPqXxgoTM5qAj51J4F-aPUhf3vaidDopNr6SrU3VgwPhWwHws_\n","slug":"sendmail","published":1,"updated":"2018-11-21T16:24:04.824Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkqle173000ecyneyo8hlqnz","content":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>Sendmail是一个linux邮件服务系统，可以使用它来搭建邮件服务器。</p>\n<p> 关于邮件的几个名词：</p>\n<blockquote>\n<p>MTA(Mail Transfer Agent)                             邮件传送代理，运行在邮件服务器的程序，负责接收发送邮件  </p>\n</blockquote>\n<blockquote>\n<p>MUA(Mail User Agent) 用户端代理，提供查看编辑提交邮件的功能（如foxmail）  </p>\n</blockquote>\n<blockquote>\n<p>MDA(Mail Delivery Agent)主要的功能就是将MTA接收的信件依照信件的流向（送到哪里）将该信件放置到本机账户下的邮件文件中（收件箱），或者再经由MTA将信件送到下个MTA。如果信件的流向是到本机，这个邮件代理的功能就不只是将由MTA传来的邮件放置到每个用户的收件箱，它还可以具有邮件过滤（filtering）与其他相关功能<a href=\"http://wenku.baidu.com/link?url=iK74BiQS1clzFxTy4B4eBcG6u4gR9EMZ-CY58DwhrNqsJSYt6P9nk-aUzGPqXxgoTM5qAj51J4F-aPUhf3vaidDopNr6SrU3VgwPhWwHws_\" target=\"_blank\" rel=\"noopener\">^foot</a>。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>我使用的是CentOS6.2 sendmail 8.14.4</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span>安装sendmail和配置工具sendmail-cf</span><br><span class=\"line\">yum install -y sendmail</span><br><span class=\"line\">yum install -y sendmail-cf</span><br><span class=\"line\"><span class=\"meta\">#</span>SMTP认证服务</span><br><span class=\"line\">yum install -y saslauthd</span><br></pre></td></tr></table></figure>\n<h2 id=\"配置sendmail\"><a href=\"#配置sendmail\" class=\"headerlink\" title=\"配置sendmail\"></a>配置sendmail</h2><p>sendmail的配置文件主要是XXX.mc文件和XXX.cf文件，mc后缀文件可以看做是配置文件的人类阅读版，通过sendmail-cf工具将它生成为cf后缀的外星人版配置文件   </p>\n<blockquote>\n<p>vim /etc/mail/sendmail.mc</p>\n</blockquote>\n<p>具体操作请参考–<a href=\"http://www.centoscn.com/CentosServer/lighttpd/2013/0726/650.html\" target=\"_blank\" rel=\"noopener\">传送门</a></p>\n<h2 id=\"常见问题\"><a href=\"#常见问题\" class=\"headerlink\" title=\"常见问题\"></a>常见问题</h2><h3 id=\"1-发出的邮件被其他MTA识别为垃圾\"><a href=\"#1-发出的邮件被其他MTA识别为垃圾\" class=\"headerlink\" title=\"1.发出的邮件被其他MTA识别为垃圾\"></a>1.发出的邮件被其他MTA识别为垃圾</h3><p>设置域名指向（上节链接），添加spf记录 <a href=\"https://www.renfei.org/blog/introduction-to-spf.html\" target=\"_blank\" rel=\"noopener\">操作教程</a><br>同时注意控制发信频率</p>\n<h3 id=\"2-在哪查看sendmail日志\"><a href=\"#2-在哪查看sendmail日志\" class=\"headerlink\" title=\"2.在哪查看sendmail日志?\"></a>2.在哪查看sendmail日志?</h3><p><strong>日志位置</strong>： /var/log/maillog<br><strong>调整日志级别（详细程度）</strong>： 修改配置文件define(<code>confLOG_LEVEL&#39;,</code>16’)dnl 默认为9<br>或者调用命令时指定sendmail -O LogLevel=14<br><a href=\"http://www-01.ibm.com/support/knowledgecenter/ssw_aix_71/com.ibm.aix.networkcomm/sendmail_debugflags.htm?lang=zh\" target=\"_blank\" rel=\"noopener\">日志级别说明</a></p>\n<h3 id=\"3-sendmail日志都是什么意思\"><a href=\"#3-sendmail日志都是什么意思\" class=\"headerlink\" title=\"3.sendmail日志都是什么意思?\"></a>3.sendmail日志都是什么意思?</h3><p><strong>注意sendmail并不保证发出的邮件一定会被发到收件人接收</strong>，所以日志中的信息只是接收端MTA反馈的连接信息。<br>具体格式，慢慢读吧—–<a href=\"http://www.softpanorama.net/Mail/Sendmail/sendmail_logs_format.shtml\" target=\"_blank\" rel=\"noopener\">sendmail日志格式</a></p>\n<h3 id=\"4-sendmail性能参数\"><a href=\"#4-sendmail性能参数\" class=\"headerlink\" title=\"4.sendmail性能参数\"></a>4.sendmail性能参数</h3><p><a href=\"http://www.5dmail.net/html/2008-4-27/200842733006.htm\" target=\"_blank\" rel=\"noopener\">http://www.5dmail.net/html/2008-4-27/200842733006.htm</a>  </p>\n<h3 id=\"5-一些相关的网站，文章\"><a href=\"#5-一些相关的网站，文章\" class=\"headerlink\" title=\"5.一些相关的网站，文章\"></a>5.一些相关的网站，文章</h3><p><a href=\"http://www.5dmail.net/\" target=\"_blank\" rel=\"noopener\">http://www.5dmail.net/</a><br><strong>sendmail官网</strong><a href=\"https://www.sendmail.com/sm/open_source/\" target=\"_blank\" rel=\"noopener\">https://www.sendmail.com/sm/open_source/</a><br><a href=\"http://park.jobdeer.com/discussion/19/%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81%E9%82%A3%E7%82%B9%E4%BA%8B\" target=\"_blank\" rel=\"noopener\">http://park.jobdeer.com/discussion/19/%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81%E9%82%A3%E7%82%B9%E4%BA%8B</a><br><strong>看邮件头</strong><a href=\"http://www.qqexmail.net/tips/st_security_look_head.asp\" target=\"_blank\" rel=\"noopener\">http://www.qqexmail.net/tips/st_security_look_head.asp</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>Sendmail是一个linux邮件服务系统，可以使用它来搭建邮件服务器。</p>\n<p> 关于邮件的几个名词：</p>\n<blockquote>\n<p>MTA(Mail Transfer Agent)                             邮件传送代理，运行在邮件服务器的程序，负责接收发送邮件  </p>\n</blockquote>\n<blockquote>\n<p>MUA(Mail User Agent) 用户端代理，提供查看编辑提交邮件的功能（如foxmail）  </p>\n</blockquote>\n<blockquote>\n<p>MDA(Mail Delivery Agent)主要的功能就是将MTA接收的信件依照信件的流向（送到哪里）将该信件放置到本机账户下的邮件文件中（收件箱），或者再经由MTA将信件送到下个MTA。如果信件的流向是到本机，这个邮件代理的功能就不只是将由MTA传来的邮件放置到每个用户的收件箱，它还可以具有邮件过滤（filtering）与其他相关功能<a href=\"http://wenku.baidu.com/link?url=iK74BiQS1clzFxTy4B4eBcG6u4gR9EMZ-CY58DwhrNqsJSYt6P9nk-aUzGPqXxgoTM5qAj51J4F-aPUhf3vaidDopNr6SrU3VgwPhWwHws_\" target=\"_blank\" rel=\"noopener\">^foot</a>。</p>\n</blockquote>","more":"<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>我使用的是CentOS6.2 sendmail 8.14.4</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span>安装sendmail和配置工具sendmail-cf</span><br><span class=\"line\">yum install -y sendmail</span><br><span class=\"line\">yum install -y sendmail-cf</span><br><span class=\"line\"><span class=\"meta\">#</span>SMTP认证服务</span><br><span class=\"line\">yum install -y saslauthd</span><br></pre></td></tr></table></figure>\n<h2 id=\"配置sendmail\"><a href=\"#配置sendmail\" class=\"headerlink\" title=\"配置sendmail\"></a>配置sendmail</h2><p>sendmail的配置文件主要是XXX.mc文件和XXX.cf文件，mc后缀文件可以看做是配置文件的人类阅读版，通过sendmail-cf工具将它生成为cf后缀的外星人版配置文件   </p>\n<blockquote>\n<p>vim /etc/mail/sendmail.mc</p>\n</blockquote>\n<p>具体操作请参考–<a href=\"http://www.centoscn.com/CentosServer/lighttpd/2013/0726/650.html\" target=\"_blank\" rel=\"noopener\">传送门</a></p>\n<h2 id=\"常见问题\"><a href=\"#常见问题\" class=\"headerlink\" title=\"常见问题\"></a>常见问题</h2><h3 id=\"1-发出的邮件被其他MTA识别为垃圾\"><a href=\"#1-发出的邮件被其他MTA识别为垃圾\" class=\"headerlink\" title=\"1.发出的邮件被其他MTA识别为垃圾\"></a>1.发出的邮件被其他MTA识别为垃圾</h3><p>设置域名指向（上节链接），添加spf记录 <a href=\"https://www.renfei.org/blog/introduction-to-spf.html\" target=\"_blank\" rel=\"noopener\">操作教程</a><br>同时注意控制发信频率</p>\n<h3 id=\"2-在哪查看sendmail日志\"><a href=\"#2-在哪查看sendmail日志\" class=\"headerlink\" title=\"2.在哪查看sendmail日志?\"></a>2.在哪查看sendmail日志?</h3><p><strong>日志位置</strong>： /var/log/maillog<br><strong>调整日志级别（详细程度）</strong>： 修改配置文件define(<code>confLOG_LEVEL&#39;,</code>16’)dnl 默认为9<br>或者调用命令时指定sendmail -O LogLevel=14<br><a href=\"http://www-01.ibm.com/support/knowledgecenter/ssw_aix_71/com.ibm.aix.networkcomm/sendmail_debugflags.htm?lang=zh\" target=\"_blank\" rel=\"noopener\">日志级别说明</a></p>\n<h3 id=\"3-sendmail日志都是什么意思\"><a href=\"#3-sendmail日志都是什么意思\" class=\"headerlink\" title=\"3.sendmail日志都是什么意思?\"></a>3.sendmail日志都是什么意思?</h3><p><strong>注意sendmail并不保证发出的邮件一定会被发到收件人接收</strong>，所以日志中的信息只是接收端MTA反馈的连接信息。<br>具体格式，慢慢读吧—–<a href=\"http://www.softpanorama.net/Mail/Sendmail/sendmail_logs_format.shtml\" target=\"_blank\" rel=\"noopener\">sendmail日志格式</a></p>\n<h3 id=\"4-sendmail性能参数\"><a href=\"#4-sendmail性能参数\" class=\"headerlink\" title=\"4.sendmail性能参数\"></a>4.sendmail性能参数</h3><p><a href=\"http://www.5dmail.net/html/2008-4-27/200842733006.htm\" target=\"_blank\" rel=\"noopener\">http://www.5dmail.net/html/2008-4-27/200842733006.htm</a>  </p>\n<h3 id=\"5-一些相关的网站，文章\"><a href=\"#5-一些相关的网站，文章\" class=\"headerlink\" title=\"5.一些相关的网站，文章\"></a>5.一些相关的网站，文章</h3><p><a href=\"http://www.5dmail.net/\" target=\"_blank\" rel=\"noopener\">http://www.5dmail.net/</a><br><strong>sendmail官网</strong><a href=\"https://www.sendmail.com/sm/open_source/\" target=\"_blank\" rel=\"noopener\">https://www.sendmail.com/sm/open_source/</a><br><a href=\"http://park.jobdeer.com/discussion/19/%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81%E9%82%A3%E7%82%B9%E4%BA%8B\" target=\"_blank\" rel=\"noopener\">http://park.jobdeer.com/discussion/19/%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81%E9%82%A3%E7%82%B9%E4%BA%8B</a><br><strong>看邮件头</strong><a href=\"http://www.qqexmail.net/tips/st_security_look_head.asp\" target=\"_blank\" rel=\"noopener\">http://www.qqexmail.net/tips/st_security_look_head.asp</a></p>"},{"title":"Shell in Action（一）文本编辑-修改hosts","date":"2015-11-30T16:32:36.000Z","_content":"\n　把自己工作环境换成linux之后总会遇到各种无语的问题，比如我在web开发时会经常要切换测试环境或者本地环境的hosts，但是在用firefox的hosts插件时发现每次修改都会卡死，最后忍无可忍打算写一个切换hosts环境的脚本，有问题欢迎指正~\n\n\n\n##问题分析\n　我们都知道hosts文件就长这样，#是注释符、ip和域名用空格分开\n下面是测试文件testhosts，用DEV和TEST区分不同环境：\n\n```\n#DEV\n74.125.207.84 accounts.a.com\n74.125.207.83 accounts.b.com\n#TEST\n64.233.168.106 www.c.com\n64.233.168.107 www.d.com\n#END\n```\n**解决步骤**\n\n\n　　1.读取用户要切换的环境\n　　2.读取hosts文件，在指定的行前添加注释\n　　3.维护一个值 保存hosts所处环境 提示用户当前hosts环境\n<!--more-->\n###一、修改host文件\n\n##ed命令\n　ed （edit）命令 可以逐行的修改文本，[[a]](#1)分为‘寻址’‘操作命令’‘文件名’三个部分\n　ed [address]command textfile\n在命令行 输入 `info ed` 查看ed完整说明 \n**寻址**\n\n| 选项        | 说明           |\n|:------------- |:-------------| \n| number      | 第number行，从0开始 | \n|+number      | 从本行后第number行开始 | \n| -number      | 从本行前第number行开始 | \n|   ，    | 1,3表示从1到3行 一个逗号表示全文 | \n| /pattern/|下一个包含/partten/的行|\n| \\$partten\\$|上一个包含partten的行|\n\n**命令部分**\n\n| 选项        | 说明           |\n|:------------- |:-------------| \n| a  | add 追加文本 | \n|c | change| \n| d   | 删除当前指向的行 | \n| i   |insert | \n| wq   |和vim一样 write&quit | \n| s/pattern/replace/  |将符合pattern的替换为replace文本 | \ned操作文本时会将文件拷贝到缓冲区，在编辑后写入文件，在命令行输入ed后程序会等待用户输入，我们用echo和管道向ed发送指令\n\n**eg1:** 在testhosts第一行添加文本（句点表示退出add模式 相当于vim的ESC）\n```shell\n(echo '0a';echo '#hosts for test';echo '.';echo 'wq')|ed testhosts\n```\n**eg2:** 把.com替换为.com.cn\n```shell\n(echo ',s/com/com.cn/';echo '.';echo 'wq')|ed testhosts\n```\n##sed命令\n　sed（stream edit），接受输入流并进行编辑，再把结果写到输出流；\n由于sed是面向流的，在使用时我们要通过管道为sed指定输入流并将输出重定向到修改后的文件: \n`cat file|sed 'command' file > newfile`\n或者使用\"sed -i file\"可以直接编辑并保存到文件 :\n`sed -i 'command' file`\n\n**sed**也是对文件逐行编辑，寻址方式和ed基本相同，但是不支持对匹配的地址进行+n/-n操作。\n\n**eg**: 使用sed将testhosts文件DEV与TEST间的hosts注释掉\n`sed -i '/#DEV/,/#TEST/s/ /#' testhosts`\n\n###二、创建永久环境变量\n    \n　在使用环境变量要注意：\n\n - 当前命令行shell和使用sh或./执行脚本创建的子shell不在同一进程中\n - 普通自定义变量不会在子shell中生效，而全局环境变量可以在子shell中使用\n - 当前命令行定义的环境变量会在退出shell退出后失效\n![举个例子][1]\n\n\n在命令行输入:\n``` \nroot@song-pc:/# echo $$\n30687\nroot@song-pc:/# export global=\"parent global\"\n```\n\n创建脚本child.sh：\n\n```\n#!/bin/bash\necho $$;\necho $global;\nexport global=\"child global\";\n```\n执行脚本，打印global\n```\nroot@song-pc:/# ./child.sh \n30794\nparent global\nroot@song-pc:/# echo $global\nparent global\n```\n$变量表示当前shell的进程id，可见命令行执行的脚本属于另一个进程，而且子进程定义的环境变量在父进程中无效；\n如果要脚本中对环境变量的修改生效,可以使用source命令（.命令）执行脚本，这用方式会在当前进程中执行脚本，但是我们定义的环境变量仍在shell关闭后失效；\n\n**通过文件保存变量：**\nlinux系统下环境配置通常保存在这几个文件中[[b]](#2)：\n- /etc/profile:System wide environment and startup programs, for login setup（所有用户可用）\n- /etc/bashrc ：System wide functions and aliases（每一个运行bash shell的用户执行此文件.当bash shell被打开时,该文件被读取）\n- ~/.bashrc：包含专用于你的bash shell的bash信息,当登录时以及每次打开新的shell时,该文件被读取.（每个用户都有一个.bashrc文件，在用户目录下）\n \n为了保证记录hosts环境的变量不会失效，我选择修改 .bashrc的方式，在修改文件后执行 source命令保存，同时可以避免其他用户修改。\n\n###三.编写脚本\n**switch_hosts.sh:** \n```  \n#!/bin/bash\n#切换本机hosts环境\n#2015-10-15 sxf 2.0 \nfile=\"/etc/hosts\";\ntype=0;\nenv[1]=\"开发\" env[2]=\"测试\"  env[3]=\"线上\";\n\necho \"现在是 ${env[$HOSTS]} 环境\";\nread -p \"选择切换到：1.开发  2.测试  3.线上 : \" type;\n\nif [ $HOSTS -eq $type ];\nthen\n        echo \"环境不变\"\n        return\nfi\ncase $type in\n1)\n        echo \"正切换到开发环境。。\"\n                sed -i '/#DEV/,/#END/s/^ /# /' $file;\n                sed -i '/#DEV/,/#TEST/s/# / /' $file;\n        ;;\n2)\n        echo \"正切换到测试环境\"\n                sed -i '/#DEV/,/#END/s/^ /# /' $file;\n                sed -i '/#TEST/,/#END/s/# / /' $file;\n        ;;\n3)\n        echo \"正切换到线上\"\n                sed -i '/#DEV/,/#END/s/^ /# /' $file;\n        ;;\n*)\n        echo \"输入错误\"\n        return\n        ;;\nesac\nsed -i \"s/HOSTS=$HOSTS/HOSTS=$type/\" .bashrc;\nsource .bashrc;\ncat $file;\nservice nscd restart;\n```\n为了使source .bashrc命令生效，要使用source switch_hosts.sh的方式执行，service nscd restart命令用来刷新DNS缓存；\n\n\n[a] <span id = \"1\">http://biancheng.dnbcw.info/shell/242647.html</span>\n[b] <span id = \"2\">http://blog.csdn.net/chenchong08/article/details/7833242</span>\n\n  [1]: /images/example.jpg\n","source":"_posts/shell-in-action-1.md","raw":"title: Shell in Action（一）文本编辑-修改hosts\ndate: 2015-12-01 00:32:36\ncategories: \ntags: [shell,Linux]\n---\n\n　把自己工作环境换成linux之后总会遇到各种无语的问题，比如我在web开发时会经常要切换测试环境或者本地环境的hosts，但是在用firefox的hosts插件时发现每次修改都会卡死，最后忍无可忍打算写一个切换hosts环境的脚本，有问题欢迎指正~\n\n\n\n##问题分析\n　我们都知道hosts文件就长这样，#是注释符、ip和域名用空格分开\n下面是测试文件testhosts，用DEV和TEST区分不同环境：\n\n```\n#DEV\n74.125.207.84 accounts.a.com\n74.125.207.83 accounts.b.com\n#TEST\n64.233.168.106 www.c.com\n64.233.168.107 www.d.com\n#END\n```\n**解决步骤**\n\n\n　　1.读取用户要切换的环境\n　　2.读取hosts文件，在指定的行前添加注释\n　　3.维护一个值 保存hosts所处环境 提示用户当前hosts环境\n<!--more-->\n###一、修改host文件\n\n##ed命令\n　ed （edit）命令 可以逐行的修改文本，[[a]](#1)分为‘寻址’‘操作命令’‘文件名’三个部分\n　ed [address]command textfile\n在命令行 输入 `info ed` 查看ed完整说明 \n**寻址**\n\n| 选项        | 说明           |\n|:------------- |:-------------| \n| number      | 第number行，从0开始 | \n|+number      | 从本行后第number行开始 | \n| -number      | 从本行前第number行开始 | \n|   ，    | 1,3表示从1到3行 一个逗号表示全文 | \n| /pattern/|下一个包含/partten/的行|\n| \\$partten\\$|上一个包含partten的行|\n\n**命令部分**\n\n| 选项        | 说明           |\n|:------------- |:-------------| \n| a  | add 追加文本 | \n|c | change| \n| d   | 删除当前指向的行 | \n| i   |insert | \n| wq   |和vim一样 write&quit | \n| s/pattern/replace/  |将符合pattern的替换为replace文本 | \ned操作文本时会将文件拷贝到缓冲区，在编辑后写入文件，在命令行输入ed后程序会等待用户输入，我们用echo和管道向ed发送指令\n\n**eg1:** 在testhosts第一行添加文本（句点表示退出add模式 相当于vim的ESC）\n```shell\n(echo '0a';echo '#hosts for test';echo '.';echo 'wq')|ed testhosts\n```\n**eg2:** 把.com替换为.com.cn\n```shell\n(echo ',s/com/com.cn/';echo '.';echo 'wq')|ed testhosts\n```\n##sed命令\n　sed（stream edit），接受输入流并进行编辑，再把结果写到输出流；\n由于sed是面向流的，在使用时我们要通过管道为sed指定输入流并将输出重定向到修改后的文件: \n`cat file|sed 'command' file > newfile`\n或者使用\"sed -i file\"可以直接编辑并保存到文件 :\n`sed -i 'command' file`\n\n**sed**也是对文件逐行编辑，寻址方式和ed基本相同，但是不支持对匹配的地址进行+n/-n操作。\n\n**eg**: 使用sed将testhosts文件DEV与TEST间的hosts注释掉\n`sed -i '/#DEV/,/#TEST/s/ /#' testhosts`\n\n###二、创建永久环境变量\n    \n　在使用环境变量要注意：\n\n - 当前命令行shell和使用sh或./执行脚本创建的子shell不在同一进程中\n - 普通自定义变量不会在子shell中生效，而全局环境变量可以在子shell中使用\n - 当前命令行定义的环境变量会在退出shell退出后失效\n![举个例子][1]\n\n\n在命令行输入:\n``` \nroot@song-pc:/# echo $$\n30687\nroot@song-pc:/# export global=\"parent global\"\n```\n\n创建脚本child.sh：\n\n```\n#!/bin/bash\necho $$;\necho $global;\nexport global=\"child global\";\n```\n执行脚本，打印global\n```\nroot@song-pc:/# ./child.sh \n30794\nparent global\nroot@song-pc:/# echo $global\nparent global\n```\n$变量表示当前shell的进程id，可见命令行执行的脚本属于另一个进程，而且子进程定义的环境变量在父进程中无效；\n如果要脚本中对环境变量的修改生效,可以使用source命令（.命令）执行脚本，这用方式会在当前进程中执行脚本，但是我们定义的环境变量仍在shell关闭后失效；\n\n**通过文件保存变量：**\nlinux系统下环境配置通常保存在这几个文件中[[b]](#2)：\n- /etc/profile:System wide environment and startup programs, for login setup（所有用户可用）\n- /etc/bashrc ：System wide functions and aliases（每一个运行bash shell的用户执行此文件.当bash shell被打开时,该文件被读取）\n- ~/.bashrc：包含专用于你的bash shell的bash信息,当登录时以及每次打开新的shell时,该文件被读取.（每个用户都有一个.bashrc文件，在用户目录下）\n \n为了保证记录hosts环境的变量不会失效，我选择修改 .bashrc的方式，在修改文件后执行 source命令保存，同时可以避免其他用户修改。\n\n###三.编写脚本\n**switch_hosts.sh:** \n```  \n#!/bin/bash\n#切换本机hosts环境\n#2015-10-15 sxf 2.0 \nfile=\"/etc/hosts\";\ntype=0;\nenv[1]=\"开发\" env[2]=\"测试\"  env[3]=\"线上\";\n\necho \"现在是 ${env[$HOSTS]} 环境\";\nread -p \"选择切换到：1.开发  2.测试  3.线上 : \" type;\n\nif [ $HOSTS -eq $type ];\nthen\n        echo \"环境不变\"\n        return\nfi\ncase $type in\n1)\n        echo \"正切换到开发环境。。\"\n                sed -i '/#DEV/,/#END/s/^ /# /' $file;\n                sed -i '/#DEV/,/#TEST/s/# / /' $file;\n        ;;\n2)\n        echo \"正切换到测试环境\"\n                sed -i '/#DEV/,/#END/s/^ /# /' $file;\n                sed -i '/#TEST/,/#END/s/# / /' $file;\n        ;;\n3)\n        echo \"正切换到线上\"\n                sed -i '/#DEV/,/#END/s/^ /# /' $file;\n        ;;\n*)\n        echo \"输入错误\"\n        return\n        ;;\nesac\nsed -i \"s/HOSTS=$HOSTS/HOSTS=$type/\" .bashrc;\nsource .bashrc;\ncat $file;\nservice nscd restart;\n```\n为了使source .bashrc命令生效，要使用source switch_hosts.sh的方式执行，service nscd restart命令用来刷新DNS缓存；\n\n\n[a] <span id = \"1\">http://biancheng.dnbcw.info/shell/242647.html</span>\n[b] <span id = \"2\">http://blog.csdn.net/chenchong08/article/details/7833242</span>\n\n  [1]: /images/example.jpg\n","slug":"shell-in-action-1","published":1,"updated":"2019-05-04T15:54:10.577Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkqle174000icynemedir66r","content":"<p>　把自己工作环境换成linux之后总会遇到各种无语的问题，比如我在web开发时会经常要切换测试环境或者本地环境的hosts，但是在用firefox的hosts插件时发现每次修改都会卡死，最后忍无可忍打算写一个切换hosts环境的脚本，有问题欢迎指正~</p>\n<p>##问题分析<br>　我们都知道hosts文件就长这样，#是注释符、ip和域名用空格分开<br>下面是测试文件testhosts，用DEV和TEST区分不同环境：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#DEV</span><br><span class=\"line\">74.125.207.84 accounts.a.com</span><br><span class=\"line\">74.125.207.83 accounts.b.com</span><br><span class=\"line\">#TEST</span><br><span class=\"line\">64.233.168.106 www.c.com</span><br><span class=\"line\">64.233.168.107 www.d.com</span><br><span class=\"line\">#END</span><br></pre></td></tr></table></figure>\n<p><strong>解决步骤</strong></p>\n<p>　　1.读取用户要切换的环境<br>　　2.读取hosts文件，在指定的行前添加注释<br>　　3.维护一个值 保存hosts所处环境 提示用户当前hosts环境<br><a id=\"more\"></a></p>\n<p>###一、修改host文件</p>\n<p>##ed命令<br>　ed （edit）命令 可以逐行的修改文本，<a href=\"#1\">[a]</a>分为‘寻址’‘操作命令’‘文件名’三个部分<br>　ed [address]command textfile<br>在命令行 输入 <code>info ed</code> 查看ed完整说明<br><strong>寻址</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">选项</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">number</td>\n<td style=\"text-align:left\">第number行，从0开始</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">+number</td>\n<td style=\"text-align:left\">从本行后第number行开始</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">-number</td>\n<td style=\"text-align:left\">从本行前第number行开始</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">，</td>\n<td style=\"text-align:left\">1,3表示从1到3行 一个逗号表示全文</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">/pattern/</td>\n<td style=\"text-align:left\">下一个包含/partten/的行</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">\\$partten\\$</td>\n<td style=\"text-align:left\">上一个包含partten的行</td>\n</tr>\n</tbody>\n</table>\n<p><strong>命令部分</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">选项</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">a</td>\n<td style=\"text-align:left\">add 追加文本</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">c</td>\n<td style=\"text-align:left\">change</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">d</td>\n<td style=\"text-align:left\">删除当前指向的行</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">i</td>\n<td style=\"text-align:left\">insert</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">wq</td>\n<td style=\"text-align:left\">和vim一样 write&amp;quit</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">s/pattern/replace/</td>\n<td style=\"text-align:left\">将符合pattern的替换为replace文本</td>\n</tr>\n</tbody>\n</table>\n<p>ed操作文本时会将文件拷贝到缓冲区，在编辑后写入文件，在命令行输入ed后程序会等待用户输入，我们用echo和管道向ed发送指令</p>\n<p><strong>eg1:</strong> 在testhosts第一行添加文本（句点表示退出add模式 相当于vim的ESC）<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(echo '0a';echo '#hosts for test';echo '.';echo 'wq')|ed testhosts</span><br></pre></td></tr></table></figure></p>\n<p><strong>eg2:</strong> 把.com替换为.com.cn<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(echo ',s/com/com.cn/';echo '.';echo 'wq')|ed testhosts</span><br></pre></td></tr></table></figure></p>\n<p>##sed命令<br>　sed（stream edit），接受输入流并进行编辑，再把结果写到输出流；<br>由于sed是面向流的，在使用时我们要通过管道为sed指定输入流并将输出重定向到修改后的文件:<br><code>cat file|sed &#39;command&#39; file &gt; newfile</code><br>或者使用”sed -i file”可以直接编辑并保存到文件 :<br><code>sed -i &#39;command&#39; file</code></p>\n<p><strong>sed</strong>也是对文件逐行编辑，寻址方式和ed基本相同，但是不支持对匹配的地址进行+n/-n操作。</p>\n<p><strong>eg</strong>: 使用sed将testhosts文件DEV与TEST间的hosts注释掉<br><code>sed -i &#39;/#DEV/,/#TEST/s/ /#&#39; testhosts</code></p>\n<p>###二、创建永久环境变量</p>\n<p>　在使用环境变量要注意：</p>\n<ul>\n<li>当前命令行shell和使用sh或./执行脚本创建的子shell不在同一进程中</li>\n<li>普通自定义变量不会在子shell中生效，而全局环境变量可以在子shell中使用</li>\n<li>当前命令行定义的环境变量会在退出shell退出后失效<br><img src=\"/images/example.jpg\" alt=\"举个例子\"></li>\n</ul>\n<p>在命令行输入:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@song-pc:/# echo $$</span><br><span class=\"line\">30687</span><br><span class=\"line\">root@song-pc:/# export global=&quot;parent global&quot;</span><br></pre></td></tr></table></figure></p>\n<p>创建脚本child.sh：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/bash</span><br><span class=\"line\">echo $$;</span><br><span class=\"line\">echo $global;</span><br><span class=\"line\">export global=&quot;child global&quot;;</span><br></pre></td></tr></table></figure>\n<p>执行脚本，打印global<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@song-pc:/# ./child.sh </span><br><span class=\"line\">30794</span><br><span class=\"line\">parent global</span><br><span class=\"line\">root@song-pc:/# echo $global</span><br><span class=\"line\">parent global</span><br></pre></td></tr></table></figure></p>\n<p>$变量表示当前shell的进程id，可见命令行执行的脚本属于另一个进程，而且子进程定义的环境变量在父进程中无效；<br>如果要脚本中对环境变量的修改生效,可以使用source命令（.命令）执行脚本，这用方式会在当前进程中执行脚本，但是我们定义的环境变量仍在shell关闭后失效；</p>\n<p><strong>通过文件保存变量：</strong><br>linux系统下环境配置通常保存在这几个文件中<a href=\"#2\">[b]</a>：</p>\n<ul>\n<li>/etc/profile:System wide environment and startup programs, for login setup（所有用户可用）</li>\n<li>/etc/bashrc ：System wide functions and aliases（每一个运行bash shell的用户执行此文件.当bash shell被打开时,该文件被读取）</li>\n<li>~/.bashrc：包含专用于你的bash shell的bash信息,当登录时以及每次打开新的shell时,该文件被读取.（每个用户都有一个.bashrc文件，在用户目录下）</li>\n</ul>\n<p>为了保证记录hosts环境的变量不会失效，我选择修改 .bashrc的方式，在修改文件后执行 source命令保存，同时可以避免其他用户修改。</p>\n<p>###三.编写脚本<br><strong>switch_hosts.sh:</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/bash</span><br><span class=\"line\">#切换本机hosts环境</span><br><span class=\"line\">#2015-10-15 sxf 2.0 </span><br><span class=\"line\">file=&quot;/etc/hosts&quot;;</span><br><span class=\"line\">type=0;</span><br><span class=\"line\">env[1]=&quot;开发&quot; env[2]=&quot;测试&quot;  env[3]=&quot;线上&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">echo &quot;现在是 $&#123;env[$HOSTS]&#125; 环境&quot;;</span><br><span class=\"line\">read -p &quot;选择切换到：1.开发  2.测试  3.线上 : &quot; type;</span><br><span class=\"line\"></span><br><span class=\"line\">if [ $HOSTS -eq $type ];</span><br><span class=\"line\">then</span><br><span class=\"line\">        echo &quot;环境不变&quot;</span><br><span class=\"line\">        return</span><br><span class=\"line\">fi</span><br><span class=\"line\">case $type in</span><br><span class=\"line\">1)</span><br><span class=\"line\">        echo &quot;正切换到开发环境。。&quot;</span><br><span class=\"line\">                sed -i &apos;/#DEV/,/#END/s/^ /# /&apos; $file;</span><br><span class=\"line\">                sed -i &apos;/#DEV/,/#TEST/s/# / /&apos; $file;</span><br><span class=\"line\">        ;;</span><br><span class=\"line\">2)</span><br><span class=\"line\">        echo &quot;正切换到测试环境&quot;</span><br><span class=\"line\">                sed -i &apos;/#DEV/,/#END/s/^ /# /&apos; $file;</span><br><span class=\"line\">                sed -i &apos;/#TEST/,/#END/s/# / /&apos; $file;</span><br><span class=\"line\">        ;;</span><br><span class=\"line\">3)</span><br><span class=\"line\">        echo &quot;正切换到线上&quot;</span><br><span class=\"line\">                sed -i &apos;/#DEV/,/#END/s/^ /# /&apos; $file;</span><br><span class=\"line\">        ;;</span><br><span class=\"line\">*)</span><br><span class=\"line\">        echo &quot;输入错误&quot;</span><br><span class=\"line\">        return</span><br><span class=\"line\">        ;;</span><br><span class=\"line\">esac</span><br><span class=\"line\">sed -i &quot;s/HOSTS=$HOSTS/HOSTS=$type/&quot; .bashrc;</span><br><span class=\"line\">source .bashrc;</span><br><span class=\"line\">cat $file;</span><br><span class=\"line\">service nscd restart;</span><br></pre></td></tr></table></figure></p>\n<p>为了使source .bashrc命令生效，要使用source switch_hosts.sh的方式执行，service nscd restart命令用来刷新DNS缓存；</p>\n<p>[a] <span id=\"1\"><a href=\"http://biancheng.dnbcw.info/shell/242647.html\" target=\"_blank\" rel=\"noopener\">http://biancheng.dnbcw.info/shell/242647.html</a></span><br>[b] <span id=\"2\"><a href=\"http://blog.csdn.net/chenchong08/article/details/7833242\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/chenchong08/article/details/7833242</a></span></p>\n","site":{"data":{}},"excerpt":"<p>　把自己工作环境换成linux之后总会遇到各种无语的问题，比如我在web开发时会经常要切换测试环境或者本地环境的hosts，但是在用firefox的hosts插件时发现每次修改都会卡死，最后忍无可忍打算写一个切换hosts环境的脚本，有问题欢迎指正~</p>\n<p>##问题分析<br>　我们都知道hosts文件就长这样，#是注释符、ip和域名用空格分开<br>下面是测试文件testhosts，用DEV和TEST区分不同环境：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#DEV</span><br><span class=\"line\">74.125.207.84 accounts.a.com</span><br><span class=\"line\">74.125.207.83 accounts.b.com</span><br><span class=\"line\">#TEST</span><br><span class=\"line\">64.233.168.106 www.c.com</span><br><span class=\"line\">64.233.168.107 www.d.com</span><br><span class=\"line\">#END</span><br></pre></td></tr></table></figure>\n<p><strong>解决步骤</strong></p>\n<p>　　1.读取用户要切换的环境<br>　　2.读取hosts文件，在指定的行前添加注释<br>　　3.维护一个值 保存hosts所处环境 提示用户当前hosts环境<br>","more":"</p>\n<p>###一、修改host文件</p>\n<p>##ed命令<br>　ed （edit）命令 可以逐行的修改文本，<a href=\"#1\">[a]</a>分为‘寻址’‘操作命令’‘文件名’三个部分<br>　ed [address]command textfile<br>在命令行 输入 <code>info ed</code> 查看ed完整说明<br><strong>寻址</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">选项</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">number</td>\n<td style=\"text-align:left\">第number行，从0开始</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">+number</td>\n<td style=\"text-align:left\">从本行后第number行开始</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">-number</td>\n<td style=\"text-align:left\">从本行前第number行开始</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">，</td>\n<td style=\"text-align:left\">1,3表示从1到3行 一个逗号表示全文</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">/pattern/</td>\n<td style=\"text-align:left\">下一个包含/partten/的行</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">\\$partten\\$</td>\n<td style=\"text-align:left\">上一个包含partten的行</td>\n</tr>\n</tbody>\n</table>\n<p><strong>命令部分</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">选项</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">a</td>\n<td style=\"text-align:left\">add 追加文本</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">c</td>\n<td style=\"text-align:left\">change</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">d</td>\n<td style=\"text-align:left\">删除当前指向的行</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">i</td>\n<td style=\"text-align:left\">insert</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">wq</td>\n<td style=\"text-align:left\">和vim一样 write&amp;quit</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">s/pattern/replace/</td>\n<td style=\"text-align:left\">将符合pattern的替换为replace文本</td>\n</tr>\n</tbody>\n</table>\n<p>ed操作文本时会将文件拷贝到缓冲区，在编辑后写入文件，在命令行输入ed后程序会等待用户输入，我们用echo和管道向ed发送指令</p>\n<p><strong>eg1:</strong> 在testhosts第一行添加文本（句点表示退出add模式 相当于vim的ESC）<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(echo '0a';echo '#hosts for test';echo '.';echo 'wq')|ed testhosts</span><br></pre></td></tr></table></figure></p>\n<p><strong>eg2:</strong> 把.com替换为.com.cn<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(echo ',s/com/com.cn/';echo '.';echo 'wq')|ed testhosts</span><br></pre></td></tr></table></figure></p>\n<p>##sed命令<br>　sed（stream edit），接受输入流并进行编辑，再把结果写到输出流；<br>由于sed是面向流的，在使用时我们要通过管道为sed指定输入流并将输出重定向到修改后的文件:<br><code>cat file|sed &#39;command&#39; file &gt; newfile</code><br>或者使用”sed -i file”可以直接编辑并保存到文件 :<br><code>sed -i &#39;command&#39; file</code></p>\n<p><strong>sed</strong>也是对文件逐行编辑，寻址方式和ed基本相同，但是不支持对匹配的地址进行+n/-n操作。</p>\n<p><strong>eg</strong>: 使用sed将testhosts文件DEV与TEST间的hosts注释掉<br><code>sed -i &#39;/#DEV/,/#TEST/s/ /#&#39; testhosts</code></p>\n<p>###二、创建永久环境变量</p>\n<p>　在使用环境变量要注意：</p>\n<ul>\n<li>当前命令行shell和使用sh或./执行脚本创建的子shell不在同一进程中</li>\n<li>普通自定义变量不会在子shell中生效，而全局环境变量可以在子shell中使用</li>\n<li>当前命令行定义的环境变量会在退出shell退出后失效<br><img src=\"/images/example.jpg\" alt=\"举个例子\"></li>\n</ul>\n<p>在命令行输入:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@song-pc:/# echo $$</span><br><span class=\"line\">30687</span><br><span class=\"line\">root@song-pc:/# export global=&quot;parent global&quot;</span><br></pre></td></tr></table></figure></p>\n<p>创建脚本child.sh：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/bash</span><br><span class=\"line\">echo $$;</span><br><span class=\"line\">echo $global;</span><br><span class=\"line\">export global=&quot;child global&quot;;</span><br></pre></td></tr></table></figure>\n<p>执行脚本，打印global<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@song-pc:/# ./child.sh </span><br><span class=\"line\">30794</span><br><span class=\"line\">parent global</span><br><span class=\"line\">root@song-pc:/# echo $global</span><br><span class=\"line\">parent global</span><br></pre></td></tr></table></figure></p>\n<p>$变量表示当前shell的进程id，可见命令行执行的脚本属于另一个进程，而且子进程定义的环境变量在父进程中无效；<br>如果要脚本中对环境变量的修改生效,可以使用source命令（.命令）执行脚本，这用方式会在当前进程中执行脚本，但是我们定义的环境变量仍在shell关闭后失效；</p>\n<p><strong>通过文件保存变量：</strong><br>linux系统下环境配置通常保存在这几个文件中<a href=\"#2\">[b]</a>：</p>\n<ul>\n<li>/etc/profile:System wide environment and startup programs, for login setup（所有用户可用）</li>\n<li>/etc/bashrc ：System wide functions and aliases（每一个运行bash shell的用户执行此文件.当bash shell被打开时,该文件被读取）</li>\n<li>~/.bashrc：包含专用于你的bash shell的bash信息,当登录时以及每次打开新的shell时,该文件被读取.（每个用户都有一个.bashrc文件，在用户目录下）</li>\n</ul>\n<p>为了保证记录hosts环境的变量不会失效，我选择修改 .bashrc的方式，在修改文件后执行 source命令保存，同时可以避免其他用户修改。</p>\n<p>###三.编写脚本<br><strong>switch_hosts.sh:</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/bash</span><br><span class=\"line\">#切换本机hosts环境</span><br><span class=\"line\">#2015-10-15 sxf 2.0 </span><br><span class=\"line\">file=&quot;/etc/hosts&quot;;</span><br><span class=\"line\">type=0;</span><br><span class=\"line\">env[1]=&quot;开发&quot; env[2]=&quot;测试&quot;  env[3]=&quot;线上&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">echo &quot;现在是 $&#123;env[$HOSTS]&#125; 环境&quot;;</span><br><span class=\"line\">read -p &quot;选择切换到：1.开发  2.测试  3.线上 : &quot; type;</span><br><span class=\"line\"></span><br><span class=\"line\">if [ $HOSTS -eq $type ];</span><br><span class=\"line\">then</span><br><span class=\"line\">        echo &quot;环境不变&quot;</span><br><span class=\"line\">        return</span><br><span class=\"line\">fi</span><br><span class=\"line\">case $type in</span><br><span class=\"line\">1)</span><br><span class=\"line\">        echo &quot;正切换到开发环境。。&quot;</span><br><span class=\"line\">                sed -i &apos;/#DEV/,/#END/s/^ /# /&apos; $file;</span><br><span class=\"line\">                sed -i &apos;/#DEV/,/#TEST/s/# / /&apos; $file;</span><br><span class=\"line\">        ;;</span><br><span class=\"line\">2)</span><br><span class=\"line\">        echo &quot;正切换到测试环境&quot;</span><br><span class=\"line\">                sed -i &apos;/#DEV/,/#END/s/^ /# /&apos; $file;</span><br><span class=\"line\">                sed -i &apos;/#TEST/,/#END/s/# / /&apos; $file;</span><br><span class=\"line\">        ;;</span><br><span class=\"line\">3)</span><br><span class=\"line\">        echo &quot;正切换到线上&quot;</span><br><span class=\"line\">                sed -i &apos;/#DEV/,/#END/s/^ /# /&apos; $file;</span><br><span class=\"line\">        ;;</span><br><span class=\"line\">*)</span><br><span class=\"line\">        echo &quot;输入错误&quot;</span><br><span class=\"line\">        return</span><br><span class=\"line\">        ;;</span><br><span class=\"line\">esac</span><br><span class=\"line\">sed -i &quot;s/HOSTS=$HOSTS/HOSTS=$type/&quot; .bashrc;</span><br><span class=\"line\">source .bashrc;</span><br><span class=\"line\">cat $file;</span><br><span class=\"line\">service nscd restart;</span><br></pre></td></tr></table></figure></p>\n<p>为了使source .bashrc命令生效，要使用source switch_hosts.sh的方式执行，service nscd restart命令用来刷新DNS缓存；</p>\n<p>[a] <span id=\"1\"><a href=\"http://biancheng.dnbcw.info/shell/242647.html\" target=\"_blank\" rel=\"noopener\">http://biancheng.dnbcw.info/shell/242647.html</a></span><br>[b] <span id=\"2\"><a href=\"http://blog.csdn.net/chenchong08/article/details/7833242\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/chenchong08/article/details/7833242</a></span></p>"},{"title":"thrift源码（一）源码结构和客户端介绍","date":"2019-05-22T15:55:19.000Z","_content":"\n## thrift架构图\n\n\n![整体视图][1]\n\n如图所示，作为一个通信框架，thrift架构上也分了不同的层，和tcp/ip的分层逻辑类似，最上层是我们的业务逻辑层，这里是我们编写的HelloService接口的实现类。\n\n<!--more-->\n\n第二层是thrift生成的HelloService.Client(或者AsyncClient)和HelloService.Processor类，分别给客户端和服务端使用，对开发者屏蔽了如何发送/处理请求，返回结果，异常检查等通信细节。\n\n第三层是thrift生成的数据序列化和反序列化的write/read方法，read()负责根据协议从字节流中解析调用的函数名，参数等，比如方法HelloService.helloString_args#read,write()则相反。\n\n第四层及以下是thrift框架的源码，TProtocol定义了数据传输协议，thrift提供了binary/json等多种编码实现。\n第五层是thrift对i/o层的封装，TTransport包含网络连接的打开关闭，输入输出流的处理等等。\n## 类图\n\n{% asset_img overview.png image %}\n\n**我使用的0.5.0版本的thrift**\n\n深色的是thrift生成的HelloService和他的内部类，Client和AsyncClient是客户端使用，Processor是服务端使用。\n\nProcessor实现TProcessor接口，Client实现TServiceClient接口\n\nTTransport被TProcessFactory，TProtocolFactory,TProtocol依赖\n\nTProtocal由TTransport组成，几乎被图中所有类依赖。\n\n\n## 客户端流程\n\n![客户端时序图][2]\n\n### 同步客户端\n发起调用的代码：\n```java\nTTransport transport=new TSocket(\"localhost\",7911);\n                transport.open();\nTProtocol protocol=new TBinaryProtocol(transport);\nHelloService.Client client=new HelloService.Client(protocol);\nclient.helloVoid();\ntransport.close();\n```\n#### 1.创建socket连接(TTransport)，选择协议(TProtocol)\n\nTSocket是TIOStreamTransport的子类，TIOStreamTransport封装了输入、输出流的处理，TScocket封装了一个Socket对象。\nTBinaryProtocol是TProtocol的子类，定义了基于二进制的通信协议\n\n#### 2.初始化Client,调用helloVoid函数\n\nhelloVoid内部执行发送请求和接收响应两步操作：\n```java\n public void helloVoid() throws TException\n    {\n      send_helloVoid();\n      recv_helloVoid();\n    }\n```\n#### 3.序列化请求并发送\n\n客户端发送请求时必然要告知服务端本次请求的方法名，参数，还有调用序号，版本号等信息，这些都要通过TProtocol序列化，协议相关细节后面介绍。\n序列化完成后，TBinaryProtocol把这些内容通过TTransport写入到输出流，通过网络发送到服务端。\n```java\n        protected TProtocol iprot_;\n        protected TProtocol oprot_;\n        protected int seqid_;\n\npublic void send_helloVoid() throws TException\n    {\n      //构造协议消息体\n      oprot_.writeMessageBegin(new TMessage(\"helloVoid\", TMessageType.CALL, ++seqid_));\n      helloVoid_args args = new helloVoid_args();\n      //把参数按协议序列化\n      args.write(oprot_);\n      oprot_.writeMessageEnd();\n      //发送数据\n      oprot_.getTransport().flush();\n    }\n```\nhelloVoid_args虽然这样命名但他是一个静态内部类，HelloSerive的每个函数都会生成这样的类。生成的代码，根据thrift文件中定义的函数参数，告诉thrift程序如何进行序列化操作(比如从TProtocol中读取TField，字节流的哪个位置起对应哪个参数，参数对应多少字节等)。\nhelloVoid_args的函数write()代码如下：\n```java\npublic static class helloVoid_args implements TBase<helloVoid_args, helloVoid_args._Fields>, java.io.Serializable, Cloneable   {\n    public void write(TProtocol oprot) throws TException {\n      //对声明为required的字段检查，required字段不能为null\n      validate();\n\n      oprot.writeStructBegin(STRUCT_DESC);\n      oprot.writeFieldStop();\n      oprot.writeStructEnd();\n    }\n    }\n```\n#### 接收响应并反序列化结果\n\n当服务端返回数据后，`recv_helloVoid`函数处理服务端返回的数据，反序列化得到`helloVoid_result`，并对异常做处理。**注意对seqid的检查**，thrift在这里处理服务端响应乱序的情况(后接收的先返回)，处理方式是直接抛出异常。\n```java\npublic void recv_helloVoid() throws TException\n    {\n      TMessage msg = iprot_.readMessageBegin();\n      if (msg.type == TMessageType.EXCEPTION) {\n        TApplicationException x = TApplicationException.read(iprot_);\n        iprot_.readMessageEnd();\n        throw x;\n      }\n      if (msg.seqid != seqid_) {\n        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, \"helloVoid failed: out of sequence response\");\n      }\n      helloVoid_result result = new helloVoid_result();\n      result.read(iprot_);\n      iprot_.readMessageEnd();\n      return;\n    }\n```\n`helloVoid_result`和`helloVoid_args`类似，他定义了方法返回值的序列化操作方式,read方法代码如下：\n```java\n  public static class helloVoid_result implements TBase<helloVoid_result, helloVoid_result._Fields>, java.io.Serializable, Cloneable   {\n\n public void read(TProtocol iprot) throws TException {\n      TField field;\n      //找到字节流中类起始位置\n      iprot.readStructBegin();\n      //循环解析TField，直到遇到TType.STOP\n      while (true)\n      {\n        //找到field起点\n        field = iprot.readFieldBegin();\n        if (field.type == TType.STOP) { \n          break;\n        }\n        //根据id找到field具体对应的那个属性，因为helloVoid返回值为空，直接跳过\n        switch (field.id) {\n          default:\n            TProtocolUtil.skip(iprot, field.type);\n        }\n        iprot.readFieldEnd();\n      }\n      iprot.readStructEnd();\n      //检查require字段\n      // check for required fields of primitive type, which can't be checked in the validate method\n      validate();\n    }\n    }\n```\n\n## 参考\nhttp://www.cnblogs.com/luxiaoxun/archive/2015/03/11/4331110.html\nhttps://my.oschina.net/xinxingegeya/blog/620576\nhttps://www.ibm.com/developerworks/cn/java/j-lo-apachethrift/index.html\n\n\n  [1]: https://www.ibm.com/developerworks/cn/java/j-lo-apachethrift/image003.jpg\n  [2]: https://www.ibm.com/developerworks/cn/java/j-lo-apachethrift/image006.png\n  [3]: https://www.ibm.com/developerworks/cn/java/j-lo-apachethrift/image004.png\n  [4]: http://upload-images.jianshu.io/upload_images/1452123-35a5505c0d9928f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\n  [5]: http://upload-images.jianshu.io/upload_images/1452123-bfb7ef28b21ba29e?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\n  [6]: https://upload-images.jianshu.io/upload_images/3169646-6eddb6e230677349.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/692\n  [7]: http://zhangtielei.com/posts/blog-rxjava-backpressure.html\n  [8]: https://baike.baidu.com/item/%E8%83%8C%E5%8E%8B%E9%98%80\n  [9]: https://github.com/apache/thrift/blob/0.8.x/lib/java/src/org/apache/thrift/server/TThreadedSelectorServer.java\n  [10]: https://upload-images.jianshu.io/upload_images/3169646-eedd2295dcc12725.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/688\n  [11]: https://static.oschina.net/uploads/space/2016/0224/192255_iHyl_1469576.png\n  [12]: https://static.oschina.net/uploads/space/2016/0224/192347_Vfen_1469576.png\n  [13]: https://static.oschina.net/uploads/space/2016/0224/192513_tzOg_1469576.png\n  [14]: https://static.oschina.net/uploads/space/2016/0224/192544_xSFh_1469576.png\n  [15]: https://static.oschina.net/uploads/space/2016/0224/192757_XK9n_1469576.png\n  [16]: https://static.oschina.net/uploads/space/2016/0224/192757_toBx_1469576.png\n  [17]: https://upload.wikimedia.org/wikipedia/commons/thumb/5/54/Big-Endian.svg/200px-Big-Endian.svg.png\n  [18]: https://upload.wikimedia.org/wikipedia/commons/thumb/e/ed/Little-Endian.svg/200px-Little-Endian.svg.png\n  [19]: https://jin-yang.github.io/post/network-tcpip-timewait.html","source":"_posts/thrift源码-客户端.md","raw":"title: thrift源码（一）源码结构和客户端介绍\ndate: 2019-05-22 23:55:19\ncategories: thrift源码\ntags: [thrift,rpc框架]\n\n---\n\n## thrift架构图\n\n\n![整体视图][1]\n\n如图所示，作为一个通信框架，thrift架构上也分了不同的层，和tcp/ip的分层逻辑类似，最上层是我们的业务逻辑层，这里是我们编写的HelloService接口的实现类。\n\n<!--more-->\n\n第二层是thrift生成的HelloService.Client(或者AsyncClient)和HelloService.Processor类，分别给客户端和服务端使用，对开发者屏蔽了如何发送/处理请求，返回结果，异常检查等通信细节。\n\n第三层是thrift生成的数据序列化和反序列化的write/read方法，read()负责根据协议从字节流中解析调用的函数名，参数等，比如方法HelloService.helloString_args#read,write()则相反。\n\n第四层及以下是thrift框架的源码，TProtocol定义了数据传输协议，thrift提供了binary/json等多种编码实现。\n第五层是thrift对i/o层的封装，TTransport包含网络连接的打开关闭，输入输出流的处理等等。\n## 类图\n\n{% asset_img overview.png image %}\n\n**我使用的0.5.0版本的thrift**\n\n深色的是thrift生成的HelloService和他的内部类，Client和AsyncClient是客户端使用，Processor是服务端使用。\n\nProcessor实现TProcessor接口，Client实现TServiceClient接口\n\nTTransport被TProcessFactory，TProtocolFactory,TProtocol依赖\n\nTProtocal由TTransport组成，几乎被图中所有类依赖。\n\n\n## 客户端流程\n\n![客户端时序图][2]\n\n### 同步客户端\n发起调用的代码：\n```java\nTTransport transport=new TSocket(\"localhost\",7911);\n                transport.open();\nTProtocol protocol=new TBinaryProtocol(transport);\nHelloService.Client client=new HelloService.Client(protocol);\nclient.helloVoid();\ntransport.close();\n```\n#### 1.创建socket连接(TTransport)，选择协议(TProtocol)\n\nTSocket是TIOStreamTransport的子类，TIOStreamTransport封装了输入、输出流的处理，TScocket封装了一个Socket对象。\nTBinaryProtocol是TProtocol的子类，定义了基于二进制的通信协议\n\n#### 2.初始化Client,调用helloVoid函数\n\nhelloVoid内部执行发送请求和接收响应两步操作：\n```java\n public void helloVoid() throws TException\n    {\n      send_helloVoid();\n      recv_helloVoid();\n    }\n```\n#### 3.序列化请求并发送\n\n客户端发送请求时必然要告知服务端本次请求的方法名，参数，还有调用序号，版本号等信息，这些都要通过TProtocol序列化，协议相关细节后面介绍。\n序列化完成后，TBinaryProtocol把这些内容通过TTransport写入到输出流，通过网络发送到服务端。\n```java\n        protected TProtocol iprot_;\n        protected TProtocol oprot_;\n        protected int seqid_;\n\npublic void send_helloVoid() throws TException\n    {\n      //构造协议消息体\n      oprot_.writeMessageBegin(new TMessage(\"helloVoid\", TMessageType.CALL, ++seqid_));\n      helloVoid_args args = new helloVoid_args();\n      //把参数按协议序列化\n      args.write(oprot_);\n      oprot_.writeMessageEnd();\n      //发送数据\n      oprot_.getTransport().flush();\n    }\n```\nhelloVoid_args虽然这样命名但他是一个静态内部类，HelloSerive的每个函数都会生成这样的类。生成的代码，根据thrift文件中定义的函数参数，告诉thrift程序如何进行序列化操作(比如从TProtocol中读取TField，字节流的哪个位置起对应哪个参数，参数对应多少字节等)。\nhelloVoid_args的函数write()代码如下：\n```java\npublic static class helloVoid_args implements TBase<helloVoid_args, helloVoid_args._Fields>, java.io.Serializable, Cloneable   {\n    public void write(TProtocol oprot) throws TException {\n      //对声明为required的字段检查，required字段不能为null\n      validate();\n\n      oprot.writeStructBegin(STRUCT_DESC);\n      oprot.writeFieldStop();\n      oprot.writeStructEnd();\n    }\n    }\n```\n#### 接收响应并反序列化结果\n\n当服务端返回数据后，`recv_helloVoid`函数处理服务端返回的数据，反序列化得到`helloVoid_result`，并对异常做处理。**注意对seqid的检查**，thrift在这里处理服务端响应乱序的情况(后接收的先返回)，处理方式是直接抛出异常。\n```java\npublic void recv_helloVoid() throws TException\n    {\n      TMessage msg = iprot_.readMessageBegin();\n      if (msg.type == TMessageType.EXCEPTION) {\n        TApplicationException x = TApplicationException.read(iprot_);\n        iprot_.readMessageEnd();\n        throw x;\n      }\n      if (msg.seqid != seqid_) {\n        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, \"helloVoid failed: out of sequence response\");\n      }\n      helloVoid_result result = new helloVoid_result();\n      result.read(iprot_);\n      iprot_.readMessageEnd();\n      return;\n    }\n```\n`helloVoid_result`和`helloVoid_args`类似，他定义了方法返回值的序列化操作方式,read方法代码如下：\n```java\n  public static class helloVoid_result implements TBase<helloVoid_result, helloVoid_result._Fields>, java.io.Serializable, Cloneable   {\n\n public void read(TProtocol iprot) throws TException {\n      TField field;\n      //找到字节流中类起始位置\n      iprot.readStructBegin();\n      //循环解析TField，直到遇到TType.STOP\n      while (true)\n      {\n        //找到field起点\n        field = iprot.readFieldBegin();\n        if (field.type == TType.STOP) { \n          break;\n        }\n        //根据id找到field具体对应的那个属性，因为helloVoid返回值为空，直接跳过\n        switch (field.id) {\n          default:\n            TProtocolUtil.skip(iprot, field.type);\n        }\n        iprot.readFieldEnd();\n      }\n      iprot.readStructEnd();\n      //检查require字段\n      // check for required fields of primitive type, which can't be checked in the validate method\n      validate();\n    }\n    }\n```\n\n## 参考\nhttp://www.cnblogs.com/luxiaoxun/archive/2015/03/11/4331110.html\nhttps://my.oschina.net/xinxingegeya/blog/620576\nhttps://www.ibm.com/developerworks/cn/java/j-lo-apachethrift/index.html\n\n\n  [1]: https://www.ibm.com/developerworks/cn/java/j-lo-apachethrift/image003.jpg\n  [2]: https://www.ibm.com/developerworks/cn/java/j-lo-apachethrift/image006.png\n  [3]: https://www.ibm.com/developerworks/cn/java/j-lo-apachethrift/image004.png\n  [4]: http://upload-images.jianshu.io/upload_images/1452123-35a5505c0d9928f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\n  [5]: http://upload-images.jianshu.io/upload_images/1452123-bfb7ef28b21ba29e?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\n  [6]: https://upload-images.jianshu.io/upload_images/3169646-6eddb6e230677349.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/692\n  [7]: http://zhangtielei.com/posts/blog-rxjava-backpressure.html\n  [8]: https://baike.baidu.com/item/%E8%83%8C%E5%8E%8B%E9%98%80\n  [9]: https://github.com/apache/thrift/blob/0.8.x/lib/java/src/org/apache/thrift/server/TThreadedSelectorServer.java\n  [10]: https://upload-images.jianshu.io/upload_images/3169646-eedd2295dcc12725.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/688\n  [11]: https://static.oschina.net/uploads/space/2016/0224/192255_iHyl_1469576.png\n  [12]: https://static.oschina.net/uploads/space/2016/0224/192347_Vfen_1469576.png\n  [13]: https://static.oschina.net/uploads/space/2016/0224/192513_tzOg_1469576.png\n  [14]: https://static.oschina.net/uploads/space/2016/0224/192544_xSFh_1469576.png\n  [15]: https://static.oschina.net/uploads/space/2016/0224/192757_XK9n_1469576.png\n  [16]: https://static.oschina.net/uploads/space/2016/0224/192757_toBx_1469576.png\n  [17]: https://upload.wikimedia.org/wikipedia/commons/thumb/5/54/Big-Endian.svg/200px-Big-Endian.svg.png\n  [18]: https://upload.wikimedia.org/wikipedia/commons/thumb/e/ed/Little-Endian.svg/200px-Little-Endian.svg.png\n  [19]: https://jin-yang.github.io/post/network-tcpip-timewait.html","slug":"thrift源码-客户端","published":1,"updated":"2019-10-24T15:47:41.884Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkqle175000kcyneuic1xwha","content":"<h2 id=\"thrift架构图\"><a href=\"#thrift架构图\" class=\"headerlink\" title=\"thrift架构图\"></a>thrift架构图</h2><p><img src=\"https://www.ibm.com/developerworks/cn/java/j-lo-apachethrift/image003.jpg\" alt=\"整体视图\"></p>\n<p>如图所示，作为一个通信框架，thrift架构上也分了不同的层，和tcp/ip的分层逻辑类似，最上层是我们的业务逻辑层，这里是我们编写的HelloService接口的实现类。</p>\n<a id=\"more\"></a>\n<p>第二层是thrift生成的HelloService.Client(或者AsyncClient)和HelloService.Processor类，分别给客户端和服务端使用，对开发者屏蔽了如何发送/处理请求，返回结果，异常检查等通信细节。</p>\n<p>第三层是thrift生成的数据序列化和反序列化的write/read方法，read()负责根据协议从字节流中解析调用的函数名，参数等，比如方法HelloService.helloString_args#read,write()则相反。</p>\n<p>第四层及以下是thrift框架的源码，TProtocol定义了数据传输协议，thrift提供了binary/json等多种编码实现。<br>第五层是thrift对i/o层的封装，TTransport包含网络连接的打开关闭，输入输出流的处理等等。</p>\n<h2 id=\"类图\"><a href=\"#类图\" class=\"headerlink\" title=\"类图\"></a>类图</h2><img src=\"/2019/05/22/thrift源码-客户端/overview.png\" title=\"image\">\n<p><strong>我使用的0.5.0版本的thrift</strong></p>\n<p>深色的是thrift生成的HelloService和他的内部类，Client和AsyncClient是客户端使用，Processor是服务端使用。</p>\n<p>Processor实现TProcessor接口，Client实现TServiceClient接口</p>\n<p>TTransport被TProcessFactory，TProtocolFactory,TProtocol依赖</p>\n<p>TProtocal由TTransport组成，几乎被图中所有类依赖。</p>\n<h2 id=\"客户端流程\"><a href=\"#客户端流程\" class=\"headerlink\" title=\"客户端流程\"></a>客户端流程</h2><p><img src=\"https://www.ibm.com/developerworks/cn/java/j-lo-apachethrift/image006.png\" alt=\"客户端时序图\"></p>\n<h3 id=\"同步客户端\"><a href=\"#同步客户端\" class=\"headerlink\" title=\"同步客户端\"></a>同步客户端</h3><p>发起调用的代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TTransport transport=<span class=\"keyword\">new</span> TSocket(<span class=\"string\">\"localhost\"</span>,<span class=\"number\">7911</span>);</span><br><span class=\"line\">                transport.open();</span><br><span class=\"line\">TProtocol protocol=<span class=\"keyword\">new</span> TBinaryProtocol(transport);</span><br><span class=\"line\">HelloService.Client client=<span class=\"keyword\">new</span> HelloService.Client(protocol);</span><br><span class=\"line\">client.helloVoid();</span><br><span class=\"line\">transport.close();</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"1-创建socket连接-TTransport-，选择协议-TProtocol\"><a href=\"#1-创建socket连接-TTransport-，选择协议-TProtocol\" class=\"headerlink\" title=\"1.创建socket连接(TTransport)，选择协议(TProtocol)\"></a>1.创建socket连接(TTransport)，选择协议(TProtocol)</h4><p>TSocket是TIOStreamTransport的子类，TIOStreamTransport封装了输入、输出流的处理，TScocket封装了一个Socket对象。<br>TBinaryProtocol是TProtocol的子类，定义了基于二进制的通信协议</p>\n<h4 id=\"2-初始化Client-调用helloVoid函数\"><a href=\"#2-初始化Client-调用helloVoid函数\" class=\"headerlink\" title=\"2.初始化Client,调用helloVoid函数\"></a>2.初始化Client,调用helloVoid函数</h4><p>helloVoid内部执行发送请求和接收响应两步操作：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">helloVoid</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> TException</span></span><br><span class=\"line\"><span class=\"function\">   </span>&#123;</span><br><span class=\"line\">     send_helloVoid();</span><br><span class=\"line\">     recv_helloVoid();</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"3-序列化请求并发送\"><a href=\"#3-序列化请求并发送\" class=\"headerlink\" title=\"3.序列化请求并发送\"></a>3.序列化请求并发送</h4><p>客户端发送请求时必然要告知服务端本次请求的方法名，参数，还有调用序号，版本号等信息，这些都要通过TProtocol序列化，协议相关细节后面介绍。<br>序列化完成后，TBinaryProtocol把这些内容通过TTransport写入到输出流，通过网络发送到服务端。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">        <span class=\"keyword\">protected</span> TProtocol iprot_;</span><br><span class=\"line\">        <span class=\"keyword\">protected</span> TProtocol oprot_;</span><br><span class=\"line\">        <span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> seqid_;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">send_helloVoid</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> TException</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//构造协议消息体</span></span><br><span class=\"line\">      oprot_.writeMessageBegin(<span class=\"keyword\">new</span> TMessage(<span class=\"string\">\"helloVoid\"</span>, TMessageType.CALL, ++seqid_));</span><br><span class=\"line\">      helloVoid_args args = <span class=\"keyword\">new</span> helloVoid_args();</span><br><span class=\"line\">      <span class=\"comment\">//把参数按协议序列化</span></span><br><span class=\"line\">      args.write(oprot_);</span><br><span class=\"line\">      oprot_.writeMessageEnd();</span><br><span class=\"line\">      <span class=\"comment\">//发送数据</span></span><br><span class=\"line\">      oprot_.getTransport().flush();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>helloVoid_args虽然这样命名但他是一个静态内部类，HelloSerive的每个函数都会生成这样的类。生成的代码，根据thrift文件中定义的函数参数，告诉thrift程序如何进行序列化操作(比如从TProtocol中读取TField，字节流的哪个位置起对应哪个参数，参数对应多少字节等)。<br>helloVoid_args的函数write()代码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">helloVoid_args</span> <span class=\"keyword\">implements</span> <span class=\"title\">TBase</span>&lt;<span class=\"title\">helloVoid_args</span>, <span class=\"title\">helloVoid_args</span>.<span class=\"title\">_Fields</span>&gt;, <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span>, <span class=\"title\">Cloneable</span>   </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">write</span><span class=\"params\">(TProtocol oprot)</span> <span class=\"keyword\">throws</span> TException </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//对声明为required的字段检查，required字段不能为null</span></span><br><span class=\"line\">      validate();</span><br><span class=\"line\"></span><br><span class=\"line\">      oprot.writeStructBegin(STRUCT_DESC);</span><br><span class=\"line\">      oprot.writeFieldStop();</span><br><span class=\"line\">      oprot.writeStructEnd();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"接收响应并反序列化结果\"><a href=\"#接收响应并反序列化结果\" class=\"headerlink\" title=\"接收响应并反序列化结果\"></a>接收响应并反序列化结果</h4><p>当服务端返回数据后，<code>recv_helloVoid</code>函数处理服务端返回的数据，反序列化得到<code>helloVoid_result</code>，并对异常做处理。<strong>注意对seqid的检查</strong>，thrift在这里处理服务端响应乱序的情况(后接收的先返回)，处理方式是直接抛出异常。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">recv_helloVoid</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> TException</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">      TMessage msg = iprot_.readMessageBegin();</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (msg.type == TMessageType.EXCEPTION) &#123;</span><br><span class=\"line\">        TApplicationException x = TApplicationException.read(iprot_);</span><br><span class=\"line\">        iprot_.readMessageEnd();</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> x;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (msg.seqid != seqid_) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> TApplicationException(TApplicationException.BAD_SEQUENCE_ID, <span class=\"string\">\"helloVoid failed: out of sequence response\"</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      helloVoid_result result = <span class=\"keyword\">new</span> helloVoid_result();</span><br><span class=\"line\">      result.read(iprot_);</span><br><span class=\"line\">      iprot_.readMessageEnd();</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>helloVoid_result</code>和<code>helloVoid_args</code>类似，他定义了方法返回值的序列化操作方式,read方法代码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">helloVoid_result</span> <span class=\"keyword\">implements</span> <span class=\"title\">TBase</span>&lt;<span class=\"title\">helloVoid_result</span>, <span class=\"title\">helloVoid_result</span>.<span class=\"title\">_Fields</span>&gt;, <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span>, <span class=\"title\">Cloneable</span>   </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">read</span><span class=\"params\">(TProtocol iprot)</span> <span class=\"keyword\">throws</span> TException </span>&#123;</span><br><span class=\"line\">     TField field;</span><br><span class=\"line\">     <span class=\"comment\">//找到字节流中类起始位置</span></span><br><span class=\"line\">     iprot.readStructBegin();</span><br><span class=\"line\">     <span class=\"comment\">//循环解析TField，直到遇到TType.STOP</span></span><br><span class=\"line\">     <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>)</span><br><span class=\"line\">     &#123;</span><br><span class=\"line\">       <span class=\"comment\">//找到field起点</span></span><br><span class=\"line\">       field = iprot.readFieldBegin();</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (field.type == TType.STOP) &#123; </span><br><span class=\"line\">         <span class=\"keyword\">break</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"comment\">//根据id找到field具体对应的那个属性，因为helloVoid返回值为空，直接跳过</span></span><br><span class=\"line\">       <span class=\"keyword\">switch</span> (field.id) &#123;</span><br><span class=\"line\">         <span class=\"keyword\">default</span>:</span><br><span class=\"line\">           TProtocolUtil.skip(iprot, field.type);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       iprot.readFieldEnd();</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     iprot.readStructEnd();</span><br><span class=\"line\">     <span class=\"comment\">//检查require字段</span></span><br><span class=\"line\">     <span class=\"comment\">// check for required fields of primitive type, which can't be checked in the validate method</span></span><br><span class=\"line\">     validate();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://www.cnblogs.com/luxiaoxun/archive/2015/03/11/4331110.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/luxiaoxun/archive/2015/03/11/4331110.html</a><br><a href=\"https://my.oschina.net/xinxingegeya/blog/620576\" target=\"_blank\" rel=\"noopener\">https://my.oschina.net/xinxingegeya/blog/620576</a><br><a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-apachethrift/index.html\" target=\"_blank\" rel=\"noopener\">https://www.ibm.com/developerworks/cn/java/j-lo-apachethrift/index.html</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"thrift架构图\"><a href=\"#thrift架构图\" class=\"headerlink\" title=\"thrift架构图\"></a>thrift架构图</h2><p><img src=\"https://www.ibm.com/developerworks/cn/java/j-lo-apachethrift/image003.jpg\" alt=\"整体视图\"></p>\n<p>如图所示，作为一个通信框架，thrift架构上也分了不同的层，和tcp/ip的分层逻辑类似，最上层是我们的业务逻辑层，这里是我们编写的HelloService接口的实现类。</p>","more":"<p>第二层是thrift生成的HelloService.Client(或者AsyncClient)和HelloService.Processor类，分别给客户端和服务端使用，对开发者屏蔽了如何发送/处理请求，返回结果，异常检查等通信细节。</p>\n<p>第三层是thrift生成的数据序列化和反序列化的write/read方法，read()负责根据协议从字节流中解析调用的函数名，参数等，比如方法HelloService.helloString_args#read,write()则相反。</p>\n<p>第四层及以下是thrift框架的源码，TProtocol定义了数据传输协议，thrift提供了binary/json等多种编码实现。<br>第五层是thrift对i/o层的封装，TTransport包含网络连接的打开关闭，输入输出流的处理等等。</p>\n<h2 id=\"类图\"><a href=\"#类图\" class=\"headerlink\" title=\"类图\"></a>类图</h2><img src=\"/2019/05/22/thrift源码-客户端/overview.png\" title=\"image\">\n<p><strong>我使用的0.5.0版本的thrift</strong></p>\n<p>深色的是thrift生成的HelloService和他的内部类，Client和AsyncClient是客户端使用，Processor是服务端使用。</p>\n<p>Processor实现TProcessor接口，Client实现TServiceClient接口</p>\n<p>TTransport被TProcessFactory，TProtocolFactory,TProtocol依赖</p>\n<p>TProtocal由TTransport组成，几乎被图中所有类依赖。</p>\n<h2 id=\"客户端流程\"><a href=\"#客户端流程\" class=\"headerlink\" title=\"客户端流程\"></a>客户端流程</h2><p><img src=\"https://www.ibm.com/developerworks/cn/java/j-lo-apachethrift/image006.png\" alt=\"客户端时序图\"></p>\n<h3 id=\"同步客户端\"><a href=\"#同步客户端\" class=\"headerlink\" title=\"同步客户端\"></a>同步客户端</h3><p>发起调用的代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TTransport transport=<span class=\"keyword\">new</span> TSocket(<span class=\"string\">\"localhost\"</span>,<span class=\"number\">7911</span>);</span><br><span class=\"line\">                transport.open();</span><br><span class=\"line\">TProtocol protocol=<span class=\"keyword\">new</span> TBinaryProtocol(transport);</span><br><span class=\"line\">HelloService.Client client=<span class=\"keyword\">new</span> HelloService.Client(protocol);</span><br><span class=\"line\">client.helloVoid();</span><br><span class=\"line\">transport.close();</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"1-创建socket连接-TTransport-，选择协议-TProtocol\"><a href=\"#1-创建socket连接-TTransport-，选择协议-TProtocol\" class=\"headerlink\" title=\"1.创建socket连接(TTransport)，选择协议(TProtocol)\"></a>1.创建socket连接(TTransport)，选择协议(TProtocol)</h4><p>TSocket是TIOStreamTransport的子类，TIOStreamTransport封装了输入、输出流的处理，TScocket封装了一个Socket对象。<br>TBinaryProtocol是TProtocol的子类，定义了基于二进制的通信协议</p>\n<h4 id=\"2-初始化Client-调用helloVoid函数\"><a href=\"#2-初始化Client-调用helloVoid函数\" class=\"headerlink\" title=\"2.初始化Client,调用helloVoid函数\"></a>2.初始化Client,调用helloVoid函数</h4><p>helloVoid内部执行发送请求和接收响应两步操作：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">helloVoid</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> TException</span></span><br><span class=\"line\"><span class=\"function\">   </span>&#123;</span><br><span class=\"line\">     send_helloVoid();</span><br><span class=\"line\">     recv_helloVoid();</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"3-序列化请求并发送\"><a href=\"#3-序列化请求并发送\" class=\"headerlink\" title=\"3.序列化请求并发送\"></a>3.序列化请求并发送</h4><p>客户端发送请求时必然要告知服务端本次请求的方法名，参数，还有调用序号，版本号等信息，这些都要通过TProtocol序列化，协议相关细节后面介绍。<br>序列化完成后，TBinaryProtocol把这些内容通过TTransport写入到输出流，通过网络发送到服务端。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">        <span class=\"keyword\">protected</span> TProtocol iprot_;</span><br><span class=\"line\">        <span class=\"keyword\">protected</span> TProtocol oprot_;</span><br><span class=\"line\">        <span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> seqid_;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">send_helloVoid</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> TException</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//构造协议消息体</span></span><br><span class=\"line\">      oprot_.writeMessageBegin(<span class=\"keyword\">new</span> TMessage(<span class=\"string\">\"helloVoid\"</span>, TMessageType.CALL, ++seqid_));</span><br><span class=\"line\">      helloVoid_args args = <span class=\"keyword\">new</span> helloVoid_args();</span><br><span class=\"line\">      <span class=\"comment\">//把参数按协议序列化</span></span><br><span class=\"line\">      args.write(oprot_);</span><br><span class=\"line\">      oprot_.writeMessageEnd();</span><br><span class=\"line\">      <span class=\"comment\">//发送数据</span></span><br><span class=\"line\">      oprot_.getTransport().flush();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>helloVoid_args虽然这样命名但他是一个静态内部类，HelloSerive的每个函数都会生成这样的类。生成的代码，根据thrift文件中定义的函数参数，告诉thrift程序如何进行序列化操作(比如从TProtocol中读取TField，字节流的哪个位置起对应哪个参数，参数对应多少字节等)。<br>helloVoid_args的函数write()代码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">helloVoid_args</span> <span class=\"keyword\">implements</span> <span class=\"title\">TBase</span>&lt;<span class=\"title\">helloVoid_args</span>, <span class=\"title\">helloVoid_args</span>.<span class=\"title\">_Fields</span>&gt;, <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span>, <span class=\"title\">Cloneable</span>   </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">write</span><span class=\"params\">(TProtocol oprot)</span> <span class=\"keyword\">throws</span> TException </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//对声明为required的字段检查，required字段不能为null</span></span><br><span class=\"line\">      validate();</span><br><span class=\"line\"></span><br><span class=\"line\">      oprot.writeStructBegin(STRUCT_DESC);</span><br><span class=\"line\">      oprot.writeFieldStop();</span><br><span class=\"line\">      oprot.writeStructEnd();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"接收响应并反序列化结果\"><a href=\"#接收响应并反序列化结果\" class=\"headerlink\" title=\"接收响应并反序列化结果\"></a>接收响应并反序列化结果</h4><p>当服务端返回数据后，<code>recv_helloVoid</code>函数处理服务端返回的数据，反序列化得到<code>helloVoid_result</code>，并对异常做处理。<strong>注意对seqid的检查</strong>，thrift在这里处理服务端响应乱序的情况(后接收的先返回)，处理方式是直接抛出异常。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">recv_helloVoid</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> TException</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">      TMessage msg = iprot_.readMessageBegin();</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (msg.type == TMessageType.EXCEPTION) &#123;</span><br><span class=\"line\">        TApplicationException x = TApplicationException.read(iprot_);</span><br><span class=\"line\">        iprot_.readMessageEnd();</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> x;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (msg.seqid != seqid_) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> TApplicationException(TApplicationException.BAD_SEQUENCE_ID, <span class=\"string\">\"helloVoid failed: out of sequence response\"</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      helloVoid_result result = <span class=\"keyword\">new</span> helloVoid_result();</span><br><span class=\"line\">      result.read(iprot_);</span><br><span class=\"line\">      iprot_.readMessageEnd();</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>helloVoid_result</code>和<code>helloVoid_args</code>类似，他定义了方法返回值的序列化操作方式,read方法代码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">helloVoid_result</span> <span class=\"keyword\">implements</span> <span class=\"title\">TBase</span>&lt;<span class=\"title\">helloVoid_result</span>, <span class=\"title\">helloVoid_result</span>.<span class=\"title\">_Fields</span>&gt;, <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span>, <span class=\"title\">Cloneable</span>   </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">read</span><span class=\"params\">(TProtocol iprot)</span> <span class=\"keyword\">throws</span> TException </span>&#123;</span><br><span class=\"line\">     TField field;</span><br><span class=\"line\">     <span class=\"comment\">//找到字节流中类起始位置</span></span><br><span class=\"line\">     iprot.readStructBegin();</span><br><span class=\"line\">     <span class=\"comment\">//循环解析TField，直到遇到TType.STOP</span></span><br><span class=\"line\">     <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>)</span><br><span class=\"line\">     &#123;</span><br><span class=\"line\">       <span class=\"comment\">//找到field起点</span></span><br><span class=\"line\">       field = iprot.readFieldBegin();</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (field.type == TType.STOP) &#123; </span><br><span class=\"line\">         <span class=\"keyword\">break</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"comment\">//根据id找到field具体对应的那个属性，因为helloVoid返回值为空，直接跳过</span></span><br><span class=\"line\">       <span class=\"keyword\">switch</span> (field.id) &#123;</span><br><span class=\"line\">         <span class=\"keyword\">default</span>:</span><br><span class=\"line\">           TProtocolUtil.skip(iprot, field.type);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       iprot.readFieldEnd();</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     iprot.readStructEnd();</span><br><span class=\"line\">     <span class=\"comment\">//检查require字段</span></span><br><span class=\"line\">     <span class=\"comment\">// check for required fields of primitive type, which can't be checked in the validate method</span></span><br><span class=\"line\">     validate();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://www.cnblogs.com/luxiaoxun/archive/2015/03/11/4331110.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/luxiaoxun/archive/2015/03/11/4331110.html</a><br><a href=\"https://my.oschina.net/xinxingegeya/blog/620576\" target=\"_blank\" rel=\"noopener\">https://my.oschina.net/xinxingegeya/blog/620576</a><br><a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-apachethrift/index.html\" target=\"_blank\" rel=\"noopener\">https://www.ibm.com/developerworks/cn/java/j-lo-apachethrift/index.html</a></p>"},{"title":"thrift源码（三）服务端","date":"2019-10-24T15:55:42.000Z","_content":"### 简单的服务端实现 TThreadPoolServer\n#### TProcessor\n和TServiceClient接口类似，TProcessor是thrift为服务端生成代码时要实现的接口，定义了服务端根据客户端请求调用本地接口实现的过程。\n\nHelloService.Processor代码如下：\n<!--more-->\n\n**iface_**是服务启动时，传入的HelloServiceImpl对象实例\n**processMap_**用来保存HelloService定义的方法。\n**process()**函数会根据方法名，找到对应的ProcessFunction实现类，调用ProcessFunction.process()方法。如果没有则返回异常。\n至于方法参数和结果，以helloString()方法为例，helloString_result和helloString_args和thrift客户端使用的类是同一个。\n```java\n        protected final HashMap<String, ProcessFunction> processMap_ = new HashMap<String, ProcessFunction>();\n        private Iface iface_;\n\n        public Processor(Iface iface) {\n            iface_ = iface;\n            processMap_.put(\"helloString\", new helloString());\n            processMap_.put(\"helloInt\", new helloInt());\n            processMap_.put(\"helloBoolean\", new helloBoolean());\n            processMap_.put(\"helloVoid\", new helloVoid());\n            processMap_.put(\"helloNull\", new helloNull());\n        }\n        public boolean process(TProtocol iprot, TProtocol oprot) throws TException {\n            TMessage msg = iprot.readMessageBegin();\n            ProcessFunction fn = processMap_.get(msg.name);\n            if (fn == null) {\n                TProtocolUtil.skip(iprot, TType.STRUCT);\n                iprot.readMessageEnd();\n                TApplicationException x = new TApplicationException(TApplicationException.UNKNOWN_METHOD,\n                        \"Invalid method name: '\" + msg.name + \"'\");\n                oprot.writeMessageBegin(new TMessage(msg.name, TMessageType.EXCEPTION, msg.seqid));\n                x.write(oprot);\n                oprot.writeMessageEnd();\n                oprot.getTransport().flush();\n                return true;\n            }\n            fn.process(msg.seqid, iprot, oprot);\n            return true;\n        }\n\n```\n\n#### TThreadPoolServer调用时序图\n启动服务端的代码代码如下：\n```java\n                // 设置服务端口为 7911\n                TServerSocket serverTransport = new TServerSocket(7911);\n                // 设置协议工厂为 TBinaryProtocol.Factory\n                TBinaryProtocol.Factory proFactory = new TBinaryProtocol.Factory();\n                // 关联处理器与 Hello 服务的实现\n                TProcessor processor = new HelloService.Processor(new HelloServiceImpl());\n                TServer server = new TThreadPoolServer(processor, serverTransport,\n                        proFactory);\n                System.out.println(\"Start server on port 7911...\");\n                server.serve();\n```\nTThreadPoolServer工作的时序图很简单，和所有服务端套接字程序一样，执行listen(),accept(),read(),write()的流程，使用的I/O模型是每处理一个客户端请求就从线程池中取出一个线程。\n\n![时序图1][3]\n\n\n\n  [1]: https://www.ibm.com/developerworks/cn/java/j-lo-apachethrift/image003.jpg\n  [2]: https://www.ibm.com/developerworks/cn/java/j-lo-apachethrift/image006.png\n  [3]: https://www.ibm.com/developerworks/cn/java/j-lo-apachethrift/image004.png\n  [4]: http://upload-images.jianshu.io/upload_images/1452123-35a5505c0d9928f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\n  [5]: http://upload-images.jianshu.io/upload_images/1452123-bfb7ef28b21ba29e?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\n  [6]: https://upload-images.jianshu.io/upload_images/3169646-6eddb6e230677349.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/692\n  [7]: http://zhangtielei.com/posts/blog-rxjava-backpressure.html\n  [8]: https://baike.baidu.com/item/%E8%83%8C%E5%8E%8B%E9%98%80\n  [9]: https://github.com/apache/thrift/blob/0.8.x/lib/java/src/org/apache/thrift/server/TThreadedSelectorServer.java\n  [10]: https://upload-images.jianshu.io/upload_images/3169646-eedd2295dcc12725.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/688\n  [11]: https://static.oschina.net/uploads/space/2016/0224/192255_iHyl_1469576.png\n  [12]: https://static.oschina.net/uploads/space/2016/0224/192347_Vfen_1469576.png\n  [13]: https://static.oschina.net/uploads/space/2016/0224/192513_tzOg_1469576.png\n  [14]: https://static.oschina.net/uploads/space/2016/0224/192544_xSFh_1469576.png\n  [15]: https://static.oschina.net/uploads/space/2016/0224/192757_XK9n_1469576.png\n  [16]: https://static.oschina.net/uploads/space/2016/0224/192757_toBx_1469576.png\n  [17]: https://upload.wikimedia.org/wikipedia/commons/thumb/5/54/Big-Endian.svg/200px-Big-Endian.svg.png\n  [18]: https://upload.wikimedia.org/wikipedia/commons/thumb/e/ed/Little-Endian.svg/200px-Little-Endian.svg.png\n  [19]: https://jin-yang.github.io/post/network-tcpip-timewait.html","source":"_posts/thrift源码（三）服务端.md","raw":"---\ntitle: thrift源码（三）服务端\ndate: 2019-10-24 23:55:42\ncategories: thrift源码\ntags: [thrift,rpc框架]\n---\n### 简单的服务端实现 TThreadPoolServer\n#### TProcessor\n和TServiceClient接口类似，TProcessor是thrift为服务端生成代码时要实现的接口，定义了服务端根据客户端请求调用本地接口实现的过程。\n\nHelloService.Processor代码如下：\n<!--more-->\n\n**iface_**是服务启动时，传入的HelloServiceImpl对象实例\n**processMap_**用来保存HelloService定义的方法。\n**process()**函数会根据方法名，找到对应的ProcessFunction实现类，调用ProcessFunction.process()方法。如果没有则返回异常。\n至于方法参数和结果，以helloString()方法为例，helloString_result和helloString_args和thrift客户端使用的类是同一个。\n```java\n        protected final HashMap<String, ProcessFunction> processMap_ = new HashMap<String, ProcessFunction>();\n        private Iface iface_;\n\n        public Processor(Iface iface) {\n            iface_ = iface;\n            processMap_.put(\"helloString\", new helloString());\n            processMap_.put(\"helloInt\", new helloInt());\n            processMap_.put(\"helloBoolean\", new helloBoolean());\n            processMap_.put(\"helloVoid\", new helloVoid());\n            processMap_.put(\"helloNull\", new helloNull());\n        }\n        public boolean process(TProtocol iprot, TProtocol oprot) throws TException {\n            TMessage msg = iprot.readMessageBegin();\n            ProcessFunction fn = processMap_.get(msg.name);\n            if (fn == null) {\n                TProtocolUtil.skip(iprot, TType.STRUCT);\n                iprot.readMessageEnd();\n                TApplicationException x = new TApplicationException(TApplicationException.UNKNOWN_METHOD,\n                        \"Invalid method name: '\" + msg.name + \"'\");\n                oprot.writeMessageBegin(new TMessage(msg.name, TMessageType.EXCEPTION, msg.seqid));\n                x.write(oprot);\n                oprot.writeMessageEnd();\n                oprot.getTransport().flush();\n                return true;\n            }\n            fn.process(msg.seqid, iprot, oprot);\n            return true;\n        }\n\n```\n\n#### TThreadPoolServer调用时序图\n启动服务端的代码代码如下：\n```java\n                // 设置服务端口为 7911\n                TServerSocket serverTransport = new TServerSocket(7911);\n                // 设置协议工厂为 TBinaryProtocol.Factory\n                TBinaryProtocol.Factory proFactory = new TBinaryProtocol.Factory();\n                // 关联处理器与 Hello 服务的实现\n                TProcessor processor = new HelloService.Processor(new HelloServiceImpl());\n                TServer server = new TThreadPoolServer(processor, serverTransport,\n                        proFactory);\n                System.out.println(\"Start server on port 7911...\");\n                server.serve();\n```\nTThreadPoolServer工作的时序图很简单，和所有服务端套接字程序一样，执行listen(),accept(),read(),write()的流程，使用的I/O模型是每处理一个客户端请求就从线程池中取出一个线程。\n\n![时序图1][3]\n\n\n\n  [1]: https://www.ibm.com/developerworks/cn/java/j-lo-apachethrift/image003.jpg\n  [2]: https://www.ibm.com/developerworks/cn/java/j-lo-apachethrift/image006.png\n  [3]: https://www.ibm.com/developerworks/cn/java/j-lo-apachethrift/image004.png\n  [4]: http://upload-images.jianshu.io/upload_images/1452123-35a5505c0d9928f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\n  [5]: http://upload-images.jianshu.io/upload_images/1452123-bfb7ef28b21ba29e?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\n  [6]: https://upload-images.jianshu.io/upload_images/3169646-6eddb6e230677349.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/692\n  [7]: http://zhangtielei.com/posts/blog-rxjava-backpressure.html\n  [8]: https://baike.baidu.com/item/%E8%83%8C%E5%8E%8B%E9%98%80\n  [9]: https://github.com/apache/thrift/blob/0.8.x/lib/java/src/org/apache/thrift/server/TThreadedSelectorServer.java\n  [10]: https://upload-images.jianshu.io/upload_images/3169646-eedd2295dcc12725.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/688\n  [11]: https://static.oschina.net/uploads/space/2016/0224/192255_iHyl_1469576.png\n  [12]: https://static.oschina.net/uploads/space/2016/0224/192347_Vfen_1469576.png\n  [13]: https://static.oschina.net/uploads/space/2016/0224/192513_tzOg_1469576.png\n  [14]: https://static.oschina.net/uploads/space/2016/0224/192544_xSFh_1469576.png\n  [15]: https://static.oschina.net/uploads/space/2016/0224/192757_XK9n_1469576.png\n  [16]: https://static.oschina.net/uploads/space/2016/0224/192757_toBx_1469576.png\n  [17]: https://upload.wikimedia.org/wikipedia/commons/thumb/5/54/Big-Endian.svg/200px-Big-Endian.svg.png\n  [18]: https://upload.wikimedia.org/wikipedia/commons/thumb/e/ed/Little-Endian.svg/200px-Little-Endian.svg.png\n  [19]: https://jin-yang.github.io/post/network-tcpip-timewait.html","slug":"thrift源码（三）服务端","published":1,"updated":"2019-10-24T16:48:56.780Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkqle177000ocyney6im1bug","content":"<h3 id=\"简单的服务端实现-TThreadPoolServer\"><a href=\"#简单的服务端实现-TThreadPoolServer\" class=\"headerlink\" title=\"简单的服务端实现 TThreadPoolServer\"></a>简单的服务端实现 TThreadPoolServer</h3><h4 id=\"TProcessor\"><a href=\"#TProcessor\" class=\"headerlink\" title=\"TProcessor\"></a>TProcessor</h4><p>和TServiceClient接口类似，TProcessor是thrift为服务端生成代码时要实现的接口，定义了服务端根据客户端请求调用本地接口实现的过程。</p>\n<p>HelloService.Processor代码如下：<br><a id=\"more\"></a></p>\n<p><strong>iface_</strong>是服务启动时，传入的HelloServiceImpl对象实例<br><strong>processMap_</strong>用来保存HelloService定义的方法。<br><strong>process()</strong>函数会根据方法名，找到对应的ProcessFunction实现类，调用ProcessFunction.process()方法。如果没有则返回异常。<br>至于方法参数和结果，以helloString()方法为例，helloString_result和helloString_args和thrift客户端使用的类是同一个。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> HashMap&lt;String, ProcessFunction&gt; processMap_ = <span class=\"keyword\">new</span> HashMap&lt;String, ProcessFunction&gt;();</span><br><span class=\"line\"><span class=\"keyword\">private</span> Iface iface_;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Processor</span><span class=\"params\">(Iface iface)</span> </span>&#123;</span><br><span class=\"line\">    iface_ = iface;</span><br><span class=\"line\">    processMap_.put(<span class=\"string\">\"helloString\"</span>, <span class=\"keyword\">new</span> helloString());</span><br><span class=\"line\">    processMap_.put(<span class=\"string\">\"helloInt\"</span>, <span class=\"keyword\">new</span> helloInt());</span><br><span class=\"line\">    processMap_.put(<span class=\"string\">\"helloBoolean\"</span>, <span class=\"keyword\">new</span> helloBoolean());</span><br><span class=\"line\">    processMap_.put(<span class=\"string\">\"helloVoid\"</span>, <span class=\"keyword\">new</span> helloVoid());</span><br><span class=\"line\">    processMap_.put(<span class=\"string\">\"helloNull\"</span>, <span class=\"keyword\">new</span> helloNull());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">process</span><span class=\"params\">(TProtocol iprot, TProtocol oprot)</span> <span class=\"keyword\">throws</span> TException </span>&#123;</span><br><span class=\"line\">    TMessage msg = iprot.readMessageBegin();</span><br><span class=\"line\">    ProcessFunction fn = processMap_.get(msg.name);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fn == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        TProtocolUtil.skip(iprot, TType.STRUCT);</span><br><span class=\"line\">        iprot.readMessageEnd();</span><br><span class=\"line\">        TApplicationException x = <span class=\"keyword\">new</span> TApplicationException(TApplicationException.UNKNOWN_METHOD,</span><br><span class=\"line\">                <span class=\"string\">\"Invalid method name: '\"</span> + msg.name + <span class=\"string\">\"'\"</span>);</span><br><span class=\"line\">        oprot.writeMessageBegin(<span class=\"keyword\">new</span> TMessage(msg.name, TMessageType.EXCEPTION, msg.seqid));</span><br><span class=\"line\">        x.write(oprot);</span><br><span class=\"line\">        oprot.writeMessageEnd();</span><br><span class=\"line\">        oprot.getTransport().flush();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fn.process(msg.seqid, iprot, oprot);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"TThreadPoolServer调用时序图\"><a href=\"#TThreadPoolServer调用时序图\" class=\"headerlink\" title=\"TThreadPoolServer调用时序图\"></a>TThreadPoolServer调用时序图</h4><p>启动服务端的代码代码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 设置服务端口为 7911</span></span><br><span class=\"line\">TServerSocket serverTransport = <span class=\"keyword\">new</span> TServerSocket(<span class=\"number\">7911</span>);</span><br><span class=\"line\"><span class=\"comment\">// 设置协议工厂为 TBinaryProtocol.Factory</span></span><br><span class=\"line\">TBinaryProtocol.Factory proFactory = <span class=\"keyword\">new</span> TBinaryProtocol.Factory();</span><br><span class=\"line\"><span class=\"comment\">// 关联处理器与 Hello 服务的实现</span></span><br><span class=\"line\">TProcessor processor = <span class=\"keyword\">new</span> HelloService.Processor(<span class=\"keyword\">new</span> HelloServiceImpl());</span><br><span class=\"line\">TServer server = <span class=\"keyword\">new</span> TThreadPoolServer(processor, serverTransport,</span><br><span class=\"line\">        proFactory);</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"Start server on port 7911...\"</span>);</span><br><span class=\"line\">server.serve();</span><br></pre></td></tr></table></figure></p>\n<p>TThreadPoolServer工作的时序图很简单，和所有服务端套接字程序一样，执行listen(),accept(),read(),write()的流程，使用的I/O模型是每处理一个客户端请求就从线程池中取出一个线程。</p>\n<p><img src=\"https://www.ibm.com/developerworks/cn/java/j-lo-apachethrift/image004.png\" alt=\"时序图1\"></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"简单的服务端实现-TThreadPoolServer\"><a href=\"#简单的服务端实现-TThreadPoolServer\" class=\"headerlink\" title=\"简单的服务端实现 TThreadPoolServer\"></a>简单的服务端实现 TThreadPoolServer</h3><h4 id=\"TProcessor\"><a href=\"#TProcessor\" class=\"headerlink\" title=\"TProcessor\"></a>TProcessor</h4><p>和TServiceClient接口类似，TProcessor是thrift为服务端生成代码时要实现的接口，定义了服务端根据客户端请求调用本地接口实现的过程。</p>\n<p>HelloService.Processor代码如下：<br>","more":"</p>\n<p><strong>iface_</strong>是服务启动时，传入的HelloServiceImpl对象实例<br><strong>processMap_</strong>用来保存HelloService定义的方法。<br><strong>process()</strong>函数会根据方法名，找到对应的ProcessFunction实现类，调用ProcessFunction.process()方法。如果没有则返回异常。<br>至于方法参数和结果，以helloString()方法为例，helloString_result和helloString_args和thrift客户端使用的类是同一个。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> HashMap&lt;String, ProcessFunction&gt; processMap_ = <span class=\"keyword\">new</span> HashMap&lt;String, ProcessFunction&gt;();</span><br><span class=\"line\"><span class=\"keyword\">private</span> Iface iface_;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Processor</span><span class=\"params\">(Iface iface)</span> </span>&#123;</span><br><span class=\"line\">    iface_ = iface;</span><br><span class=\"line\">    processMap_.put(<span class=\"string\">\"helloString\"</span>, <span class=\"keyword\">new</span> helloString());</span><br><span class=\"line\">    processMap_.put(<span class=\"string\">\"helloInt\"</span>, <span class=\"keyword\">new</span> helloInt());</span><br><span class=\"line\">    processMap_.put(<span class=\"string\">\"helloBoolean\"</span>, <span class=\"keyword\">new</span> helloBoolean());</span><br><span class=\"line\">    processMap_.put(<span class=\"string\">\"helloVoid\"</span>, <span class=\"keyword\">new</span> helloVoid());</span><br><span class=\"line\">    processMap_.put(<span class=\"string\">\"helloNull\"</span>, <span class=\"keyword\">new</span> helloNull());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">process</span><span class=\"params\">(TProtocol iprot, TProtocol oprot)</span> <span class=\"keyword\">throws</span> TException </span>&#123;</span><br><span class=\"line\">    TMessage msg = iprot.readMessageBegin();</span><br><span class=\"line\">    ProcessFunction fn = processMap_.get(msg.name);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fn == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        TProtocolUtil.skip(iprot, TType.STRUCT);</span><br><span class=\"line\">        iprot.readMessageEnd();</span><br><span class=\"line\">        TApplicationException x = <span class=\"keyword\">new</span> TApplicationException(TApplicationException.UNKNOWN_METHOD,</span><br><span class=\"line\">                <span class=\"string\">\"Invalid method name: '\"</span> + msg.name + <span class=\"string\">\"'\"</span>);</span><br><span class=\"line\">        oprot.writeMessageBegin(<span class=\"keyword\">new</span> TMessage(msg.name, TMessageType.EXCEPTION, msg.seqid));</span><br><span class=\"line\">        x.write(oprot);</span><br><span class=\"line\">        oprot.writeMessageEnd();</span><br><span class=\"line\">        oprot.getTransport().flush();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fn.process(msg.seqid, iprot, oprot);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"TThreadPoolServer调用时序图\"><a href=\"#TThreadPoolServer调用时序图\" class=\"headerlink\" title=\"TThreadPoolServer调用时序图\"></a>TThreadPoolServer调用时序图</h4><p>启动服务端的代码代码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 设置服务端口为 7911</span></span><br><span class=\"line\">TServerSocket serverTransport = <span class=\"keyword\">new</span> TServerSocket(<span class=\"number\">7911</span>);</span><br><span class=\"line\"><span class=\"comment\">// 设置协议工厂为 TBinaryProtocol.Factory</span></span><br><span class=\"line\">TBinaryProtocol.Factory proFactory = <span class=\"keyword\">new</span> TBinaryProtocol.Factory();</span><br><span class=\"line\"><span class=\"comment\">// 关联处理器与 Hello 服务的实现</span></span><br><span class=\"line\">TProcessor processor = <span class=\"keyword\">new</span> HelloService.Processor(<span class=\"keyword\">new</span> HelloServiceImpl());</span><br><span class=\"line\">TServer server = <span class=\"keyword\">new</span> TThreadPoolServer(processor, serverTransport,</span><br><span class=\"line\">        proFactory);</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"Start server on port 7911...\"</span>);</span><br><span class=\"line\">server.serve();</span><br></pre></td></tr></table></figure></p>\n<p>TThreadPoolServer工作的时序图很简单，和所有服务端套接字程序一样，执行listen(),accept(),read(),write()的流程，使用的I/O模型是每处理一个客户端请求就从线程池中取出一个线程。</p>\n<p><img src=\"https://www.ibm.com/developerworks/cn/java/j-lo-apachethrift/image004.png\" alt=\"时序图1\"></p>"},{"title":"zookeeper,kafka集群安装","date":"2017-07-25T16:09:46.000Z","_content":"\n系统版本 CentOS 6.6\njava version 1.7\nzookeeper版本 3.4.10\nkafka版本 0.11.0.1\n\n## 安装zookeeper\n\n### 1.下载\n```bash\nwget https://mirrors.tuna.tsinghua.edu.cn/apache/zookeeper/zookeeper-3.4.10/zookeeper-3.4.10.tar.gz\ntar -xvf zookeeper-3.4.10.tar.gz\n```\n<!--more-->\n\n### 2.修改配置文件\n\n\n把zoo_sample.cfg改成zoo.cfg\n```bash\ncd zookeeper-3.4.10/conf\nmv zoo_sample.cfg zoo.cfg\n```\n配置文件说明：\n\n>tickTime=2000\ndataDir=/var/lib/zookeeper\nclientPort=2181\ninitLimit=5\nsyncLimit=2\nserver.1=192.168.185.153:2888:3888\nserver.2=192.168.185.154:2888:3888\nserver.3=10.252.81.25:2888:3888\n\n\n- **tickTime**: 默认2000ms,zk的基本时间单位，用来做发送心跳消息的时间间隔，会话超时的最小时间是2×tickTime.\n- **dataDir**: 存储内存数据库快照的位置，也是更新数据库的事务日志的默认存储位置\n- **clientPort**: 给客户端连接的端口\n- **initLimit**: 用来配置 Zookeeper Leader接受Follower初始化连接时最长能忍受多少个心跳时间间隔数,默认5，即5×tickTime=10000ms\n- **syncLimit**:  Leader 与 Follower 之间发送消息，请求和应答时间长度，最长不能超过多少个 tickTime 的时间长度，总的时间长度就是 2*2000=4 秒\n- **server.x**: server.id=ip:port1:port2,使用伪集群模式时可以填写相同的ip（但是端口要不同）,port1是集群中实例通信的端口，port2是用来选举leader的端口\n\n在每个机器依次执行 1 2 两步，并使用相同的配置文件。\n\n### 3.创建myid文件\n在配置的dataDir目录创建一个名为myid的文件，文件内容是配置的server.id的id对应的数字，用来告知机器它代表的server。\n```\necho \"3\">/var/lib/zookeeper/myid\n```\n最后执行 `bash bin/zkServer.sh start` 逐个启动zk\n\n### 4.测试\n执行`bin/zkCli.sh -server 127.0.0.1:2181`启动客户端建立连接\n看到`Welcome to ZooKeeper!`表示连接成功。\n\n## 安装kafka\n在安装并启动zookeeper之后，就可以安装kafka了。\n### 1.下载\n```bash\nwget http://mirror.bit.edu.cn/apache/kafka/0.11.0.1/kafka_2.11-0.11.0.1.tgz\ntar -xzf kafka_2.11-0.11.0.1.tgz\n```\n### 2.修改配置文件\nconf/server.properties文件 \n默认配置简要介绍如下，[完整配置参考](https://kafka.apache.org/documentation/#configuration)：\n```bash\n# broker的唯一id\nbroker.id=0\n\n# 接收请求发送响应的线程数\nnumnetwork.threads=3\n\n# 处理请求的线程数（包含磁盘i/o）\nnum.io.threads=8\n# The send buffer (SO_SNDBUF) used by the socket server\nsocket.send.buffer.bytes=102400\n# The receive buffer (SO_RCVBUF) used by the socket server\nsocket.receive.buffer.bytes=102400\n# The maximum size of a request that the socket server will accept (protection against OOM)\nsocket.request.max.bytes=104857600\n\n#Log Basics #\n# 保存日志文件位置\nlog.dirs=/tmp/kafka-logs\n# 每个主题默认的分区数\nnum.partitions=1\n# 每个数据目录的数量，用于启动时的日志恢复和关机时的flush\n# 对于具有位于RAID阵列中的数据目录的安装，建议增加此值。\nnum.recovery.threads.per.data.dir=1\n\n#Internal Topic Settings  #############################\n# offset topic的备份数   \noffsets.topic.replication.factor=1\ntransaction.state.log.replication.factor=1\ntransaction.state.log.min.isr=1\n\n##Log Retention Policy 日志保留策略##################\n\n# 至少保留多久\nlog.retention.hours=168\n\n# 最大日志，超过会划分新日志\nlog.segment.bytes=1073741824\n\n# 检查日志是否删除的时间间隔\nlog.retention.check.interval.ms=300000\n\n## Zookeeper #####\n\n# Zookeeper 连接地址\nzookeeper.connect=localhost:2181\n# Zookeeper 连接 Timeout \nzookeeper.connection.timeout.ms=6000\n\n\n### Group Coordinator Settings####################\n#0.11.0.0引入的新配置，指定当新成员加入组时，GroupCoordinator将延迟初始消费者重新平衡（rebalance）的时间（毫秒），重新平衡将进一步延迟group.initial.rebalance.delay.ms的值，最大值为max.poll.interval.ms。\n#测试环境配置为0减少等待时间，生产环境建议配置3秒\ngroup.initial.rebalance.delay.ms=0\n```\n修改这几个字段\n>broker.id=yourid\nnum.parttions=3\noffsets.topic.replication.factor=3\ntransaction.state.log.replication.factor=3\ntransaction.state.log.min.isr=2\nzookeeper.connect=192.168.185.153:2181,192.168.185.154:2181,10.252.81.25:2181\n\n### 3.启动kafka\n```bash\nbin/kafka-server-start.sh config/server.properties &\n```\n### 4.测试\n\n创建话题\"hello-kafka\",复制2份，使用2个partition\n```bash\n>bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 2 --partitions 2 --topic hello-kafka\n```\n>Created topic \"hello-kafka\".\n\n查看kafka状态\n```bash\nbin/kafka-topics.sh --describe --zookeeper localhost:2181 --topic hello-kafka\n```\n输出\n>Topic:hello-kafka\tPartitionCount:2\tReplicationFactor:2\tConfigs:\n\tTopic: hello-kafka\tPartition: 0\tLeader: 3\tReplicas: 3,2\tIsr: 3,2\n\tTopic: hello-kafka\tPartition: 1\tLeader: 1\tReplicas: 1,3\tIsr: 1\n\n连接zookeeper服务端，看到kafka在zookeeper保存的话题等信息\n```bash\n[zk: 127.0.0.1:2181(CONNECTED) 2] ls /\n[isr_change_notification, zookeeper, admin, consumers, cluster, config, latest_producer_id_block, controller, brokers, controller_epoch]\n\n[zk: 127.0.0.1:2181(CONNECTED) 5] ls /brokers/topics\n[hello, my-test, my-replicated-topi, my-replicated-topic, hello-kafka]\n```\n\n\n参考\nzookeeper介绍 ：https://www.ibm.com/developerworks/cn/opensource/os-cn-zookeeper/\nzookeeper官方文档 ：http://zookeeper.apache.org/doc/r3.4.10/zookeeperStarted.html\nkafka官方文档 ：https://kafka.apache.org/documentation/\nkafka文档翻译 ：http://www.orchome.com/472\n\n\n\n","source":"_posts/zookeeper,kafka集群安装.md","raw":"# zookeeper,kafka集群安装\n\ntitle: zookeeper,kafka集群安装\ndate: 2017-07-26 00:09:46\ncategories: \ntags: [kafaka,zookeeper,集群]\n\n---\n\n系统版本 CentOS 6.6\njava version 1.7\nzookeeper版本 3.4.10\nkafka版本 0.11.0.1\n\n## 安装zookeeper\n\n### 1.下载\n```bash\nwget https://mirrors.tuna.tsinghua.edu.cn/apache/zookeeper/zookeeper-3.4.10/zookeeper-3.4.10.tar.gz\ntar -xvf zookeeper-3.4.10.tar.gz\n```\n<!--more-->\n\n### 2.修改配置文件\n\n\n把zoo_sample.cfg改成zoo.cfg\n```bash\ncd zookeeper-3.4.10/conf\nmv zoo_sample.cfg zoo.cfg\n```\n配置文件说明：\n\n>tickTime=2000\ndataDir=/var/lib/zookeeper\nclientPort=2181\ninitLimit=5\nsyncLimit=2\nserver.1=192.168.185.153:2888:3888\nserver.2=192.168.185.154:2888:3888\nserver.3=10.252.81.25:2888:3888\n\n\n- **tickTime**: 默认2000ms,zk的基本时间单位，用来做发送心跳消息的时间间隔，会话超时的最小时间是2×tickTime.\n- **dataDir**: 存储内存数据库快照的位置，也是更新数据库的事务日志的默认存储位置\n- **clientPort**: 给客户端连接的端口\n- **initLimit**: 用来配置 Zookeeper Leader接受Follower初始化连接时最长能忍受多少个心跳时间间隔数,默认5，即5×tickTime=10000ms\n- **syncLimit**:  Leader 与 Follower 之间发送消息，请求和应答时间长度，最长不能超过多少个 tickTime 的时间长度，总的时间长度就是 2*2000=4 秒\n- **server.x**: server.id=ip:port1:port2,使用伪集群模式时可以填写相同的ip（但是端口要不同）,port1是集群中实例通信的端口，port2是用来选举leader的端口\n\n在每个机器依次执行 1 2 两步，并使用相同的配置文件。\n\n### 3.创建myid文件\n在配置的dataDir目录创建一个名为myid的文件，文件内容是配置的server.id的id对应的数字，用来告知机器它代表的server。\n```\necho \"3\">/var/lib/zookeeper/myid\n```\n最后执行 `bash bin/zkServer.sh start` 逐个启动zk\n\n### 4.测试\n执行`bin/zkCli.sh -server 127.0.0.1:2181`启动客户端建立连接\n看到`Welcome to ZooKeeper!`表示连接成功。\n\n## 安装kafka\n在安装并启动zookeeper之后，就可以安装kafka了。\n### 1.下载\n```bash\nwget http://mirror.bit.edu.cn/apache/kafka/0.11.0.1/kafka_2.11-0.11.0.1.tgz\ntar -xzf kafka_2.11-0.11.0.1.tgz\n```\n### 2.修改配置文件\nconf/server.properties文件 \n默认配置简要介绍如下，[完整配置参考](https://kafka.apache.org/documentation/#configuration)：\n```bash\n# broker的唯一id\nbroker.id=0\n\n# 接收请求发送响应的线程数\nnumnetwork.threads=3\n\n# 处理请求的线程数（包含磁盘i/o）\nnum.io.threads=8\n# The send buffer (SO_SNDBUF) used by the socket server\nsocket.send.buffer.bytes=102400\n# The receive buffer (SO_RCVBUF) used by the socket server\nsocket.receive.buffer.bytes=102400\n# The maximum size of a request that the socket server will accept (protection against OOM)\nsocket.request.max.bytes=104857600\n\n#Log Basics #\n# 保存日志文件位置\nlog.dirs=/tmp/kafka-logs\n# 每个主题默认的分区数\nnum.partitions=1\n# 每个数据目录的数量，用于启动时的日志恢复和关机时的flush\n# 对于具有位于RAID阵列中的数据目录的安装，建议增加此值。\nnum.recovery.threads.per.data.dir=1\n\n#Internal Topic Settings  #############################\n# offset topic的备份数   \noffsets.topic.replication.factor=1\ntransaction.state.log.replication.factor=1\ntransaction.state.log.min.isr=1\n\n##Log Retention Policy 日志保留策略##################\n\n# 至少保留多久\nlog.retention.hours=168\n\n# 最大日志，超过会划分新日志\nlog.segment.bytes=1073741824\n\n# 检查日志是否删除的时间间隔\nlog.retention.check.interval.ms=300000\n\n## Zookeeper #####\n\n# Zookeeper 连接地址\nzookeeper.connect=localhost:2181\n# Zookeeper 连接 Timeout \nzookeeper.connection.timeout.ms=6000\n\n\n### Group Coordinator Settings####################\n#0.11.0.0引入的新配置，指定当新成员加入组时，GroupCoordinator将延迟初始消费者重新平衡（rebalance）的时间（毫秒），重新平衡将进一步延迟group.initial.rebalance.delay.ms的值，最大值为max.poll.interval.ms。\n#测试环境配置为0减少等待时间，生产环境建议配置3秒\ngroup.initial.rebalance.delay.ms=0\n```\n修改这几个字段\n>broker.id=yourid\nnum.parttions=3\noffsets.topic.replication.factor=3\ntransaction.state.log.replication.factor=3\ntransaction.state.log.min.isr=2\nzookeeper.connect=192.168.185.153:2181,192.168.185.154:2181,10.252.81.25:2181\n\n### 3.启动kafka\n```bash\nbin/kafka-server-start.sh config/server.properties &\n```\n### 4.测试\n\n创建话题\"hello-kafka\",复制2份，使用2个partition\n```bash\n>bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 2 --partitions 2 --topic hello-kafka\n```\n>Created topic \"hello-kafka\".\n\n查看kafka状态\n```bash\nbin/kafka-topics.sh --describe --zookeeper localhost:2181 --topic hello-kafka\n```\n输出\n>Topic:hello-kafka\tPartitionCount:2\tReplicationFactor:2\tConfigs:\n\tTopic: hello-kafka\tPartition: 0\tLeader: 3\tReplicas: 3,2\tIsr: 3,2\n\tTopic: hello-kafka\tPartition: 1\tLeader: 1\tReplicas: 1,3\tIsr: 1\n\n连接zookeeper服务端，看到kafka在zookeeper保存的话题等信息\n```bash\n[zk: 127.0.0.1:2181(CONNECTED) 2] ls /\n[isr_change_notification, zookeeper, admin, consumers, cluster, config, latest_producer_id_block, controller, brokers, controller_epoch]\n\n[zk: 127.0.0.1:2181(CONNECTED) 5] ls /brokers/topics\n[hello, my-test, my-replicated-topi, my-replicated-topic, hello-kafka]\n```\n\n\n参考\nzookeeper介绍 ：https://www.ibm.com/developerworks/cn/opensource/os-cn-zookeeper/\nzookeeper官方文档 ：http://zookeeper.apache.org/doc/r3.4.10/zookeeperStarted.html\nkafka官方文档 ：https://kafka.apache.org/documentation/\nkafka文档翻译 ：http://www.orchome.com/472\n\n\n\n","slug":"zookeeper,kafka集群安装","published":1,"updated":"2018-11-21T16:24:30.257Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkqle178000rcynehjp9hmej","content":"<p>系统版本 CentOS 6.6<br>java version 1.7<br>zookeeper版本 3.4.10<br>kafka版本 0.11.0.1</p>\n<h2 id=\"安装zookeeper\"><a href=\"#安装zookeeper\" class=\"headerlink\" title=\"安装zookeeper\"></a>安装zookeeper</h2><h3 id=\"1-下载\"><a href=\"#1-下载\" class=\"headerlink\" title=\"1.下载\"></a>1.下载</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://mirrors.tuna.tsinghua.edu.cn/apache/zookeeper/zookeeper-3.4.10/zookeeper-3.4.10.tar.gz</span><br><span class=\"line\">tar -xvf zookeeper-3.4.10.tar.gz</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h3 id=\"2-修改配置文件\"><a href=\"#2-修改配置文件\" class=\"headerlink\" title=\"2.修改配置文件\"></a>2.修改配置文件</h3><p>把zoo_sample.cfg改成zoo.cfg<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> zookeeper-3.4.10/conf</span><br><span class=\"line\">mv zoo_sample.cfg zoo.cfg</span><br></pre></td></tr></table></figure></p>\n<p>配置文件说明：</p>\n<blockquote>\n<p>tickTime=2000<br>dataDir=/var/lib/zookeeper<br>clientPort=2181<br>initLimit=5<br>syncLimit=2<br>server.1=192.168.185.153:2888:3888<br>server.2=192.168.185.154:2888:3888<br>server.3=10.252.81.25:2888:3888</p>\n</blockquote>\n<ul>\n<li><strong>tickTime</strong>: 默认2000ms,zk的基本时间单位，用来做发送心跳消息的时间间隔，会话超时的最小时间是2×tickTime.</li>\n<li><strong>dataDir</strong>: 存储内存数据库快照的位置，也是更新数据库的事务日志的默认存储位置</li>\n<li><strong>clientPort</strong>: 给客户端连接的端口</li>\n<li><strong>initLimit</strong>: 用来配置 Zookeeper Leader接受Follower初始化连接时最长能忍受多少个心跳时间间隔数,默认5，即5×tickTime=10000ms</li>\n<li><strong>syncLimit</strong>:  Leader 与 Follower 之间发送消息，请求和应答时间长度，最长不能超过多少个 tickTime 的时间长度，总的时间长度就是 2*2000=4 秒</li>\n<li><strong>server.x</strong>: server.id=ip:port1:port2,使用伪集群模式时可以填写相同的ip（但是端口要不同）,port1是集群中实例通信的端口，port2是用来选举leader的端口</li>\n</ul>\n<p>在每个机器依次执行 1 2 两步，并使用相同的配置文件。</p>\n<h3 id=\"3-创建myid文件\"><a href=\"#3-创建myid文件\" class=\"headerlink\" title=\"3.创建myid文件\"></a>3.创建myid文件</h3><p>在配置的dataDir目录创建一个名为myid的文件，文件内容是配置的server.id的id对应的数字，用来告知机器它代表的server。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo &quot;3&quot;&gt;/var/lib/zookeeper/myid</span><br></pre></td></tr></table></figure></p>\n<p>最后执行 <code>bash bin/zkServer.sh start</code> 逐个启动zk</p>\n<h3 id=\"4-测试\"><a href=\"#4-测试\" class=\"headerlink\" title=\"4.测试\"></a>4.测试</h3><p>执行<code>bin/zkCli.sh -server 127.0.0.1:2181</code>启动客户端建立连接<br>看到<code>Welcome to ZooKeeper!</code>表示连接成功。</p>\n<h2 id=\"安装kafka\"><a href=\"#安装kafka\" class=\"headerlink\" title=\"安装kafka\"></a>安装kafka</h2><p>在安装并启动zookeeper之后，就可以安装kafka了。</p>\n<h3 id=\"1-下载-1\"><a href=\"#1-下载-1\" class=\"headerlink\" title=\"1.下载\"></a>1.下载</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget http://mirror.bit.edu.cn/apache/kafka/0.11.0.1/kafka_2.11-0.11.0.1.tgz</span><br><span class=\"line\">tar -xzf kafka_2.11-0.11.0.1.tgz</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-修改配置文件-1\"><a href=\"#2-修改配置文件-1\" class=\"headerlink\" title=\"2.修改配置文件\"></a>2.修改配置文件</h3><p>conf/server.properties文件<br>默认配置简要介绍如下，<a href=\"https://kafka.apache.org/documentation/#configuration\" target=\"_blank\" rel=\"noopener\">完整配置参考</a>：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># broker的唯一id</span></span><br><span class=\"line\">broker.id=0</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 接收请求发送响应的线程数</span></span><br><span class=\"line\">numnetwork.threads=3</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 处理请求的线程数（包含磁盘i/o）</span></span><br><span class=\"line\">num.io.threads=8</span><br><span class=\"line\"><span class=\"comment\"># The send buffer (SO_SNDBUF) used by the socket server</span></span><br><span class=\"line\">socket.send.buffer.bytes=102400</span><br><span class=\"line\"><span class=\"comment\"># The receive buffer (SO_RCVBUF) used by the socket server</span></span><br><span class=\"line\">socket.receive.buffer.bytes=102400</span><br><span class=\"line\"><span class=\"comment\"># The maximum size of a request that the socket server will accept (protection against OOM)</span></span><br><span class=\"line\">socket.request.max.bytes=104857600</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#Log Basics #</span></span><br><span class=\"line\"><span class=\"comment\"># 保存日志文件位置</span></span><br><span class=\"line\">log.dirs=/tmp/kafka-logs</span><br><span class=\"line\"><span class=\"comment\"># 每个主题默认的分区数</span></span><br><span class=\"line\">num.partitions=1</span><br><span class=\"line\"><span class=\"comment\"># 每个数据目录的数量，用于启动时的日志恢复和关机时的flush</span></span><br><span class=\"line\"><span class=\"comment\"># 对于具有位于RAID阵列中的数据目录的安装，建议增加此值。</span></span><br><span class=\"line\">num.recovery.threads.per.data.dir=1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#Internal Topic Settings  #############################</span></span><br><span class=\"line\"><span class=\"comment\"># offset topic的备份数   </span></span><br><span class=\"line\">offsets.topic.replication.factor=1</span><br><span class=\"line\">transaction.state.log.replication.factor=1</span><br><span class=\"line\">transaction.state.log.min.isr=1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">##Log Retention Policy 日志保留策略##################</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 至少保留多久</span></span><br><span class=\"line\">log.retention.hours=168</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 最大日志，超过会划分新日志</span></span><br><span class=\"line\">log.segment.bytes=1073741824</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 检查日志是否删除的时间间隔</span></span><br><span class=\"line\">log.retention.check.interval.ms=300000</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## Zookeeper #####</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Zookeeper 连接地址</span></span><br><span class=\"line\">zookeeper.connect=localhost:2181</span><br><span class=\"line\"><span class=\"comment\"># Zookeeper 连接 Timeout </span></span><br><span class=\"line\">zookeeper.connection.timeout.ms=6000</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">### Group Coordinator Settings####################</span></span><br><span class=\"line\"><span class=\"comment\">#0.11.0.0引入的新配置，指定当新成员加入组时，GroupCoordinator将延迟初始消费者重新平衡（rebalance）的时间（毫秒），重新平衡将进一步延迟group.initial.rebalance.delay.ms的值，最大值为max.poll.interval.ms。</span></span><br><span class=\"line\"><span class=\"comment\">#测试环境配置为0减少等待时间，生产环境建议配置3秒</span></span><br><span class=\"line\">group.initial.rebalance.delay.ms=0</span><br></pre></td></tr></table></figure></p>\n<p>修改这几个字段</p>\n<blockquote>\n<p>broker.id=yourid<br>num.parttions=3<br>offsets.topic.replication.factor=3<br>transaction.state.log.replication.factor=3<br>transaction.state.log.min.isr=2<br>zookeeper.connect=192.168.185.153:2181,192.168.185.154:2181,10.252.81.25:2181</p>\n</blockquote>\n<h3 id=\"3-启动kafka\"><a href=\"#3-启动kafka\" class=\"headerlink\" title=\"3.启动kafka\"></a>3.启动kafka</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bin/kafka-server-start.sh config/server.properties &amp;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-测试-1\"><a href=\"#4-测试-1\" class=\"headerlink\" title=\"4.测试\"></a>4.测试</h3><p>创建话题”hello-kafka”,复制2份，使用2个partition<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 2 --partitions 2 --topic hello-kafka</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>Created topic “hello-kafka”.</p>\n</blockquote>\n<p>查看kafka状态<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bin/kafka-topics.sh --describe --zookeeper localhost:2181 --topic hello-kafka</span><br></pre></td></tr></table></figure></p>\n<p>输出</p>\n<blockquote>\n<p>Topic:hello-kafka    PartitionCount:2    ReplicationFactor:2    Configs:<br>    Topic: hello-kafka    Partition: 0    Leader: 3    Replicas: 3,2    Isr: 3,2<br>    Topic: hello-kafka    Partition: 1    Leader: 1    Replicas: 1,3    Isr: 1</p>\n</blockquote>\n<p>连接zookeeper服务端，看到kafka在zookeeper保存的话题等信息<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[zk: 127.0.0.1:2181(CONNECTED) 2] ls /</span><br><span class=\"line\">[isr_change_notification, zookeeper, admin, consumers, cluster, config, latest_producer_id_block, controller, brokers, controller_epoch]</span><br><span class=\"line\"></span><br><span class=\"line\">[zk: 127.0.0.1:2181(CONNECTED) 5] ls /brokers/topics</span><br><span class=\"line\">[hello, my-test, my-replicated-topi, my-replicated-topic, hello-kafka]</span><br></pre></td></tr></table></figure></p>\n<p>参考<br>zookeeper介绍 ：<a href=\"https://www.ibm.com/developerworks/cn/opensource/os-cn-zookeeper/\" target=\"_blank\" rel=\"noopener\">https://www.ibm.com/developerworks/cn/opensource/os-cn-zookeeper/</a><br>zookeeper官方文档 ：<a href=\"http://zookeeper.apache.org/doc/r3.4.10/zookeeperStarted.html\" target=\"_blank\" rel=\"noopener\">http://zookeeper.apache.org/doc/r3.4.10/zookeeperStarted.html</a><br>kafka官方文档 ：<a href=\"https://kafka.apache.org/documentation/\" target=\"_blank\" rel=\"noopener\">https://kafka.apache.org/documentation/</a><br>kafka文档翻译 ：<a href=\"http://www.orchome.com/472\" target=\"_blank\" rel=\"noopener\">http://www.orchome.com/472</a></p>\n","site":{"data":{}},"excerpt":"<p>系统版本 CentOS 6.6<br>java version 1.7<br>zookeeper版本 3.4.10<br>kafka版本 0.11.0.1</p>\n<h2 id=\"安装zookeeper\"><a href=\"#安装zookeeper\" class=\"headerlink\" title=\"安装zookeeper\"></a>安装zookeeper</h2><h3 id=\"1-下载\"><a href=\"#1-下载\" class=\"headerlink\" title=\"1.下载\"></a>1.下载</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://mirrors.tuna.tsinghua.edu.cn/apache/zookeeper/zookeeper-3.4.10/zookeeper-3.4.10.tar.gz</span><br><span class=\"line\">tar -xvf zookeeper-3.4.10.tar.gz</span><br></pre></td></tr></table></figure>","more":"<h3 id=\"2-修改配置文件\"><a href=\"#2-修改配置文件\" class=\"headerlink\" title=\"2.修改配置文件\"></a>2.修改配置文件</h3><p>把zoo_sample.cfg改成zoo.cfg<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> zookeeper-3.4.10/conf</span><br><span class=\"line\">mv zoo_sample.cfg zoo.cfg</span><br></pre></td></tr></table></figure></p>\n<p>配置文件说明：</p>\n<blockquote>\n<p>tickTime=2000<br>dataDir=/var/lib/zookeeper<br>clientPort=2181<br>initLimit=5<br>syncLimit=2<br>server.1=192.168.185.153:2888:3888<br>server.2=192.168.185.154:2888:3888<br>server.3=10.252.81.25:2888:3888</p>\n</blockquote>\n<ul>\n<li><strong>tickTime</strong>: 默认2000ms,zk的基本时间单位，用来做发送心跳消息的时间间隔，会话超时的最小时间是2×tickTime.</li>\n<li><strong>dataDir</strong>: 存储内存数据库快照的位置，也是更新数据库的事务日志的默认存储位置</li>\n<li><strong>clientPort</strong>: 给客户端连接的端口</li>\n<li><strong>initLimit</strong>: 用来配置 Zookeeper Leader接受Follower初始化连接时最长能忍受多少个心跳时间间隔数,默认5，即5×tickTime=10000ms</li>\n<li><strong>syncLimit</strong>:  Leader 与 Follower 之间发送消息，请求和应答时间长度，最长不能超过多少个 tickTime 的时间长度，总的时间长度就是 2*2000=4 秒</li>\n<li><strong>server.x</strong>: server.id=ip:port1:port2,使用伪集群模式时可以填写相同的ip（但是端口要不同）,port1是集群中实例通信的端口，port2是用来选举leader的端口</li>\n</ul>\n<p>在每个机器依次执行 1 2 两步，并使用相同的配置文件。</p>\n<h3 id=\"3-创建myid文件\"><a href=\"#3-创建myid文件\" class=\"headerlink\" title=\"3.创建myid文件\"></a>3.创建myid文件</h3><p>在配置的dataDir目录创建一个名为myid的文件，文件内容是配置的server.id的id对应的数字，用来告知机器它代表的server。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo &quot;3&quot;&gt;/var/lib/zookeeper/myid</span><br></pre></td></tr></table></figure></p>\n<p>最后执行 <code>bash bin/zkServer.sh start</code> 逐个启动zk</p>\n<h3 id=\"4-测试\"><a href=\"#4-测试\" class=\"headerlink\" title=\"4.测试\"></a>4.测试</h3><p>执行<code>bin/zkCli.sh -server 127.0.0.1:2181</code>启动客户端建立连接<br>看到<code>Welcome to ZooKeeper!</code>表示连接成功。</p>\n<h2 id=\"安装kafka\"><a href=\"#安装kafka\" class=\"headerlink\" title=\"安装kafka\"></a>安装kafka</h2><p>在安装并启动zookeeper之后，就可以安装kafka了。</p>\n<h3 id=\"1-下载-1\"><a href=\"#1-下载-1\" class=\"headerlink\" title=\"1.下载\"></a>1.下载</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget http://mirror.bit.edu.cn/apache/kafka/0.11.0.1/kafka_2.11-0.11.0.1.tgz</span><br><span class=\"line\">tar -xzf kafka_2.11-0.11.0.1.tgz</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-修改配置文件-1\"><a href=\"#2-修改配置文件-1\" class=\"headerlink\" title=\"2.修改配置文件\"></a>2.修改配置文件</h3><p>conf/server.properties文件<br>默认配置简要介绍如下，<a href=\"https://kafka.apache.org/documentation/#configuration\" target=\"_blank\" rel=\"noopener\">完整配置参考</a>：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># broker的唯一id</span></span><br><span class=\"line\">broker.id=0</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 接收请求发送响应的线程数</span></span><br><span class=\"line\">numnetwork.threads=3</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 处理请求的线程数（包含磁盘i/o）</span></span><br><span class=\"line\">num.io.threads=8</span><br><span class=\"line\"><span class=\"comment\"># The send buffer (SO_SNDBUF) used by the socket server</span></span><br><span class=\"line\">socket.send.buffer.bytes=102400</span><br><span class=\"line\"><span class=\"comment\"># The receive buffer (SO_RCVBUF) used by the socket server</span></span><br><span class=\"line\">socket.receive.buffer.bytes=102400</span><br><span class=\"line\"><span class=\"comment\"># The maximum size of a request that the socket server will accept (protection against OOM)</span></span><br><span class=\"line\">socket.request.max.bytes=104857600</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#Log Basics #</span></span><br><span class=\"line\"><span class=\"comment\"># 保存日志文件位置</span></span><br><span class=\"line\">log.dirs=/tmp/kafka-logs</span><br><span class=\"line\"><span class=\"comment\"># 每个主题默认的分区数</span></span><br><span class=\"line\">num.partitions=1</span><br><span class=\"line\"><span class=\"comment\"># 每个数据目录的数量，用于启动时的日志恢复和关机时的flush</span></span><br><span class=\"line\"><span class=\"comment\"># 对于具有位于RAID阵列中的数据目录的安装，建议增加此值。</span></span><br><span class=\"line\">num.recovery.threads.per.data.dir=1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#Internal Topic Settings  #############################</span></span><br><span class=\"line\"><span class=\"comment\"># offset topic的备份数   </span></span><br><span class=\"line\">offsets.topic.replication.factor=1</span><br><span class=\"line\">transaction.state.log.replication.factor=1</span><br><span class=\"line\">transaction.state.log.min.isr=1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">##Log Retention Policy 日志保留策略##################</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 至少保留多久</span></span><br><span class=\"line\">log.retention.hours=168</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 最大日志，超过会划分新日志</span></span><br><span class=\"line\">log.segment.bytes=1073741824</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 检查日志是否删除的时间间隔</span></span><br><span class=\"line\">log.retention.check.interval.ms=300000</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## Zookeeper #####</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Zookeeper 连接地址</span></span><br><span class=\"line\">zookeeper.connect=localhost:2181</span><br><span class=\"line\"><span class=\"comment\"># Zookeeper 连接 Timeout </span></span><br><span class=\"line\">zookeeper.connection.timeout.ms=6000</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">### Group Coordinator Settings####################</span></span><br><span class=\"line\"><span class=\"comment\">#0.11.0.0引入的新配置，指定当新成员加入组时，GroupCoordinator将延迟初始消费者重新平衡（rebalance）的时间（毫秒），重新平衡将进一步延迟group.initial.rebalance.delay.ms的值，最大值为max.poll.interval.ms。</span></span><br><span class=\"line\"><span class=\"comment\">#测试环境配置为0减少等待时间，生产环境建议配置3秒</span></span><br><span class=\"line\">group.initial.rebalance.delay.ms=0</span><br></pre></td></tr></table></figure></p>\n<p>修改这几个字段</p>\n<blockquote>\n<p>broker.id=yourid<br>num.parttions=3<br>offsets.topic.replication.factor=3<br>transaction.state.log.replication.factor=3<br>transaction.state.log.min.isr=2<br>zookeeper.connect=192.168.185.153:2181,192.168.185.154:2181,10.252.81.25:2181</p>\n</blockquote>\n<h3 id=\"3-启动kafka\"><a href=\"#3-启动kafka\" class=\"headerlink\" title=\"3.启动kafka\"></a>3.启动kafka</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bin/kafka-server-start.sh config/server.properties &amp;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-测试-1\"><a href=\"#4-测试-1\" class=\"headerlink\" title=\"4.测试\"></a>4.测试</h3><p>创建话题”hello-kafka”,复制2份，使用2个partition<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 2 --partitions 2 --topic hello-kafka</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>Created topic “hello-kafka”.</p>\n</blockquote>\n<p>查看kafka状态<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bin/kafka-topics.sh --describe --zookeeper localhost:2181 --topic hello-kafka</span><br></pre></td></tr></table></figure></p>\n<p>输出</p>\n<blockquote>\n<p>Topic:hello-kafka    PartitionCount:2    ReplicationFactor:2    Configs:<br>    Topic: hello-kafka    Partition: 0    Leader: 3    Replicas: 3,2    Isr: 3,2<br>    Topic: hello-kafka    Partition: 1    Leader: 1    Replicas: 1,3    Isr: 1</p>\n</blockquote>\n<p>连接zookeeper服务端，看到kafka在zookeeper保存的话题等信息<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[zk: 127.0.0.1:2181(CONNECTED) 2] ls /</span><br><span class=\"line\">[isr_change_notification, zookeeper, admin, consumers, cluster, config, latest_producer_id_block, controller, brokers, controller_epoch]</span><br><span class=\"line\"></span><br><span class=\"line\">[zk: 127.0.0.1:2181(CONNECTED) 5] ls /brokers/topics</span><br><span class=\"line\">[hello, my-test, my-replicated-topi, my-replicated-topic, hello-kafka]</span><br></pre></td></tr></table></figure></p>\n<p>参考<br>zookeeper介绍 ：<a href=\"https://www.ibm.com/developerworks/cn/opensource/os-cn-zookeeper/\" target=\"_blank\" rel=\"noopener\">https://www.ibm.com/developerworks/cn/opensource/os-cn-zookeeper/</a><br>zookeeper官方文档 ：<a href=\"http://zookeeper.apache.org/doc/r3.4.10/zookeeperStarted.html\" target=\"_blank\" rel=\"noopener\">http://zookeeper.apache.org/doc/r3.4.10/zookeeperStarted.html</a><br>kafka官方文档 ：<a href=\"https://kafka.apache.org/documentation/\" target=\"_blank\" rel=\"noopener\">https://kafka.apache.org/documentation/</a><br>kafka文档翻译 ：<a href=\"http://www.orchome.com/472\" target=\"_blank\" rel=\"noopener\">http://www.orchome.com/472</a></p>"},{"title":"为什么别人能把java gc讲清楚","date":"2020-05-26T18:13:10.000Z","_content":"\n你关于JavaGC的知识都是从哪儿学习的呢?是看博客或者看书还是看oracle的文档?今天来推荐 [Plumbr.io][1]上的一个文章(Plumbr是一家提供jvm监控和优化方案的公司),标题叫《Java Garbage Collection handbook》整个文章大概有75页,包括GC概念介绍/算法介绍/算法实现/gc调优等7个小节,这里只引用其中几个段落,来看一下作者是怎么介绍JavaGC知识的.\n\n<!--more-->\n\n### 形象地概括 Garbage Collection\n在[费曼学习法][2]中有这样一个逻辑:如果你不能把一个概念简化到让一个小孩子都能理解,那么说明你还没有掌握它. 在plumbr.io的文档第一节,作者形象地把gc和生活中的清理垃圾做对比: 打扫垃圾时我们会把垃圾挑出来然后扔掉, 而gc的过程是把需要保留的内存对象挑出来, 然后清理剩下的部分. **在文章开始先给出通俗又准确的定义,让别人对核心概念有一个认识**.\n\n>At first sight, garbage collection should be dealing with what the name suggests – finding and throwing away the garbage. In reality it is doing exactly the opposite. Garbage Collection is tracking down all the objects that are still used and marks the rest as garbage.\n\n### 先说为什么\n\n我们都知道jvm内存模型中堆内存是分代的,**那么为什么分代呢?又为什么要分成新生代和老年代呢?**\n\n在文章中,作者先介绍分代的原因:\n首先每次GC处理的对象越少,那么STW暂停的时间越短,所以把对象分为几个部分(分代也是一种分治的思想)\n>As we have mentioned before, doing a garbage collection entails stopping the application completely. It is also quite obvious that the more objects there are the longer it takes to collect all the garbage.But what if we would have a possibility to work with smaller memory regions? \n\n而分为young/old两部分,是因为根据研究人员通过对Java程序中的对象的观察得出的分代假设(Weak Generational Hypothesis),根据存活时间的不同,对象自然分为两个部分:\n{% asset_img 1.png image %}\n\n介绍JVM堆内存组成前,作者先介绍了Weak Generational Hypothesis,**先说为什么再说是什么**,可以让人更容易理解. 比如,在了解对象分代假设之后,因为通常对象只要活过一段时间后(中间的谷底),大多数都能活很久(右边),所以在young generational中添加了survivor区域,并且存活的对象要在两个survivor区域间复制几次才会进入老年代.\n\n>This process of copying the live objects between the two Survivor spaces is repeated several times until some objects are considered to have matured and are ‘old enough’. Remember that, based on the generational hypothesis, objects which have survived for some time are expected to continue to be used for very long time.\n\n{% asset_img 2.png image %}\n\n### 使用图片描述细节\ncms回收器的工作流程步骤比较多(有些书简化成了4步,明显和GC日志的输出对应不上),plumbr的在介绍cms回收器时使用一些精致的图片,来描述gc时内存中对象的变化.\n在Initial Mark阶段,图片上特别画出了跨代引用的对象,因为这个阶段只标记gc root直接引用的对象,所有有三个绿色obj.\n{% asset_img 3.png image %}\n而在concurrent mark阶段,又因为cms回收器会遍历对象,图中把间接引用的对象标记绿色.\n{% asset_img 4.png image %}\n画的最好的是preclean阶段,图中标记出了跨代引用更新之后,因为[card marking机制][7]被标记为dirty的card被clean的过程(红色的card被更新,看了这个两个图,我才理解preclean的过程和card marking的作用)\n{% asset_img 5.png image %}\n{% asset_img 6.png image %}\n### 总结\n最容易骗你的就是你自己,所以有时候你感觉自己懂了并不能说明你懂了,如果你能让别人也懂那你大概是真的懂,而让别人懂还需要有讲述问题的技巧才行.用一张图来总结plumbr的文章\n![nb](/images/nb.jpeg)\n\n***想看《Java Garbage Collection handbook》完整版的朋友,在公众号后台回复\"gc\"即可***\n\n  [1]: https://plumbr.io/java-garbage-collection-handbook\n  [2]: https://www.zhihu.com/question/20576786/answer/17338936\n  [3]: https://plumbr.io/app/uploads/2015/05/object-age-based-on-GC-generation-generational-hypothesis.png\n  [4]: https://plumbr.io/app/uploads/2015/05/how-java-garbage-collection-works.png\n  [5]: https://plumbr.io/app/uploads/2015/06/g1-06.png\n  [6]: https://plumbr.io/app/uploads/2015/06/g1-07.png\n  [7]: http://psy-lob-saw.blogspot.com/2014/10/the-jvm-write-barrier-card-marking.html\n  [8]: https://plumbr.io/app/uploads/2015/06/g1-08.png\n  [9]: https://plumbr.io/app/uploads/2015/06/g1-09.png","source":"_posts/为什么别人能把java-gc讲清楚.md","raw":"---\ntitle: 为什么别人能把java gc讲清楚\ndate: 2020-05-27 02:13:10\ntags: [java基础]\n---\n\n你关于JavaGC的知识都是从哪儿学习的呢?是看博客或者看书还是看oracle的文档?今天来推荐 [Plumbr.io][1]上的一个文章(Plumbr是一家提供jvm监控和优化方案的公司),标题叫《Java Garbage Collection handbook》整个文章大概有75页,包括GC概念介绍/算法介绍/算法实现/gc调优等7个小节,这里只引用其中几个段落,来看一下作者是怎么介绍JavaGC知识的.\n\n<!--more-->\n\n### 形象地概括 Garbage Collection\n在[费曼学习法][2]中有这样一个逻辑:如果你不能把一个概念简化到让一个小孩子都能理解,那么说明你还没有掌握它. 在plumbr.io的文档第一节,作者形象地把gc和生活中的清理垃圾做对比: 打扫垃圾时我们会把垃圾挑出来然后扔掉, 而gc的过程是把需要保留的内存对象挑出来, 然后清理剩下的部分. **在文章开始先给出通俗又准确的定义,让别人对核心概念有一个认识**.\n\n>At first sight, garbage collection should be dealing with what the name suggests – finding and throwing away the garbage. In reality it is doing exactly the opposite. Garbage Collection is tracking down all the objects that are still used and marks the rest as garbage.\n\n### 先说为什么\n\n我们都知道jvm内存模型中堆内存是分代的,**那么为什么分代呢?又为什么要分成新生代和老年代呢?**\n\n在文章中,作者先介绍分代的原因:\n首先每次GC处理的对象越少,那么STW暂停的时间越短,所以把对象分为几个部分(分代也是一种分治的思想)\n>As we have mentioned before, doing a garbage collection entails stopping the application completely. It is also quite obvious that the more objects there are the longer it takes to collect all the garbage.But what if we would have a possibility to work with smaller memory regions? \n\n而分为young/old两部分,是因为根据研究人员通过对Java程序中的对象的观察得出的分代假设(Weak Generational Hypothesis),根据存活时间的不同,对象自然分为两个部分:\n{% asset_img 1.png image %}\n\n介绍JVM堆内存组成前,作者先介绍了Weak Generational Hypothesis,**先说为什么再说是什么**,可以让人更容易理解. 比如,在了解对象分代假设之后,因为通常对象只要活过一段时间后(中间的谷底),大多数都能活很久(右边),所以在young generational中添加了survivor区域,并且存活的对象要在两个survivor区域间复制几次才会进入老年代.\n\n>This process of copying the live objects between the two Survivor spaces is repeated several times until some objects are considered to have matured and are ‘old enough’. Remember that, based on the generational hypothesis, objects which have survived for some time are expected to continue to be used for very long time.\n\n{% asset_img 2.png image %}\n\n### 使用图片描述细节\ncms回收器的工作流程步骤比较多(有些书简化成了4步,明显和GC日志的输出对应不上),plumbr的在介绍cms回收器时使用一些精致的图片,来描述gc时内存中对象的变化.\n在Initial Mark阶段,图片上特别画出了跨代引用的对象,因为这个阶段只标记gc root直接引用的对象,所有有三个绿色obj.\n{% asset_img 3.png image %}\n而在concurrent mark阶段,又因为cms回收器会遍历对象,图中把间接引用的对象标记绿色.\n{% asset_img 4.png image %}\n画的最好的是preclean阶段,图中标记出了跨代引用更新之后,因为[card marking机制][7]被标记为dirty的card被clean的过程(红色的card被更新,看了这个两个图,我才理解preclean的过程和card marking的作用)\n{% asset_img 5.png image %}\n{% asset_img 6.png image %}\n### 总结\n最容易骗你的就是你自己,所以有时候你感觉自己懂了并不能说明你懂了,如果你能让别人也懂那你大概是真的懂,而让别人懂还需要有讲述问题的技巧才行.用一张图来总结plumbr的文章\n![nb](/images/nb.jpeg)\n\n***想看《Java Garbage Collection handbook》完整版的朋友,在公众号后台回复\"gc\"即可***\n\n  [1]: https://plumbr.io/java-garbage-collection-handbook\n  [2]: https://www.zhihu.com/question/20576786/answer/17338936\n  [3]: https://plumbr.io/app/uploads/2015/05/object-age-based-on-GC-generation-generational-hypothesis.png\n  [4]: https://plumbr.io/app/uploads/2015/05/how-java-garbage-collection-works.png\n  [5]: https://plumbr.io/app/uploads/2015/06/g1-06.png\n  [6]: https://plumbr.io/app/uploads/2015/06/g1-07.png\n  [7]: http://psy-lob-saw.blogspot.com/2014/10/the-jvm-write-barrier-card-marking.html\n  [8]: https://plumbr.io/app/uploads/2015/06/g1-08.png\n  [9]: https://plumbr.io/app/uploads/2015/06/g1-09.png","slug":"为什么别人能把java-gc讲清楚","published":1,"updated":"2020-06-21T05:10:37.564Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkqle179000ucyned1txgs9z","content":"<p>你关于JavaGC的知识都是从哪儿学习的呢?是看博客或者看书还是看oracle的文档?今天来推荐 <a href=\"https://plumbr.io/java-garbage-collection-handbook\" target=\"_blank\" rel=\"noopener\">Plumbr.io</a>上的一个文章(Plumbr是一家提供jvm监控和优化方案的公司),标题叫《Java Garbage Collection handbook》整个文章大概有75页,包括GC概念介绍/算法介绍/算法实现/gc调优等7个小节,这里只引用其中几个段落,来看一下作者是怎么介绍JavaGC知识的.</p>\n<a id=\"more\"></a>\n<h3 id=\"形象地概括-Garbage-Collection\"><a href=\"#形象地概括-Garbage-Collection\" class=\"headerlink\" title=\"形象地概括 Garbage Collection\"></a>形象地概括 Garbage Collection</h3><p>在<a href=\"https://www.zhihu.com/question/20576786/answer/17338936\" target=\"_blank\" rel=\"noopener\">费曼学习法</a>中有这样一个逻辑:如果你不能把一个概念简化到让一个小孩子都能理解,那么说明你还没有掌握它. 在plumbr.io的文档第一节,作者形象地把gc和生活中的清理垃圾做对比: 打扫垃圾时我们会把垃圾挑出来然后扔掉, 而gc的过程是把需要保留的内存对象挑出来, 然后清理剩下的部分. <strong>在文章开始先给出通俗又准确的定义,让别人对核心概念有一个认识</strong>.</p>\n<blockquote>\n<p>At first sight, garbage collection should be dealing with what the name suggests – finding and throwing away the garbage. In reality it is doing exactly the opposite. Garbage Collection is tracking down all the objects that are still used and marks the rest as garbage.</p>\n</blockquote>\n<h3 id=\"先说为什么\"><a href=\"#先说为什么\" class=\"headerlink\" title=\"先说为什么\"></a>先说为什么</h3><p>我们都知道jvm内存模型中堆内存是分代的,<strong>那么为什么分代呢?又为什么要分成新生代和老年代呢?</strong></p>\n<p>在文章中,作者先介绍分代的原因:<br>首先每次GC处理的对象越少,那么STW暂停的时间越短,所以把对象分为几个部分(分代也是一种分治的思想)</p>\n<blockquote>\n<p>As we have mentioned before, doing a garbage collection entails stopping the application completely. It is also quite obvious that the more objects there are the longer it takes to collect all the garbage.But what if we would have a possibility to work with smaller memory regions? </p>\n</blockquote>\n<p>而分为young/old两部分,是因为根据研究人员通过对Java程序中的对象的观察得出的分代假设(Weak Generational Hypothesis),根据存活时间的不同,对象自然分为两个部分:<br><img src=\"/2020/05/27/为什么别人能把java-gc讲清楚/1.png\" title=\"image\"></p>\n<p>介绍JVM堆内存组成前,作者先介绍了Weak Generational Hypothesis,<strong>先说为什么再说是什么</strong>,可以让人更容易理解. 比如,在了解对象分代假设之后,因为通常对象只要活过一段时间后(中间的谷底),大多数都能活很久(右边),所以在young generational中添加了survivor区域,并且存活的对象要在两个survivor区域间复制几次才会进入老年代.</p>\n<blockquote>\n<p>This process of copying the live objects between the two Survivor spaces is repeated several times until some objects are considered to have matured and are ‘old enough’. Remember that, based on the generational hypothesis, objects which have survived for some time are expected to continue to be used for very long time.</p>\n</blockquote>\n<img src=\"/2020/05/27/为什么别人能把java-gc讲清楚/2.png\" title=\"image\">\n<h3 id=\"使用图片描述细节\"><a href=\"#使用图片描述细节\" class=\"headerlink\" title=\"使用图片描述细节\"></a>使用图片描述细节</h3><p>cms回收器的工作流程步骤比较多(有些书简化成了4步,明显和GC日志的输出对应不上),plumbr的在介绍cms回收器时使用一些精致的图片,来描述gc时内存中对象的变化.<br>在Initial Mark阶段,图片上特别画出了跨代引用的对象,因为这个阶段只标记gc root直接引用的对象,所有有三个绿色obj.<br><img src=\"/2020/05/27/为什么别人能把java-gc讲清楚/3.png\" title=\"image\"><br>而在concurrent mark阶段,又因为cms回收器会遍历对象,图中把间接引用的对象标记绿色.<br><img src=\"/2020/05/27/为什么别人能把java-gc讲清楚/4.png\" title=\"image\"><br>画的最好的是preclean阶段,图中标记出了跨代引用更新之后,因为<a href=\"http://psy-lob-saw.blogspot.com/2014/10/the-jvm-write-barrier-card-marking.html\" target=\"_blank\" rel=\"noopener\">card marking机制</a>被标记为dirty的card被clean的过程(红色的card被更新,看了这个两个图,我才理解preclean的过程和card marking的作用)<br><img src=\"/2020/05/27/为什么别人能把java-gc讲清楚/5.png\" title=\"image\"><br><img src=\"/2020/05/27/为什么别人能把java-gc讲清楚/6.png\" title=\"image\"></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>最容易骗你的就是你自己,所以有时候你感觉自己懂了并不能说明你懂了,如果你能让别人也懂那你大概是真的懂,而让别人懂还需要有讲述问题的技巧才行.用一张图来总结plumbr的文章<br><img src=\"/images/nb.jpeg\" alt=\"nb\"></p>\n<p><strong><em>想看《Java Garbage Collection handbook》完整版的朋友,在公众号后台回复”gc”即可</em></strong></p>\n","site":{"data":{}},"excerpt":"<p>你关于JavaGC的知识都是从哪儿学习的呢?是看博客或者看书还是看oracle的文档?今天来推荐 <a href=\"https://plumbr.io/java-garbage-collection-handbook\" target=\"_blank\" rel=\"noopener\">Plumbr.io</a>上的一个文章(Plumbr是一家提供jvm监控和优化方案的公司),标题叫《Java Garbage Collection handbook》整个文章大概有75页,包括GC概念介绍/算法介绍/算法实现/gc调优等7个小节,这里只引用其中几个段落,来看一下作者是怎么介绍JavaGC知识的.</p>","more":"<h3 id=\"形象地概括-Garbage-Collection\"><a href=\"#形象地概括-Garbage-Collection\" class=\"headerlink\" title=\"形象地概括 Garbage Collection\"></a>形象地概括 Garbage Collection</h3><p>在<a href=\"https://www.zhihu.com/question/20576786/answer/17338936\" target=\"_blank\" rel=\"noopener\">费曼学习法</a>中有这样一个逻辑:如果你不能把一个概念简化到让一个小孩子都能理解,那么说明你还没有掌握它. 在plumbr.io的文档第一节,作者形象地把gc和生活中的清理垃圾做对比: 打扫垃圾时我们会把垃圾挑出来然后扔掉, 而gc的过程是把需要保留的内存对象挑出来, 然后清理剩下的部分. <strong>在文章开始先给出通俗又准确的定义,让别人对核心概念有一个认识</strong>.</p>\n<blockquote>\n<p>At first sight, garbage collection should be dealing with what the name suggests – finding and throwing away the garbage. In reality it is doing exactly the opposite. Garbage Collection is tracking down all the objects that are still used and marks the rest as garbage.</p>\n</blockquote>\n<h3 id=\"先说为什么\"><a href=\"#先说为什么\" class=\"headerlink\" title=\"先说为什么\"></a>先说为什么</h3><p>我们都知道jvm内存模型中堆内存是分代的,<strong>那么为什么分代呢?又为什么要分成新生代和老年代呢?</strong></p>\n<p>在文章中,作者先介绍分代的原因:<br>首先每次GC处理的对象越少,那么STW暂停的时间越短,所以把对象分为几个部分(分代也是一种分治的思想)</p>\n<blockquote>\n<p>As we have mentioned before, doing a garbage collection entails stopping the application completely. It is also quite obvious that the more objects there are the longer it takes to collect all the garbage.But what if we would have a possibility to work with smaller memory regions? </p>\n</blockquote>\n<p>而分为young/old两部分,是因为根据研究人员通过对Java程序中的对象的观察得出的分代假设(Weak Generational Hypothesis),根据存活时间的不同,对象自然分为两个部分:<br><img src=\"/2020/05/27/为什么别人能把java-gc讲清楚/1.png\" title=\"image\"></p>\n<p>介绍JVM堆内存组成前,作者先介绍了Weak Generational Hypothesis,<strong>先说为什么再说是什么</strong>,可以让人更容易理解. 比如,在了解对象分代假设之后,因为通常对象只要活过一段时间后(中间的谷底),大多数都能活很久(右边),所以在young generational中添加了survivor区域,并且存活的对象要在两个survivor区域间复制几次才会进入老年代.</p>\n<blockquote>\n<p>This process of copying the live objects between the two Survivor spaces is repeated several times until some objects are considered to have matured and are ‘old enough’. Remember that, based on the generational hypothesis, objects which have survived for some time are expected to continue to be used for very long time.</p>\n</blockquote>\n<img src=\"/2020/05/27/为什么别人能把java-gc讲清楚/2.png\" title=\"image\">\n<h3 id=\"使用图片描述细节\"><a href=\"#使用图片描述细节\" class=\"headerlink\" title=\"使用图片描述细节\"></a>使用图片描述细节</h3><p>cms回收器的工作流程步骤比较多(有些书简化成了4步,明显和GC日志的输出对应不上),plumbr的在介绍cms回收器时使用一些精致的图片,来描述gc时内存中对象的变化.<br>在Initial Mark阶段,图片上特别画出了跨代引用的对象,因为这个阶段只标记gc root直接引用的对象,所有有三个绿色obj.<br><img src=\"/2020/05/27/为什么别人能把java-gc讲清楚/3.png\" title=\"image\"><br>而在concurrent mark阶段,又因为cms回收器会遍历对象,图中把间接引用的对象标记绿色.<br><img src=\"/2020/05/27/为什么别人能把java-gc讲清楚/4.png\" title=\"image\"><br>画的最好的是preclean阶段,图中标记出了跨代引用更新之后,因为<a href=\"http://psy-lob-saw.blogspot.com/2014/10/the-jvm-write-barrier-card-marking.html\" target=\"_blank\" rel=\"noopener\">card marking机制</a>被标记为dirty的card被clean的过程(红色的card被更新,看了这个两个图,我才理解preclean的过程和card marking的作用)<br><img src=\"/2020/05/27/为什么别人能把java-gc讲清楚/5.png\" title=\"image\"><br><img src=\"/2020/05/27/为什么别人能把java-gc讲清楚/6.png\" title=\"image\"></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>最容易骗你的就是你自己,所以有时候你感觉自己懂了并不能说明你懂了,如果你能让别人也懂那你大概是真的懂,而让别人懂还需要有讲述问题的技巧才行.用一张图来总结plumbr的文章<br><img src=\"/images/nb.jpeg\" alt=\"nb\"></p>\n<p><strong><em>想看《Java Garbage Collection handbook》完整版的朋友,在公众号后台回复”gc”即可</em></strong></p>"},{"title":"图解redis主从","date":"2017-10-22T13:15:46.000Z","_content":"\n### 一、建立连接\n\n当slave收到客户端发来的slave of 命令之后，首先会在redisServer结构体中保存master的host和ip地址，然后建立一个到master的socket连接。\n连接成功后，slave会发送PING命令来测试连接是否可用，成功获得响应后，执行REPLCONF命令把自己的listen_port发送到master,后者会在redisClient中包存slave的监听端口。\n<!--more-->\n\n![连接][1]\n### 二、初次同步数据\n连接成功后，slave会发送**PSYNC**命令请求同步数据，由于第一次同步，所以会执行一次**完整重同步**的过程，master收到请求后执行**BGSAVE**命令创建RDB文件[^code]，然后把数据发送到slave \n![full同步][2]\n### 三、命令传播（propagate）\n同步完成后，master收到的写命令，会由master发送到slave，保证数据同步。命令在master执行成功后会立刻向客户端发送结果，因此命令传播是**异步执行**的，因此redis只能保证主从数据的**最终一致性**。\n在命令传播的过程中，master不只把数据发送给slave,还会保存在AOF文件，和复制积压缓冲区(backlog buffer)内。[a]\n![此处输入图片的描述][3]\n### 四、增量重同步\n刚才提到的backlog buffer是一个FIFO的定长队列(环形队列实现)，默认1MB大小，可以通过`repl_backlog_size`配置。它的作用是保存最近的更新命令并记录offsetr。当slave断线重连时，如果能根据offset在buffer中找到丢失的数据,那么只需增量的复制丢失数据即可，不需要进行完成的重同步。\n![此处输入图片的描述][4]\n\n### 五、心跳消息\nslave定时向master发送REPLCONF命令，通知master当前的自己offset，当master发现slave复制落后时，会主动发送丢失了命令。\n心跳消息让master了解slave的连接状态，如果当前slave数量小于min-slave，master会拒绝写命令。info命令输出的lag值反应了slave的上次通信时间。（master也会主动向slave发送PING命令）\n```\n# Replication\nrole:master\nconnected_slaves:2\nslave0:ip=127.0.0.1,port=6381,state=online,offset=4518,lag=1\nslave1:ip=127.0.0.1,port=6380,state=online,offset=4518,lag=1\n```\n![heart][5]\n\n### 六、 补充\n这是一次重新连接的日志，从服务器发送同步请求，master回复rdb文件。日志中**Partial resynchronization not possible (no cached master)**表示尝试增量同步失败，在我使用redis 2.8.19版本时似乎无法模拟出增量同步的情况，每次断线重连都是完整同步，按照作者说明关闭了slave的aof也不行(同步时不能进行write aof)，[github上这个问题对应的issue][6]\n**从服务器**\n```[15846] 11 Jan 20:25:34.722 * DB loaded from disk: 2.233 seconds\n[15846] 11 Jan 20:25:34.722 * The server is now ready to accept connections on port 6380\n[15846] 11 Jan 20:25:35.490 * Connecting to MASTER 127.0.0.1:6379\n[15846] 11 Jan 20:25:35.491 * MASTER <-> SLAVE sync started\n[15846] 11 Jan 20:25:35.491 * Non blocking connect for SYNC fired the event.\n[15846] 11 Jan 20:25:35.491 * Master replied to PING, replication can continue...\n[15846] 11 Jan 20:25:35.491 * Partial resynchronization not possible (no cached master)\n[15846] 11 Jan 20:25:35.495 * Full resync from master: 13cb06d81ed35702e1cf20dba3aa1159b9a068bd:15931\n[15846] 11 Jan 20:25:41.428 * MASTER <-> SLAVE sync: receiving 225990523 bytes from master\n[15846] 11 Jan 20:25:44.383 * MASTER <-> SLAVE sync: Flushing old data\n[15846] 11 Jan 20:25:44.560 * MASTER <-> SLAVE sync: Loading DB in memory\n[15846] 11 Jan 20:25:46.948 * MASTER <-> SLAVE sync: Finished with success```\n**主服务器：**\n```[14562] 11 Jan 20:23:17.478 # Connection with slave 127.0.0.1:6380 lost.\n[14562] 11 Jan 20:23:29.644 # Connection with slave 127.0.0.1:6381 lost.\n[14562] 11 Jan 20:25:35.492 * Slave 127.0.0.1:6380 asks for synchronization\n[14562] 11 Jan 20:25:35.492 * Full resync requested by slave 127.0.0.1:6380\n[14562] 11 Jan 20:25:35.492 * Starting BGSAVE for SYNC with target: disk\n[14562] 11 Jan 20:25:35.494 * Background saving started by pid 15849\n[14562] 11 Jan 20:25:40.504 * Slave 127.0.0.1:6381 asks for synchronization\n[14562] 11 Jan 20:25:40.504 * Full resync requested by slave 127.0.0.1:6381\n[14562] 11 Jan 20:25:40.504 * Waiting for end of BGSAVE for SYNC\n[15849] 11 Jan 20:25:41.341 * DB saved on disk\n[15849] 11 Jan 20:25:41.342 * RDB: 76 MB of memory used by copy-on-write\n[14562] 11 Jan 20:25:41.427 * Background saving terminated with success\n[14562] 11 Jan 20:25:44.180 * Synchronization with slave 127.0.0.1:6381 succeeded\n[14562] 11 Jan 20:25:44.461 * Synchronization with slave 127.0.0.1:6380 succeeded```\n\n\n[^code]: 当配置设置同步方式为Disk-backed时才会把RDB文件写入磁盘，Diskless模式会直接把RDB文件写到slave的socket\n\n\n  [1]: /images/redis/conn1.png\n  [2]: /images/redis/FULLSYNC.png\n  [3]: /images/redis/prpogate2.png\n  [4]: /images/redis/incssync.png\n  [5]: /images/redis/ping.png\n  [6]: https://github.com/antirez/redis/issues/4102","source":"_posts/图解redis主从.md","raw":"\ntitle: 图解redis主从\ndate: 2017-10-22 21:15:46\ncategories: redis进阶\ntags: [redis,nosql,源码]\n---\n\n### 一、建立连接\n\n当slave收到客户端发来的slave of 命令之后，首先会在redisServer结构体中保存master的host和ip地址，然后建立一个到master的socket连接。\n连接成功后，slave会发送PING命令来测试连接是否可用，成功获得响应后，执行REPLCONF命令把自己的listen_port发送到master,后者会在redisClient中包存slave的监听端口。\n<!--more-->\n\n![连接][1]\n### 二、初次同步数据\n连接成功后，slave会发送**PSYNC**命令请求同步数据，由于第一次同步，所以会执行一次**完整重同步**的过程，master收到请求后执行**BGSAVE**命令创建RDB文件[^code]，然后把数据发送到slave \n![full同步][2]\n### 三、命令传播（propagate）\n同步完成后，master收到的写命令，会由master发送到slave，保证数据同步。命令在master执行成功后会立刻向客户端发送结果，因此命令传播是**异步执行**的，因此redis只能保证主从数据的**最终一致性**。\n在命令传播的过程中，master不只把数据发送给slave,还会保存在AOF文件，和复制积压缓冲区(backlog buffer)内。[a]\n![此处输入图片的描述][3]\n### 四、增量重同步\n刚才提到的backlog buffer是一个FIFO的定长队列(环形队列实现)，默认1MB大小，可以通过`repl_backlog_size`配置。它的作用是保存最近的更新命令并记录offsetr。当slave断线重连时，如果能根据offset在buffer中找到丢失的数据,那么只需增量的复制丢失数据即可，不需要进行完成的重同步。\n![此处输入图片的描述][4]\n\n### 五、心跳消息\nslave定时向master发送REPLCONF命令，通知master当前的自己offset，当master发现slave复制落后时，会主动发送丢失了命令。\n心跳消息让master了解slave的连接状态，如果当前slave数量小于min-slave，master会拒绝写命令。info命令输出的lag值反应了slave的上次通信时间。（master也会主动向slave发送PING命令）\n```\n# Replication\nrole:master\nconnected_slaves:2\nslave0:ip=127.0.0.1,port=6381,state=online,offset=4518,lag=1\nslave1:ip=127.0.0.1,port=6380,state=online,offset=4518,lag=1\n```\n![heart][5]\n\n### 六、 补充\n这是一次重新连接的日志，从服务器发送同步请求，master回复rdb文件。日志中**Partial resynchronization not possible (no cached master)**表示尝试增量同步失败，在我使用redis 2.8.19版本时似乎无法模拟出增量同步的情况，每次断线重连都是完整同步，按照作者说明关闭了slave的aof也不行(同步时不能进行write aof)，[github上这个问题对应的issue][6]\n**从服务器**\n```[15846] 11 Jan 20:25:34.722 * DB loaded from disk: 2.233 seconds\n[15846] 11 Jan 20:25:34.722 * The server is now ready to accept connections on port 6380\n[15846] 11 Jan 20:25:35.490 * Connecting to MASTER 127.0.0.1:6379\n[15846] 11 Jan 20:25:35.491 * MASTER <-> SLAVE sync started\n[15846] 11 Jan 20:25:35.491 * Non blocking connect for SYNC fired the event.\n[15846] 11 Jan 20:25:35.491 * Master replied to PING, replication can continue...\n[15846] 11 Jan 20:25:35.491 * Partial resynchronization not possible (no cached master)\n[15846] 11 Jan 20:25:35.495 * Full resync from master: 13cb06d81ed35702e1cf20dba3aa1159b9a068bd:15931\n[15846] 11 Jan 20:25:41.428 * MASTER <-> SLAVE sync: receiving 225990523 bytes from master\n[15846] 11 Jan 20:25:44.383 * MASTER <-> SLAVE sync: Flushing old data\n[15846] 11 Jan 20:25:44.560 * MASTER <-> SLAVE sync: Loading DB in memory\n[15846] 11 Jan 20:25:46.948 * MASTER <-> SLAVE sync: Finished with success```\n**主服务器：**\n```[14562] 11 Jan 20:23:17.478 # Connection with slave 127.0.0.1:6380 lost.\n[14562] 11 Jan 20:23:29.644 # Connection with slave 127.0.0.1:6381 lost.\n[14562] 11 Jan 20:25:35.492 * Slave 127.0.0.1:6380 asks for synchronization\n[14562] 11 Jan 20:25:35.492 * Full resync requested by slave 127.0.0.1:6380\n[14562] 11 Jan 20:25:35.492 * Starting BGSAVE for SYNC with target: disk\n[14562] 11 Jan 20:25:35.494 * Background saving started by pid 15849\n[14562] 11 Jan 20:25:40.504 * Slave 127.0.0.1:6381 asks for synchronization\n[14562] 11 Jan 20:25:40.504 * Full resync requested by slave 127.0.0.1:6381\n[14562] 11 Jan 20:25:40.504 * Waiting for end of BGSAVE for SYNC\n[15849] 11 Jan 20:25:41.341 * DB saved on disk\n[15849] 11 Jan 20:25:41.342 * RDB: 76 MB of memory used by copy-on-write\n[14562] 11 Jan 20:25:41.427 * Background saving terminated with success\n[14562] 11 Jan 20:25:44.180 * Synchronization with slave 127.0.0.1:6381 succeeded\n[14562] 11 Jan 20:25:44.461 * Synchronization with slave 127.0.0.1:6380 succeeded```\n\n\n[^code]: 当配置设置同步方式为Disk-backed时才会把RDB文件写入磁盘，Diskless模式会直接把RDB文件写到slave的socket\n\n\n  [1]: /images/redis/conn1.png\n  [2]: /images/redis/FULLSYNC.png\n  [3]: /images/redis/prpogate2.png\n  [4]: /images/redis/incssync.png\n  [5]: /images/redis/ping.png\n  [6]: https://github.com/antirez/redis/issues/4102","slug":"图解redis主从","published":1,"updated":"2019-05-04T16:09:49.938Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkqle179000vcynes787cn95","content":"<h3 id=\"一、建立连接\"><a href=\"#一、建立连接\" class=\"headerlink\" title=\"一、建立连接\"></a>一、建立连接</h3><p>当slave收到客户端发来的slave of 命令之后，首先会在redisServer结构体中保存master的host和ip地址，然后建立一个到master的socket连接。<br>连接成功后，slave会发送PING命令来测试连接是否可用，成功获得响应后，执行REPLCONF命令把自己的listen_port发送到master,后者会在redisClient中包存slave的监听端口。<br><a id=\"more\"></a></p>\n<p><img src=\"/images/redis/conn1.png\" alt=\"连接\"></p>\n<h3 id=\"二、初次同步数据\"><a href=\"#二、初次同步数据\" class=\"headerlink\" title=\"二、初次同步数据\"></a>二、初次同步数据</h3><p>连接成功后，slave会发送<strong>PSYNC</strong>命令请求同步数据，由于第一次同步，所以会执行一次<strong>完整重同步</strong>的过程，master收到请求后执行<strong>BGSAVE</strong>命令创建RDB文件<a href=\"当配置设置同步方式为Disk-backed时才会把RDB文件写入磁盘，Diskless模式会直接把RDB文件写到slave的socket\">^code</a>，然后把数据发送到slave<br><img src=\"/images/redis/FULLSYNC.png\" alt=\"full同步\"></p>\n<h3 id=\"三、命令传播（propagate）\"><a href=\"#三、命令传播（propagate）\" class=\"headerlink\" title=\"三、命令传播（propagate）\"></a>三、命令传播（propagate）</h3><p>同步完成后，master收到的写命令，会由master发送到slave，保证数据同步。命令在master执行成功后会立刻向客户端发送结果，因此命令传播是<strong>异步执行</strong>的，因此redis只能保证主从数据的<strong>最终一致性</strong>。<br>在命令传播的过程中，master不只把数据发送给slave,还会保存在AOF文件，和复制积压缓冲区(backlog buffer)内。[a]<br><img src=\"/images/redis/prpogate2.png\" alt=\"此处输入图片的描述\"></p>\n<h3 id=\"四、增量重同步\"><a href=\"#四、增量重同步\" class=\"headerlink\" title=\"四、增量重同步\"></a>四、增量重同步</h3><p>刚才提到的backlog buffer是一个FIFO的定长队列(环形队列实现)，默认1MB大小，可以通过<code>repl_backlog_size</code>配置。它的作用是保存最近的更新命令并记录offsetr。当slave断线重连时，如果能根据offset在buffer中找到丢失的数据,那么只需增量的复制丢失数据即可，不需要进行完成的重同步。<br><img src=\"/images/redis/incssync.png\" alt=\"此处输入图片的描述\"></p>\n<h3 id=\"五、心跳消息\"><a href=\"#五、心跳消息\" class=\"headerlink\" title=\"五、心跳消息\"></a>五、心跳消息</h3><p>slave定时向master发送REPLCONF命令，通知master当前的自己offset，当master发现slave复制落后时，会主动发送丢失了命令。<br>心跳消息让master了解slave的连接状态，如果当前slave数量小于min-slave，master会拒绝写命令。info命令输出的lag值反应了slave的上次通信时间。（master也会主动向slave发送PING命令）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Replication</span><br><span class=\"line\">role:master</span><br><span class=\"line\">connected_slaves:2</span><br><span class=\"line\">slave0:ip=127.0.0.1,port=6381,state=online,offset=4518,lag=1</span><br><span class=\"line\">slave1:ip=127.0.0.1,port=6380,state=online,offset=4518,lag=1</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"/images/redis/ping.png\" alt=\"heart\"></p>\n<h3 id=\"六、-补充\"><a href=\"#六、-补充\" class=\"headerlink\" title=\"六、 补充\"></a>六、 补充</h3><p>这是一次重新连接的日志，从服务器发送同步请求，master回复rdb文件。日志中<strong>Partial resynchronization not possible (no cached master)</strong>表示尝试增量同步失败，在我使用redis 2.8.19版本时似乎无法模拟出增量同步的情况，每次断线重连都是完整同步，按照作者说明关闭了slave的aof也不行(同步时不能进行write aof)，<a href=\"https://github.com/antirez/redis/issues/4102\" target=\"_blank\" rel=\"noopener\">github上这个问题对应的issue</a><br><strong>从服务器</strong><br><figure class=\"highlight plain\"><figcaption><span>11 Jan 20:25:34.722 * DB loaded from disk: 2.233 seconds</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[15846] 11 Jan 20:25:34.722 * The server is now ready to accept connections on port 6380</span><br><span class=\"line\">[15846] 11 Jan 20:25:35.490 * Connecting to MASTER 127.0.0.1:6379</span><br><span class=\"line\">[15846] 11 Jan 20:25:35.491 * MASTER &lt;-&gt; SLAVE sync started</span><br><span class=\"line\">[15846] 11 Jan 20:25:35.491 * Non blocking connect for SYNC fired the event.</span><br><span class=\"line\">[15846] 11 Jan 20:25:35.491 * Master replied to PING, replication can continue...</span><br><span class=\"line\">[15846] 11 Jan 20:25:35.491 * Partial resynchronization not possible (no cached master)</span><br><span class=\"line\">[15846] 11 Jan 20:25:35.495 * Full resync from master: 13cb06d81ed35702e1cf20dba3aa1159b9a068bd:15931</span><br><span class=\"line\">[15846] 11 Jan 20:25:41.428 * MASTER &lt;-&gt; SLAVE sync: receiving 225990523 bytes from master</span><br><span class=\"line\">[15846] 11 Jan 20:25:44.383 * MASTER &lt;-&gt; SLAVE sync: Flushing old data</span><br><span class=\"line\">[15846] 11 Jan 20:25:44.560 * MASTER &lt;-&gt; SLAVE sync: Loading DB in memory</span><br><span class=\"line\">[15846] 11 Jan 20:25:46.948 * MASTER &lt;-&gt; SLAVE sync: Finished with success</span><br></pre></td></tr></table></figure></p>\n<p><strong>主服务器：</strong><br><figure class=\"highlight plain\"><figcaption><span>11 Jan 20:23:17.478 # Connection with slave 127.0.0.1:6380 lost.</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[14562] 11 Jan 20:23:29.644 # Connection with slave 127.0.0.1:6381 lost.</span><br><span class=\"line\">[14562] 11 Jan 20:25:35.492 * Slave 127.0.0.1:6380 asks for synchronization</span><br><span class=\"line\">[14562] 11 Jan 20:25:35.492 * Full resync requested by slave 127.0.0.1:6380</span><br><span class=\"line\">[14562] 11 Jan 20:25:35.492 * Starting BGSAVE for SYNC with target: disk</span><br><span class=\"line\">[14562] 11 Jan 20:25:35.494 * Background saving started by pid 15849</span><br><span class=\"line\">[14562] 11 Jan 20:25:40.504 * Slave 127.0.0.1:6381 asks for synchronization</span><br><span class=\"line\">[14562] 11 Jan 20:25:40.504 * Full resync requested by slave 127.0.0.1:6381</span><br><span class=\"line\">[14562] 11 Jan 20:25:40.504 * Waiting for end of BGSAVE for SYNC</span><br><span class=\"line\">[15849] 11 Jan 20:25:41.341 * DB saved on disk</span><br><span class=\"line\">[15849] 11 Jan 20:25:41.342 * RDB: 76 MB of memory used by copy-on-write</span><br><span class=\"line\">[14562] 11 Jan 20:25:41.427 * Background saving terminated with success</span><br><span class=\"line\">[14562] 11 Jan 20:25:44.180 * Synchronization with slave 127.0.0.1:6381 succeeded</span><br><span class=\"line\">[14562] 11 Jan 20:25:44.461 * Synchronization with slave 127.0.0.1:6380 succeeded</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"一、建立连接\"><a href=\"#一、建立连接\" class=\"headerlink\" title=\"一、建立连接\"></a>一、建立连接</h3><p>当slave收到客户端发来的slave of 命令之后，首先会在redisServer结构体中保存master的host和ip地址，然后建立一个到master的socket连接。<br>连接成功后，slave会发送PING命令来测试连接是否可用，成功获得响应后，执行REPLCONF命令把自己的listen_port发送到master,后者会在redisClient中包存slave的监听端口。<br>","more":"</p>\n<p><img src=\"/images/redis/conn1.png\" alt=\"连接\"></p>\n<h3 id=\"二、初次同步数据\"><a href=\"#二、初次同步数据\" class=\"headerlink\" title=\"二、初次同步数据\"></a>二、初次同步数据</h3><p>连接成功后，slave会发送<strong>PSYNC</strong>命令请求同步数据，由于第一次同步，所以会执行一次<strong>完整重同步</strong>的过程，master收到请求后执行<strong>BGSAVE</strong>命令创建RDB文件<a href=\"当配置设置同步方式为Disk-backed时才会把RDB文件写入磁盘，Diskless模式会直接把RDB文件写到slave的socket\">^code</a>，然后把数据发送到slave<br><img src=\"/images/redis/FULLSYNC.png\" alt=\"full同步\"></p>\n<h3 id=\"三、命令传播（propagate）\"><a href=\"#三、命令传播（propagate）\" class=\"headerlink\" title=\"三、命令传播（propagate）\"></a>三、命令传播（propagate）</h3><p>同步完成后，master收到的写命令，会由master发送到slave，保证数据同步。命令在master执行成功后会立刻向客户端发送结果，因此命令传播是<strong>异步执行</strong>的，因此redis只能保证主从数据的<strong>最终一致性</strong>。<br>在命令传播的过程中，master不只把数据发送给slave,还会保存在AOF文件，和复制积压缓冲区(backlog buffer)内。[a]<br><img src=\"/images/redis/prpogate2.png\" alt=\"此处输入图片的描述\"></p>\n<h3 id=\"四、增量重同步\"><a href=\"#四、增量重同步\" class=\"headerlink\" title=\"四、增量重同步\"></a>四、增量重同步</h3><p>刚才提到的backlog buffer是一个FIFO的定长队列(环形队列实现)，默认1MB大小，可以通过<code>repl_backlog_size</code>配置。它的作用是保存最近的更新命令并记录offsetr。当slave断线重连时，如果能根据offset在buffer中找到丢失的数据,那么只需增量的复制丢失数据即可，不需要进行完成的重同步。<br><img src=\"/images/redis/incssync.png\" alt=\"此处输入图片的描述\"></p>\n<h3 id=\"五、心跳消息\"><a href=\"#五、心跳消息\" class=\"headerlink\" title=\"五、心跳消息\"></a>五、心跳消息</h3><p>slave定时向master发送REPLCONF命令，通知master当前的自己offset，当master发现slave复制落后时，会主动发送丢失了命令。<br>心跳消息让master了解slave的连接状态，如果当前slave数量小于min-slave，master会拒绝写命令。info命令输出的lag值反应了slave的上次通信时间。（master也会主动向slave发送PING命令）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Replication</span><br><span class=\"line\">role:master</span><br><span class=\"line\">connected_slaves:2</span><br><span class=\"line\">slave0:ip=127.0.0.1,port=6381,state=online,offset=4518,lag=1</span><br><span class=\"line\">slave1:ip=127.0.0.1,port=6380,state=online,offset=4518,lag=1</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"/images/redis/ping.png\" alt=\"heart\"></p>\n<h3 id=\"六、-补充\"><a href=\"#六、-补充\" class=\"headerlink\" title=\"六、 补充\"></a>六、 补充</h3><p>这是一次重新连接的日志，从服务器发送同步请求，master回复rdb文件。日志中<strong>Partial resynchronization not possible (no cached master)</strong>表示尝试增量同步失败，在我使用redis 2.8.19版本时似乎无法模拟出增量同步的情况，每次断线重连都是完整同步，按照作者说明关闭了slave的aof也不行(同步时不能进行write aof)，<a href=\"https://github.com/antirez/redis/issues/4102\" target=\"_blank\" rel=\"noopener\">github上这个问题对应的issue</a><br><strong>从服务器</strong><br><figure class=\"highlight plain\"><figcaption><span>11 Jan 20:25:34.722 * DB loaded from disk: 2.233 seconds</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[15846] 11 Jan 20:25:34.722 * The server is now ready to accept connections on port 6380</span><br><span class=\"line\">[15846] 11 Jan 20:25:35.490 * Connecting to MASTER 127.0.0.1:6379</span><br><span class=\"line\">[15846] 11 Jan 20:25:35.491 * MASTER &lt;-&gt; SLAVE sync started</span><br><span class=\"line\">[15846] 11 Jan 20:25:35.491 * Non blocking connect for SYNC fired the event.</span><br><span class=\"line\">[15846] 11 Jan 20:25:35.491 * Master replied to PING, replication can continue...</span><br><span class=\"line\">[15846] 11 Jan 20:25:35.491 * Partial resynchronization not possible (no cached master)</span><br><span class=\"line\">[15846] 11 Jan 20:25:35.495 * Full resync from master: 13cb06d81ed35702e1cf20dba3aa1159b9a068bd:15931</span><br><span class=\"line\">[15846] 11 Jan 20:25:41.428 * MASTER &lt;-&gt; SLAVE sync: receiving 225990523 bytes from master</span><br><span class=\"line\">[15846] 11 Jan 20:25:44.383 * MASTER &lt;-&gt; SLAVE sync: Flushing old data</span><br><span class=\"line\">[15846] 11 Jan 20:25:44.560 * MASTER &lt;-&gt; SLAVE sync: Loading DB in memory</span><br><span class=\"line\">[15846] 11 Jan 20:25:46.948 * MASTER &lt;-&gt; SLAVE sync: Finished with success</span><br></pre></td></tr></table></figure></p>\n<p><strong>主服务器：</strong><br><figure class=\"highlight plain\"><figcaption><span>11 Jan 20:23:17.478 # Connection with slave 127.0.0.1:6380 lost.</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[14562] 11 Jan 20:23:29.644 # Connection with slave 127.0.0.1:6381 lost.</span><br><span class=\"line\">[14562] 11 Jan 20:25:35.492 * Slave 127.0.0.1:6380 asks for synchronization</span><br><span class=\"line\">[14562] 11 Jan 20:25:35.492 * Full resync requested by slave 127.0.0.1:6380</span><br><span class=\"line\">[14562] 11 Jan 20:25:35.492 * Starting BGSAVE for SYNC with target: disk</span><br><span class=\"line\">[14562] 11 Jan 20:25:35.494 * Background saving started by pid 15849</span><br><span class=\"line\">[14562] 11 Jan 20:25:40.504 * Slave 127.0.0.1:6381 asks for synchronization</span><br><span class=\"line\">[14562] 11 Jan 20:25:40.504 * Full resync requested by slave 127.0.0.1:6381</span><br><span class=\"line\">[14562] 11 Jan 20:25:40.504 * Waiting for end of BGSAVE for SYNC</span><br><span class=\"line\">[15849] 11 Jan 20:25:41.341 * DB saved on disk</span><br><span class=\"line\">[15849] 11 Jan 20:25:41.342 * RDB: 76 MB of memory used by copy-on-write</span><br><span class=\"line\">[14562] 11 Jan 20:25:41.427 * Background saving terminated with success</span><br><span class=\"line\">[14562] 11 Jan 20:25:44.180 * Synchronization with slave 127.0.0.1:6381 succeeded</span><br><span class=\"line\">[14562] 11 Jan 20:25:44.461 * Synchronization with slave 127.0.0.1:6380 succeeded</span><br></pre></td></tr></table></figure></p>"},{"title":"量化交易入门","date":"2020-01-31T02:24:31.000Z","_content":"\n之前听说过一些通过python编写交易策略的量化交易平台，现在来了解一下交易平台的使用方式。这篇文章会演示怎么在交易平台上编写一个简单基金定投策略。\n\n## 量化交易介绍\n\n> [量化交易（Quantitative Trading）](https://wiki.mbalib.com/wiki/%E9%87%8F%E5%8C%96%E4%BA%A4%E6%98%93)是指借助现代统计学和数学的方法，利用计算机技术来进行交易的证券投资方式。\n\n量化交易的核心是数学模型，编程只是量化交易的实现方式。数学模型的评估方式是通过输入历史数据让我们“穿越”回之前的某一个时刻，然后按照模型进行交易，对比策略带来的收益（回测）。如果严格按照数据进行决策，量化交易可以克服人性的弱点，也可以克服认知偏差，另外在一个很大的资本市场，比如有成千上万只股票的时候，量化交易有更强的信息处理能力，能捕捉更多的投资机会。不过因为模型主要是根据历史数据来构建的，所以它吸收新的信息的能力比较迟钝。一旦发生某些重大事件（比如东哥事件～），有效性很可能就会受到影响。现在国内也有一些量化交易的主题基金，和其他主题的基金相比表现比较一般。\n\n<!--more-->\n\n<div align=center> {% asset_img found.jpeg image %} </div>\n\n量化投资的代表人物是[詹姆斯·西蒙斯](https://wiki.mbalib.com/wiki/%E8%A5%BF%E8%92%99%E6%96%AF)（James Simons），他是一位数学家，和陈省身一起提出了“陈-西蒙斯定理”，后来成立了文艺复兴科技公司开始从事量化交易，截至2019年10月，他的净资产估计为216亿美元，美国排名21位。\n\n<div align=center> {% asset_img james.jpg image %} </div>\n\n（西蒙斯公司旗下的大奖章基金，在2008年标普500指数下跌37％时，扣除费用后的收益为82％）\n\n## 量化交易平台\n\n量化交易平台提供了开发交易策略的平台，一般都会提供比较完整的股票/基金/期货数据，还有策略的在线运行环境。在百度上搜索“量化交易平台”，我随便选了一个叫“JoinQuant聚宽”的平台，地址是 https://www.joinquant.com ，后面的演示以这个平台为准。\n\n\n## 编写交易策略\n\n在joinquant上注册之后，就可以新建交易策略了,下面是一个基金定投策略的代码：\n\n代码很简单，initialize执行交易前的准备工作，函数buy执行具体的交易操作\n\n在initialize函数中：\n\n`set_benchmark` 会设置一个和你的策略对比的基准，000016.XSHG是上证50股票代码\n\n`set_option` 可以设定一些自定义配置，开启了动态复权， [可以在回测时使用真实的价格交易](https://blog.csdn.net/ywbhnay/article/details/100848696)\n\n`set_subportfolios` 设置账户资金和账户类型（open_fund代表场外基金）\n\n`set_redeem_latency` 设置赎回到账日为T+2(stock_fund代表股票型基金)\n\n`run_weekly` 设置交易函数的运行频率，每周一参考 reference_security 的开盘时间（每天9:30按昨日净值买入）\n\n\n**注意** 在选择基准的时候最好选择股票代码，我在使用上证50的基金502049.XSHG时,发现基准收益率有不准确的问题\n\n在buy函数中：\n\n参数context 包含了当前账户信息和持仓信息\ns 代表要定投的基金，定投策略是每周一买入1000元，当基金价格超过持仓成本50%后全部卖出\n\n\n```python\ndef initialize(context):\n    # 设定基准\n    set_benchmark('000016.XSHG')\n    # 开启动态复权模式(真实价格)\n    set_option(\"use_real_price\", True)\n\n    ### 场外基金相关设定 ###\n    # 设置账户类型: 场外基金账户\n    set_subportfolios([SubPortfolioConfig(context.portfolio.cash, 'open_fund')])\n    # 设置赎回到账日\n    set_redeem_latency(2, 'stock_fund')\n\n    ## 运行函数（reference_security为运行时间的参考标的；传入的标的只做种类区分，因此传入'000300.XSHG'或'510300.XSHG'是一样的）\n    # 开盘时运行\n    run_weekly(buy, weekday=1, reference_security='000016.XSHG')\n\ndef buy(context):\n    # 设置场外基金标的为易方达上证50指数A('110003.OF')\n    s = '110003.OF'\n    # 止盈线\n    max_profit = 0.50\n    # 持仓成本和当前价格\n    avg = context.portfolio.positions[s].avg_cost\n    price = context.portfolio.positions[s].price\n\n    # 打印当前收益\n    log.info('returns=',context.portfolio.total_value)\n    if avg != 0 and price !=0:\n        if (price-avg)/avg > max_profit:\n            log.info('sell:',context.portfolio.positions[s].closeable_amount)\n            redeem(s,context.portfolio.positions[s].closeable_amount)\n            return\n    # 申购基金\n    o = purchase(s, 1000)\n```\n\n策略写完之后，可以直接在平台上调试，选择运行的起止时间，还有初始资金，点击编译运行即可（为了提高运行速度，调试时不用选择太长的时间间隔）：\n\n{% asset_img debug.png image %}\n\n## 策略回测\n\n要想获得更详细的收益信息，可以点击运行回测按钮，回测的时间跨度可以更长一点，我这里选择的是2016-01-01到2020-01-20，初始资金为20万。回测结果如下图，\n红色是基准收益，就是第一个交易日用全部资金买入上证50之后的收益率，蓝色是定投的收益，定投4年的收益率为46%，重点关注收益率和最大回撤率,最大回撤率代表最倒霉的情况下策略的亏损。\n\n{% asset_img run.png image %}\n\n如果调整max_profit改为30%止盈，最大回撤率会降低，但是收益也会下降：\n\n{% asset_img run1.png image %}\n\n## 模拟交易\n\n回测只能说明策略的历史表现如何，我们还可以通过模拟交易让策略按照当前股市的真实情况运行一段时间，观察实际表现。关注了joinquant的公众号之后，还可以接收微信通知，不过模拟交易有时间限制，需要通过积分续费。\n\n{% asset_img real.png image %}\n\n## 总结\n\n借助交易平台只需要有一点编程基础和理财经验就可以编写自己的交易策略，主要的学习成本都在金融常识和各种交易指标上。另外在测试策略时最好和其他网站对比一下数据，确保基础数据都是准确的。","source":"_posts/量化交易入门.md","raw":"---\ntitle: 量化交易入门\ndate: 2020-01-31 10:24:31\ntags: [理财]\n---\n\n之前听说过一些通过python编写交易策略的量化交易平台，现在来了解一下交易平台的使用方式。这篇文章会演示怎么在交易平台上编写一个简单基金定投策略。\n\n## 量化交易介绍\n\n> [量化交易（Quantitative Trading）](https://wiki.mbalib.com/wiki/%E9%87%8F%E5%8C%96%E4%BA%A4%E6%98%93)是指借助现代统计学和数学的方法，利用计算机技术来进行交易的证券投资方式。\n\n量化交易的核心是数学模型，编程只是量化交易的实现方式。数学模型的评估方式是通过输入历史数据让我们“穿越”回之前的某一个时刻，然后按照模型进行交易，对比策略带来的收益（回测）。如果严格按照数据进行决策，量化交易可以克服人性的弱点，也可以克服认知偏差，另外在一个很大的资本市场，比如有成千上万只股票的时候，量化交易有更强的信息处理能力，能捕捉更多的投资机会。不过因为模型主要是根据历史数据来构建的，所以它吸收新的信息的能力比较迟钝。一旦发生某些重大事件（比如东哥事件～），有效性很可能就会受到影响。现在国内也有一些量化交易的主题基金，和其他主题的基金相比表现比较一般。\n\n<!--more-->\n\n<div align=center> {% asset_img found.jpeg image %} </div>\n\n量化投资的代表人物是[詹姆斯·西蒙斯](https://wiki.mbalib.com/wiki/%E8%A5%BF%E8%92%99%E6%96%AF)（James Simons），他是一位数学家，和陈省身一起提出了“陈-西蒙斯定理”，后来成立了文艺复兴科技公司开始从事量化交易，截至2019年10月，他的净资产估计为216亿美元，美国排名21位。\n\n<div align=center> {% asset_img james.jpg image %} </div>\n\n（西蒙斯公司旗下的大奖章基金，在2008年标普500指数下跌37％时，扣除费用后的收益为82％）\n\n## 量化交易平台\n\n量化交易平台提供了开发交易策略的平台，一般都会提供比较完整的股票/基金/期货数据，还有策略的在线运行环境。在百度上搜索“量化交易平台”，我随便选了一个叫“JoinQuant聚宽”的平台，地址是 https://www.joinquant.com ，后面的演示以这个平台为准。\n\n\n## 编写交易策略\n\n在joinquant上注册之后，就可以新建交易策略了,下面是一个基金定投策略的代码：\n\n代码很简单，initialize执行交易前的准备工作，函数buy执行具体的交易操作\n\n在initialize函数中：\n\n`set_benchmark` 会设置一个和你的策略对比的基准，000016.XSHG是上证50股票代码\n\n`set_option` 可以设定一些自定义配置，开启了动态复权， [可以在回测时使用真实的价格交易](https://blog.csdn.net/ywbhnay/article/details/100848696)\n\n`set_subportfolios` 设置账户资金和账户类型（open_fund代表场外基金）\n\n`set_redeem_latency` 设置赎回到账日为T+2(stock_fund代表股票型基金)\n\n`run_weekly` 设置交易函数的运行频率，每周一参考 reference_security 的开盘时间（每天9:30按昨日净值买入）\n\n\n**注意** 在选择基准的时候最好选择股票代码，我在使用上证50的基金502049.XSHG时,发现基准收益率有不准确的问题\n\n在buy函数中：\n\n参数context 包含了当前账户信息和持仓信息\ns 代表要定投的基金，定投策略是每周一买入1000元，当基金价格超过持仓成本50%后全部卖出\n\n\n```python\ndef initialize(context):\n    # 设定基准\n    set_benchmark('000016.XSHG')\n    # 开启动态复权模式(真实价格)\n    set_option(\"use_real_price\", True)\n\n    ### 场外基金相关设定 ###\n    # 设置账户类型: 场外基金账户\n    set_subportfolios([SubPortfolioConfig(context.portfolio.cash, 'open_fund')])\n    # 设置赎回到账日\n    set_redeem_latency(2, 'stock_fund')\n\n    ## 运行函数（reference_security为运行时间的参考标的；传入的标的只做种类区分，因此传入'000300.XSHG'或'510300.XSHG'是一样的）\n    # 开盘时运行\n    run_weekly(buy, weekday=1, reference_security='000016.XSHG')\n\ndef buy(context):\n    # 设置场外基金标的为易方达上证50指数A('110003.OF')\n    s = '110003.OF'\n    # 止盈线\n    max_profit = 0.50\n    # 持仓成本和当前价格\n    avg = context.portfolio.positions[s].avg_cost\n    price = context.portfolio.positions[s].price\n\n    # 打印当前收益\n    log.info('returns=',context.portfolio.total_value)\n    if avg != 0 and price !=0:\n        if (price-avg)/avg > max_profit:\n            log.info('sell:',context.portfolio.positions[s].closeable_amount)\n            redeem(s,context.portfolio.positions[s].closeable_amount)\n            return\n    # 申购基金\n    o = purchase(s, 1000)\n```\n\n策略写完之后，可以直接在平台上调试，选择运行的起止时间，还有初始资金，点击编译运行即可（为了提高运行速度，调试时不用选择太长的时间间隔）：\n\n{% asset_img debug.png image %}\n\n## 策略回测\n\n要想获得更详细的收益信息，可以点击运行回测按钮，回测的时间跨度可以更长一点，我这里选择的是2016-01-01到2020-01-20，初始资金为20万。回测结果如下图，\n红色是基准收益，就是第一个交易日用全部资金买入上证50之后的收益率，蓝色是定投的收益，定投4年的收益率为46%，重点关注收益率和最大回撤率,最大回撤率代表最倒霉的情况下策略的亏损。\n\n{% asset_img run.png image %}\n\n如果调整max_profit改为30%止盈，最大回撤率会降低，但是收益也会下降：\n\n{% asset_img run1.png image %}\n\n## 模拟交易\n\n回测只能说明策略的历史表现如何，我们还可以通过模拟交易让策略按照当前股市的真实情况运行一段时间，观察实际表现。关注了joinquant的公众号之后，还可以接收微信通知，不过模拟交易有时间限制，需要通过积分续费。\n\n{% asset_img real.png image %}\n\n## 总结\n\n借助交易平台只需要有一点编程基础和理财经验就可以编写自己的交易策略，主要的学习成本都在金融常识和各种交易指标上。另外在测试策略时最好和其他网站对比一下数据，确保基础数据都是准确的。","slug":"量化交易入门","published":1,"updated":"2020-05-21T15:21:24.733Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkqle17c000ycynertk5wfwo","content":"<p>之前听说过一些通过python编写交易策略的量化交易平台，现在来了解一下交易平台的使用方式。这篇文章会演示怎么在交易平台上编写一个简单基金定投策略。</p>\n<h2 id=\"量化交易介绍\"><a href=\"#量化交易介绍\" class=\"headerlink\" title=\"量化交易介绍\"></a>量化交易介绍</h2><blockquote>\n<p><a href=\"https://wiki.mbalib.com/wiki/%E9%87%8F%E5%8C%96%E4%BA%A4%E6%98%93\" target=\"_blank\" rel=\"noopener\">量化交易（Quantitative Trading）</a>是指借助现代统计学和数学的方法，利用计算机技术来进行交易的证券投资方式。</p>\n</blockquote>\n<p>量化交易的核心是数学模型，编程只是量化交易的实现方式。数学模型的评估方式是通过输入历史数据让我们“穿越”回之前的某一个时刻，然后按照模型进行交易，对比策略带来的收益（回测）。如果严格按照数据进行决策，量化交易可以克服人性的弱点，也可以克服认知偏差，另外在一个很大的资本市场，比如有成千上万只股票的时候，量化交易有更强的信息处理能力，能捕捉更多的投资机会。不过因为模型主要是根据历史数据来构建的，所以它吸收新的信息的能力比较迟钝。一旦发生某些重大事件（比如东哥事件～），有效性很可能就会受到影响。现在国内也有一些量化交易的主题基金，和其他主题的基金相比表现比较一般。</p>\n<a id=\"more\"></a>\n<div align=\"center\"> <img src=\"/2020/01/31/量化交易入门/found.jpeg\" title=\"image\"> </div>\n\n<p>量化投资的代表人物是<a href=\"https://wiki.mbalib.com/wiki/%E8%A5%BF%E8%92%99%E6%96%AF\" target=\"_blank\" rel=\"noopener\">詹姆斯·西蒙斯</a>（James Simons），他是一位数学家，和陈省身一起提出了“陈-西蒙斯定理”，后来成立了文艺复兴科技公司开始从事量化交易，截至2019年10月，他的净资产估计为216亿美元，美国排名21位。</p>\n<div align=\"center\"> <img src=\"/2020/01/31/量化交易入门/james.jpg\" title=\"image\"> </div>\n\n<p>（西蒙斯公司旗下的大奖章基金，在2008年标普500指数下跌37％时，扣除费用后的收益为82％）</p>\n<h2 id=\"量化交易平台\"><a href=\"#量化交易平台\" class=\"headerlink\" title=\"量化交易平台\"></a>量化交易平台</h2><p>量化交易平台提供了开发交易策略的平台，一般都会提供比较完整的股票/基金/期货数据，还有策略的在线运行环境。在百度上搜索“量化交易平台”，我随便选了一个叫“JoinQuant聚宽”的平台，地址是 <a href=\"https://www.joinquant.com\" target=\"_blank\" rel=\"noopener\">https://www.joinquant.com</a> ，后面的演示以这个平台为准。</p>\n<h2 id=\"编写交易策略\"><a href=\"#编写交易策略\" class=\"headerlink\" title=\"编写交易策略\"></a>编写交易策略</h2><p>在joinquant上注册之后，就可以新建交易策略了,下面是一个基金定投策略的代码：</p>\n<p>代码很简单，initialize执行交易前的准备工作，函数buy执行具体的交易操作</p>\n<p>在initialize函数中：</p>\n<p><code>set_benchmark</code> 会设置一个和你的策略对比的基准，000016.XSHG是上证50股票代码</p>\n<p><code>set_option</code> 可以设定一些自定义配置，开启了动态复权， <a href=\"https://blog.csdn.net/ywbhnay/article/details/100848696\" target=\"_blank\" rel=\"noopener\">可以在回测时使用真实的价格交易</a></p>\n<p><code>set_subportfolios</code> 设置账户资金和账户类型（open_fund代表场外基金）</p>\n<p><code>set_redeem_latency</code> 设置赎回到账日为T+2(stock_fund代表股票型基金)</p>\n<p><code>run_weekly</code> 设置交易函数的运行频率，每周一参考 reference_security 的开盘时间（每天9:30按昨日净值买入）</p>\n<p><strong>注意</strong> 在选择基准的时候最好选择股票代码，我在使用上证50的基金502049.XSHG时,发现基准收益率有不准确的问题</p>\n<p>在buy函数中：</p>\n<p>参数context 包含了当前账户信息和持仓信息<br>s 代表要定投的基金，定投策略是每周一买入1000元，当基金价格超过持仓成本50%后全部卖出</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">initialize</span><span class=\"params\">(context)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># 设定基准</span></span><br><span class=\"line\">    set_benchmark(<span class=\"string\">'000016.XSHG'</span>)</span><br><span class=\"line\">    <span class=\"comment\"># 开启动态复权模式(真实价格)</span></span><br><span class=\"line\">    set_option(<span class=\"string\">\"use_real_price\"</span>, <span class=\"keyword\">True</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">### 场外基金相关设定 ###</span></span><br><span class=\"line\">    <span class=\"comment\"># 设置账户类型: 场外基金账户</span></span><br><span class=\"line\">    set_subportfolios([SubPortfolioConfig(context.portfolio.cash, <span class=\"string\">'open_fund'</span>)])</span><br><span class=\"line\">    <span class=\"comment\"># 设置赎回到账日</span></span><br><span class=\"line\">    set_redeem_latency(<span class=\"number\">2</span>, <span class=\"string\">'stock_fund'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">## 运行函数（reference_security为运行时间的参考标的；传入的标的只做种类区分，因此传入'000300.XSHG'或'510300.XSHG'是一样的）</span></span><br><span class=\"line\">    <span class=\"comment\"># 开盘时运行</span></span><br><span class=\"line\">    run_weekly(buy, weekday=<span class=\"number\">1</span>, reference_security=<span class=\"string\">'000016.XSHG'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">buy</span><span class=\"params\">(context)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># 设置场外基金标的为易方达上证50指数A('110003.OF')</span></span><br><span class=\"line\">    s = <span class=\"string\">'110003.OF'</span></span><br><span class=\"line\">    <span class=\"comment\"># 止盈线</span></span><br><span class=\"line\">    max_profit = <span class=\"number\">0.50</span></span><br><span class=\"line\">    <span class=\"comment\"># 持仓成本和当前价格</span></span><br><span class=\"line\">    avg = context.portfolio.positions[s].avg_cost</span><br><span class=\"line\">    price = context.portfolio.positions[s].price</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 打印当前收益</span></span><br><span class=\"line\">    log.info(<span class=\"string\">'returns='</span>,context.portfolio.total_value)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> avg != <span class=\"number\">0</span> <span class=\"keyword\">and</span> price !=<span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (price-avg)/avg &gt; max_profit:</span><br><span class=\"line\">            log.info(<span class=\"string\">'sell:'</span>,context.portfolio.positions[s].closeable_amount)</span><br><span class=\"line\">            redeem(s,context.portfolio.positions[s].closeable_amount)</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">    <span class=\"comment\"># 申购基金</span></span><br><span class=\"line\">    o = purchase(s, <span class=\"number\">1000</span>)</span><br></pre></td></tr></table></figure>\n<p>策略写完之后，可以直接在平台上调试，选择运行的起止时间，还有初始资金，点击编译运行即可（为了提高运行速度，调试时不用选择太长的时间间隔）：</p>\n<img src=\"/2020/01/31/量化交易入门/debug.png\" title=\"image\">\n<h2 id=\"策略回测\"><a href=\"#策略回测\" class=\"headerlink\" title=\"策略回测\"></a>策略回测</h2><p>要想获得更详细的收益信息，可以点击运行回测按钮，回测的时间跨度可以更长一点，我这里选择的是2016-01-01到2020-01-20，初始资金为20万。回测结果如下图，<br>红色是基准收益，就是第一个交易日用全部资金买入上证50之后的收益率，蓝色是定投的收益，定投4年的收益率为46%，重点关注收益率和最大回撤率,最大回撤率代表最倒霉的情况下策略的亏损。</p>\n<img src=\"/2020/01/31/量化交易入门/run.png\" title=\"image\">\n<p>如果调整max_profit改为30%止盈，最大回撤率会降低，但是收益也会下降：</p>\n<img src=\"/2020/01/31/量化交易入门/run1.png\" title=\"image\">\n<h2 id=\"模拟交易\"><a href=\"#模拟交易\" class=\"headerlink\" title=\"模拟交易\"></a>模拟交易</h2><p>回测只能说明策略的历史表现如何，我们还可以通过模拟交易让策略按照当前股市的真实情况运行一段时间，观察实际表现。关注了joinquant的公众号之后，还可以接收微信通知，不过模拟交易有时间限制，需要通过积分续费。</p>\n<img src=\"/2020/01/31/量化交易入门/real.png\" title=\"image\">\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>借助交易平台只需要有一点编程基础和理财经验就可以编写自己的交易策略，主要的学习成本都在金融常识和各种交易指标上。另外在测试策略时最好和其他网站对比一下数据，确保基础数据都是准确的。</p>\n","site":{"data":{}},"excerpt":"<p>之前听说过一些通过python编写交易策略的量化交易平台，现在来了解一下交易平台的使用方式。这篇文章会演示怎么在交易平台上编写一个简单基金定投策略。</p>\n<h2 id=\"量化交易介绍\"><a href=\"#量化交易介绍\" class=\"headerlink\" title=\"量化交易介绍\"></a>量化交易介绍</h2><blockquote>\n<p><a href=\"https://wiki.mbalib.com/wiki/%E9%87%8F%E5%8C%96%E4%BA%A4%E6%98%93\" target=\"_blank\" rel=\"noopener\">量化交易（Quantitative Trading）</a>是指借助现代统计学和数学的方法，利用计算机技术来进行交易的证券投资方式。</p>\n</blockquote>\n<p>量化交易的核心是数学模型，编程只是量化交易的实现方式。数学模型的评估方式是通过输入历史数据让我们“穿越”回之前的某一个时刻，然后按照模型进行交易，对比策略带来的收益（回测）。如果严格按照数据进行决策，量化交易可以克服人性的弱点，也可以克服认知偏差，另外在一个很大的资本市场，比如有成千上万只股票的时候，量化交易有更强的信息处理能力，能捕捉更多的投资机会。不过因为模型主要是根据历史数据来构建的，所以它吸收新的信息的能力比较迟钝。一旦发生某些重大事件（比如东哥事件～），有效性很可能就会受到影响。现在国内也有一些量化交易的主题基金，和其他主题的基金相比表现比较一般。</p>","more":"<div align=\"center\"> <img src=\"/2020/01/31/量化交易入门/found.jpeg\" title=\"image\"> </div>\n\n<p>量化投资的代表人物是<a href=\"https://wiki.mbalib.com/wiki/%E8%A5%BF%E8%92%99%E6%96%AF\" target=\"_blank\" rel=\"noopener\">詹姆斯·西蒙斯</a>（James Simons），他是一位数学家，和陈省身一起提出了“陈-西蒙斯定理”，后来成立了文艺复兴科技公司开始从事量化交易，截至2019年10月，他的净资产估计为216亿美元，美国排名21位。</p>\n<div align=\"center\"> <img src=\"/2020/01/31/量化交易入门/james.jpg\" title=\"image\"> </div>\n\n<p>（西蒙斯公司旗下的大奖章基金，在2008年标普500指数下跌37％时，扣除费用后的收益为82％）</p>\n<h2 id=\"量化交易平台\"><a href=\"#量化交易平台\" class=\"headerlink\" title=\"量化交易平台\"></a>量化交易平台</h2><p>量化交易平台提供了开发交易策略的平台，一般都会提供比较完整的股票/基金/期货数据，还有策略的在线运行环境。在百度上搜索“量化交易平台”，我随便选了一个叫“JoinQuant聚宽”的平台，地址是 <a href=\"https://www.joinquant.com\" target=\"_blank\" rel=\"noopener\">https://www.joinquant.com</a> ，后面的演示以这个平台为准。</p>\n<h2 id=\"编写交易策略\"><a href=\"#编写交易策略\" class=\"headerlink\" title=\"编写交易策略\"></a>编写交易策略</h2><p>在joinquant上注册之后，就可以新建交易策略了,下面是一个基金定投策略的代码：</p>\n<p>代码很简单，initialize执行交易前的准备工作，函数buy执行具体的交易操作</p>\n<p>在initialize函数中：</p>\n<p><code>set_benchmark</code> 会设置一个和你的策略对比的基准，000016.XSHG是上证50股票代码</p>\n<p><code>set_option</code> 可以设定一些自定义配置，开启了动态复权， <a href=\"https://blog.csdn.net/ywbhnay/article/details/100848696\" target=\"_blank\" rel=\"noopener\">可以在回测时使用真实的价格交易</a></p>\n<p><code>set_subportfolios</code> 设置账户资金和账户类型（open_fund代表场外基金）</p>\n<p><code>set_redeem_latency</code> 设置赎回到账日为T+2(stock_fund代表股票型基金)</p>\n<p><code>run_weekly</code> 设置交易函数的运行频率，每周一参考 reference_security 的开盘时间（每天9:30按昨日净值买入）</p>\n<p><strong>注意</strong> 在选择基准的时候最好选择股票代码，我在使用上证50的基金502049.XSHG时,发现基准收益率有不准确的问题</p>\n<p>在buy函数中：</p>\n<p>参数context 包含了当前账户信息和持仓信息<br>s 代表要定投的基金，定投策略是每周一买入1000元，当基金价格超过持仓成本50%后全部卖出</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">initialize</span><span class=\"params\">(context)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># 设定基准</span></span><br><span class=\"line\">    set_benchmark(<span class=\"string\">'000016.XSHG'</span>)</span><br><span class=\"line\">    <span class=\"comment\"># 开启动态复权模式(真实价格)</span></span><br><span class=\"line\">    set_option(<span class=\"string\">\"use_real_price\"</span>, <span class=\"keyword\">True</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">### 场外基金相关设定 ###</span></span><br><span class=\"line\">    <span class=\"comment\"># 设置账户类型: 场外基金账户</span></span><br><span class=\"line\">    set_subportfolios([SubPortfolioConfig(context.portfolio.cash, <span class=\"string\">'open_fund'</span>)])</span><br><span class=\"line\">    <span class=\"comment\"># 设置赎回到账日</span></span><br><span class=\"line\">    set_redeem_latency(<span class=\"number\">2</span>, <span class=\"string\">'stock_fund'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">## 运行函数（reference_security为运行时间的参考标的；传入的标的只做种类区分，因此传入'000300.XSHG'或'510300.XSHG'是一样的）</span></span><br><span class=\"line\">    <span class=\"comment\"># 开盘时运行</span></span><br><span class=\"line\">    run_weekly(buy, weekday=<span class=\"number\">1</span>, reference_security=<span class=\"string\">'000016.XSHG'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">buy</span><span class=\"params\">(context)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># 设置场外基金标的为易方达上证50指数A('110003.OF')</span></span><br><span class=\"line\">    s = <span class=\"string\">'110003.OF'</span></span><br><span class=\"line\">    <span class=\"comment\"># 止盈线</span></span><br><span class=\"line\">    max_profit = <span class=\"number\">0.50</span></span><br><span class=\"line\">    <span class=\"comment\"># 持仓成本和当前价格</span></span><br><span class=\"line\">    avg = context.portfolio.positions[s].avg_cost</span><br><span class=\"line\">    price = context.portfolio.positions[s].price</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 打印当前收益</span></span><br><span class=\"line\">    log.info(<span class=\"string\">'returns='</span>,context.portfolio.total_value)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> avg != <span class=\"number\">0</span> <span class=\"keyword\">and</span> price !=<span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (price-avg)/avg &gt; max_profit:</span><br><span class=\"line\">            log.info(<span class=\"string\">'sell:'</span>,context.portfolio.positions[s].closeable_amount)</span><br><span class=\"line\">            redeem(s,context.portfolio.positions[s].closeable_amount)</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">    <span class=\"comment\"># 申购基金</span></span><br><span class=\"line\">    o = purchase(s, <span class=\"number\">1000</span>)</span><br></pre></td></tr></table></figure>\n<p>策略写完之后，可以直接在平台上调试，选择运行的起止时间，还有初始资金，点击编译运行即可（为了提高运行速度，调试时不用选择太长的时间间隔）：</p>\n<img src=\"/2020/01/31/量化交易入门/debug.png\" title=\"image\">\n<h2 id=\"策略回测\"><a href=\"#策略回测\" class=\"headerlink\" title=\"策略回测\"></a>策略回测</h2><p>要想获得更详细的收益信息，可以点击运行回测按钮，回测的时间跨度可以更长一点，我这里选择的是2016-01-01到2020-01-20，初始资金为20万。回测结果如下图，<br>红色是基准收益，就是第一个交易日用全部资金买入上证50之后的收益率，蓝色是定投的收益，定投4年的收益率为46%，重点关注收益率和最大回撤率,最大回撤率代表最倒霉的情况下策略的亏损。</p>\n<img src=\"/2020/01/31/量化交易入门/run.png\" title=\"image\">\n<p>如果调整max_profit改为30%止盈，最大回撤率会降低，但是收益也会下降：</p>\n<img src=\"/2020/01/31/量化交易入门/run1.png\" title=\"image\">\n<h2 id=\"模拟交易\"><a href=\"#模拟交易\" class=\"headerlink\" title=\"模拟交易\"></a>模拟交易</h2><p>回测只能说明策略的历史表现如何，我们还可以通过模拟交易让策略按照当前股市的真实情况运行一段时间，观察实际表现。关注了joinquant的公众号之后，还可以接收微信通知，不过模拟交易有时间限制，需要通过积分续费。</p>\n<img src=\"/2020/01/31/量化交易入门/real.png\" title=\"image\">\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>借助交易平台只需要有一点编程基础和理财经验就可以编写自己的交易策略，主要的学习成本都在金融常识和各种交易指标上。另外在测试策略时最好和其他网站对比一下数据，确保基础数据都是准确的。</p>"},{"title":"2020年理财总结","date":"2020-12-31T15:39:55.000Z","_content":"\n## 收益总结\n\n2020年预期总收益率10%，实际整体收益率9.85%，稳健组合收益率2.8%，积极组合收益率17%\n积极组合中基金收益率25%（年收益率=年持有收益/(当前总市值-年持有收益)）\n\n在投入成本/回报上，稳健/积极成本占比保持在1:1左右，基金成本占积极组合的50%左右，而在收益贡献上，稳健组合占总收益的15%，积极组合占总收益的85%，其中基金收益占总收益的74%\n\n在大环境上，今年沪深300上涨27%，创业板上涨64%，黄金上涨13%，中证白酒上涨119%。。\n\n## 今年做错的事\n<!--more-->\n为了尽量客观，不被马后炮的心理影响，在总结事情的对错时，我会尽量从当时的行为动机上来判断，按照这件事是否符合原则，是否值得借鉴来判断“对”或“错”。\n\n### 心态爆炸，追涨杀跌\n\n20年美股账户亏损最多的一只股，vix指数etf。\n\n{% asset_img vix1.jpeg image %}\n\n\nvix指数从19年9月开始持续分批买入，期间vix指数一路下跌，持仓成本大概是15块，直到2020年1月23号武汉封城，1月25号vix上涨11%到13块，在1月27号13块先卖出25%，但是之后的两周美股没有受到疫情影响，vix又开始下跌，**这时我就开始着急了，在2月18号以11块清仓**。然而就在清仓后, 从2月24号开始，一周内vix上涨53%，三月份美股熔断, vix上涨**101%**。后来我又在三月底和五月底买入，最后还是亏损离场。\n\n{% asset_img vix0.jpeg image %}\n\n**错误一：决策受情绪影响**\n\n\n最让人绝望的是先给他希望，然后再给予打击让他希望破灭。之前我可以最大回撤50%仍然持有，但是当黑天鹅出现后，vix当周上涨15%，让我感觉可以回本离场，然后又用两周下跌了15%，这时我又认为疫情对vix利好已经不存在，海外市场也不会受影响，所以清仓放弃。其实当时作出这种判断不能算是错误，毕竟没想到疫情早就已经在海外开始传播，只是爆发时间晚一点而已，最主要的错误还是当时**心态爆炸**直接全部清仓了，如果理智一点的话我可以和1月25号一样分批离场，然后再等待疫情的消息。\n\n**错误二：选择了不了解的股票**\n\n\nvix这种指数本身就不适合长期持有，它不适合使用定投的策略，而且vix本身更适合在黑天鹅事件发生时做避险或对冲使用，但是我却在**真·黑天鹅**事件来临时把他卖出了，可能所有的黑天鹅事件只有在回头看的时候才能发现它的破坏力，而我本身并没有判断这种重大事件影响的能力，反而容易被媒体和大众情绪影响（比如03年非典时海外病例并不多）。\n\n### 错失10倍股\n\n{% asset_img nio.jpeg image %}\n\n错过了10倍股蔚来，今年买入两次蔚来，分别持有了**12天和4天**，第一次买入价格是2.78，现在的价格是49，已经上涨了**17倍**，如果能坚持持有的话，我的美股账户也能回本了😭。\n\n**错误一：买入不信任的公司股票**\n在买入nio时我本身对它并没什么信心（现在也没有），也不了解这家公司（现在也是），买入时只是看它跌的够便宜，想买一只困境反转股，但是一开始就对它的合理估值没有预期，基本涨10%就卖掉了，“用人不疑，疑人不用”这样应该会轻松一点。\n\n**错误二：不能长期持有**\n我的股票交易习惯不好，美股平均持有时间只有一个月左右，因此2020年我错过了b站（持有一个月，27买入，现在85）和拼多多（持有一个月，81买入，现在177）两只翻倍股。。。频繁的短线交易不适合我，一是交易费占总成本比例太高，二是没那个时间，三是即使我每天都买入然后涨一点就卖出，这样确实能有不错的收益，但是对于翻倍股来说仍然没有长期持有收益高。\n\n## 今年做对的事\n\n### 2/3月份市场下跌时主动增加了基金的仓位\n\n2月3号是春节后A股第一个交易日，当天上证下跌7.72%到2700点左右，我是从2月4号开始加仓基金，买入了易方达中小盘，易方达上证50，和两只QDII基金（买的少），然后3月份，美股熔断，我又加仓了易方达中小盘和易方达上证50，现在这两只基金收益占我的基金累计收益的50%。\n\n当时加仓的动机：\n\n1. 首先我的基金占比就不高，并且下跌7%也没有让我心态爆炸，想着“别人恐惧我贪婪”的原则，打算抄底。\n\n2. 当时A股的估值并不高，毕竟号称3000点下随便买\n\n3. 买入QDII的原因主要是避险，当时我的想法是疫情不会在海外扩散，这和我卖出vix的认知相似\n\n4. 买入上证50是感觉龙头股一般抗风险能力更强\n\n这里我做对的是，首先当时**心态**还是比较轻松，没有着急割肉，另外年初时基金**仓位低**，仓位低所以心态平静，也是因为仓位低所以敢继续买入。而且因为不知道后续是否下跌，还使用了**分批买入**的方式（我本打算3号下午收盘前看情况买入，不过错过了，最后在4号买入，当天上证也止跌，收涨1%）。\n\n### 养成记账的习惯\n\n从2019年11月开始，使用基金净值法，每个月记录理财组合的净值和成本变化，虽然很多数据没有分析价值，但是这样可以养成定期总结的习惯，后来从20年10月开始每周在且慢小程序上记录净值和成本。\n\n### 开始学习筛选基金的方法\n\n20年开始会主动关注一些基金理财类的账号，看看明星基金经理的采访，了解基金的分类，费率和评价指标，会使用各种平台对比不同基金，筛选了6只看好的债券类基金，在选择基金时慢慢形成自己的原则。\n\n## 从今年的经历得到的原则\n\n一，不要在心态爆炸的时候做加仓/减仓的操作，即使忍不住也要分批操作，不要一口气清仓/all in\n\n二，今年的疫情国内控制—>海外爆发，和股市熔断->暴涨说明，人即使在黑天鹅事件中也无法预测它的破坏力，从历史上也无法得到完全相同的参考，所以不要去赌它的走势和影响\n\n三，严格执行仓位管理可以避免重大风险事件的影响，可以保证心理健康，也可以保留底牌，避免彻底清仓放弃\n\n四，选股/选基金前，一定要先做了解，不要让买一只股票的思考时间比选择点哪个外卖的时间还短\n\n五，每个股票尽量持有一年以上，选择了解且信任的股票/基金，然后长期持有\n\n## 2021年的目标\n\n### 承受-7%最大回撤，预期收益率10%\n\n取值的原因：\n\n-7%的亏损心理上可以接受，毕竟不会亏损本金，在已经得到收益时人都是风险厌恶的心理，因为忽略了理财的时间成本；\n10%的年化已经是比较高的目标了，参考沪深300的3年年化是10%，5年年化是8.5%。\n\n- key result 1: 如果明年倒霉，股市大跌，必须在亏损接近7%时分批减仓，然后等机会（3000点以下？）再分批买入\n- key result 2: 如果运气好，提前完成目标，必须把基金仓位转换到债券过渡\n- key result 3: 如果难完成+10%的目标，至少保证完成+7%以上（这是债券平均收益）\n\n### 严格执行仓位管理\n\n仓位计算方式使用 某个标的市值/总市值，原因是这样比较好算\n\n- key result 0: 按照估算的收益率和最大回撤选择基金/债券/活期理财的比例\n- key result 1: 每1到3个月做一次稳健/积极组合的仓位再平衡，保证仓位比例1:1\n- key result 2: 保证稳健组合中的活期理财（小于6个月）比例不小于50%\n- key result 4: 任何资产的仓位都不可能是0%或100%\n\n### 练习选基/选股的能力\n\n- key result 1: 分别选择5只信任的主动型基金/固定类基金/短债基金，记录对比参数和选择原因，加入到积极组合持仓中\n- key result 2: 选择1-3只信任的美股/港股股票，行业仅限互联网或消费股，记录选择原因，持有一年\n\n## 总结\n\n2020年的整体收益还是满意的，遗憾的是错过了很多翻倍的股票，而且在基金仓位上也过分保守，不过作为一个业余韭菜想要只通过理财实现财富自由是不可能的，我只能把它当作一种抵抗通胀的手段。“我不希望做最聪明的人,但希望避免做蠢事” 如果我们想获得收益，首先要具备定义什么是蠢事的原则，然后做蠢事的次数比市场上其他韭菜同类少就好了。\n","source":"_posts/2020年理财总结.md","raw":"---\ntitle: 2020年理财总结\ndate: 2020-12-31 23:39:55\ntags: [理财]\n---\n\n## 收益总结\n\n2020年预期总收益率10%，实际整体收益率9.85%，稳健组合收益率2.8%，积极组合收益率17%\n积极组合中基金收益率25%（年收益率=年持有收益/(当前总市值-年持有收益)）\n\n在投入成本/回报上，稳健/积极成本占比保持在1:1左右，基金成本占积极组合的50%左右，而在收益贡献上，稳健组合占总收益的15%，积极组合占总收益的85%，其中基金收益占总收益的74%\n\n在大环境上，今年沪深300上涨27%，创业板上涨64%，黄金上涨13%，中证白酒上涨119%。。\n\n## 今年做错的事\n<!--more-->\n为了尽量客观，不被马后炮的心理影响，在总结事情的对错时，我会尽量从当时的行为动机上来判断，按照这件事是否符合原则，是否值得借鉴来判断“对”或“错”。\n\n### 心态爆炸，追涨杀跌\n\n20年美股账户亏损最多的一只股，vix指数etf。\n\n{% asset_img vix1.jpeg image %}\n\n\nvix指数从19年9月开始持续分批买入，期间vix指数一路下跌，持仓成本大概是15块，直到2020年1月23号武汉封城，1月25号vix上涨11%到13块，在1月27号13块先卖出25%，但是之后的两周美股没有受到疫情影响，vix又开始下跌，**这时我就开始着急了，在2月18号以11块清仓**。然而就在清仓后, 从2月24号开始，一周内vix上涨53%，三月份美股熔断, vix上涨**101%**。后来我又在三月底和五月底买入，最后还是亏损离场。\n\n{% asset_img vix0.jpeg image %}\n\n**错误一：决策受情绪影响**\n\n\n最让人绝望的是先给他希望，然后再给予打击让他希望破灭。之前我可以最大回撤50%仍然持有，但是当黑天鹅出现后，vix当周上涨15%，让我感觉可以回本离场，然后又用两周下跌了15%，这时我又认为疫情对vix利好已经不存在，海外市场也不会受影响，所以清仓放弃。其实当时作出这种判断不能算是错误，毕竟没想到疫情早就已经在海外开始传播，只是爆发时间晚一点而已，最主要的错误还是当时**心态爆炸**直接全部清仓了，如果理智一点的话我可以和1月25号一样分批离场，然后再等待疫情的消息。\n\n**错误二：选择了不了解的股票**\n\n\nvix这种指数本身就不适合长期持有，它不适合使用定投的策略，而且vix本身更适合在黑天鹅事件发生时做避险或对冲使用，但是我却在**真·黑天鹅**事件来临时把他卖出了，可能所有的黑天鹅事件只有在回头看的时候才能发现它的破坏力，而我本身并没有判断这种重大事件影响的能力，反而容易被媒体和大众情绪影响（比如03年非典时海外病例并不多）。\n\n### 错失10倍股\n\n{% asset_img nio.jpeg image %}\n\n错过了10倍股蔚来，今年买入两次蔚来，分别持有了**12天和4天**，第一次买入价格是2.78，现在的价格是49，已经上涨了**17倍**，如果能坚持持有的话，我的美股账户也能回本了😭。\n\n**错误一：买入不信任的公司股票**\n在买入nio时我本身对它并没什么信心（现在也没有），也不了解这家公司（现在也是），买入时只是看它跌的够便宜，想买一只困境反转股，但是一开始就对它的合理估值没有预期，基本涨10%就卖掉了，“用人不疑，疑人不用”这样应该会轻松一点。\n\n**错误二：不能长期持有**\n我的股票交易习惯不好，美股平均持有时间只有一个月左右，因此2020年我错过了b站（持有一个月，27买入，现在85）和拼多多（持有一个月，81买入，现在177）两只翻倍股。。。频繁的短线交易不适合我，一是交易费占总成本比例太高，二是没那个时间，三是即使我每天都买入然后涨一点就卖出，这样确实能有不错的收益，但是对于翻倍股来说仍然没有长期持有收益高。\n\n## 今年做对的事\n\n### 2/3月份市场下跌时主动增加了基金的仓位\n\n2月3号是春节后A股第一个交易日，当天上证下跌7.72%到2700点左右，我是从2月4号开始加仓基金，买入了易方达中小盘，易方达上证50，和两只QDII基金（买的少），然后3月份，美股熔断，我又加仓了易方达中小盘和易方达上证50，现在这两只基金收益占我的基金累计收益的50%。\n\n当时加仓的动机：\n\n1. 首先我的基金占比就不高，并且下跌7%也没有让我心态爆炸，想着“别人恐惧我贪婪”的原则，打算抄底。\n\n2. 当时A股的估值并不高，毕竟号称3000点下随便买\n\n3. 买入QDII的原因主要是避险，当时我的想法是疫情不会在海外扩散，这和我卖出vix的认知相似\n\n4. 买入上证50是感觉龙头股一般抗风险能力更强\n\n这里我做对的是，首先当时**心态**还是比较轻松，没有着急割肉，另外年初时基金**仓位低**，仓位低所以心态平静，也是因为仓位低所以敢继续买入。而且因为不知道后续是否下跌，还使用了**分批买入**的方式（我本打算3号下午收盘前看情况买入，不过错过了，最后在4号买入，当天上证也止跌，收涨1%）。\n\n### 养成记账的习惯\n\n从2019年11月开始，使用基金净值法，每个月记录理财组合的净值和成本变化，虽然很多数据没有分析价值，但是这样可以养成定期总结的习惯，后来从20年10月开始每周在且慢小程序上记录净值和成本。\n\n### 开始学习筛选基金的方法\n\n20年开始会主动关注一些基金理财类的账号，看看明星基金经理的采访，了解基金的分类，费率和评价指标，会使用各种平台对比不同基金，筛选了6只看好的债券类基金，在选择基金时慢慢形成自己的原则。\n\n## 从今年的经历得到的原则\n\n一，不要在心态爆炸的时候做加仓/减仓的操作，即使忍不住也要分批操作，不要一口气清仓/all in\n\n二，今年的疫情国内控制—>海外爆发，和股市熔断->暴涨说明，人即使在黑天鹅事件中也无法预测它的破坏力，从历史上也无法得到完全相同的参考，所以不要去赌它的走势和影响\n\n三，严格执行仓位管理可以避免重大风险事件的影响，可以保证心理健康，也可以保留底牌，避免彻底清仓放弃\n\n四，选股/选基金前，一定要先做了解，不要让买一只股票的思考时间比选择点哪个外卖的时间还短\n\n五，每个股票尽量持有一年以上，选择了解且信任的股票/基金，然后长期持有\n\n## 2021年的目标\n\n### 承受-7%最大回撤，预期收益率10%\n\n取值的原因：\n\n-7%的亏损心理上可以接受，毕竟不会亏损本金，在已经得到收益时人都是风险厌恶的心理，因为忽略了理财的时间成本；\n10%的年化已经是比较高的目标了，参考沪深300的3年年化是10%，5年年化是8.5%。\n\n- key result 1: 如果明年倒霉，股市大跌，必须在亏损接近7%时分批减仓，然后等机会（3000点以下？）再分批买入\n- key result 2: 如果运气好，提前完成目标，必须把基金仓位转换到债券过渡\n- key result 3: 如果难完成+10%的目标，至少保证完成+7%以上（这是债券平均收益）\n\n### 严格执行仓位管理\n\n仓位计算方式使用 某个标的市值/总市值，原因是这样比较好算\n\n- key result 0: 按照估算的收益率和最大回撤选择基金/债券/活期理财的比例\n- key result 1: 每1到3个月做一次稳健/积极组合的仓位再平衡，保证仓位比例1:1\n- key result 2: 保证稳健组合中的活期理财（小于6个月）比例不小于50%\n- key result 4: 任何资产的仓位都不可能是0%或100%\n\n### 练习选基/选股的能力\n\n- key result 1: 分别选择5只信任的主动型基金/固定类基金/短债基金，记录对比参数和选择原因，加入到积极组合持仓中\n- key result 2: 选择1-3只信任的美股/港股股票，行业仅限互联网或消费股，记录选择原因，持有一年\n\n## 总结\n\n2020年的整体收益还是满意的，遗憾的是错过了很多翻倍的股票，而且在基金仓位上也过分保守，不过作为一个业余韭菜想要只通过理财实现财富自由是不可能的，我只能把它当作一种抵抗通胀的手段。“我不希望做最聪明的人,但希望避免做蠢事” 如果我们想获得收益，首先要具备定义什么是蠢事的原则，然后做蠢事的次数比市场上其他韭菜同类少就好了。\n","slug":"2020年理财总结","published":1,"updated":"2021-01-03T16:11:50.187Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkqle1cj0025cynejyt9hs66","content":"<h2 id=\"收益总结\"><a href=\"#收益总结\" class=\"headerlink\" title=\"收益总结\"></a>收益总结</h2><p>2020年预期总收益率10%，实际整体收益率9.85%，稳健组合收益率2.8%，积极组合收益率17%<br>积极组合中基金收益率25%（年收益率=年持有收益/(当前总市值-年持有收益)）</p>\n<p>在投入成本/回报上，稳健/积极成本占比保持在1:1左右，基金成本占积极组合的50%左右，而在收益贡献上，稳健组合占总收益的15%，积极组合占总收益的85%，其中基金收益占总收益的74%</p>\n<p>在大环境上，今年沪深300上涨27%，创业板上涨64%，黄金上涨13%，中证白酒上涨119%。。</p>\n<h2 id=\"今年做错的事\"><a href=\"#今年做错的事\" class=\"headerlink\" title=\"今年做错的事\"></a>今年做错的事</h2><a id=\"more\"></a>\n<p>为了尽量客观，不被马后炮的心理影响，在总结事情的对错时，我会尽量从当时的行为动机上来判断，按照这件事是否符合原则，是否值得借鉴来判断“对”或“错”。</p>\n<h3 id=\"心态爆炸，追涨杀跌\"><a href=\"#心态爆炸，追涨杀跌\" class=\"headerlink\" title=\"心态爆炸，追涨杀跌\"></a>心态爆炸，追涨杀跌</h3><p>20年美股账户亏损最多的一只股，vix指数etf。</p>\n<img src=\"/2020/12/31/2020年理财总结/vix1.jpeg\" title=\"image\">\n<p>vix指数从19年9月开始持续分批买入，期间vix指数一路下跌，持仓成本大概是15块，直到2020年1月23号武汉封城，1月25号vix上涨11%到13块，在1月27号13块先卖出25%，但是之后的两周美股没有受到疫情影响，vix又开始下跌，<strong>这时我就开始着急了，在2月18号以11块清仓</strong>。然而就在清仓后, 从2月24号开始，一周内vix上涨53%，三月份美股熔断, vix上涨<strong>101%</strong>。后来我又在三月底和五月底买入，最后还是亏损离场。</p>\n<img src=\"/2020/12/31/2020年理财总结/vix0.jpeg\" title=\"image\">\n<p><strong>错误一：决策受情绪影响</strong></p>\n<p>最让人绝望的是先给他希望，然后再给予打击让他希望破灭。之前我可以最大回撤50%仍然持有，但是当黑天鹅出现后，vix当周上涨15%，让我感觉可以回本离场，然后又用两周下跌了15%，这时我又认为疫情对vix利好已经不存在，海外市场也不会受影响，所以清仓放弃。其实当时作出这种判断不能算是错误，毕竟没想到疫情早就已经在海外开始传播，只是爆发时间晚一点而已，最主要的错误还是当时<strong>心态爆炸</strong>直接全部清仓了，如果理智一点的话我可以和1月25号一样分批离场，然后再等待疫情的消息。</p>\n<p><strong>错误二：选择了不了解的股票</strong></p>\n<p>vix这种指数本身就不适合长期持有，它不适合使用定投的策略，而且vix本身更适合在黑天鹅事件发生时做避险或对冲使用，但是我却在<strong>真·黑天鹅</strong>事件来临时把他卖出了，可能所有的黑天鹅事件只有在回头看的时候才能发现它的破坏力，而我本身并没有判断这种重大事件影响的能力，反而容易被媒体和大众情绪影响（比如03年非典时海外病例并不多）。</p>\n<h3 id=\"错失10倍股\"><a href=\"#错失10倍股\" class=\"headerlink\" title=\"错失10倍股\"></a>错失10倍股</h3><img src=\"/2020/12/31/2020年理财总结/nio.jpeg\" title=\"image\">\n<p>错过了10倍股蔚来，今年买入两次蔚来，分别持有了<strong>12天和4天</strong>，第一次买入价格是2.78，现在的价格是49，已经上涨了<strong>17倍</strong>，如果能坚持持有的话，我的美股账户也能回本了😭。</p>\n<p><strong>错误一：买入不信任的公司股票</strong><br>在买入nio时我本身对它并没什么信心（现在也没有），也不了解这家公司（现在也是），买入时只是看它跌的够便宜，想买一只困境反转股，但是一开始就对它的合理估值没有预期，基本涨10%就卖掉了，“用人不疑，疑人不用”这样应该会轻松一点。</p>\n<p><strong>错误二：不能长期持有</strong><br>我的股票交易习惯不好，美股平均持有时间只有一个月左右，因此2020年我错过了b站（持有一个月，27买入，现在85）和拼多多（持有一个月，81买入，现在177）两只翻倍股。。。频繁的短线交易不适合我，一是交易费占总成本比例太高，二是没那个时间，三是即使我每天都买入然后涨一点就卖出，这样确实能有不错的收益，但是对于翻倍股来说仍然没有长期持有收益高。</p>\n<h2 id=\"今年做对的事\"><a href=\"#今年做对的事\" class=\"headerlink\" title=\"今年做对的事\"></a>今年做对的事</h2><h3 id=\"2-3月份市场下跌时主动增加了基金的仓位\"><a href=\"#2-3月份市场下跌时主动增加了基金的仓位\" class=\"headerlink\" title=\"2/3月份市场下跌时主动增加了基金的仓位\"></a>2/3月份市场下跌时主动增加了基金的仓位</h3><p>2月3号是春节后A股第一个交易日，当天上证下跌7.72%到2700点左右，我是从2月4号开始加仓基金，买入了易方达中小盘，易方达上证50，和两只QDII基金（买的少），然后3月份，美股熔断，我又加仓了易方达中小盘和易方达上证50，现在这两只基金收益占我的基金累计收益的50%。</p>\n<p>当时加仓的动机：</p>\n<ol>\n<li><p>首先我的基金占比就不高，并且下跌7%也没有让我心态爆炸，想着“别人恐惧我贪婪”的原则，打算抄底。</p>\n</li>\n<li><p>当时A股的估值并不高，毕竟号称3000点下随便买</p>\n</li>\n<li><p>买入QDII的原因主要是避险，当时我的想法是疫情不会在海外扩散，这和我卖出vix的认知相似</p>\n</li>\n<li><p>买入上证50是感觉龙头股一般抗风险能力更强</p>\n</li>\n</ol>\n<p>这里我做对的是，首先当时<strong>心态</strong>还是比较轻松，没有着急割肉，另外年初时基金<strong>仓位低</strong>，仓位低所以心态平静，也是因为仓位低所以敢继续买入。而且因为不知道后续是否下跌，还使用了<strong>分批买入</strong>的方式（我本打算3号下午收盘前看情况买入，不过错过了，最后在4号买入，当天上证也止跌，收涨1%）。</p>\n<h3 id=\"养成记账的习惯\"><a href=\"#养成记账的习惯\" class=\"headerlink\" title=\"养成记账的习惯\"></a>养成记账的习惯</h3><p>从2019年11月开始，使用基金净值法，每个月记录理财组合的净值和成本变化，虽然很多数据没有分析价值，但是这样可以养成定期总结的习惯，后来从20年10月开始每周在且慢小程序上记录净值和成本。</p>\n<h3 id=\"开始学习筛选基金的方法\"><a href=\"#开始学习筛选基金的方法\" class=\"headerlink\" title=\"开始学习筛选基金的方法\"></a>开始学习筛选基金的方法</h3><p>20年开始会主动关注一些基金理财类的账号，看看明星基金经理的采访，了解基金的分类，费率和评价指标，会使用各种平台对比不同基金，筛选了6只看好的债券类基金，在选择基金时慢慢形成自己的原则。</p>\n<h2 id=\"从今年的经历得到的原则\"><a href=\"#从今年的经历得到的原则\" class=\"headerlink\" title=\"从今年的经历得到的原则\"></a>从今年的经历得到的原则</h2><p>一，不要在心态爆炸的时候做加仓/减仓的操作，即使忍不住也要分批操作，不要一口气清仓/all in</p>\n<p>二，今年的疫情国内控制—&gt;海外爆发，和股市熔断-&gt;暴涨说明，人即使在黑天鹅事件中也无法预测它的破坏力，从历史上也无法得到完全相同的参考，所以不要去赌它的走势和影响</p>\n<p>三，严格执行仓位管理可以避免重大风险事件的影响，可以保证心理健康，也可以保留底牌，避免彻底清仓放弃</p>\n<p>四，选股/选基金前，一定要先做了解，不要让买一只股票的思考时间比选择点哪个外卖的时间还短</p>\n<p>五，每个股票尽量持有一年以上，选择了解且信任的股票/基金，然后长期持有</p>\n<h2 id=\"2021年的目标\"><a href=\"#2021年的目标\" class=\"headerlink\" title=\"2021年的目标\"></a>2021年的目标</h2><h3 id=\"承受-7-最大回撤，预期收益率10\"><a href=\"#承受-7-最大回撤，预期收益率10\" class=\"headerlink\" title=\"承受-7%最大回撤，预期收益率10%\"></a>承受-7%最大回撤，预期收益率10%</h3><p>取值的原因：</p>\n<p>-7%的亏损心理上可以接受，毕竟不会亏损本金，在已经得到收益时人都是风险厌恶的心理，因为忽略了理财的时间成本；<br>10%的年化已经是比较高的目标了，参考沪深300的3年年化是10%，5年年化是8.5%。</p>\n<ul>\n<li>key result 1: 如果明年倒霉，股市大跌，必须在亏损接近7%时分批减仓，然后等机会（3000点以下？）再分批买入</li>\n<li>key result 2: 如果运气好，提前完成目标，必须把基金仓位转换到债券过渡</li>\n<li>key result 3: 如果难完成+10%的目标，至少保证完成+7%以上（这是债券平均收益）</li>\n</ul>\n<h3 id=\"严格执行仓位管理\"><a href=\"#严格执行仓位管理\" class=\"headerlink\" title=\"严格执行仓位管理\"></a>严格执行仓位管理</h3><p>仓位计算方式使用 某个标的市值/总市值，原因是这样比较好算</p>\n<ul>\n<li>key result 0: 按照估算的收益率和最大回撤选择基金/债券/活期理财的比例</li>\n<li>key result 1: 每1到3个月做一次稳健/积极组合的仓位再平衡，保证仓位比例1:1</li>\n<li>key result 2: 保证稳健组合中的活期理财（小于6个月）比例不小于50%</li>\n<li>key result 4: 任何资产的仓位都不可能是0%或100%</li>\n</ul>\n<h3 id=\"练习选基-选股的能力\"><a href=\"#练习选基-选股的能力\" class=\"headerlink\" title=\"练习选基/选股的能力\"></a>练习选基/选股的能力</h3><ul>\n<li>key result 1: 分别选择5只信任的主动型基金/固定类基金/短债基金，记录对比参数和选择原因，加入到积极组合持仓中</li>\n<li>key result 2: 选择1-3只信任的美股/港股股票，行业仅限互联网或消费股，记录选择原因，持有一年</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>2020年的整体收益还是满意的，遗憾的是错过了很多翻倍的股票，而且在基金仓位上也过分保守，不过作为一个业余韭菜想要只通过理财实现财富自由是不可能的，我只能把它当作一种抵抗通胀的手段。“我不希望做最聪明的人,但希望避免做蠢事” 如果我们想获得收益，首先要具备定义什么是蠢事的原则，然后做蠢事的次数比市场上其他韭菜同类少就好了。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"收益总结\"><a href=\"#收益总结\" class=\"headerlink\" title=\"收益总结\"></a>收益总结</h2><p>2020年预期总收益率10%，实际整体收益率9.85%，稳健组合收益率2.8%，积极组合收益率17%<br>积极组合中基金收益率25%（年收益率=年持有收益/(当前总市值-年持有收益)）</p>\n<p>在投入成本/回报上，稳健/积极成本占比保持在1:1左右，基金成本占积极组合的50%左右，而在收益贡献上，稳健组合占总收益的15%，积极组合占总收益的85%，其中基金收益占总收益的74%</p>\n<p>在大环境上，今年沪深300上涨27%，创业板上涨64%，黄金上涨13%，中证白酒上涨119%。。</p>\n<h2 id=\"今年做错的事\"><a href=\"#今年做错的事\" class=\"headerlink\" title=\"今年做错的事\"></a>今年做错的事</h2>","more":"<p>为了尽量客观，不被马后炮的心理影响，在总结事情的对错时，我会尽量从当时的行为动机上来判断，按照这件事是否符合原则，是否值得借鉴来判断“对”或“错”。</p>\n<h3 id=\"心态爆炸，追涨杀跌\"><a href=\"#心态爆炸，追涨杀跌\" class=\"headerlink\" title=\"心态爆炸，追涨杀跌\"></a>心态爆炸，追涨杀跌</h3><p>20年美股账户亏损最多的一只股，vix指数etf。</p>\n<img src=\"/2020/12/31/2020年理财总结/vix1.jpeg\" title=\"image\">\n<p>vix指数从19年9月开始持续分批买入，期间vix指数一路下跌，持仓成本大概是15块，直到2020年1月23号武汉封城，1月25号vix上涨11%到13块，在1月27号13块先卖出25%，但是之后的两周美股没有受到疫情影响，vix又开始下跌，<strong>这时我就开始着急了，在2月18号以11块清仓</strong>。然而就在清仓后, 从2月24号开始，一周内vix上涨53%，三月份美股熔断, vix上涨<strong>101%</strong>。后来我又在三月底和五月底买入，最后还是亏损离场。</p>\n<img src=\"/2020/12/31/2020年理财总结/vix0.jpeg\" title=\"image\">\n<p><strong>错误一：决策受情绪影响</strong></p>\n<p>最让人绝望的是先给他希望，然后再给予打击让他希望破灭。之前我可以最大回撤50%仍然持有，但是当黑天鹅出现后，vix当周上涨15%，让我感觉可以回本离场，然后又用两周下跌了15%，这时我又认为疫情对vix利好已经不存在，海外市场也不会受影响，所以清仓放弃。其实当时作出这种判断不能算是错误，毕竟没想到疫情早就已经在海外开始传播，只是爆发时间晚一点而已，最主要的错误还是当时<strong>心态爆炸</strong>直接全部清仓了，如果理智一点的话我可以和1月25号一样分批离场，然后再等待疫情的消息。</p>\n<p><strong>错误二：选择了不了解的股票</strong></p>\n<p>vix这种指数本身就不适合长期持有，它不适合使用定投的策略，而且vix本身更适合在黑天鹅事件发生时做避险或对冲使用，但是我却在<strong>真·黑天鹅</strong>事件来临时把他卖出了，可能所有的黑天鹅事件只有在回头看的时候才能发现它的破坏力，而我本身并没有判断这种重大事件影响的能力，反而容易被媒体和大众情绪影响（比如03年非典时海外病例并不多）。</p>\n<h3 id=\"错失10倍股\"><a href=\"#错失10倍股\" class=\"headerlink\" title=\"错失10倍股\"></a>错失10倍股</h3><img src=\"/2020/12/31/2020年理财总结/nio.jpeg\" title=\"image\">\n<p>错过了10倍股蔚来，今年买入两次蔚来，分别持有了<strong>12天和4天</strong>，第一次买入价格是2.78，现在的价格是49，已经上涨了<strong>17倍</strong>，如果能坚持持有的话，我的美股账户也能回本了😭。</p>\n<p><strong>错误一：买入不信任的公司股票</strong><br>在买入nio时我本身对它并没什么信心（现在也没有），也不了解这家公司（现在也是），买入时只是看它跌的够便宜，想买一只困境反转股，但是一开始就对它的合理估值没有预期，基本涨10%就卖掉了，“用人不疑，疑人不用”这样应该会轻松一点。</p>\n<p><strong>错误二：不能长期持有</strong><br>我的股票交易习惯不好，美股平均持有时间只有一个月左右，因此2020年我错过了b站（持有一个月，27买入，现在85）和拼多多（持有一个月，81买入，现在177）两只翻倍股。。。频繁的短线交易不适合我，一是交易费占总成本比例太高，二是没那个时间，三是即使我每天都买入然后涨一点就卖出，这样确实能有不错的收益，但是对于翻倍股来说仍然没有长期持有收益高。</p>\n<h2 id=\"今年做对的事\"><a href=\"#今年做对的事\" class=\"headerlink\" title=\"今年做对的事\"></a>今年做对的事</h2><h3 id=\"2-3月份市场下跌时主动增加了基金的仓位\"><a href=\"#2-3月份市场下跌时主动增加了基金的仓位\" class=\"headerlink\" title=\"2/3月份市场下跌时主动增加了基金的仓位\"></a>2/3月份市场下跌时主动增加了基金的仓位</h3><p>2月3号是春节后A股第一个交易日，当天上证下跌7.72%到2700点左右，我是从2月4号开始加仓基金，买入了易方达中小盘，易方达上证50，和两只QDII基金（买的少），然后3月份，美股熔断，我又加仓了易方达中小盘和易方达上证50，现在这两只基金收益占我的基金累计收益的50%。</p>\n<p>当时加仓的动机：</p>\n<ol>\n<li><p>首先我的基金占比就不高，并且下跌7%也没有让我心态爆炸，想着“别人恐惧我贪婪”的原则，打算抄底。</p>\n</li>\n<li><p>当时A股的估值并不高，毕竟号称3000点下随便买</p>\n</li>\n<li><p>买入QDII的原因主要是避险，当时我的想法是疫情不会在海外扩散，这和我卖出vix的认知相似</p>\n</li>\n<li><p>买入上证50是感觉龙头股一般抗风险能力更强</p>\n</li>\n</ol>\n<p>这里我做对的是，首先当时<strong>心态</strong>还是比较轻松，没有着急割肉，另外年初时基金<strong>仓位低</strong>，仓位低所以心态平静，也是因为仓位低所以敢继续买入。而且因为不知道后续是否下跌，还使用了<strong>分批买入</strong>的方式（我本打算3号下午收盘前看情况买入，不过错过了，最后在4号买入，当天上证也止跌，收涨1%）。</p>\n<h3 id=\"养成记账的习惯\"><a href=\"#养成记账的习惯\" class=\"headerlink\" title=\"养成记账的习惯\"></a>养成记账的习惯</h3><p>从2019年11月开始，使用基金净值法，每个月记录理财组合的净值和成本变化，虽然很多数据没有分析价值，但是这样可以养成定期总结的习惯，后来从20年10月开始每周在且慢小程序上记录净值和成本。</p>\n<h3 id=\"开始学习筛选基金的方法\"><a href=\"#开始学习筛选基金的方法\" class=\"headerlink\" title=\"开始学习筛选基金的方法\"></a>开始学习筛选基金的方法</h3><p>20年开始会主动关注一些基金理财类的账号，看看明星基金经理的采访，了解基金的分类，费率和评价指标，会使用各种平台对比不同基金，筛选了6只看好的债券类基金，在选择基金时慢慢形成自己的原则。</p>\n<h2 id=\"从今年的经历得到的原则\"><a href=\"#从今年的经历得到的原则\" class=\"headerlink\" title=\"从今年的经历得到的原则\"></a>从今年的经历得到的原则</h2><p>一，不要在心态爆炸的时候做加仓/减仓的操作，即使忍不住也要分批操作，不要一口气清仓/all in</p>\n<p>二，今年的疫情国内控制—&gt;海外爆发，和股市熔断-&gt;暴涨说明，人即使在黑天鹅事件中也无法预测它的破坏力，从历史上也无法得到完全相同的参考，所以不要去赌它的走势和影响</p>\n<p>三，严格执行仓位管理可以避免重大风险事件的影响，可以保证心理健康，也可以保留底牌，避免彻底清仓放弃</p>\n<p>四，选股/选基金前，一定要先做了解，不要让买一只股票的思考时间比选择点哪个外卖的时间还短</p>\n<p>五，每个股票尽量持有一年以上，选择了解且信任的股票/基金，然后长期持有</p>\n<h2 id=\"2021年的目标\"><a href=\"#2021年的目标\" class=\"headerlink\" title=\"2021年的目标\"></a>2021年的目标</h2><h3 id=\"承受-7-最大回撤，预期收益率10\"><a href=\"#承受-7-最大回撤，预期收益率10\" class=\"headerlink\" title=\"承受-7%最大回撤，预期收益率10%\"></a>承受-7%最大回撤，预期收益率10%</h3><p>取值的原因：</p>\n<p>-7%的亏损心理上可以接受，毕竟不会亏损本金，在已经得到收益时人都是风险厌恶的心理，因为忽略了理财的时间成本；<br>10%的年化已经是比较高的目标了，参考沪深300的3年年化是10%，5年年化是8.5%。</p>\n<ul>\n<li>key result 1: 如果明年倒霉，股市大跌，必须在亏损接近7%时分批减仓，然后等机会（3000点以下？）再分批买入</li>\n<li>key result 2: 如果运气好，提前完成目标，必须把基金仓位转换到债券过渡</li>\n<li>key result 3: 如果难完成+10%的目标，至少保证完成+7%以上（这是债券平均收益）</li>\n</ul>\n<h3 id=\"严格执行仓位管理\"><a href=\"#严格执行仓位管理\" class=\"headerlink\" title=\"严格执行仓位管理\"></a>严格执行仓位管理</h3><p>仓位计算方式使用 某个标的市值/总市值，原因是这样比较好算</p>\n<ul>\n<li>key result 0: 按照估算的收益率和最大回撤选择基金/债券/活期理财的比例</li>\n<li>key result 1: 每1到3个月做一次稳健/积极组合的仓位再平衡，保证仓位比例1:1</li>\n<li>key result 2: 保证稳健组合中的活期理财（小于6个月）比例不小于50%</li>\n<li>key result 4: 任何资产的仓位都不可能是0%或100%</li>\n</ul>\n<h3 id=\"练习选基-选股的能力\"><a href=\"#练习选基-选股的能力\" class=\"headerlink\" title=\"练习选基/选股的能力\"></a>练习选基/选股的能力</h3><ul>\n<li>key result 1: 分别选择5只信任的主动型基金/固定类基金/短债基金，记录对比参数和选择原因，加入到积极组合持仓中</li>\n<li>key result 2: 选择1-3只信任的美股/港股股票，行业仅限互联网或消费股，记录选择原因，持有一年</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>2020年的整体收益还是满意的，遗憾的是错过了很多翻倍的股票，而且在基金仓位上也过分保守，不过作为一个业余韭菜想要只通过理财实现财富自由是不可能的，我只能把它当作一种抵抗通胀的手段。“我不希望做最聪明的人,但希望避免做蠢事” 如果我们想获得收益，首先要具备定义什么是蠢事的原则，然后做蠢事的次数比市场上其他韭菜同类少就好了。</p>"},{"title":"如何设计布隆过滤器(1)","date":"2020-08-19T03:53:39.000Z","_content":"\n## what.布隆过滤器是什么\n\n![示意图](https://upload.wikimedia.org/wikipedia/commons/a/ac/Bloom_filter.svg \"示意图\")\n\n<!--more-->\n\n和java的hashmap类似，布隆过滤器(后面用BF代替)是一个使用hash算法+bit数组实现的数据结构，一般只提供**add()/contains()** 两个接口.\nBF比hashmap使用更少的存储空间，但是BF.contains(x)在返回true时，x可能并不存在BF中，这个情况发生的概率这里用**false positive**（fp）表示。不过bloomfilter.contains(x)返回false时，可以**100%**保证x一定不在BF中。\n\nfp存在的原因是，在hash冲突时，hashmap可以通过元素的原始值来查找元素，但是**为了追求更小的空间占用**，BF不可能保存元素的原始值，所以hash冲突发生时，contains()会直接返回true，虽然牺牲了准确率，不过BF可以保证fp不超过期望值。\n因为fp和hash冲突的概率正相关，为了减少hash冲突，BF会使用多个独立的hash函数来定位一个元素，如果一个hash函数冲突的概率是1/m,那么k个hash函数都发生冲突的概率是(1/m)^k。\n\nBF还有其他类型，比如提供resize()方法的可以扩展的BF,提供count()/delete()方法的计数BF。\n| 方法    | hashmap   |  bloomfilter  |\n| --------   | -----:  | :----:  |\n|hash|一次hash计算|多次hash计算|\n|add|Y|Y|\n|contains|Y|Y(有错误概率)|\n|get|Y|N|\n|delete|Y|N（可选）|\n|resize|Y|N（可选）|\n\n## why.为什么要用布隆过滤器\nBF有着出色的空间复杂度，在保存100w元素，fp=0.01条件下，只需要9585058bit,约1.1mb存储空间。\nBF的时间复杂度只有常数级别，插入和查询操作复杂度为O(k),k为hash计算次数。\n基础的BF实现起来也十分简单。\n\n## when.什么时候使用 \nBF一般用来实现一个黑名单的功能，比如浏览器恶意地址检查，爬虫网页地址过滤，推荐系统内容去重等。\n因为hash冲突无法避免，false positive不可能为0, 所以过滤内容时必须处理“误杀”的情况。一般有**接受或二次检查**两种方式，比如在推荐系统中，少量内容的“误杀”是可以接受的。而在恶意地址检查时，浏览器不能拒绝用户访问一个正常地址，所以BF判断网址在黑名单中后，还需要用完整的网址在数据库的黑名单表中执行一次查询。\n\n**什么时候不用**\n1.要单独靠BF实现100%正确的contains()方法的场景\n2.实际元素数量并不多的场景（hashmap就可以搞定）\n3.如果你的元素值本身就是唯一且均匀地分布在一个**有限区域的整数**，比如ipv4地址，一定范围内的时间戳，数据库自增主键等，这时直接使用**bitmap**即可，bitmap使用更少的内存，保证100%正确并且能提供count()方法。\n比如要统计用户在过去一周中哪几天有登陆行为，且用户id是int类型的数据库主键，只需要每天生成一个可以保存全部用户大小的bitmap，在用户登陆时将制定bit设置为1即可，一亿用户大约需要11mb内存，BF在相同条件下需要约100mb内存(fp=0.01)。\n4.如果涉及到删除元素或者很难预估总体元素数量（需要动态扩容）的情况，基础的BF无法满足要求，需要修改内部设计才能实现。\n\n## how.怎么实现布隆过滤器 \n### 如何选择hash函数\n\n**安全性考虑**\nhash函数一般分为**加密hash和非加密hash**两种，主要区别是加密hash比非加密hash有更“好”的安全性，一般体现在hash函数找到碰撞/根据hash值反推出原始内容的成本是否足够高。常见加密hash函数:md5,sha-2，非加密hash函数:crc32,murmurhash等。\n\n在guava和hbase的BF中使用的是**murmurhash**函数，作为非加密hash,murmurhash的速度比较快，并且已经被广泛使用。\n在redission(`github.com/redisson`)的BF实现中使用的是google的**highwayhash**,是一种带token的加密hash函数,需要指定hashseed来计算hash值，我通过简单的测试发现murmurhash和highwayhash的执行速度没有明显区别(字符串长度小于500时)，更准确的性能测试可以参考`github.com/rurban/smhasher`。\n\n选择加密的hash函数可以减少BF受到**hashflood攻击**的可能(恶意制造大量hash冲突发起dos攻击，一般数据结构在hash冲突是查询复杂度会下降，比如java从O(1)下降到O(logn))，因此在使用数据库查询做二次检查的场景，建议使用加密hash。\n\n**速度考虑**\n和BF的介绍不同，在实际使用中只需要调用一次hash函数，然后再用hash值计算出多个子hash值，这样可以减少hash运算的时间，前提是hash函数产生的hash值足够长也分布随机。\n\nhash值的计算代码如下：\n```java\n//128位的hash结果通过长度为2的long数组范围\nlong[] hashes = HighwayHash.hash128(data, 0, data.length, HASH_KEYS);\nlong[] indexes = hash(hashes[0], hashes[1], hashIterations, size);\n//使用hash值，进行iterations次计算\nprivate long[] hash(long hash1, long hash2, int iterations, long size) {\n    long[] indexes = new long[iterations];                                \n    long hash = hash1;                                                  \n    for (int i = 0; i < iterations; i++) {                              \n        indexes[i] = (hash & Long.MAX_VALUE) % size;      \n        //最好不要使用乘法运算\n        if (i % 2 == 0) {                                               \n            hash += hash2;                                              \n        } else {                                                        \n            hash += hash1;                                              \n        }                                                               \n    }                                                                   \n    return indexes;                                                     \n}                                                                       \n```\n\n### 如何保证fp不超过期望值 \n布隆过滤器是通过调整bit数组大小和hash计算次数来控制fp在一定范围以下的。\n**假设bit数组大小为m,要保存的元素数量为n,hash计算次数为k**\nk的[计算过程](https://blog.csdn.net/quiet_girl/article/details/88523974 \"计算过程\")如下：\n\n首先假设每个bit被设置的概率是独立的，那么某个bit被设置为1的概率是 $1/m$\n\n在经过k次hash计算后，这个bit还没有被设置为1的概率是： $(1-1/m)^{k}$，可以近似为： $e^{-k/m}$ (自然对数e的近似公式)\n\n>在已经保存了n个元素后，这个bit还是0的概率：$e^{-nk/m}$, 反之这个bit是1的概率： $1-e^{-nk/m}$\n\n>判断一个元素是否存在时，如果发生hash冲突的概率：$FP=(1-e^{-nk/m})^{k}$\n\n>这时假设函数f(k)，使$FP=f(k)=(1-e^{-nk/m})^{k}$,**让FP取最小值,则函数f(k)的导数等于0**, 经过求导和化简得到:$k=\\frac{m}{n}ln2$\n所以$k$是fp为最小值的情况下，即最佳条件下的hash计算次数。\n\nm的计算过程如下：\n> 前面已经得到$FP=(1-e^{-nk/m})^{k}$, 而$k=\\frac{m}{n}ln2$\n带入k,然后再化简得到 $m=-\\frac{nlnFP}{(ln2)^2}$\n\n在实际使用中，需要先根据fp的期望值和n计算m的大小，然后计算k的值，用代码表示：\n```java\n//计算m                                                                  \nprivate long optimalNumOfBits(long n, double p) {                      \n    if (p == 0) {                                                      \n        p = Double.MIN_VALUE;                                          \n    }                                                                  \n    return (long) (-n * Math.log(p) / (Math.log(2) * Math.log(2)));    \n}     \n//计算k\nprivate int optimalNumOfHashFunctions(long n, long m) {                \n    return Math.max(1, (int) Math.round((double) m / n * Math.log(2)));\n}                                                                      \n                                                                 \n```\n\n## 总结\n布隆过滤器是一个常用的数据结构，通过牺牲准确率获得更高的空间利用率，在实现上会调整bit数组大小和hash计算次数提高准确率。布隆过滤器应用场景有限，一般适用于大量数据重复过滤的情况，在使用时应该根据数据特点与hashmap,bitmap等数据结构做对比。\n\n![关注公众号,第一时间更新](http://throwsnew.com/images/qrcode.jpg \"关注公众号,第一时间更新\")\n\n\n***下期预告：在分布式场景，怎么用布隆过滤器实现全局过滤？***\n\n","source":"_posts/bloomfilter01.md","raw":"---\ntitle: 如何设计布隆过滤器(1)\ndate: 2020-08-19 11:53:39\ntags: [中间件]\n---\n\n## what.布隆过滤器是什么\n\n![示意图](https://upload.wikimedia.org/wikipedia/commons/a/ac/Bloom_filter.svg \"示意图\")\n\n<!--more-->\n\n和java的hashmap类似，布隆过滤器(后面用BF代替)是一个使用hash算法+bit数组实现的数据结构，一般只提供**add()/contains()** 两个接口.\nBF比hashmap使用更少的存储空间，但是BF.contains(x)在返回true时，x可能并不存在BF中，这个情况发生的概率这里用**false positive**（fp）表示。不过bloomfilter.contains(x)返回false时，可以**100%**保证x一定不在BF中。\n\nfp存在的原因是，在hash冲突时，hashmap可以通过元素的原始值来查找元素，但是**为了追求更小的空间占用**，BF不可能保存元素的原始值，所以hash冲突发生时，contains()会直接返回true，虽然牺牲了准确率，不过BF可以保证fp不超过期望值。\n因为fp和hash冲突的概率正相关，为了减少hash冲突，BF会使用多个独立的hash函数来定位一个元素，如果一个hash函数冲突的概率是1/m,那么k个hash函数都发生冲突的概率是(1/m)^k。\n\nBF还有其他类型，比如提供resize()方法的可以扩展的BF,提供count()/delete()方法的计数BF。\n| 方法    | hashmap   |  bloomfilter  |\n| --------   | -----:  | :----:  |\n|hash|一次hash计算|多次hash计算|\n|add|Y|Y|\n|contains|Y|Y(有错误概率)|\n|get|Y|N|\n|delete|Y|N（可选）|\n|resize|Y|N（可选）|\n\n## why.为什么要用布隆过滤器\nBF有着出色的空间复杂度，在保存100w元素，fp=0.01条件下，只需要9585058bit,约1.1mb存储空间。\nBF的时间复杂度只有常数级别，插入和查询操作复杂度为O(k),k为hash计算次数。\n基础的BF实现起来也十分简单。\n\n## when.什么时候使用 \nBF一般用来实现一个黑名单的功能，比如浏览器恶意地址检查，爬虫网页地址过滤，推荐系统内容去重等。\n因为hash冲突无法避免，false positive不可能为0, 所以过滤内容时必须处理“误杀”的情况。一般有**接受或二次检查**两种方式，比如在推荐系统中，少量内容的“误杀”是可以接受的。而在恶意地址检查时，浏览器不能拒绝用户访问一个正常地址，所以BF判断网址在黑名单中后，还需要用完整的网址在数据库的黑名单表中执行一次查询。\n\n**什么时候不用**\n1.要单独靠BF实现100%正确的contains()方法的场景\n2.实际元素数量并不多的场景（hashmap就可以搞定）\n3.如果你的元素值本身就是唯一且均匀地分布在一个**有限区域的整数**，比如ipv4地址，一定范围内的时间戳，数据库自增主键等，这时直接使用**bitmap**即可，bitmap使用更少的内存，保证100%正确并且能提供count()方法。\n比如要统计用户在过去一周中哪几天有登陆行为，且用户id是int类型的数据库主键，只需要每天生成一个可以保存全部用户大小的bitmap，在用户登陆时将制定bit设置为1即可，一亿用户大约需要11mb内存，BF在相同条件下需要约100mb内存(fp=0.01)。\n4.如果涉及到删除元素或者很难预估总体元素数量（需要动态扩容）的情况，基础的BF无法满足要求，需要修改内部设计才能实现。\n\n## how.怎么实现布隆过滤器 \n### 如何选择hash函数\n\n**安全性考虑**\nhash函数一般分为**加密hash和非加密hash**两种，主要区别是加密hash比非加密hash有更“好”的安全性，一般体现在hash函数找到碰撞/根据hash值反推出原始内容的成本是否足够高。常见加密hash函数:md5,sha-2，非加密hash函数:crc32,murmurhash等。\n\n在guava和hbase的BF中使用的是**murmurhash**函数，作为非加密hash,murmurhash的速度比较快，并且已经被广泛使用。\n在redission(`github.com/redisson`)的BF实现中使用的是google的**highwayhash**,是一种带token的加密hash函数,需要指定hashseed来计算hash值，我通过简单的测试发现murmurhash和highwayhash的执行速度没有明显区别(字符串长度小于500时)，更准确的性能测试可以参考`github.com/rurban/smhasher`。\n\n选择加密的hash函数可以减少BF受到**hashflood攻击**的可能(恶意制造大量hash冲突发起dos攻击，一般数据结构在hash冲突是查询复杂度会下降，比如java从O(1)下降到O(logn))，因此在使用数据库查询做二次检查的场景，建议使用加密hash。\n\n**速度考虑**\n和BF的介绍不同，在实际使用中只需要调用一次hash函数，然后再用hash值计算出多个子hash值，这样可以减少hash运算的时间，前提是hash函数产生的hash值足够长也分布随机。\n\nhash值的计算代码如下：\n```java\n//128位的hash结果通过长度为2的long数组范围\nlong[] hashes = HighwayHash.hash128(data, 0, data.length, HASH_KEYS);\nlong[] indexes = hash(hashes[0], hashes[1], hashIterations, size);\n//使用hash值，进行iterations次计算\nprivate long[] hash(long hash1, long hash2, int iterations, long size) {\n    long[] indexes = new long[iterations];                                \n    long hash = hash1;                                                  \n    for (int i = 0; i < iterations; i++) {                              \n        indexes[i] = (hash & Long.MAX_VALUE) % size;      \n        //最好不要使用乘法运算\n        if (i % 2 == 0) {                                               \n            hash += hash2;                                              \n        } else {                                                        \n            hash += hash1;                                              \n        }                                                               \n    }                                                                   \n    return indexes;                                                     \n}                                                                       \n```\n\n### 如何保证fp不超过期望值 \n布隆过滤器是通过调整bit数组大小和hash计算次数来控制fp在一定范围以下的。\n**假设bit数组大小为m,要保存的元素数量为n,hash计算次数为k**\nk的[计算过程](https://blog.csdn.net/quiet_girl/article/details/88523974 \"计算过程\")如下：\n\n首先假设每个bit被设置的概率是独立的，那么某个bit被设置为1的概率是 $1/m$\n\n在经过k次hash计算后，这个bit还没有被设置为1的概率是： $(1-1/m)^{k}$，可以近似为： $e^{-k/m}$ (自然对数e的近似公式)\n\n>在已经保存了n个元素后，这个bit还是0的概率：$e^{-nk/m}$, 反之这个bit是1的概率： $1-e^{-nk/m}$\n\n>判断一个元素是否存在时，如果发生hash冲突的概率：$FP=(1-e^{-nk/m})^{k}$\n\n>这时假设函数f(k)，使$FP=f(k)=(1-e^{-nk/m})^{k}$,**让FP取最小值,则函数f(k)的导数等于0**, 经过求导和化简得到:$k=\\frac{m}{n}ln2$\n所以$k$是fp为最小值的情况下，即最佳条件下的hash计算次数。\n\nm的计算过程如下：\n> 前面已经得到$FP=(1-e^{-nk/m})^{k}$, 而$k=\\frac{m}{n}ln2$\n带入k,然后再化简得到 $m=-\\frac{nlnFP}{(ln2)^2}$\n\n在实际使用中，需要先根据fp的期望值和n计算m的大小，然后计算k的值，用代码表示：\n```java\n//计算m                                                                  \nprivate long optimalNumOfBits(long n, double p) {                      \n    if (p == 0) {                                                      \n        p = Double.MIN_VALUE;                                          \n    }                                                                  \n    return (long) (-n * Math.log(p) / (Math.log(2) * Math.log(2)));    \n}     \n//计算k\nprivate int optimalNumOfHashFunctions(long n, long m) {                \n    return Math.max(1, (int) Math.round((double) m / n * Math.log(2)));\n}                                                                      \n                                                                 \n```\n\n## 总结\n布隆过滤器是一个常用的数据结构，通过牺牲准确率获得更高的空间利用率，在实现上会调整bit数组大小和hash计算次数提高准确率。布隆过滤器应用场景有限，一般适用于大量数据重复过滤的情况，在使用时应该根据数据特点与hashmap,bitmap等数据结构做对比。\n\n![关注公众号,第一时间更新](http://throwsnew.com/images/qrcode.jpg \"关注公众号,第一时间更新\")\n\n\n***下期预告：在分布式场景，怎么用布隆过滤器实现全局过滤？***\n\n","slug":"bloomfilter01","published":1,"updated":"2020-10-19T05:12:01.452Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkqle1cl0027cynedp3tuz6x","content":"<h2 id=\"what-布隆过滤器是什么\"><a href=\"#what-布隆过滤器是什么\" class=\"headerlink\" title=\"what.布隆过滤器是什么\"></a>what.布隆过滤器是什么</h2><p><img src=\"https://upload.wikimedia.org/wikipedia/commons/a/ac/Bloom_filter.svg\" alt=\"示意图\" title=\"示意图\"></p>\n<a id=\"more\"></a>\n<p>和java的hashmap类似，布隆过滤器(后面用BF代替)是一个使用hash算法+bit数组实现的数据结构，一般只提供<strong>add()/contains()</strong> 两个接口.<br>BF比hashmap使用更少的存储空间，但是BF.contains(x)在返回true时，x可能并不存在BF中，这个情况发生的概率这里用<strong>false positive</strong>（fp）表示。不过bloomfilter.contains(x)返回false时，可以<strong>100%</strong>保证x一定不在BF中。</p>\n<p>fp存在的原因是，在hash冲突时，hashmap可以通过元素的原始值来查找元素，但是<strong>为了追求更小的空间占用</strong>，BF不可能保存元素的原始值，所以hash冲突发生时，contains()会直接返回true，虽然牺牲了准确率，不过BF可以保证fp不超过期望值。<br>因为fp和hash冲突的概率正相关，为了减少hash冲突，BF会使用多个独立的hash函数来定位一个元素，如果一个hash函数冲突的概率是1/m,那么k个hash函数都发生冲突的概率是(1/m)^k。</p>\n<p>BF还有其他类型，比如提供resize()方法的可以扩展的BF,提供count()/delete()方法的计数BF。<br>| 方法    | hashmap   |  bloomfilter  |<br>| ——–   | —–:  | :—-:  |<br>|hash|一次hash计算|多次hash计算|<br>|add|Y|Y|<br>|contains|Y|Y(有错误概率)|<br>|get|Y|N|<br>|delete|Y|N（可选）|<br>|resize|Y|N（可选）|</p>\n<h2 id=\"why-为什么要用布隆过滤器\"><a href=\"#why-为什么要用布隆过滤器\" class=\"headerlink\" title=\"why.为什么要用布隆过滤器\"></a>why.为什么要用布隆过滤器</h2><p>BF有着出色的空间复杂度，在保存100w元素，fp=0.01条件下，只需要9585058bit,约1.1mb存储空间。<br>BF的时间复杂度只有常数级别，插入和查询操作复杂度为O(k),k为hash计算次数。<br>基础的BF实现起来也十分简单。</p>\n<h2 id=\"when-什么时候使用\"><a href=\"#when-什么时候使用\" class=\"headerlink\" title=\"when.什么时候使用\"></a>when.什么时候使用</h2><p>BF一般用来实现一个黑名单的功能，比如浏览器恶意地址检查，爬虫网页地址过滤，推荐系统内容去重等。<br>因为hash冲突无法避免，false positive不可能为0, 所以过滤内容时必须处理“误杀”的情况。一般有<strong>接受或二次检查</strong>两种方式，比如在推荐系统中，少量内容的“误杀”是可以接受的。而在恶意地址检查时，浏览器不能拒绝用户访问一个正常地址，所以BF判断网址在黑名单中后，还需要用完整的网址在数据库的黑名单表中执行一次查询。</p>\n<p><strong>什么时候不用</strong><br>1.要单独靠BF实现100%正确的contains()方法的场景<br>2.实际元素数量并不多的场景（hashmap就可以搞定）<br>3.如果你的元素值本身就是唯一且均匀地分布在一个<strong>有限区域的整数</strong>，比如ipv4地址，一定范围内的时间戳，数据库自增主键等，这时直接使用<strong>bitmap</strong>即可，bitmap使用更少的内存，保证100%正确并且能提供count()方法。<br>比如要统计用户在过去一周中哪几天有登陆行为，且用户id是int类型的数据库主键，只需要每天生成一个可以保存全部用户大小的bitmap，在用户登陆时将制定bit设置为1即可，一亿用户大约需要11mb内存，BF在相同条件下需要约100mb内存(fp=0.01)。<br>4.如果涉及到删除元素或者很难预估总体元素数量（需要动态扩容）的情况，基础的BF无法满足要求，需要修改内部设计才能实现。</p>\n<h2 id=\"how-怎么实现布隆过滤器\"><a href=\"#how-怎么实现布隆过滤器\" class=\"headerlink\" title=\"how.怎么实现布隆过滤器\"></a>how.怎么实现布隆过滤器</h2><h3 id=\"如何选择hash函数\"><a href=\"#如何选择hash函数\" class=\"headerlink\" title=\"如何选择hash函数\"></a>如何选择hash函数</h3><p><strong>安全性考虑</strong><br>hash函数一般分为<strong>加密hash和非加密hash</strong>两种，主要区别是加密hash比非加密hash有更“好”的安全性，一般体现在hash函数找到碰撞/根据hash值反推出原始内容的成本是否足够高。常见加密hash函数:md5,sha-2，非加密hash函数:crc32,murmurhash等。</p>\n<p>在guava和hbase的BF中使用的是<strong>murmurhash</strong>函数，作为非加密hash,murmurhash的速度比较快，并且已经被广泛使用。<br>在redission(<code>github.com/redisson</code>)的BF实现中使用的是google的<strong>highwayhash</strong>,是一种带token的加密hash函数,需要指定hashseed来计算hash值，我通过简单的测试发现murmurhash和highwayhash的执行速度没有明显区别(字符串长度小于500时)，更准确的性能测试可以参考<code>github.com/rurban/smhasher</code>。</p>\n<p>选择加密的hash函数可以减少BF受到<strong>hashflood攻击</strong>的可能(恶意制造大量hash冲突发起dos攻击，一般数据结构在hash冲突是查询复杂度会下降，比如java从O(1)下降到O(logn))，因此在使用数据库查询做二次检查的场景，建议使用加密hash。</p>\n<p><strong>速度考虑</strong><br>和BF的介绍不同，在实际使用中只需要调用一次hash函数，然后再用hash值计算出多个子hash值，这样可以减少hash运算的时间，前提是hash函数产生的hash值足够长也分布随机。</p>\n<p>hash值的计算代码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//128位的hash结果通过长度为2的long数组范围</span></span><br><span class=\"line\"><span class=\"keyword\">long</span>[] hashes = HighwayHash.hash128(data, <span class=\"number\">0</span>, data.length, HASH_KEYS);</span><br><span class=\"line\"><span class=\"keyword\">long</span>[] indexes = hash(hashes[<span class=\"number\">0</span>], hashes[<span class=\"number\">1</span>], hashIterations, size);</span><br><span class=\"line\"><span class=\"comment\">//使用hash值，进行iterations次计算</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">long</span>[] hash(<span class=\"keyword\">long</span> hash1, <span class=\"keyword\">long</span> hash2, <span class=\"keyword\">int</span> iterations, <span class=\"keyword\">long</span> size) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span>[] indexes = <span class=\"keyword\">new</span> <span class=\"keyword\">long</span>[iterations];                                </span><br><span class=\"line\">    <span class=\"keyword\">long</span> hash = hash1;                                                  </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; iterations; i++) &#123;                              </span><br><span class=\"line\">        indexes[i] = (hash &amp; Long.MAX_VALUE) % size;      </span><br><span class=\"line\">        <span class=\"comment\">//最好不要使用乘法运算</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i % <span class=\"number\">2</span> == <span class=\"number\">0</span>) &#123;                                               </span><br><span class=\"line\">            hash += hash2;                                              </span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;                                                        </span><br><span class=\"line\">            hash += hash1;                                              </span><br><span class=\"line\">        &#125;                                                               </span><br><span class=\"line\">    &#125;                                                                   </span><br><span class=\"line\">    <span class=\"keyword\">return</span> indexes;                                                     </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"如何保证fp不超过期望值\"><a href=\"#如何保证fp不超过期望值\" class=\"headerlink\" title=\"如何保证fp不超过期望值\"></a>如何保证fp不超过期望值</h3><p>布隆过滤器是通过调整bit数组大小和hash计算次数来控制fp在一定范围以下的。<br><strong>假设bit数组大小为m,要保存的元素数量为n,hash计算次数为k</strong><br>k的<a href=\"https://blog.csdn.net/quiet_girl/article/details/88523974\" title=\"计算过程\" target=\"_blank\" rel=\"noopener\">计算过程</a>如下：</p>\n<p>首先假设每个bit被设置的概率是独立的，那么某个bit被设置为1的概率是 $1/m$</p>\n<p>在经过k次hash计算后，这个bit还没有被设置为1的概率是： $(1-1/m)^{k}$，可以近似为： $e^{-k/m}$ (自然对数e的近似公式)</p>\n<blockquote>\n<p>在已经保存了n个元素后，这个bit还是0的概率：$e^{-nk/m}$, 反之这个bit是1的概率： $1-e^{-nk/m}$</p>\n</blockquote>\n<blockquote>\n<p>判断一个元素是否存在时，如果发生hash冲突的概率：$FP=(1-e^{-nk/m})^{k}$</p>\n</blockquote>\n<blockquote>\n<p>这时假设函数f(k)，使$FP=f(k)=(1-e^{-nk/m})^{k}$,<strong>让FP取最小值,则函数f(k)的导数等于0</strong>, 经过求导和化简得到:$k=\\frac{m}{n}ln2$<br>所以$k$是fp为最小值的情况下，即最佳条件下的hash计算次数。</p>\n</blockquote>\n<p>m的计算过程如下：</p>\n<blockquote>\n<p>前面已经得到$FP=(1-e^{-nk/m})^{k}$, 而$k=\\frac{m}{n}ln2$<br>带入k,然后再化简得到 $m=-\\frac{nlnFP}{(ln2)^2}$</p>\n</blockquote>\n<p>在实际使用中，需要先根据fp的期望值和n计算m的大小，然后计算k的值，用代码表示：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//计算m                                                                  </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">long</span> <span class=\"title\">optimalNumOfBits</span><span class=\"params\">(<span class=\"keyword\">long</span> n, <span class=\"keyword\">double</span> p)</span> </span>&#123;                      </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p == <span class=\"number\">0</span>) &#123;                                                      </span><br><span class=\"line\">        p = Double.MIN_VALUE;                                          </span><br><span class=\"line\">    &#125;                                                                  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"keyword\">long</span>) (-n * Math.log(p) / (Math.log(<span class=\"number\">2</span>) * Math.log(<span class=\"number\">2</span>)));    </span><br><span class=\"line\">&#125;     </span><br><span class=\"line\"><span class=\"comment\">//计算k</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">optimalNumOfHashFunctions</span><span class=\"params\">(<span class=\"keyword\">long</span> n, <span class=\"keyword\">long</span> m)</span> </span>&#123;                </span><br><span class=\"line\">    <span class=\"keyword\">return</span> Math.max(<span class=\"number\">1</span>, (<span class=\"keyword\">int</span>) Math.round((<span class=\"keyword\">double</span>) m / n * Math.log(<span class=\"number\">2</span>)));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>布隆过滤器是一个常用的数据结构，通过牺牲准确率获得更高的空间利用率，在实现上会调整bit数组大小和hash计算次数提高准确率。布隆过滤器应用场景有限，一般适用于大量数据重复过滤的情况，在使用时应该根据数据特点与hashmap,bitmap等数据结构做对比。</p>\n<p><img src=\"http://throwsnew.com/images/qrcode.jpg\" alt=\"关注公众号,第一时间更新\" title=\"关注公众号,第一时间更新\"></p>\n<p><strong><em>下期预告：在分布式场景，怎么用布隆过滤器实现全局过滤？</em></strong></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"what-布隆过滤器是什么\"><a href=\"#what-布隆过滤器是什么\" class=\"headerlink\" title=\"what.布隆过滤器是什么\"></a>what.布隆过滤器是什么</h2><p><img src=\"https://upload.wikimedia.org/wikipedia/commons/a/ac/Bloom_filter.svg\" alt=\"示意图\" title=\"示意图\"></p>","more":"<p>和java的hashmap类似，布隆过滤器(后面用BF代替)是一个使用hash算法+bit数组实现的数据结构，一般只提供<strong>add()/contains()</strong> 两个接口.<br>BF比hashmap使用更少的存储空间，但是BF.contains(x)在返回true时，x可能并不存在BF中，这个情况发生的概率这里用<strong>false positive</strong>（fp）表示。不过bloomfilter.contains(x)返回false时，可以<strong>100%</strong>保证x一定不在BF中。</p>\n<p>fp存在的原因是，在hash冲突时，hashmap可以通过元素的原始值来查找元素，但是<strong>为了追求更小的空间占用</strong>，BF不可能保存元素的原始值，所以hash冲突发生时，contains()会直接返回true，虽然牺牲了准确率，不过BF可以保证fp不超过期望值。<br>因为fp和hash冲突的概率正相关，为了减少hash冲突，BF会使用多个独立的hash函数来定位一个元素，如果一个hash函数冲突的概率是1/m,那么k个hash函数都发生冲突的概率是(1/m)^k。</p>\n<p>BF还有其他类型，比如提供resize()方法的可以扩展的BF,提供count()/delete()方法的计数BF。<br>| 方法    | hashmap   |  bloomfilter  |<br>| ——–   | —–:  | :—-:  |<br>|hash|一次hash计算|多次hash计算|<br>|add|Y|Y|<br>|contains|Y|Y(有错误概率)|<br>|get|Y|N|<br>|delete|Y|N（可选）|<br>|resize|Y|N（可选）|</p>\n<h2 id=\"why-为什么要用布隆过滤器\"><a href=\"#why-为什么要用布隆过滤器\" class=\"headerlink\" title=\"why.为什么要用布隆过滤器\"></a>why.为什么要用布隆过滤器</h2><p>BF有着出色的空间复杂度，在保存100w元素，fp=0.01条件下，只需要9585058bit,约1.1mb存储空间。<br>BF的时间复杂度只有常数级别，插入和查询操作复杂度为O(k),k为hash计算次数。<br>基础的BF实现起来也十分简单。</p>\n<h2 id=\"when-什么时候使用\"><a href=\"#when-什么时候使用\" class=\"headerlink\" title=\"when.什么时候使用\"></a>when.什么时候使用</h2><p>BF一般用来实现一个黑名单的功能，比如浏览器恶意地址检查，爬虫网页地址过滤，推荐系统内容去重等。<br>因为hash冲突无法避免，false positive不可能为0, 所以过滤内容时必须处理“误杀”的情况。一般有<strong>接受或二次检查</strong>两种方式，比如在推荐系统中，少量内容的“误杀”是可以接受的。而在恶意地址检查时，浏览器不能拒绝用户访问一个正常地址，所以BF判断网址在黑名单中后，还需要用完整的网址在数据库的黑名单表中执行一次查询。</p>\n<p><strong>什么时候不用</strong><br>1.要单独靠BF实现100%正确的contains()方法的场景<br>2.实际元素数量并不多的场景（hashmap就可以搞定）<br>3.如果你的元素值本身就是唯一且均匀地分布在一个<strong>有限区域的整数</strong>，比如ipv4地址，一定范围内的时间戳，数据库自增主键等，这时直接使用<strong>bitmap</strong>即可，bitmap使用更少的内存，保证100%正确并且能提供count()方法。<br>比如要统计用户在过去一周中哪几天有登陆行为，且用户id是int类型的数据库主键，只需要每天生成一个可以保存全部用户大小的bitmap，在用户登陆时将制定bit设置为1即可，一亿用户大约需要11mb内存，BF在相同条件下需要约100mb内存(fp=0.01)。<br>4.如果涉及到删除元素或者很难预估总体元素数量（需要动态扩容）的情况，基础的BF无法满足要求，需要修改内部设计才能实现。</p>\n<h2 id=\"how-怎么实现布隆过滤器\"><a href=\"#how-怎么实现布隆过滤器\" class=\"headerlink\" title=\"how.怎么实现布隆过滤器\"></a>how.怎么实现布隆过滤器</h2><h3 id=\"如何选择hash函数\"><a href=\"#如何选择hash函数\" class=\"headerlink\" title=\"如何选择hash函数\"></a>如何选择hash函数</h3><p><strong>安全性考虑</strong><br>hash函数一般分为<strong>加密hash和非加密hash</strong>两种，主要区别是加密hash比非加密hash有更“好”的安全性，一般体现在hash函数找到碰撞/根据hash值反推出原始内容的成本是否足够高。常见加密hash函数:md5,sha-2，非加密hash函数:crc32,murmurhash等。</p>\n<p>在guava和hbase的BF中使用的是<strong>murmurhash</strong>函数，作为非加密hash,murmurhash的速度比较快，并且已经被广泛使用。<br>在redission(<code>github.com/redisson</code>)的BF实现中使用的是google的<strong>highwayhash</strong>,是一种带token的加密hash函数,需要指定hashseed来计算hash值，我通过简单的测试发现murmurhash和highwayhash的执行速度没有明显区别(字符串长度小于500时)，更准确的性能测试可以参考<code>github.com/rurban/smhasher</code>。</p>\n<p>选择加密的hash函数可以减少BF受到<strong>hashflood攻击</strong>的可能(恶意制造大量hash冲突发起dos攻击，一般数据结构在hash冲突是查询复杂度会下降，比如java从O(1)下降到O(logn))，因此在使用数据库查询做二次检查的场景，建议使用加密hash。</p>\n<p><strong>速度考虑</strong><br>和BF的介绍不同，在实际使用中只需要调用一次hash函数，然后再用hash值计算出多个子hash值，这样可以减少hash运算的时间，前提是hash函数产生的hash值足够长也分布随机。</p>\n<p>hash值的计算代码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//128位的hash结果通过长度为2的long数组范围</span></span><br><span class=\"line\"><span class=\"keyword\">long</span>[] hashes = HighwayHash.hash128(data, <span class=\"number\">0</span>, data.length, HASH_KEYS);</span><br><span class=\"line\"><span class=\"keyword\">long</span>[] indexes = hash(hashes[<span class=\"number\">0</span>], hashes[<span class=\"number\">1</span>], hashIterations, size);</span><br><span class=\"line\"><span class=\"comment\">//使用hash值，进行iterations次计算</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">long</span>[] hash(<span class=\"keyword\">long</span> hash1, <span class=\"keyword\">long</span> hash2, <span class=\"keyword\">int</span> iterations, <span class=\"keyword\">long</span> size) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span>[] indexes = <span class=\"keyword\">new</span> <span class=\"keyword\">long</span>[iterations];                                </span><br><span class=\"line\">    <span class=\"keyword\">long</span> hash = hash1;                                                  </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; iterations; i++) &#123;                              </span><br><span class=\"line\">        indexes[i] = (hash &amp; Long.MAX_VALUE) % size;      </span><br><span class=\"line\">        <span class=\"comment\">//最好不要使用乘法运算</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i % <span class=\"number\">2</span> == <span class=\"number\">0</span>) &#123;                                               </span><br><span class=\"line\">            hash += hash2;                                              </span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;                                                        </span><br><span class=\"line\">            hash += hash1;                                              </span><br><span class=\"line\">        &#125;                                                               </span><br><span class=\"line\">    &#125;                                                                   </span><br><span class=\"line\">    <span class=\"keyword\">return</span> indexes;                                                     </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"如何保证fp不超过期望值\"><a href=\"#如何保证fp不超过期望值\" class=\"headerlink\" title=\"如何保证fp不超过期望值\"></a>如何保证fp不超过期望值</h3><p>布隆过滤器是通过调整bit数组大小和hash计算次数来控制fp在一定范围以下的。<br><strong>假设bit数组大小为m,要保存的元素数量为n,hash计算次数为k</strong><br>k的<a href=\"https://blog.csdn.net/quiet_girl/article/details/88523974\" title=\"计算过程\" target=\"_blank\" rel=\"noopener\">计算过程</a>如下：</p>\n<p>首先假设每个bit被设置的概率是独立的，那么某个bit被设置为1的概率是 $1/m$</p>\n<p>在经过k次hash计算后，这个bit还没有被设置为1的概率是： $(1-1/m)^{k}$，可以近似为： $e^{-k/m}$ (自然对数e的近似公式)</p>\n<blockquote>\n<p>在已经保存了n个元素后，这个bit还是0的概率：$e^{-nk/m}$, 反之这个bit是1的概率： $1-e^{-nk/m}$</p>\n</blockquote>\n<blockquote>\n<p>判断一个元素是否存在时，如果发生hash冲突的概率：$FP=(1-e^{-nk/m})^{k}$</p>\n</blockquote>\n<blockquote>\n<p>这时假设函数f(k)，使$FP=f(k)=(1-e^{-nk/m})^{k}$,<strong>让FP取最小值,则函数f(k)的导数等于0</strong>, 经过求导和化简得到:$k=\\frac{m}{n}ln2$<br>所以$k$是fp为最小值的情况下，即最佳条件下的hash计算次数。</p>\n</blockquote>\n<p>m的计算过程如下：</p>\n<blockquote>\n<p>前面已经得到$FP=(1-e^{-nk/m})^{k}$, 而$k=\\frac{m}{n}ln2$<br>带入k,然后再化简得到 $m=-\\frac{nlnFP}{(ln2)^2}$</p>\n</blockquote>\n<p>在实际使用中，需要先根据fp的期望值和n计算m的大小，然后计算k的值，用代码表示：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//计算m                                                                  </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">long</span> <span class=\"title\">optimalNumOfBits</span><span class=\"params\">(<span class=\"keyword\">long</span> n, <span class=\"keyword\">double</span> p)</span> </span>&#123;                      </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p == <span class=\"number\">0</span>) &#123;                                                      </span><br><span class=\"line\">        p = Double.MIN_VALUE;                                          </span><br><span class=\"line\">    &#125;                                                                  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"keyword\">long</span>) (-n * Math.log(p) / (Math.log(<span class=\"number\">2</span>) * Math.log(<span class=\"number\">2</span>)));    </span><br><span class=\"line\">&#125;     </span><br><span class=\"line\"><span class=\"comment\">//计算k</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">optimalNumOfHashFunctions</span><span class=\"params\">(<span class=\"keyword\">long</span> n, <span class=\"keyword\">long</span> m)</span> </span>&#123;                </span><br><span class=\"line\">    <span class=\"keyword\">return</span> Math.max(<span class=\"number\">1</span>, (<span class=\"keyword\">int</span>) Math.round((<span class=\"keyword\">double</span>) m / n * Math.log(<span class=\"number\">2</span>)));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>布隆过滤器是一个常用的数据结构，通过牺牲准确率获得更高的空间利用率，在实现上会调整bit数组大小和hash计算次数提高准确率。布隆过滤器应用场景有限，一般适用于大量数据重复过滤的情况，在使用时应该根据数据特点与hashmap,bitmap等数据结构做对比。</p>\n<p><img src=\"http://throwsnew.com/images/qrcode.jpg\" alt=\"关注公众号,第一时间更新\" title=\"关注公众号,第一时间更新\"></p>\n<p><strong><em>下期预告：在分布式场景，怎么用布隆过滤器实现全局过滤？</em></strong></p>"},{"title":"jenkins on kubernetes实践","date":"2017-08-26T13:05:46.000Z","_content":"\n**jenkins是什么？**\nJenkins是一个开源的持续集成工具，可用于自动化的执行与构建，测试和交付或部署软件有关的各种任务,有非常丰富的插件支持。\n**kubernetes是什么？**\nKubernetes是容器集群管理系统，是一个开源的平台，可以实现容器集群的自动化部署、自动扩缩容、维护等功能。[这个视频生动地介绍了k8s][1]\n**jenkins on k8s 有什么好处？**\njenkins通过单Master多个Slave的方式提供服务，Master保存了任务的配置信息，安装的插件等等，而slave主要负责执行任务，在使用中存在以下几个问题：\n<!--more-->\n1. 当存在多个slave时，运行slave的机器难以统一管理，每次添加新节点时总要做大量的重复工作。\n2. 由于不同业务的构建频率并不相同，在使用会发现有很多slave大多数时间都处于空闲状态，造成资源浪费\n3. jenkins默认采取保守的调度方式，造成某些slave的负载过高，任务不能平均分配\n![jenkins架构][2]\n\n使用k8s管理jenkins具有以下优势：\n\n1. 使用docker运行jenkins保证环境的一致性，可以根据不同业务选择合适的镜像\n2. k8s对抽象后的资源（pods）进行统一的管理调度，提供资源隔离和共享，使机器计算资源变得弹性可扩展,避免资源浪费。\n3. k8s提供容器的自愈功能，能够保证始终有一定数量的容器是可用的\n4. k8s默认的调度器提供了针对节点当前资源分配容器的调度策略，调度器支持插件化部署便于自定义。\n\n### **一，搭建环境**\n\n#### 工具准备\n\n> kubernetes v1.8.4\ndocker v1.12.6\njenkins master镜像 jenkins/jenkins:lts（v2.73.3）\nslave镜像 jenkinsci/jnlp-slave\nKubernetes plugin (v1.1)\n\n#### 安装kubernetes集群\n\n中文教程：https://www.kubernetes.org.cn/2906.html\n安装成功之后访问dashboard地址就可以看到集群的控制面板：\n![dashboard][3]\n集群安装完成后，创建命名空间kubernetes-plugin\n```\nkubectl create namespace kubernetes-plugin\nkubectl config set-context $(kubectl config current-context) --namespace=kubernetes-plugin\nkubectl create -f service-account.yml\n```\n\n### **二，创建StatefulSet**\n>**StatefulSet(有状态副本集)**：Deployments适用于运行无状态应用，StatefulSet则为有状态的应用提供了支持，可以为应用提供有序的部署和扩展，稳定的持久化存储，我们使用SS来运行jenkins master。\n\n创建完整的Stateful Set需要依次创建一下对象：\n1、Persistent Volume\n2、Persistent Volume Claim\n3、StatefulSet\n4、Service\n\n\n#### **创建PersistentVolume：**\n\n为了保存应用运行时的数据需要先创建k8s的卷文件，K8s中存在Volume和PersistentVolume两种类型：\n\n >- Volume：与docker中的volume不同在于Volume生命周期是和pod绑定的，与pod中的container无关。k8s为Volume提供了多种类型文件系统（cephfs,nfs...,简单起见我直接选择了hostPath，使用的node节点本地的存储系统）\n >- PersistentVolume:从名字可以看出来，PV的生命周期独立于使用它的pod，不会像volume随pod消失而消失，而是做为一个集群中的资源存在（像node节点一样），同时PV屏蔽了使用具体存储系统的细节。\n\nk8s中的对象都是通过[yaml文件][4]来定义的，首先创建名为`jenkins-volume.yml`的文件:\n\n**注意**：PV的创建有静态，动态两种方式，动态创建可以减少管理员的操作步骤，需要提供指定的[StorageClass][5]。为了测试方便，所以我们直接选择静态创建，manual是一个不存在的storage class\n```\nkind: PersistentVolume\napiVersion: v1\nmetadata:\n  name: jenkins-volume\n  labels:\n    type: local\nspec:\n  storageClassName: manual\n  capacity:\n    storage: 10Gi\n  accessModes:\n    - ReadWriteOnce\n  hostPath:\n    path: \"/tmp/data\"\n\n```\nmaster节点执行下面的命令，PV就手动创建完了\n`kubectl create -f jenkins-volume1.yaml`\n#### **创建PersistentVolumeClaim：**\n>PersistentVolumeClaim(PVC):\n持久化存储卷索取，如果说PV是集群中的资源，PVC就是资源的消费者，PVC可以指定需要的资源大小和访问方式,pod不会和PV直接接触，而是通过PVC来请求资源，PV的生成阶段叫做provision,生成PV后会绑定到PVC对象，然后才能被其他对象使用。\n\nPV和PVC的生命周期如下图：\n![pv life][6]\n\n创建文件`jenkins-claim.yaml`\n**注意：** name必须为jenkins-home-jenkins-0否则会绑定失败\n```\nkind: PersistentVolumeClaim\napiVersion: v1\nmetadata:\n  name: jenkins-home-jenkins-0\nspec:\n  storageClassName: manual\n  accessModes:\n    - ReadWriteOnce\n  resources:\n    requests:\n      storage: 3Gi\n```\n执行命令`kubectl create -f jenkins-claim.yaml`\n然后查看PVC是否创建成功，status为bound说明PVC已经绑定\n```\n[root@master ~]# kubectl describe pvc jenkins-home-jenkins-0\nName:          jenkins-home-jenkins-0\nNamespace:     kubernetes-plugin\nStorageClass:  manual\nStatus:        Bound\nVolume:        jenkins-volume\nLabels:        <none>\nAnnotations:   pv.kubernetes.io/bind-completed=yes\n               pv.kubernetes.io/bound-by-controller=yes\nCapacity:      10Gi\nAccess Modes:  RWO\nEvents:        <none>\n```\n#### **创建StatefulSet和Service：**\n\n从kubernetes-plugin github仓库下载jenkins.yml文件\n```\nwget https://raw.githubusercontent.com/jenkinsci/kubernetes-plugin/master/src/main/kubernetes/jenkins.yml\n```\n修改jenkins.yml：\n去掉87行`externalTrafficPolicy: Local`（这是GKE使用的）\n修改83行` type: LoadBalancer`改为` type: NodePort`\n\n**注意：** \nservice type=ClusterIP时只允许从集群内部访问， type设置为NodePort是为了从集群外的机器访问jenkins,请谨慎使用，开启NodePort会在所有节点（含master）的统一固定端口开放服务。\n\n执行命令\n```\n[root@master ~]# kubectl create -f jenkins.yml \nstatefulset \"jenkins\" created\nservice \"jenkins\" created\n```\n访问jenkins master,地址为`masterip:32058`\n```\n#查看映射的端口\n[root@master ~]# kubectl get service jenkins\nNAME      TYPE       CLUSTER-IP    EXTERNAL-IP   PORT(S)                        AGE\njenkins   NodePort   10.96.82.68   <none>        80:32058/TCP,50000:30345/TCP   1m\n```\n查看pod : jenkins-0的容器日志，粘贴下面的密码进入jenkins,jenkins安装完成。\n> Jenkins initial setup is required. An admin user has been created and a password generated.\nPlease use the following password to proceed to installation:\n70aa7b41ba894855abccd09306625b8a \n\n刷新dashboard，切换命名空间到kubernetes-plugin,结果如下：\n![success][7]\n\n### 问题分析\n1.创建stateful set时失败，提示\"PersistentVolumeClaim is not bound: \"jenkins-home-jenkins-0\"：\"\n因为采用静态创建PV时，StatefulSet会按照固定名称查找PVC，PVC的名字要满足\n>PVC_name == volumeClaimTemplates_name + \"-\" + pod_name\n\n这里的名字就是`jenkins-home-jenkins-0`\n\n2.pod启动失败，jenkins用户没有目录权限\n错误提示\"touch: cannot touch ‘/var/jenkins_home/copy_reference_file.log’: Permission denied\nCan not write to /var/jenkins_home/copy_reference_file.log. Wrong volume permissions?\"\n要确保节点目录开放权限,在node上执行命令：\n```\nsudo chown -R 1000:1000 /var/jenkins_home/\nsudo chown -R 1000:1000 /tmp/data\n##如果仍然失败，尝试在node上重启docker\nsystemctl restart docker\n\n```\n注意pv指定的hostPath权限也要修改，否则是无效的\n\n\n\n###  三 ，配置jenkins\n#### 创建jenkins服务账号\n```\nwget https://raw.githubusercontent.com/jenkinsci/kubernetes-plugin/master/src/main/kubernetes/service-account.yml\nkubectl create -f service-account.yml\n```\n#### 配置插件\n访问`http://masterip:32058/pluginManager/`,搜索插件Kubernetes plugin安装；\n访问 http://masterip:32058/configure\n选择新建云--kubernetes,在URl填写api server地址，\n执行kubectl describe命令，复制output中的token，填入到 ‘Kubernetes server certificate key’\n```\n[root@master ~]# kubectl get secret \nNAME                  TYPE                                  DATA      AGE\ndefault-token-4kb54   kubernetes.io/service-account-token   3         1d\njenkins-token-wzbsx   kubernetes.io/service-account-token   3         1d\n[root@master ~]# kubectl describe secret/jenkins-token-wzbsx\n...\n```\njenkins url,tunnel填写service的CLUSTER-IP即可，结果如图：\n![peizhi1][8]\n选择add pod template，填写下面的内容，retain slave可以设置运行jenkins slave 的container空闲后能存活多久。\n![content][9]\n插件配置完成。\n### 四 ，测试\n#### 1. 扩容测试\n**StatefulSet扩容：**\n首先需要手动创建PV，PVC(见第二步),然后执行扩容命令\n` kubectl scale statefulset/jenkins --replicas=２`\n查看StatefulSet,此时已经拥有两个master节点，访问service时会**随机**将请求发送给后端的master。\n```\n[root@master ~]# kubectl get statefulset/jenkins \nNAME      DESIRED   CURRENT   AGE\njenkins   2         2         5d\n```\n虽然通过k8s可以轻松实现jenkins master节点的拓展，但是由于jenkins存储数据的方式通过本地文件存储，master之间的数据同步还是一个麻烦的问题，参考[jenkins存储模型][10]。\n\n*jenkins master上保存的文件：*\n```\nls /temp/data\njenkins.CLI.xml\njenkins.install.InstallUtil.lastExecVersion\njenkins.install.UpgradeWizard.state\njenkins.model.ArtifactManagerConfiguration.xml\njenkins.model.JenkinsLocationConfiguration.xml\njobs\nlogs\nnodeMonitors.xml\nnodes\n```\n\n#### 2. 高可用测试\n现在stateful set中已经有两个pod,在jenkins-1所在的节点执行`docker stop`停止运行jenkins-master的容器，同时在命令行查看pod的状态，可以看到jenkins-1异常（Error状态）之后慢慢恢复了运行状态（Running）：\n```\n[root@master ~]# kubectl get pods -w\nNAME        READY     STATUS    RESTARTS   AGE\njenkins-0   1/1       Running   0          1d\njenkins-1   0/1       Running   1         20h\njenkins-1   1/1       Running   1         20h\njenkins-1   0/1       Error     1         20h\njenkins-1   0/1       CrashLoopBackOff   1         20h\njenkins-1   0/1       Running   2         20h\njenkins-1   1/1       Running   2         20h\n```\n`kubectl describe pod jenkins-1`查看pod的事件日志，k8s通过探针(probe)接口检测到服务停止之后自动执行了拉取镜像，重启container的操作。\n```\nEvents:\n  Type     Reason      Age                From                              Message\n  ----     ------      ----               ----                              -------\n  Warning  Unhealthy   27m (x2 over 27m)  kubelet, iz8pscwd1fv6kprs1zw21kz  Readiness probe failed: HTTP probe failed with statuscode: 503\n  Warning  Unhealthy   27m (x2 over 27m)  kubelet, iz8pscwd1fv6kprs1zw21kz  Liveness probe failed: HTTP probe failed with statuscode: 503\n  Warning  Unhealthy   24m                kubelet, iz8pscwd1fv6kprs1zw21kz  Readiness probe failed: Get http://192.168.24.4:8080/login: dial tcp 192.168.24.4:8080: getsockopt: connection refused\n  Warning  BackOff     20m (x2 over 20m)  kubelet, iz8pscwd1fv6kprs1zw21kz  Back-off restarting failed container\n  Warning  FailedSync  20m (x2 over 20m)  kubelet, iz8pscwd1fv6kprs1zw21kz  Error syncing pod\n  Normal   Pulling     19m (x3 over 20h)  kubelet, iz8pscwd1fv6kprs1zw21kz  pulling image \"jenkins/jenkins:lts-alpine\"\n  Normal   Started     19m (x3 over 20h)  kubelet, iz8pscwd1fv6kprs1zw21kz  Started container\n  Normal   Pulled      19m (x3 over 20h)  kubelet, iz8pscwd1fv6kprs1zw21kz  Successfully pulled image \"jenkins/jenkins:lts-alpine\"\n  Normal   Created     19m (x3 over 20h)  kubelet, iz8pscwd1fv6kprs1zw21kz  Created container\n```\n#### 3. jenkins构建测试\n当前集群中使用的jenkins slave镜像只包含一个java运行环境来运行jenkins-slave.jar,在实际使用中需要自定义合适的镜像。选择自定义镜像之后需要修改插件的配置，同样name命名为jnlp替换默认镜像，arguments安装工具提示填写即可。\n![container][11]\n创建job，同时开始构建,k8s会在不同节点上创建pod来运行任务\n![此处输入图片的描述][13]\n构建全部完成后，资源随即被释放\n![此处输入图片的描述][14]\n\n**jenkins默认调度策略**\n1. 尝试在上次构建的节点上构建，指定某台slave之后会一直使用。\n2.当队列有2个构建时，不会立刻创建两个executor,而是先创建一个executor然后尝试等待executor空闲，目的是保证每个executor被充分利用。\n**k8s调度策略**\n1. 使用Pod.spec.nodeSelector根据label为pod选择node\n2.调度器scheduler有Predicates，Priorities两个阶段，分别负责节点过滤和评分排序，各个阶段都有k8s提供的检查项，我们可以自由组合。\n（比如PodFitsResources检查cpu内存等资源，PodFitsHostPorts检查端口占用，SelectorSpreadPriority要求一个服务尽量分散分布）[自定义schduler参考][15]\n**资源不足时会发生什么**\n当前集群中有3个节点，我在node2运行一个CPU占用限制在80%的程序,然后设置jenkins插件ContainerTemplate的request和limit均为`cpu 500m,内存500Mi`,（500m代表单核CPU的50%）看一下pod会怎么调度\nk8s仍然尝试在node2分配节点（为什么其他节点不行），结果POD处于pending状态：\n```\"status\": {\n    \"phase\": \"Pending\",\n    \"conditions\": [\n      {\n        \"type\": \"PodScheduled\",\n        \"status\": \"False\",\n        \"lastProbeTime\": null,\n        \"lastTransitionTime\": \"2017-12-09T08:29:10Z\",\n        \"reason\": \"Unschedulable\",\n        \"message\": \"No nodes are available that match all of the predicates: Insufficient cpu (4), PodToleratesNodeTaints (1).\"\n      }\n    ],\n    \"qosClass\": \"Guaranteed\"\n```\n最后pod被删除，而jenkins任务会阻塞一直到有其他空闲的slave出现。\n### **四 ，总结**\n本文介绍了在k8s集群部署jenkins服务的方式和k8s带来的资源管理便捷，由于我也是刚开始接触k8s,所用的实例只是搭建了用于测试的实验环境，离在实际生产环境中使用还有问题需要验证。\n\n\n  [1]: http://docs.kubernetes.org.cn/227.html\n  [2]: /images/jenkins/jenkins-arch.png\n  [3]: /images/jenkins/kongzhimianban.png\n  [4]: http://www.ruanyifeng.com/blog/2016/07/yaml.html\n  [5]: https://kubernetes.io/docs/concepts/storage/storage-classes/\n  [6]: /images/jenkins/pvlife.png\n  [7]: /images/jenkins/success.png\n  [8]: /images/jenkins/config1.png\n  [9]: /images/jenkins/config.png\n  [10]: https://yq.aliyun.com/articles/224376\n  [11]: /images/jenkins/container.png\n  [12]: /images/jenkins/jobs.png\n  [13]: /images/jenkins/pods1.png\n  [14]: /images/jenkins/result2.png\n  [15]: http://dockone.io/article/2885","source":"_posts/jenkins on kubernetes实践.md","raw":"# jenkins on kubernetes实践\n\ntitle: jenkins on kubernetes实践\ndate: 2017-08-26 21:05:46\ncategories: 容器技术\ntags: [jenkins,docker,kubernetes]\n\n------\n\n**jenkins是什么？**\nJenkins是一个开源的持续集成工具，可用于自动化的执行与构建，测试和交付或部署软件有关的各种任务,有非常丰富的插件支持。\n**kubernetes是什么？**\nKubernetes是容器集群管理系统，是一个开源的平台，可以实现容器集群的自动化部署、自动扩缩容、维护等功能。[这个视频生动地介绍了k8s][1]\n**jenkins on k8s 有什么好处？**\njenkins通过单Master多个Slave的方式提供服务，Master保存了任务的配置信息，安装的插件等等，而slave主要负责执行任务，在使用中存在以下几个问题：\n<!--more-->\n1. 当存在多个slave时，运行slave的机器难以统一管理，每次添加新节点时总要做大量的重复工作。\n2. 由于不同业务的构建频率并不相同，在使用会发现有很多slave大多数时间都处于空闲状态，造成资源浪费\n3. jenkins默认采取保守的调度方式，造成某些slave的负载过高，任务不能平均分配\n![jenkins架构][2]\n\n使用k8s管理jenkins具有以下优势：\n\n1. 使用docker运行jenkins保证环境的一致性，可以根据不同业务选择合适的镜像\n2. k8s对抽象后的资源（pods）进行统一的管理调度，提供资源隔离和共享，使机器计算资源变得弹性可扩展,避免资源浪费。\n3. k8s提供容器的自愈功能，能够保证始终有一定数量的容器是可用的\n4. k8s默认的调度器提供了针对节点当前资源分配容器的调度策略，调度器支持插件化部署便于自定义。\n\n### **一，搭建环境**\n\n#### 工具准备\n\n> kubernetes v1.8.4\ndocker v1.12.6\njenkins master镜像 jenkins/jenkins:lts（v2.73.3）\nslave镜像 jenkinsci/jnlp-slave\nKubernetes plugin (v1.1)\n\n#### 安装kubernetes集群\n\n中文教程：https://www.kubernetes.org.cn/2906.html\n安装成功之后访问dashboard地址就可以看到集群的控制面板：\n![dashboard][3]\n集群安装完成后，创建命名空间kubernetes-plugin\n```\nkubectl create namespace kubernetes-plugin\nkubectl config set-context $(kubectl config current-context) --namespace=kubernetes-plugin\nkubectl create -f service-account.yml\n```\n\n### **二，创建StatefulSet**\n>**StatefulSet(有状态副本集)**：Deployments适用于运行无状态应用，StatefulSet则为有状态的应用提供了支持，可以为应用提供有序的部署和扩展，稳定的持久化存储，我们使用SS来运行jenkins master。\n\n创建完整的Stateful Set需要依次创建一下对象：\n1、Persistent Volume\n2、Persistent Volume Claim\n3、StatefulSet\n4、Service\n\n\n#### **创建PersistentVolume：**\n\n为了保存应用运行时的数据需要先创建k8s的卷文件，K8s中存在Volume和PersistentVolume两种类型：\n\n >- Volume：与docker中的volume不同在于Volume生命周期是和pod绑定的，与pod中的container无关。k8s为Volume提供了多种类型文件系统（cephfs,nfs...,简单起见我直接选择了hostPath，使用的node节点本地的存储系统）\n >- PersistentVolume:从名字可以看出来，PV的生命周期独立于使用它的pod，不会像volume随pod消失而消失，而是做为一个集群中的资源存在（像node节点一样），同时PV屏蔽了使用具体存储系统的细节。\n\nk8s中的对象都是通过[yaml文件][4]来定义的，首先创建名为`jenkins-volume.yml`的文件:\n\n**注意**：PV的创建有静态，动态两种方式，动态创建可以减少管理员的操作步骤，需要提供指定的[StorageClass][5]。为了测试方便，所以我们直接选择静态创建，manual是一个不存在的storage class\n```\nkind: PersistentVolume\napiVersion: v1\nmetadata:\n  name: jenkins-volume\n  labels:\n    type: local\nspec:\n  storageClassName: manual\n  capacity:\n    storage: 10Gi\n  accessModes:\n    - ReadWriteOnce\n  hostPath:\n    path: \"/tmp/data\"\n\n```\nmaster节点执行下面的命令，PV就手动创建完了\n`kubectl create -f jenkins-volume1.yaml`\n#### **创建PersistentVolumeClaim：**\n>PersistentVolumeClaim(PVC):\n持久化存储卷索取，如果说PV是集群中的资源，PVC就是资源的消费者，PVC可以指定需要的资源大小和访问方式,pod不会和PV直接接触，而是通过PVC来请求资源，PV的生成阶段叫做provision,生成PV后会绑定到PVC对象，然后才能被其他对象使用。\n\nPV和PVC的生命周期如下图：\n![pv life][6]\n\n创建文件`jenkins-claim.yaml`\n**注意：** name必须为jenkins-home-jenkins-0否则会绑定失败\n```\nkind: PersistentVolumeClaim\napiVersion: v1\nmetadata:\n  name: jenkins-home-jenkins-0\nspec:\n  storageClassName: manual\n  accessModes:\n    - ReadWriteOnce\n  resources:\n    requests:\n      storage: 3Gi\n```\n执行命令`kubectl create -f jenkins-claim.yaml`\n然后查看PVC是否创建成功，status为bound说明PVC已经绑定\n```\n[root@master ~]# kubectl describe pvc jenkins-home-jenkins-0\nName:          jenkins-home-jenkins-0\nNamespace:     kubernetes-plugin\nStorageClass:  manual\nStatus:        Bound\nVolume:        jenkins-volume\nLabels:        <none>\nAnnotations:   pv.kubernetes.io/bind-completed=yes\n               pv.kubernetes.io/bound-by-controller=yes\nCapacity:      10Gi\nAccess Modes:  RWO\nEvents:        <none>\n```\n#### **创建StatefulSet和Service：**\n\n从kubernetes-plugin github仓库下载jenkins.yml文件\n```\nwget https://raw.githubusercontent.com/jenkinsci/kubernetes-plugin/master/src/main/kubernetes/jenkins.yml\n```\n修改jenkins.yml：\n去掉87行`externalTrafficPolicy: Local`（这是GKE使用的）\n修改83行` type: LoadBalancer`改为` type: NodePort`\n\n**注意：** \nservice type=ClusterIP时只允许从集群内部访问， type设置为NodePort是为了从集群外的机器访问jenkins,请谨慎使用，开启NodePort会在所有节点（含master）的统一固定端口开放服务。\n\n执行命令\n```\n[root@master ~]# kubectl create -f jenkins.yml \nstatefulset \"jenkins\" created\nservice \"jenkins\" created\n```\n访问jenkins master,地址为`masterip:32058`\n```\n#查看映射的端口\n[root@master ~]# kubectl get service jenkins\nNAME      TYPE       CLUSTER-IP    EXTERNAL-IP   PORT(S)                        AGE\njenkins   NodePort   10.96.82.68   <none>        80:32058/TCP,50000:30345/TCP   1m\n```\n查看pod : jenkins-0的容器日志，粘贴下面的密码进入jenkins,jenkins安装完成。\n> Jenkins initial setup is required. An admin user has been created and a password generated.\nPlease use the following password to proceed to installation:\n70aa7b41ba894855abccd09306625b8a \n\n刷新dashboard，切换命名空间到kubernetes-plugin,结果如下：\n![success][7]\n\n### 问题分析\n1.创建stateful set时失败，提示\"PersistentVolumeClaim is not bound: \"jenkins-home-jenkins-0\"：\"\n因为采用静态创建PV时，StatefulSet会按照固定名称查找PVC，PVC的名字要满足\n>PVC_name == volumeClaimTemplates_name + \"-\" + pod_name\n\n这里的名字就是`jenkins-home-jenkins-0`\n\n2.pod启动失败，jenkins用户没有目录权限\n错误提示\"touch: cannot touch ‘/var/jenkins_home/copy_reference_file.log’: Permission denied\nCan not write to /var/jenkins_home/copy_reference_file.log. Wrong volume permissions?\"\n要确保节点目录开放权限,在node上执行命令：\n```\nsudo chown -R 1000:1000 /var/jenkins_home/\nsudo chown -R 1000:1000 /tmp/data\n##如果仍然失败，尝试在node上重启docker\nsystemctl restart docker\n\n```\n注意pv指定的hostPath权限也要修改，否则是无效的\n\n\n\n###  三 ，配置jenkins\n#### 创建jenkins服务账号\n```\nwget https://raw.githubusercontent.com/jenkinsci/kubernetes-plugin/master/src/main/kubernetes/service-account.yml\nkubectl create -f service-account.yml\n```\n#### 配置插件\n访问`http://masterip:32058/pluginManager/`,搜索插件Kubernetes plugin安装；\n访问 http://masterip:32058/configure\n选择新建云--kubernetes,在URl填写api server地址，\n执行kubectl describe命令，复制output中的token，填入到 ‘Kubernetes server certificate key’\n```\n[root@master ~]# kubectl get secret \nNAME                  TYPE                                  DATA      AGE\ndefault-token-4kb54   kubernetes.io/service-account-token   3         1d\njenkins-token-wzbsx   kubernetes.io/service-account-token   3         1d\n[root@master ~]# kubectl describe secret/jenkins-token-wzbsx\n...\n```\njenkins url,tunnel填写service的CLUSTER-IP即可，结果如图：\n![peizhi1][8]\n选择add pod template，填写下面的内容，retain slave可以设置运行jenkins slave 的container空闲后能存活多久。\n![content][9]\n插件配置完成。\n### 四 ，测试\n#### 1. 扩容测试\n**StatefulSet扩容：**\n首先需要手动创建PV，PVC(见第二步),然后执行扩容命令\n` kubectl scale statefulset/jenkins --replicas=２`\n查看StatefulSet,此时已经拥有两个master节点，访问service时会**随机**将请求发送给后端的master。\n```\n[root@master ~]# kubectl get statefulset/jenkins \nNAME      DESIRED   CURRENT   AGE\njenkins   2         2         5d\n```\n虽然通过k8s可以轻松实现jenkins master节点的拓展，但是由于jenkins存储数据的方式通过本地文件存储，master之间的数据同步还是一个麻烦的问题，参考[jenkins存储模型][10]。\n\n*jenkins master上保存的文件：*\n```\nls /temp/data\njenkins.CLI.xml\njenkins.install.InstallUtil.lastExecVersion\njenkins.install.UpgradeWizard.state\njenkins.model.ArtifactManagerConfiguration.xml\njenkins.model.JenkinsLocationConfiguration.xml\njobs\nlogs\nnodeMonitors.xml\nnodes\n```\n\n#### 2. 高可用测试\n现在stateful set中已经有两个pod,在jenkins-1所在的节点执行`docker stop`停止运行jenkins-master的容器，同时在命令行查看pod的状态，可以看到jenkins-1异常（Error状态）之后慢慢恢复了运行状态（Running）：\n```\n[root@master ~]# kubectl get pods -w\nNAME        READY     STATUS    RESTARTS   AGE\njenkins-0   1/1       Running   0          1d\njenkins-1   0/1       Running   1         20h\njenkins-1   1/1       Running   1         20h\njenkins-1   0/1       Error     1         20h\njenkins-1   0/1       CrashLoopBackOff   1         20h\njenkins-1   0/1       Running   2         20h\njenkins-1   1/1       Running   2         20h\n```\n`kubectl describe pod jenkins-1`查看pod的事件日志，k8s通过探针(probe)接口检测到服务停止之后自动执行了拉取镜像，重启container的操作。\n```\nEvents:\n  Type     Reason      Age                From                              Message\n  ----     ------      ----               ----                              -------\n  Warning  Unhealthy   27m (x2 over 27m)  kubelet, iz8pscwd1fv6kprs1zw21kz  Readiness probe failed: HTTP probe failed with statuscode: 503\n  Warning  Unhealthy   27m (x2 over 27m)  kubelet, iz8pscwd1fv6kprs1zw21kz  Liveness probe failed: HTTP probe failed with statuscode: 503\n  Warning  Unhealthy   24m                kubelet, iz8pscwd1fv6kprs1zw21kz  Readiness probe failed: Get http://192.168.24.4:8080/login: dial tcp 192.168.24.4:8080: getsockopt: connection refused\n  Warning  BackOff     20m (x2 over 20m)  kubelet, iz8pscwd1fv6kprs1zw21kz  Back-off restarting failed container\n  Warning  FailedSync  20m (x2 over 20m)  kubelet, iz8pscwd1fv6kprs1zw21kz  Error syncing pod\n  Normal   Pulling     19m (x3 over 20h)  kubelet, iz8pscwd1fv6kprs1zw21kz  pulling image \"jenkins/jenkins:lts-alpine\"\n  Normal   Started     19m (x3 over 20h)  kubelet, iz8pscwd1fv6kprs1zw21kz  Started container\n  Normal   Pulled      19m (x3 over 20h)  kubelet, iz8pscwd1fv6kprs1zw21kz  Successfully pulled image \"jenkins/jenkins:lts-alpine\"\n  Normal   Created     19m (x3 over 20h)  kubelet, iz8pscwd1fv6kprs1zw21kz  Created container\n```\n#### 3. jenkins构建测试\n当前集群中使用的jenkins slave镜像只包含一个java运行环境来运行jenkins-slave.jar,在实际使用中需要自定义合适的镜像。选择自定义镜像之后需要修改插件的配置，同样name命名为jnlp替换默认镜像，arguments安装工具提示填写即可。\n![container][11]\n创建job，同时开始构建,k8s会在不同节点上创建pod来运行任务\n![此处输入图片的描述][13]\n构建全部完成后，资源随即被释放\n![此处输入图片的描述][14]\n\n**jenkins默认调度策略**\n1. 尝试在上次构建的节点上构建，指定某台slave之后会一直使用。\n2.当队列有2个构建时，不会立刻创建两个executor,而是先创建一个executor然后尝试等待executor空闲，目的是保证每个executor被充分利用。\n**k8s调度策略**\n1. 使用Pod.spec.nodeSelector根据label为pod选择node\n2.调度器scheduler有Predicates，Priorities两个阶段，分别负责节点过滤和评分排序，各个阶段都有k8s提供的检查项，我们可以自由组合。\n（比如PodFitsResources检查cpu内存等资源，PodFitsHostPorts检查端口占用，SelectorSpreadPriority要求一个服务尽量分散分布）[自定义schduler参考][15]\n**资源不足时会发生什么**\n当前集群中有3个节点，我在node2运行一个CPU占用限制在80%的程序,然后设置jenkins插件ContainerTemplate的request和limit均为`cpu 500m,内存500Mi`,（500m代表单核CPU的50%）看一下pod会怎么调度\nk8s仍然尝试在node2分配节点（为什么其他节点不行），结果POD处于pending状态：\n```\"status\": {\n    \"phase\": \"Pending\",\n    \"conditions\": [\n      {\n        \"type\": \"PodScheduled\",\n        \"status\": \"False\",\n        \"lastProbeTime\": null,\n        \"lastTransitionTime\": \"2017-12-09T08:29:10Z\",\n        \"reason\": \"Unschedulable\",\n        \"message\": \"No nodes are available that match all of the predicates: Insufficient cpu (4), PodToleratesNodeTaints (1).\"\n      }\n    ],\n    \"qosClass\": \"Guaranteed\"\n```\n最后pod被删除，而jenkins任务会阻塞一直到有其他空闲的slave出现。\n### **四 ，总结**\n本文介绍了在k8s集群部署jenkins服务的方式和k8s带来的资源管理便捷，由于我也是刚开始接触k8s,所用的实例只是搭建了用于测试的实验环境，离在实际生产环境中使用还有问题需要验证。\n\n\n  [1]: http://docs.kubernetes.org.cn/227.html\n  [2]: /images/jenkins/jenkins-arch.png\n  [3]: /images/jenkins/kongzhimianban.png\n  [4]: http://www.ruanyifeng.com/blog/2016/07/yaml.html\n  [5]: https://kubernetes.io/docs/concepts/storage/storage-classes/\n  [6]: /images/jenkins/pvlife.png\n  [7]: /images/jenkins/success.png\n  [8]: /images/jenkins/config1.png\n  [9]: /images/jenkins/config.png\n  [10]: https://yq.aliyun.com/articles/224376\n  [11]: /images/jenkins/container.png\n  [12]: /images/jenkins/jobs.png\n  [13]: /images/jenkins/pods1.png\n  [14]: /images/jenkins/result2.png\n  [15]: http://dockone.io/article/2885","slug":"jenkins on kubernetes实践","published":1,"updated":"2019-05-04T15:44:19.590Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkqle1co002acyne62152l71","content":"<p><strong>jenkins是什么？</strong><br>Jenkins是一个开源的持续集成工具，可用于自动化的执行与构建，测试和交付或部署软件有关的各种任务,有非常丰富的插件支持。<br><strong>kubernetes是什么？</strong><br>Kubernetes是容器集群管理系统，是一个开源的平台，可以实现容器集群的自动化部署、自动扩缩容、维护等功能。<a href=\"http://docs.kubernetes.org.cn/227.html\" target=\"_blank\" rel=\"noopener\">这个视频生动地介绍了k8s</a><br><strong>jenkins on k8s 有什么好处？</strong><br>jenkins通过单Master多个Slave的方式提供服务，Master保存了任务的配置信息，安装的插件等等，而slave主要负责执行任务，在使用中存在以下几个问题：<br><a id=\"more\"></a></p>\n<ol>\n<li>当存在多个slave时，运行slave的机器难以统一管理，每次添加新节点时总要做大量的重复工作。</li>\n<li>由于不同业务的构建频率并不相同，在使用会发现有很多slave大多数时间都处于空闲状态，造成资源浪费</li>\n<li>jenkins默认采取保守的调度方式，造成某些slave的负载过高，任务不能平均分配<br><img src=\"/images/jenkins/jenkins-arch.png\" alt=\"jenkins架构\"></li>\n</ol>\n<p>使用k8s管理jenkins具有以下优势：</p>\n<ol>\n<li>使用docker运行jenkins保证环境的一致性，可以根据不同业务选择合适的镜像</li>\n<li>k8s对抽象后的资源（pods）进行统一的管理调度，提供资源隔离和共享，使机器计算资源变得弹性可扩展,避免资源浪费。</li>\n<li>k8s提供容器的自愈功能，能够保证始终有一定数量的容器是可用的</li>\n<li>k8s默认的调度器提供了针对节点当前资源分配容器的调度策略，调度器支持插件化部署便于自定义。</li>\n</ol>\n<h3 id=\"一，搭建环境\"><a href=\"#一，搭建环境\" class=\"headerlink\" title=\"一，搭建环境\"></a><strong>一，搭建环境</strong></h3><h4 id=\"工具准备\"><a href=\"#工具准备\" class=\"headerlink\" title=\"工具准备\"></a>工具准备</h4><blockquote>\n<p>kubernetes v1.8.4<br>docker v1.12.6<br>jenkins master镜像 jenkins/jenkins:lts（v2.73.3）<br>slave镜像 jenkinsci/jnlp-slave<br>Kubernetes plugin (v1.1)</p>\n</blockquote>\n<h4 id=\"安装kubernetes集群\"><a href=\"#安装kubernetes集群\" class=\"headerlink\" title=\"安装kubernetes集群\"></a>安装kubernetes集群</h4><p>中文教程：<a href=\"https://www.kubernetes.org.cn/2906.html\" target=\"_blank\" rel=\"noopener\">https://www.kubernetes.org.cn/2906.html</a><br>安装成功之后访问dashboard地址就可以看到集群的控制面板：<br><img src=\"/images/jenkins/kongzhimianban.png\" alt=\"dashboard\"><br>集群安装完成后，创建命名空间kubernetes-plugin<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl create namespace kubernetes-plugin</span><br><span class=\"line\">kubectl config set-context $(kubectl config current-context) --namespace=kubernetes-plugin</span><br><span class=\"line\">kubectl create -f service-account.yml</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"二，创建StatefulSet\"><a href=\"#二，创建StatefulSet\" class=\"headerlink\" title=\"二，创建StatefulSet\"></a><strong>二，创建StatefulSet</strong></h3><blockquote>\n<p><strong>StatefulSet(有状态副本集)</strong>：Deployments适用于运行无状态应用，StatefulSet则为有状态的应用提供了支持，可以为应用提供有序的部署和扩展，稳定的持久化存储，我们使用SS来运行jenkins master。</p>\n</blockquote>\n<p>创建完整的Stateful Set需要依次创建一下对象：<br>1、Persistent Volume<br>2、Persistent Volume Claim<br>3、StatefulSet<br>4、Service</p>\n<h4 id=\"创建PersistentVolume：\"><a href=\"#创建PersistentVolume：\" class=\"headerlink\" title=\"创建PersistentVolume：\"></a><strong>创建PersistentVolume：</strong></h4><p>为了保存应用运行时的数据需要先创建k8s的卷文件，K8s中存在Volume和PersistentVolume两种类型：</p>\n<blockquote>\n<ul>\n<li>Volume：与docker中的volume不同在于Volume生命周期是和pod绑定的，与pod中的container无关。k8s为Volume提供了多种类型文件系统（cephfs,nfs…,简单起见我直接选择了hostPath，使用的node节点本地的存储系统）</li>\n<li>PersistentVolume:从名字可以看出来，PV的生命周期独立于使用它的pod，不会像volume随pod消失而消失，而是做为一个集群中的资源存在（像node节点一样），同时PV屏蔽了使用具体存储系统的细节。</li>\n</ul>\n</blockquote>\n<p>k8s中的对象都是通过<a href=\"http://www.ruanyifeng.com/blog/2016/07/yaml.html\" target=\"_blank\" rel=\"noopener\">yaml文件</a>来定义的，首先创建名为<code>jenkins-volume.yml</code>的文件:</p>\n<p><strong>注意</strong>：PV的创建有静态，动态两种方式，动态创建可以减少管理员的操作步骤，需要提供指定的<a href=\"https://kubernetes.io/docs/concepts/storage/storage-classes/\" target=\"_blank\" rel=\"noopener\">StorageClass</a>。为了测试方便，所以我们直接选择静态创建，manual是一个不存在的storage class<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kind: PersistentVolume</span><br><span class=\"line\">apiVersion: v1</span><br><span class=\"line\">metadata:</span><br><span class=\"line\">  name: jenkins-volume</span><br><span class=\"line\">  labels:</span><br><span class=\"line\">    type: local</span><br><span class=\"line\">spec:</span><br><span class=\"line\">  storageClassName: manual</span><br><span class=\"line\">  capacity:</span><br><span class=\"line\">    storage: 10Gi</span><br><span class=\"line\">  accessModes:</span><br><span class=\"line\">    - ReadWriteOnce</span><br><span class=\"line\">  hostPath:</span><br><span class=\"line\">    path: &quot;/tmp/data&quot;</span><br></pre></td></tr></table></figure></p>\n<p>master节点执行下面的命令，PV就手动创建完了<br><code>kubectl create -f jenkins-volume1.yaml</code></p>\n<h4 id=\"创建PersistentVolumeClaim：\"><a href=\"#创建PersistentVolumeClaim：\" class=\"headerlink\" title=\"创建PersistentVolumeClaim：\"></a><strong>创建PersistentVolumeClaim：</strong></h4><blockquote>\n<p>PersistentVolumeClaim(PVC):<br>持久化存储卷索取，如果说PV是集群中的资源，PVC就是资源的消费者，PVC可以指定需要的资源大小和访问方式,pod不会和PV直接接触，而是通过PVC来请求资源，PV的生成阶段叫做provision,生成PV后会绑定到PVC对象，然后才能被其他对象使用。</p>\n</blockquote>\n<p>PV和PVC的生命周期如下图：<br><img src=\"/images/jenkins/pvlife.png\" alt=\"pv life\"></p>\n<p>创建文件<code>jenkins-claim.yaml</code><br><strong>注意：</strong> name必须为jenkins-home-jenkins-0否则会绑定失败<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kind: PersistentVolumeClaim</span><br><span class=\"line\">apiVersion: v1</span><br><span class=\"line\">metadata:</span><br><span class=\"line\">  name: jenkins-home-jenkins-0</span><br><span class=\"line\">spec:</span><br><span class=\"line\">  storageClassName: manual</span><br><span class=\"line\">  accessModes:</span><br><span class=\"line\">    - ReadWriteOnce</span><br><span class=\"line\">  resources:</span><br><span class=\"line\">    requests:</span><br><span class=\"line\">      storage: 3Gi</span><br></pre></td></tr></table></figure></p>\n<p>执行命令<code>kubectl create -f jenkins-claim.yaml</code><br>然后查看PVC是否创建成功，status为bound说明PVC已经绑定<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@master ~]# kubectl describe pvc jenkins-home-jenkins-0</span><br><span class=\"line\">Name:          jenkins-home-jenkins-0</span><br><span class=\"line\">Namespace:     kubernetes-plugin</span><br><span class=\"line\">StorageClass:  manual</span><br><span class=\"line\">Status:        Bound</span><br><span class=\"line\">Volume:        jenkins-volume</span><br><span class=\"line\">Labels:        &lt;none&gt;</span><br><span class=\"line\">Annotations:   pv.kubernetes.io/bind-completed=yes</span><br><span class=\"line\">               pv.kubernetes.io/bound-by-controller=yes</span><br><span class=\"line\">Capacity:      10Gi</span><br><span class=\"line\">Access Modes:  RWO</span><br><span class=\"line\">Events:        &lt;none&gt;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"创建StatefulSet和Service：\"><a href=\"#创建StatefulSet和Service：\" class=\"headerlink\" title=\"创建StatefulSet和Service：\"></a><strong>创建StatefulSet和Service：</strong></h4><p>从kubernetes-plugin github仓库下载jenkins.yml文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://raw.githubusercontent.com/jenkinsci/kubernetes-plugin/master/src/main/kubernetes/jenkins.yml</span><br></pre></td></tr></table></figure></p>\n<p>修改jenkins.yml：<br>去掉87行<code>externalTrafficPolicy: Local</code>（这是GKE使用的）<br>修改83行<code>type: LoadBalancer</code>改为<code>type: NodePort</code></p>\n<p><strong>注意：</strong><br>service type=ClusterIP时只允许从集群内部访问， type设置为NodePort是为了从集群外的机器访问jenkins,请谨慎使用，开启NodePort会在所有节点（含master）的统一固定端口开放服务。</p>\n<p>执行命令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@master ~]# kubectl create -f jenkins.yml </span><br><span class=\"line\">statefulset &quot;jenkins&quot; created</span><br><span class=\"line\">service &quot;jenkins&quot; created</span><br></pre></td></tr></table></figure></p>\n<p>访问jenkins master,地址为<code>masterip:32058</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#查看映射的端口</span><br><span class=\"line\">[root@master ~]# kubectl get service jenkins</span><br><span class=\"line\">NAME      TYPE       CLUSTER-IP    EXTERNAL-IP   PORT(S)                        AGE</span><br><span class=\"line\">jenkins   NodePort   10.96.82.68   &lt;none&gt;        80:32058/TCP,50000:30345/TCP   1m</span><br></pre></td></tr></table></figure></p>\n<p>查看pod : jenkins-0的容器日志，粘贴下面的密码进入jenkins,jenkins安装完成。</p>\n<blockquote>\n<p>Jenkins initial setup is required. An admin user has been created and a password generated.<br>Please use the following password to proceed to installation:<br>70aa7b41ba894855abccd09306625b8a </p>\n</blockquote>\n<p>刷新dashboard，切换命名空间到kubernetes-plugin,结果如下：<br><img src=\"/images/jenkins/success.png\" alt=\"success\"></p>\n<h3 id=\"问题分析\"><a href=\"#问题分析\" class=\"headerlink\" title=\"问题分析\"></a>问题分析</h3><p>1.创建stateful set时失败，提示”PersistentVolumeClaim is not bound: “jenkins-home-jenkins-0”：”<br>因为采用静态创建PV时，StatefulSet会按照固定名称查找PVC，PVC的名字要满足</p>\n<blockquote>\n<p>PVC_name == volumeClaimTemplates_name + “-“ + pod_name</p>\n</blockquote>\n<p>这里的名字就是<code>jenkins-home-jenkins-0</code></p>\n<p>2.pod启动失败，jenkins用户没有目录权限<br>错误提示”touch: cannot touch ‘/var/jenkins_home/copy_reference_file.log’: Permission denied<br>Can not write to /var/jenkins_home/copy_reference_file.log. Wrong volume permissions?”<br>要确保节点目录开放权限,在node上执行命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo chown -R 1000:1000 /var/jenkins_home/</span><br><span class=\"line\">sudo chown -R 1000:1000 /tmp/data</span><br><span class=\"line\">##如果仍然失败，尝试在node上重启docker</span><br><span class=\"line\">systemctl restart docker</span><br></pre></td></tr></table></figure></p>\n<p>注意pv指定的hostPath权限也要修改，否则是无效的</p>\n<h3 id=\"三-，配置jenkins\"><a href=\"#三-，配置jenkins\" class=\"headerlink\" title=\"三 ，配置jenkins\"></a>三 ，配置jenkins</h3><h4 id=\"创建jenkins服务账号\"><a href=\"#创建jenkins服务账号\" class=\"headerlink\" title=\"创建jenkins服务账号\"></a>创建jenkins服务账号</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://raw.githubusercontent.com/jenkinsci/kubernetes-plugin/master/src/main/kubernetes/service-account.yml</span><br><span class=\"line\">kubectl create -f service-account.yml</span><br></pre></td></tr></table></figure>\n<h4 id=\"配置插件\"><a href=\"#配置插件\" class=\"headerlink\" title=\"配置插件\"></a>配置插件</h4><p>访问<code>http://masterip:32058/pluginManager/</code>,搜索插件Kubernetes plugin安装；<br>访问 <a href=\"http://masterip:32058/configure\" target=\"_blank\" rel=\"noopener\">http://masterip:32058/configure</a><br>选择新建云–kubernetes,在URl填写api server地址，<br>执行kubectl describe命令，复制output中的token，填入到 ‘Kubernetes server certificate key’<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@master ~]# kubectl get secret </span><br><span class=\"line\">NAME                  TYPE                                  DATA      AGE</span><br><span class=\"line\">default-token-4kb54   kubernetes.io/service-account-token   3         1d</span><br><span class=\"line\">jenkins-token-wzbsx   kubernetes.io/service-account-token   3         1d</span><br><span class=\"line\">[root@master ~]# kubectl describe secret/jenkins-token-wzbsx</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n<p>jenkins url,tunnel填写service的CLUSTER-IP即可，结果如图：<br><img src=\"/images/jenkins/config1.png\" alt=\"peizhi1\"><br>选择add pod template，填写下面的内容，retain slave可以设置运行jenkins slave 的container空闲后能存活多久。<br><img src=\"/images/jenkins/config.png\" alt=\"content\"><br>插件配置完成。</p>\n<h3 id=\"四-，测试\"><a href=\"#四-，测试\" class=\"headerlink\" title=\"四 ，测试\"></a>四 ，测试</h3><h4 id=\"1-扩容测试\"><a href=\"#1-扩容测试\" class=\"headerlink\" title=\"1. 扩容测试\"></a>1. 扩容测试</h4><p><strong>StatefulSet扩容：</strong><br>首先需要手动创建PV，PVC(见第二步),然后执行扩容命令<br><code>kubectl scale statefulset/jenkins --replicas=２</code><br>查看StatefulSet,此时已经拥有两个master节点，访问service时会<strong>随机</strong>将请求发送给后端的master。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@master ~]# kubectl get statefulset/jenkins </span><br><span class=\"line\">NAME      DESIRED   CURRENT   AGE</span><br><span class=\"line\">jenkins   2         2         5d</span><br></pre></td></tr></table></figure></p>\n<p>虽然通过k8s可以轻松实现jenkins master节点的拓展，但是由于jenkins存储数据的方式通过本地文件存储，master之间的数据同步还是一个麻烦的问题，参考<a href=\"https://yq.aliyun.com/articles/224376\" target=\"_blank\" rel=\"noopener\">jenkins存储模型</a>。</p>\n<p><em>jenkins master上保存的文件：</em><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls /temp/data</span><br><span class=\"line\">jenkins.CLI.xml</span><br><span class=\"line\">jenkins.install.InstallUtil.lastExecVersion</span><br><span class=\"line\">jenkins.install.UpgradeWizard.state</span><br><span class=\"line\">jenkins.model.ArtifactManagerConfiguration.xml</span><br><span class=\"line\">jenkins.model.JenkinsLocationConfiguration.xml</span><br><span class=\"line\">jobs</span><br><span class=\"line\">logs</span><br><span class=\"line\">nodeMonitors.xml</span><br><span class=\"line\">nodes</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"2-高可用测试\"><a href=\"#2-高可用测试\" class=\"headerlink\" title=\"2. 高可用测试\"></a>2. 高可用测试</h4><p>现在stateful set中已经有两个pod,在jenkins-1所在的节点执行<code>docker stop</code>停止运行jenkins-master的容器，同时在命令行查看pod的状态，可以看到jenkins-1异常（Error状态）之后慢慢恢复了运行状态（Running）：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@master ~]# kubectl get pods -w</span><br><span class=\"line\">NAME        READY     STATUS    RESTARTS   AGE</span><br><span class=\"line\">jenkins-0   1/1       Running   0          1d</span><br><span class=\"line\">jenkins-1   0/1       Running   1         20h</span><br><span class=\"line\">jenkins-1   1/1       Running   1         20h</span><br><span class=\"line\">jenkins-1   0/1       Error     1         20h</span><br><span class=\"line\">jenkins-1   0/1       CrashLoopBackOff   1         20h</span><br><span class=\"line\">jenkins-1   0/1       Running   2         20h</span><br><span class=\"line\">jenkins-1   1/1       Running   2         20h</span><br></pre></td></tr></table></figure></p>\n<p><code>kubectl describe pod jenkins-1</code>查看pod的事件日志，k8s通过探针(probe)接口检测到服务停止之后自动执行了拉取镜像，重启container的操作。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Events:</span><br><span class=\"line\">  Type     Reason      Age                From                              Message</span><br><span class=\"line\">  ----     ------      ----               ----                              -------</span><br><span class=\"line\">  Warning  Unhealthy   27m (x2 over 27m)  kubelet, iz8pscwd1fv6kprs1zw21kz  Readiness probe failed: HTTP probe failed with statuscode: 503</span><br><span class=\"line\">  Warning  Unhealthy   27m (x2 over 27m)  kubelet, iz8pscwd1fv6kprs1zw21kz  Liveness probe failed: HTTP probe failed with statuscode: 503</span><br><span class=\"line\">  Warning  Unhealthy   24m                kubelet, iz8pscwd1fv6kprs1zw21kz  Readiness probe failed: Get http://192.168.24.4:8080/login: dial tcp 192.168.24.4:8080: getsockopt: connection refused</span><br><span class=\"line\">  Warning  BackOff     20m (x2 over 20m)  kubelet, iz8pscwd1fv6kprs1zw21kz  Back-off restarting failed container</span><br><span class=\"line\">  Warning  FailedSync  20m (x2 over 20m)  kubelet, iz8pscwd1fv6kprs1zw21kz  Error syncing pod</span><br><span class=\"line\">  Normal   Pulling     19m (x3 over 20h)  kubelet, iz8pscwd1fv6kprs1zw21kz  pulling image &quot;jenkins/jenkins:lts-alpine&quot;</span><br><span class=\"line\">  Normal   Started     19m (x3 over 20h)  kubelet, iz8pscwd1fv6kprs1zw21kz  Started container</span><br><span class=\"line\">  Normal   Pulled      19m (x3 over 20h)  kubelet, iz8pscwd1fv6kprs1zw21kz  Successfully pulled image &quot;jenkins/jenkins:lts-alpine&quot;</span><br><span class=\"line\">  Normal   Created     19m (x3 over 20h)  kubelet, iz8pscwd1fv6kprs1zw21kz  Created container</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"3-jenkins构建测试\"><a href=\"#3-jenkins构建测试\" class=\"headerlink\" title=\"3. jenkins构建测试\"></a>3. jenkins构建测试</h4><p>当前集群中使用的jenkins slave镜像只包含一个java运行环境来运行jenkins-slave.jar,在实际使用中需要自定义合适的镜像。选择自定义镜像之后需要修改插件的配置，同样name命名为jnlp替换默认镜像，arguments安装工具提示填写即可。<br><img src=\"/images/jenkins/container.png\" alt=\"container\"><br>创建job，同时开始构建,k8s会在不同节点上创建pod来运行任务<br><img src=\"/images/jenkins/pods1.png\" alt=\"此处输入图片的描述\"><br>构建全部完成后，资源随即被释放<br><img src=\"/images/jenkins/result2.png\" alt=\"此处输入图片的描述\"></p>\n<p><strong>jenkins默认调度策略</strong></p>\n<ol>\n<li>尝试在上次构建的节点上构建，指定某台slave之后会一直使用。<br>2.当队列有2个构建时，不会立刻创建两个executor,而是先创建一个executor然后尝试等待executor空闲，目的是保证每个executor被充分利用。<br><strong>k8s调度策略</strong></li>\n<li>使用Pod.spec.nodeSelector根据label为pod选择node<br>2.调度器scheduler有Predicates，Priorities两个阶段，分别负责节点过滤和评分排序，各个阶段都有k8s提供的检查项，我们可以自由组合。<br>（比如PodFitsResources检查cpu内存等资源，PodFitsHostPorts检查端口占用，SelectorSpreadPriority要求一个服务尽量分散分布）<a href=\"http://dockone.io/article/2885\" target=\"_blank\" rel=\"noopener\">自定义schduler参考</a><br><strong>资源不足时会发生什么</strong><br>当前集群中有3个节点，我在node2运行一个CPU占用限制在80%的程序,然后设置jenkins插件ContainerTemplate的request和limit均为<code>cpu 500m,内存500Mi</code>,（500m代表单核CPU的50%）看一下pod会怎么调度<br>k8s仍然尝试在node2分配节点（为什么其他节点不行），结果POD处于pending状态：<figure class=\"highlight plain\"><figcaption><span>&#123;</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;phase&quot;: &quot;Pending&quot;,</span><br><span class=\"line\">&quot;conditions&quot;: [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    &quot;type&quot;: &quot;PodScheduled&quot;,</span><br><span class=\"line\">    &quot;status&quot;: &quot;False&quot;,</span><br><span class=\"line\">    &quot;lastProbeTime&quot;: null,</span><br><span class=\"line\">    &quot;lastTransitionTime&quot;: &quot;2017-12-09T08:29:10Z&quot;,</span><br><span class=\"line\">    &quot;reason&quot;: &quot;Unschedulable&quot;,</span><br><span class=\"line\">    &quot;message&quot;: &quot;No nodes are available that match all of the predicates: Insufficient cpu (4), PodToleratesNodeTaints (1).&quot;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">],</span><br><span class=\"line\">&quot;qosClass&quot;: &quot;Guaranteed&quot;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>最后pod被删除，而jenkins任务会阻塞一直到有其他空闲的slave出现。</p>\n<h3 id=\"四-，总结\"><a href=\"#四-，总结\" class=\"headerlink\" title=\"四 ，总结\"></a><strong>四 ，总结</strong></h3><p>本文介绍了在k8s集群部署jenkins服务的方式和k8s带来的资源管理便捷，由于我也是刚开始接触k8s,所用的实例只是搭建了用于测试的实验环境，离在实际生产环境中使用还有问题需要验证。</p>\n","site":{"data":{}},"excerpt":"<p><strong>jenkins是什么？</strong><br>Jenkins是一个开源的持续集成工具，可用于自动化的执行与构建，测试和交付或部署软件有关的各种任务,有非常丰富的插件支持。<br><strong>kubernetes是什么？</strong><br>Kubernetes是容器集群管理系统，是一个开源的平台，可以实现容器集群的自动化部署、自动扩缩容、维护等功能。<a href=\"http://docs.kubernetes.org.cn/227.html\" target=\"_blank\" rel=\"noopener\">这个视频生动地介绍了k8s</a><br><strong>jenkins on k8s 有什么好处？</strong><br>jenkins通过单Master多个Slave的方式提供服务，Master保存了任务的配置信息，安装的插件等等，而slave主要负责执行任务，在使用中存在以下几个问题：<br>","more":"</p>\n<ol>\n<li>当存在多个slave时，运行slave的机器难以统一管理，每次添加新节点时总要做大量的重复工作。</li>\n<li>由于不同业务的构建频率并不相同，在使用会发现有很多slave大多数时间都处于空闲状态，造成资源浪费</li>\n<li>jenkins默认采取保守的调度方式，造成某些slave的负载过高，任务不能平均分配<br><img src=\"/images/jenkins/jenkins-arch.png\" alt=\"jenkins架构\"></li>\n</ol>\n<p>使用k8s管理jenkins具有以下优势：</p>\n<ol>\n<li>使用docker运行jenkins保证环境的一致性，可以根据不同业务选择合适的镜像</li>\n<li>k8s对抽象后的资源（pods）进行统一的管理调度，提供资源隔离和共享，使机器计算资源变得弹性可扩展,避免资源浪费。</li>\n<li>k8s提供容器的自愈功能，能够保证始终有一定数量的容器是可用的</li>\n<li>k8s默认的调度器提供了针对节点当前资源分配容器的调度策略，调度器支持插件化部署便于自定义。</li>\n</ol>\n<h3 id=\"一，搭建环境\"><a href=\"#一，搭建环境\" class=\"headerlink\" title=\"一，搭建环境\"></a><strong>一，搭建环境</strong></h3><h4 id=\"工具准备\"><a href=\"#工具准备\" class=\"headerlink\" title=\"工具准备\"></a>工具准备</h4><blockquote>\n<p>kubernetes v1.8.4<br>docker v1.12.6<br>jenkins master镜像 jenkins/jenkins:lts（v2.73.3）<br>slave镜像 jenkinsci/jnlp-slave<br>Kubernetes plugin (v1.1)</p>\n</blockquote>\n<h4 id=\"安装kubernetes集群\"><a href=\"#安装kubernetes集群\" class=\"headerlink\" title=\"安装kubernetes集群\"></a>安装kubernetes集群</h4><p>中文教程：<a href=\"https://www.kubernetes.org.cn/2906.html\" target=\"_blank\" rel=\"noopener\">https://www.kubernetes.org.cn/2906.html</a><br>安装成功之后访问dashboard地址就可以看到集群的控制面板：<br><img src=\"/images/jenkins/kongzhimianban.png\" alt=\"dashboard\"><br>集群安装完成后，创建命名空间kubernetes-plugin<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl create namespace kubernetes-plugin</span><br><span class=\"line\">kubectl config set-context $(kubectl config current-context) --namespace=kubernetes-plugin</span><br><span class=\"line\">kubectl create -f service-account.yml</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"二，创建StatefulSet\"><a href=\"#二，创建StatefulSet\" class=\"headerlink\" title=\"二，创建StatefulSet\"></a><strong>二，创建StatefulSet</strong></h3><blockquote>\n<p><strong>StatefulSet(有状态副本集)</strong>：Deployments适用于运行无状态应用，StatefulSet则为有状态的应用提供了支持，可以为应用提供有序的部署和扩展，稳定的持久化存储，我们使用SS来运行jenkins master。</p>\n</blockquote>\n<p>创建完整的Stateful Set需要依次创建一下对象：<br>1、Persistent Volume<br>2、Persistent Volume Claim<br>3、StatefulSet<br>4、Service</p>\n<h4 id=\"创建PersistentVolume：\"><a href=\"#创建PersistentVolume：\" class=\"headerlink\" title=\"创建PersistentVolume：\"></a><strong>创建PersistentVolume：</strong></h4><p>为了保存应用运行时的数据需要先创建k8s的卷文件，K8s中存在Volume和PersistentVolume两种类型：</p>\n<blockquote>\n<ul>\n<li>Volume：与docker中的volume不同在于Volume生命周期是和pod绑定的，与pod中的container无关。k8s为Volume提供了多种类型文件系统（cephfs,nfs…,简单起见我直接选择了hostPath，使用的node节点本地的存储系统）</li>\n<li>PersistentVolume:从名字可以看出来，PV的生命周期独立于使用它的pod，不会像volume随pod消失而消失，而是做为一个集群中的资源存在（像node节点一样），同时PV屏蔽了使用具体存储系统的细节。</li>\n</ul>\n</blockquote>\n<p>k8s中的对象都是通过<a href=\"http://www.ruanyifeng.com/blog/2016/07/yaml.html\" target=\"_blank\" rel=\"noopener\">yaml文件</a>来定义的，首先创建名为<code>jenkins-volume.yml</code>的文件:</p>\n<p><strong>注意</strong>：PV的创建有静态，动态两种方式，动态创建可以减少管理员的操作步骤，需要提供指定的<a href=\"https://kubernetes.io/docs/concepts/storage/storage-classes/\" target=\"_blank\" rel=\"noopener\">StorageClass</a>。为了测试方便，所以我们直接选择静态创建，manual是一个不存在的storage class<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kind: PersistentVolume</span><br><span class=\"line\">apiVersion: v1</span><br><span class=\"line\">metadata:</span><br><span class=\"line\">  name: jenkins-volume</span><br><span class=\"line\">  labels:</span><br><span class=\"line\">    type: local</span><br><span class=\"line\">spec:</span><br><span class=\"line\">  storageClassName: manual</span><br><span class=\"line\">  capacity:</span><br><span class=\"line\">    storage: 10Gi</span><br><span class=\"line\">  accessModes:</span><br><span class=\"line\">    - ReadWriteOnce</span><br><span class=\"line\">  hostPath:</span><br><span class=\"line\">    path: &quot;/tmp/data&quot;</span><br></pre></td></tr></table></figure></p>\n<p>master节点执行下面的命令，PV就手动创建完了<br><code>kubectl create -f jenkins-volume1.yaml</code></p>\n<h4 id=\"创建PersistentVolumeClaim：\"><a href=\"#创建PersistentVolumeClaim：\" class=\"headerlink\" title=\"创建PersistentVolumeClaim：\"></a><strong>创建PersistentVolumeClaim：</strong></h4><blockquote>\n<p>PersistentVolumeClaim(PVC):<br>持久化存储卷索取，如果说PV是集群中的资源，PVC就是资源的消费者，PVC可以指定需要的资源大小和访问方式,pod不会和PV直接接触，而是通过PVC来请求资源，PV的生成阶段叫做provision,生成PV后会绑定到PVC对象，然后才能被其他对象使用。</p>\n</blockquote>\n<p>PV和PVC的生命周期如下图：<br><img src=\"/images/jenkins/pvlife.png\" alt=\"pv life\"></p>\n<p>创建文件<code>jenkins-claim.yaml</code><br><strong>注意：</strong> name必须为jenkins-home-jenkins-0否则会绑定失败<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kind: PersistentVolumeClaim</span><br><span class=\"line\">apiVersion: v1</span><br><span class=\"line\">metadata:</span><br><span class=\"line\">  name: jenkins-home-jenkins-0</span><br><span class=\"line\">spec:</span><br><span class=\"line\">  storageClassName: manual</span><br><span class=\"line\">  accessModes:</span><br><span class=\"line\">    - ReadWriteOnce</span><br><span class=\"line\">  resources:</span><br><span class=\"line\">    requests:</span><br><span class=\"line\">      storage: 3Gi</span><br></pre></td></tr></table></figure></p>\n<p>执行命令<code>kubectl create -f jenkins-claim.yaml</code><br>然后查看PVC是否创建成功，status为bound说明PVC已经绑定<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@master ~]# kubectl describe pvc jenkins-home-jenkins-0</span><br><span class=\"line\">Name:          jenkins-home-jenkins-0</span><br><span class=\"line\">Namespace:     kubernetes-plugin</span><br><span class=\"line\">StorageClass:  manual</span><br><span class=\"line\">Status:        Bound</span><br><span class=\"line\">Volume:        jenkins-volume</span><br><span class=\"line\">Labels:        &lt;none&gt;</span><br><span class=\"line\">Annotations:   pv.kubernetes.io/bind-completed=yes</span><br><span class=\"line\">               pv.kubernetes.io/bound-by-controller=yes</span><br><span class=\"line\">Capacity:      10Gi</span><br><span class=\"line\">Access Modes:  RWO</span><br><span class=\"line\">Events:        &lt;none&gt;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"创建StatefulSet和Service：\"><a href=\"#创建StatefulSet和Service：\" class=\"headerlink\" title=\"创建StatefulSet和Service：\"></a><strong>创建StatefulSet和Service：</strong></h4><p>从kubernetes-plugin github仓库下载jenkins.yml文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://raw.githubusercontent.com/jenkinsci/kubernetes-plugin/master/src/main/kubernetes/jenkins.yml</span><br></pre></td></tr></table></figure></p>\n<p>修改jenkins.yml：<br>去掉87行<code>externalTrafficPolicy: Local</code>（这是GKE使用的）<br>修改83行<code>type: LoadBalancer</code>改为<code>type: NodePort</code></p>\n<p><strong>注意：</strong><br>service type=ClusterIP时只允许从集群内部访问， type设置为NodePort是为了从集群外的机器访问jenkins,请谨慎使用，开启NodePort会在所有节点（含master）的统一固定端口开放服务。</p>\n<p>执行命令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@master ~]# kubectl create -f jenkins.yml </span><br><span class=\"line\">statefulset &quot;jenkins&quot; created</span><br><span class=\"line\">service &quot;jenkins&quot; created</span><br></pre></td></tr></table></figure></p>\n<p>访问jenkins master,地址为<code>masterip:32058</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#查看映射的端口</span><br><span class=\"line\">[root@master ~]# kubectl get service jenkins</span><br><span class=\"line\">NAME      TYPE       CLUSTER-IP    EXTERNAL-IP   PORT(S)                        AGE</span><br><span class=\"line\">jenkins   NodePort   10.96.82.68   &lt;none&gt;        80:32058/TCP,50000:30345/TCP   1m</span><br></pre></td></tr></table></figure></p>\n<p>查看pod : jenkins-0的容器日志，粘贴下面的密码进入jenkins,jenkins安装完成。</p>\n<blockquote>\n<p>Jenkins initial setup is required. An admin user has been created and a password generated.<br>Please use the following password to proceed to installation:<br>70aa7b41ba894855abccd09306625b8a </p>\n</blockquote>\n<p>刷新dashboard，切换命名空间到kubernetes-plugin,结果如下：<br><img src=\"/images/jenkins/success.png\" alt=\"success\"></p>\n<h3 id=\"问题分析\"><a href=\"#问题分析\" class=\"headerlink\" title=\"问题分析\"></a>问题分析</h3><p>1.创建stateful set时失败，提示”PersistentVolumeClaim is not bound: “jenkins-home-jenkins-0”：”<br>因为采用静态创建PV时，StatefulSet会按照固定名称查找PVC，PVC的名字要满足</p>\n<blockquote>\n<p>PVC_name == volumeClaimTemplates_name + “-“ + pod_name</p>\n</blockquote>\n<p>这里的名字就是<code>jenkins-home-jenkins-0</code></p>\n<p>2.pod启动失败，jenkins用户没有目录权限<br>错误提示”touch: cannot touch ‘/var/jenkins_home/copy_reference_file.log’: Permission denied<br>Can not write to /var/jenkins_home/copy_reference_file.log. Wrong volume permissions?”<br>要确保节点目录开放权限,在node上执行命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo chown -R 1000:1000 /var/jenkins_home/</span><br><span class=\"line\">sudo chown -R 1000:1000 /tmp/data</span><br><span class=\"line\">##如果仍然失败，尝试在node上重启docker</span><br><span class=\"line\">systemctl restart docker</span><br></pre></td></tr></table></figure></p>\n<p>注意pv指定的hostPath权限也要修改，否则是无效的</p>\n<h3 id=\"三-，配置jenkins\"><a href=\"#三-，配置jenkins\" class=\"headerlink\" title=\"三 ，配置jenkins\"></a>三 ，配置jenkins</h3><h4 id=\"创建jenkins服务账号\"><a href=\"#创建jenkins服务账号\" class=\"headerlink\" title=\"创建jenkins服务账号\"></a>创建jenkins服务账号</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://raw.githubusercontent.com/jenkinsci/kubernetes-plugin/master/src/main/kubernetes/service-account.yml</span><br><span class=\"line\">kubectl create -f service-account.yml</span><br></pre></td></tr></table></figure>\n<h4 id=\"配置插件\"><a href=\"#配置插件\" class=\"headerlink\" title=\"配置插件\"></a>配置插件</h4><p>访问<code>http://masterip:32058/pluginManager/</code>,搜索插件Kubernetes plugin安装；<br>访问 <a href=\"http://masterip:32058/configure\" target=\"_blank\" rel=\"noopener\">http://masterip:32058/configure</a><br>选择新建云–kubernetes,在URl填写api server地址，<br>执行kubectl describe命令，复制output中的token，填入到 ‘Kubernetes server certificate key’<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@master ~]# kubectl get secret </span><br><span class=\"line\">NAME                  TYPE                                  DATA      AGE</span><br><span class=\"line\">default-token-4kb54   kubernetes.io/service-account-token   3         1d</span><br><span class=\"line\">jenkins-token-wzbsx   kubernetes.io/service-account-token   3         1d</span><br><span class=\"line\">[root@master ~]# kubectl describe secret/jenkins-token-wzbsx</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n<p>jenkins url,tunnel填写service的CLUSTER-IP即可，结果如图：<br><img src=\"/images/jenkins/config1.png\" alt=\"peizhi1\"><br>选择add pod template，填写下面的内容，retain slave可以设置运行jenkins slave 的container空闲后能存活多久。<br><img src=\"/images/jenkins/config.png\" alt=\"content\"><br>插件配置完成。</p>\n<h3 id=\"四-，测试\"><a href=\"#四-，测试\" class=\"headerlink\" title=\"四 ，测试\"></a>四 ，测试</h3><h4 id=\"1-扩容测试\"><a href=\"#1-扩容测试\" class=\"headerlink\" title=\"1. 扩容测试\"></a>1. 扩容测试</h4><p><strong>StatefulSet扩容：</strong><br>首先需要手动创建PV，PVC(见第二步),然后执行扩容命令<br><code>kubectl scale statefulset/jenkins --replicas=２</code><br>查看StatefulSet,此时已经拥有两个master节点，访问service时会<strong>随机</strong>将请求发送给后端的master。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@master ~]# kubectl get statefulset/jenkins </span><br><span class=\"line\">NAME      DESIRED   CURRENT   AGE</span><br><span class=\"line\">jenkins   2         2         5d</span><br></pre></td></tr></table></figure></p>\n<p>虽然通过k8s可以轻松实现jenkins master节点的拓展，但是由于jenkins存储数据的方式通过本地文件存储，master之间的数据同步还是一个麻烦的问题，参考<a href=\"https://yq.aliyun.com/articles/224376\" target=\"_blank\" rel=\"noopener\">jenkins存储模型</a>。</p>\n<p><em>jenkins master上保存的文件：</em><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls /temp/data</span><br><span class=\"line\">jenkins.CLI.xml</span><br><span class=\"line\">jenkins.install.InstallUtil.lastExecVersion</span><br><span class=\"line\">jenkins.install.UpgradeWizard.state</span><br><span class=\"line\">jenkins.model.ArtifactManagerConfiguration.xml</span><br><span class=\"line\">jenkins.model.JenkinsLocationConfiguration.xml</span><br><span class=\"line\">jobs</span><br><span class=\"line\">logs</span><br><span class=\"line\">nodeMonitors.xml</span><br><span class=\"line\">nodes</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"2-高可用测试\"><a href=\"#2-高可用测试\" class=\"headerlink\" title=\"2. 高可用测试\"></a>2. 高可用测试</h4><p>现在stateful set中已经有两个pod,在jenkins-1所在的节点执行<code>docker stop</code>停止运行jenkins-master的容器，同时在命令行查看pod的状态，可以看到jenkins-1异常（Error状态）之后慢慢恢复了运行状态（Running）：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@master ~]# kubectl get pods -w</span><br><span class=\"line\">NAME        READY     STATUS    RESTARTS   AGE</span><br><span class=\"line\">jenkins-0   1/1       Running   0          1d</span><br><span class=\"line\">jenkins-1   0/1       Running   1         20h</span><br><span class=\"line\">jenkins-1   1/1       Running   1         20h</span><br><span class=\"line\">jenkins-1   0/1       Error     1         20h</span><br><span class=\"line\">jenkins-1   0/1       CrashLoopBackOff   1         20h</span><br><span class=\"line\">jenkins-1   0/1       Running   2         20h</span><br><span class=\"line\">jenkins-1   1/1       Running   2         20h</span><br></pre></td></tr></table></figure></p>\n<p><code>kubectl describe pod jenkins-1</code>查看pod的事件日志，k8s通过探针(probe)接口检测到服务停止之后自动执行了拉取镜像，重启container的操作。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Events:</span><br><span class=\"line\">  Type     Reason      Age                From                              Message</span><br><span class=\"line\">  ----     ------      ----               ----                              -------</span><br><span class=\"line\">  Warning  Unhealthy   27m (x2 over 27m)  kubelet, iz8pscwd1fv6kprs1zw21kz  Readiness probe failed: HTTP probe failed with statuscode: 503</span><br><span class=\"line\">  Warning  Unhealthy   27m (x2 over 27m)  kubelet, iz8pscwd1fv6kprs1zw21kz  Liveness probe failed: HTTP probe failed with statuscode: 503</span><br><span class=\"line\">  Warning  Unhealthy   24m                kubelet, iz8pscwd1fv6kprs1zw21kz  Readiness probe failed: Get http://192.168.24.4:8080/login: dial tcp 192.168.24.4:8080: getsockopt: connection refused</span><br><span class=\"line\">  Warning  BackOff     20m (x2 over 20m)  kubelet, iz8pscwd1fv6kprs1zw21kz  Back-off restarting failed container</span><br><span class=\"line\">  Warning  FailedSync  20m (x2 over 20m)  kubelet, iz8pscwd1fv6kprs1zw21kz  Error syncing pod</span><br><span class=\"line\">  Normal   Pulling     19m (x3 over 20h)  kubelet, iz8pscwd1fv6kprs1zw21kz  pulling image &quot;jenkins/jenkins:lts-alpine&quot;</span><br><span class=\"line\">  Normal   Started     19m (x3 over 20h)  kubelet, iz8pscwd1fv6kprs1zw21kz  Started container</span><br><span class=\"line\">  Normal   Pulled      19m (x3 over 20h)  kubelet, iz8pscwd1fv6kprs1zw21kz  Successfully pulled image &quot;jenkins/jenkins:lts-alpine&quot;</span><br><span class=\"line\">  Normal   Created     19m (x3 over 20h)  kubelet, iz8pscwd1fv6kprs1zw21kz  Created container</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"3-jenkins构建测试\"><a href=\"#3-jenkins构建测试\" class=\"headerlink\" title=\"3. jenkins构建测试\"></a>3. jenkins构建测试</h4><p>当前集群中使用的jenkins slave镜像只包含一个java运行环境来运行jenkins-slave.jar,在实际使用中需要自定义合适的镜像。选择自定义镜像之后需要修改插件的配置，同样name命名为jnlp替换默认镜像，arguments安装工具提示填写即可。<br><img src=\"/images/jenkins/container.png\" alt=\"container\"><br>创建job，同时开始构建,k8s会在不同节点上创建pod来运行任务<br><img src=\"/images/jenkins/pods1.png\" alt=\"此处输入图片的描述\"><br>构建全部完成后，资源随即被释放<br><img src=\"/images/jenkins/result2.png\" alt=\"此处输入图片的描述\"></p>\n<p><strong>jenkins默认调度策略</strong></p>\n<ol>\n<li>尝试在上次构建的节点上构建，指定某台slave之后会一直使用。<br>2.当队列有2个构建时，不会立刻创建两个executor,而是先创建一个executor然后尝试等待executor空闲，目的是保证每个executor被充分利用。<br><strong>k8s调度策略</strong></li>\n<li>使用Pod.spec.nodeSelector根据label为pod选择node<br>2.调度器scheduler有Predicates，Priorities两个阶段，分别负责节点过滤和评分排序，各个阶段都有k8s提供的检查项，我们可以自由组合。<br>（比如PodFitsResources检查cpu内存等资源，PodFitsHostPorts检查端口占用，SelectorSpreadPriority要求一个服务尽量分散分布）<a href=\"http://dockone.io/article/2885\" target=\"_blank\" rel=\"noopener\">自定义schduler参考</a><br><strong>资源不足时会发生什么</strong><br>当前集群中有3个节点，我在node2运行一个CPU占用限制在80%的程序,然后设置jenkins插件ContainerTemplate的request和limit均为<code>cpu 500m,内存500Mi</code>,（500m代表单核CPU的50%）看一下pod会怎么调度<br>k8s仍然尝试在node2分配节点（为什么其他节点不行），结果POD处于pending状态：<figure class=\"highlight plain\"><figcaption><span>&#123;</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;phase&quot;: &quot;Pending&quot;,</span><br><span class=\"line\">&quot;conditions&quot;: [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    &quot;type&quot;: &quot;PodScheduled&quot;,</span><br><span class=\"line\">    &quot;status&quot;: &quot;False&quot;,</span><br><span class=\"line\">    &quot;lastProbeTime&quot;: null,</span><br><span class=\"line\">    &quot;lastTransitionTime&quot;: &quot;2017-12-09T08:29:10Z&quot;,</span><br><span class=\"line\">    &quot;reason&quot;: &quot;Unschedulable&quot;,</span><br><span class=\"line\">    &quot;message&quot;: &quot;No nodes are available that match all of the predicates: Insufficient cpu (4), PodToleratesNodeTaints (1).&quot;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">],</span><br><span class=\"line\">&quot;qosClass&quot;: &quot;Guaranteed&quot;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>最后pod被删除，而jenkins任务会阻塞一直到有其他空闲的slave出现。</p>\n<h3 id=\"四-，总结\"><a href=\"#四-，总结\" class=\"headerlink\" title=\"四 ，总结\"></a><strong>四 ，总结</strong></h3><p>本文介绍了在k8s集群部署jenkins服务的方式和k8s带来的资源管理便捷，由于我也是刚开始接触k8s,所用的实例只是搭建了用于测试的实验环境，离在实际生产环境中使用还有问题需要验证。</p>"},{"title":"mongodb:使用spring-data处理嵌套文档的实践","date":"2018-06-12T15:10:50.000Z","_content":"### 场景介绍\n在使用mongoDB保存数据时，不需要再严格遵守数据库范式，比如在设计用户订单存储时，我们可以把用户和订单的信息保存在同一个文档当中，用嵌套的方式代替用户表引用订单表的方式。本文以一个用户-订单的实例来介绍使用mongoDB嵌套保存数据时如何结合spring mongo data 实现基本功能，并对不同方案做了性能对比。\n\n在用户-订单的例子中，订单作为数嵌套保存在用户信息中，对外提供了更新和分页查询订单的功能，查询返回的订单以时间倒序，数据格式如下：\n<!--more-->\n```\n{\n\t\"_id\" : ObjectId(\"5c209db62a14a9019787860b\"),\n\t\"userId\" : \"u1\",\n\t\"userType\" : \"TYPE\",\n\t\"name\" : \"user1545641398911\",\n\t\"orderList\" : [\n\t\t{\n\t\t\t\"_id\" : \"order1\",\n\t\t\t\"info\" : \"Info:order01545641398901\",\n\t\t\t\"createTime\" : NumberLong(\"1545641398901\")\n\t\t},\n\t\t{\n\t\t\t\"_id\" : \"order0\",\n\t\t\t\"info\" : \"Info:order11545641398900\",\n\t\t\t\"createTime\" : NumberLong(\"1545641398900\")\n\t\t}\n    ]\n}\n```\n### 更新用户订单接口\n**接口描述：**首先根据userId查找到用户，如果订单_id已存在则替换，否则插入新订单,如果用户不存在则插入新文档；\n\n我们习惯直接用新数据替换整个文档的内容，不过当用户订单很多时就需要订单数组做局部更新（减少发送数据的大小，\n可以用pull/push操作符来完成，假设要添加id为1,2,3的订单，mongo命令如下：\n```\n//删除_id相同的订单\ndb.user.update({\"userId\":\"user9\"},\n            {$pull:\n                {orderList:{\n                    _id:{$in:[\"1\",\"2\",\"3\"]}\n                }}\n            })\n//保存新数据\ndb.user.update(\n            {\"userId\":\"user9\"},\n            {\n                $push:{orderList:{$each:[{\"_id\":\"1\"},{\"_id\":\"2\"},{\"_id\":\"3\"}]}},\n                \"$set\":{\n                    \"userId\":\"user9\",\n                    \"userType\":\"C\",\n                    \"userName\":\"name\"}\n            },\n            {\"upsert\":true}\n        )\n```\n\n**注意问题**\nmongoDB不允许在更新时对某个属性执行多个操作，所以对orderList的pull和push操作只能分开执行\n\n### 订单查询和分页接口\n**接口描述：**查询指定用户，某个时间前的订单列表，支持分页，以时间倒序，返回结果包含订单和用户信息\n\n实现方式有两种，一个是用聚合查询，支持灵活的查询方式，不过耗时长，或者用slice对订单数组分页，不过不能按时间过滤订单且订单要先倒序保存好，耗时短；\n用聚合查询，mongo命令：\n```\n db.user.aggregate([\n       {\"$match\" : { \"userId\" : \"u1\", \"userType\" : \"TYPE\" }},\n       //把orderList打散为独立文档，方便后续查询，排序\n       { \"$unwind\" : \"$orderList\" },\n       //按时间过滤\n       { \"$match\" : { \"orderList.createTime\" : { \"$lte\" :  1545030349990}}},\n       //时间倒序\n       { \"$sort\" : { \"orderList.createTime\" : -1 } },\n       //分页大小\n       {\"$limit\" : 100},\n       //用group还原，如果只返回订单列表则不用这步\n       //$last操作符选择返回的用户属性，$push操作符恢复打散的orderList\n       { \"$group\" : {\n       \"_id\" : \"$_id\",\n       \"userType\" : { \"$last\" : \"$userType\" },\n       \"userId\" : { \"$last\" : \"$userId\" },\n       \"name\" : { \"$last\" : \"$name\" },\n       \"orderList\" : { \"$push\" : \"$orderList\" }\n       }}\n       ])\n```\n用slice命令：\n```\n//跳过20条，返回10条\ndb.user.find({userId:\"u1\"},{orderList:{$slice:[20,10]}}).pretty()\n```\n**注意问题**\n聚合查询最后的为什么group：\n这是执行unwind后的用户文档,原本一个文档安装orderList数组的数量被分成多个文档，用户的信息也被分散，所以最后需要group重新组合：\n```\n{ \"_id\" : ObjectId(\"5c209db62a14a9019787860b\"), \"userId\" : \"u1\", \"userType\" : \"TYPE\", \"name\" : \"user1545641398911\", \"orderList\" : { \"_id\" : \"order18\", \"info\" : \"Info:order181545641398918\", \"createTime\" : NumberLong(\"1545641398918\") }, \"_class\" : \"com.throwsnew.springbootstudy.accessdata.mongo.model.User\" }\n{ \"_id\" : ObjectId(\"5c209db62a14a9019787860b\"), \"userId\" : \"u1\", \"userType\" : \"TYPE\", \"name\" : \"user1545641398911\", \"orderList\" : { \"_id\" : \"order19\", \"info\" : \"Info:order191545641398919\", \"createTime\" : NumberLong(\"1545641398919\") }, \"_class\" : \"com.throwsnew.springbootstudy.accessdata.mongo.model.User\" }\n```\n### 使用spring-data实现接口\n个人感觉mongo这种json风格的命令并不是很好用，当嵌套多层时简直要晃瞎眼，而且在spring-data-mongodb的java驱动实现时使用的又是命令式的风格，所以即使熟悉了mongo命令也不能很快写出对应的java代码：\n#### 更新接口实现\n借助spring-data-mongodb 中的Update、PushOperatorBuilder类实现\n```\n        List<String> ids = orderList.stream().map(Order::getId).collect(Collectors.toList());\n        Query query = new Query();\n        query.addCriteria(Criteria.where(\"userId\").is(userId));\n        query.addCriteria(Criteria.where(\"userType\").is(userType));\n        Update updateOld = new Update();\n        updateOld.pull(\"orderList\", Query.query(Criteria.where(\"_id\").in(\n                ids)));\n        UpdateResult pullResult = mongoTemplate.updateFirst(query, updateOld, User.class);\n        \n        Update updateNew = new Update();\n        PushOperatorBuilder push = updateNew.push(\"orderList\");\n        push.each(orderList);\n        //push使用sort会让执行时间加倍\n//        push.sort(new Sort(Direction.DESC, \"createTime\"));\n        updateNew.set(\"userId\", userId);\n        updateNew.set(\"userType\", userType);\n        updateNew.set(\"userName\", \"name\");\n        UpdateResult pushResult = mongoTemplate\n                .upsert(query, updateNew, User.class);\n                \n       Assert.isTrue(pullResult.wasAcknowledged() && pushResult.wasAcknowledged());\n\n```\n#### 查询接口实现\n```\n        MatchOperation matchUser = match(Criteria.where(\"userId\").is(userId)\n                .and(\"userType\").is(userType));\n\n        GroupOperation groupOperation = group(\"_id\")\n                .last(\"userType\").as(\"userType\")\n                .last(\"userId\").as(\"userId\")\n                .last(\"name\").as(\"name\")\n                .push(\"orderList\").as(\"orderList\");\n        MatchOperation matchCreateTime;\n        if (maxCreateTime == 0L) {\n            matchCreateTime = match(Criteria.where(\"orderList.createTime\").gt(0L));\n        } else {\n            matchCreateTime = match(Criteria.where(\"orderList.createTime\").lte(maxCreateTime));\n        }\n\n        Aggregation aggregation = Aggregation.newAggregation(\n                matchUser,\n                unwind(\"orderList\"),\n                matchCreateTime,\n                sort(Direction.DESC, \"orderList.createTime\"),\n                limit(size),\n                groupOperation\n        );\n        AggregationResults<User> users = mongoTemplate\n                .aggregate(aggregation, User.class, User.class);\n        if (CollectionUtils.isEmpty(users.getMappedResults())) {\n            return null;\n        } else {\n            return users.getMappedResults().get(0);\n        }\n\n```\n### 性能测试\n用jmh框架对查询和更新两个接口做性能测试，mongoDB实例安装在本地，以副本集方式运行，测试数据量为5000用户 每个用户10000订单，本机配置16GB内存，8核CPU。[测试用例源码地址][1]\n\n这里的测试数据只能说明在指定数据量下接口的表现，随着数据量变化接口表现也不同。\n`关于jmh输出，以updateByPush为例，说明99.9%的请求耗时分布在50.013-6.460到50.013+6.460之间，cnt表示执行次数`\n#### 更新接口测试\n测试结果表明，在这个实例中通过push/pull更新（不排序）比替换整个文档更新耗时减少25ms（平均值），如果更新时排序则和替换文档耗时相近。\n\n通过push/pull更新(push时排序)\n```\nResult \"updateByPush\":\n  50.013 ±(99.9%) 6.460 ms/op [Average]\n  (min, avg, max) = (45.299, 50.013, 59.592), stdev = 4.273\n  CI (99.9%): [43.553, 56.473] (assumes normal distribution)\n\n\n# Run complete. Total time: 00:00:14\n\nBenchmark                  Mode  Cnt   Score   Error  Units\nJmhBenchmark.updateByPush  avgt   10  50.013 ± 6.460  ms/op\n\n```\n通过pull/push更新（push时不排序）\n```\nResult \"updateByPush\":\n  25.034 ±(99.9%) 22.153 ms/op [Average]\n  (min, avg, max) = (16.419, 25.034, 61.959), stdev = 14.653\n  CI (99.9%): [2.880, 47.187] (assumes normal distribution)\n\n\n# Run complete. Total time: 00:00:15\n\nBenchmark                  Mode  Cnt   Score    Error  Units\nJmhBenchmark.updateByPush  avgt   10  25.034 ± 22.153  ms/op\n```\n通过替换整个文档更新\n```\nResult \"updateByReplace\":\n  45.985 ±(99.9%) 17.885 ms/op [Average]\n  (min, avg, max) = (41.466, 45.985, 79.604), stdev = 11.830\n  CI (99.9%): [28.100, 63.869] (assumes normal distribution)\n\nBenchmark                     Mode  Cnt   Score    Error  Units\nJmhBenchmark.updateByReplace  avgt   10  45.985 ± 17.885  ms/op\n```\n\n#### 查询接口测试\n分别测试了slice查询，和聚合查询排序，聚合查询不排序三种。其中slice查询不代表实际的耗时，因为它不能实现按时间查询的功能。对于聚合查询，如果更新时排序则不需要再次排序。\n\nslice查询分页(不能设置分页查询条件，不能排序)\n```\nResult \"findBySlice\":\n  1.531 ±(99.9%) 0.128 ms/op [Average]\n  (min, avg, max) = (1.437, 1.531, 1.669), stdev = 0.085\n  CI (99.9%): [1.404, 1.659] (assumes normal distribution)\n\nBenchmark                 Mode  Cnt  Score   Error  Units\nJmhBenchmark.findBySlice  avgt   10  1.531 ± 0.128  ms/op\n```\naggregation查询分页(按时间查询并分页)\n```\nResult \"findByAggregation\":\n  7.612 ±(99.9%) 0.747 ms/op [Average]\n  (min, avg, max) = (6.986, 7.612, 8.697), stdev = 0.494\n  CI (99.9%): [6.865, 8.359] (assumes normal distribution)\n\nBenchmark                       Mode  Cnt  Score   Error  Units\nJmhBenchmark.findByAggregation  avgt   10  7.612 ± 0.747  ms/op\n```\naggregation查询分页(按时间查询并分页，添加了sort操作)\n```\nResult \"findByAggregation\":\n  15.609 ±(99.9%) 0.795 ms/op [Average]\n  (min, avg, max) = (14.731, 15.609, 16.237), stdev = 0.526\n  CI (99.9%): [14.814, 16.404] (assumes normal distribution)\n\n\nBenchmark                       Mode  Cnt   Score   Error  Units\nJmhBenchmark.findByAggregation  avgt   10  15.609 ± 0.795  ms/op\n```\n\n### 创建索引\n创建索引可以优化查询速度，在创建索引后再次对查询和更新接口做性能测试，在本例中创建索引后并没有明显的提升，\n而且**在嵌套文档上创建的索引在聚合查询中并没有用到，在聚合查询中只包含match和sort时才能使用索引，在unwind之前match或sort(orderList.createTime)会命中索引，但unwind执行后无法使用**\n\n>来自mongo权威指南的描述：管道如果不是直接从原先的集合中使用数据，那就无法在筛选和排序中使用索引。\n\n#### 对父文档创建索引\n```\ndb.user.createIndex({userId:1},{unique:true})\n```\n\n创建索引会加速对用户的查询，但是也会增加写数据时的操作；在测试中添加索引后查询时间略有减少，\n更新操作耗时也减少了(因为没有更新被索引字段)。\n\n加索引后聚合查询时间(执行sort)，pull/push时间（不sort)和通过替换更新的时间：\n\n\n```\nBenchmark                       Mode  Cnt   Score   Error  Units\nJmhBenchmark.findByAggregation  avgt   10  12.829 ± 0.592  ms/op\nJmhBenchmark.updateByPush       avgt   10  17.962 ± 4.572  ms/op\nJmhBenchmark.updateByReplace    avgt   10  41.691 ± 2.140  ms/op\n```\n\n#### 对子文档创建索引\n去掉父文档上的索引，在嵌套的文档上创建一个createTime字段的索引\n\n```\ndb.user.createIndex({\"orderList.createTime\":1})\ndb.user.getIndexes()\n```\n\n再执行测试结果如下：\n```\nBenchmark                       Mode  Cnt    Score     Error  Units\nJmhBenchmark.findByAggregation  avgt   10  15.866 ± 0.863  ms/op\nJmhBenchmark.updateByPush       avgt   10  172.905 ± 121.534  ms/op\nJmhBenchmark.updateByReplace    avgt   10  127.146 ± 84.696  ms/op\n```\n实际上在查询时索引并没有被使用(COLLSCAN)，反而更新子文档的耗时因为要更新索引大大增加；\n对聚合查询执行explain的输出也说明没有用到createTime索引：\n```\n\t\t\t\"$cursor\" : {\n\t\t\t\t\"query\" : {\n\t\t\t\t\t\"userId\" : \"u666\",\n\t\t\t\t\t\"userType\" : \"B\"\n\t\t\t\t},\n\t\t\t\t\"queryPlanner\" : {\n\t\t\t\t\t\"plannerVersion\" : 1,\n\t\t\t\t\t\"namespace\" : \"test.user\",\n\t\t\t\t\t\"indexFilterSet\" : false,\n\t\t\t\t\t\"parsedQuery\" : {\n\t\t\t\t\t\t\"$and\" : [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"userId\" : {\n\t\t\t\t\t\t\t\t\t\"$eq\" : \"u666\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"userType\" : {\n\t\t\t\t\t\t\t\t\t\"$eq\" : \"B\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t]\n\t\t\t\t\t},\n\t\t\t\t\t\"winningPlan\" : {\n\t\t\t\t\t\t\"stage\" : \"COLLSCAN\",\n```\n\n#### ttl索引不支持嵌套文档\n通常让mongo文档自动过期可以通过ttl索引实现，但是ttl索引在嵌套文档上无效，只能让父文档过期。\n在createTime上设置ttl索引，不会执行过期操作\n```\ndb.user.createIndex( { \"orderList.createTime\": 1 }, { expireAfterSeconds: 0 }\n```\n### 总结\n使用mongoDB保存嵌套文档时，在被嵌套文档上的CRUD操作会变得相对更复杂，查询一般要通过聚合来实现，带来的好处是mongodb可以保证对一个文档的操作是原子性的，如果分散到多个文档保存需要mongoDB的事务支持(升级到v4.0)。\n如果嵌套文档数组元素数量较多，还要注意最后单个文档大小不能超过16MB的限制。\nTTL索引和嵌套文档上创建的索引不能保证一定有效，需要手动验证。\n当嵌套文档较小时可以直接使用替换的方式更新，查询操作也可以直接返回整个文档，设计上避免了文档相互引用带来的复杂度。\n\n\n  [1]: https://github.com/xianfengsong/someDemo/tree/master/spring-boot-study","source":"_posts/mongodb-使用spring-data处理嵌套文档的实践.md","raw":"title: mongodb:使用spring-data处理嵌套文档的实践\ndate: 2018-06-12 23:10:50\ncategories: mongodb\ntags: [mongodb,springboot]\n---\n### 场景介绍\n在使用mongoDB保存数据时，不需要再严格遵守数据库范式，比如在设计用户订单存储时，我们可以把用户和订单的信息保存在同一个文档当中，用嵌套的方式代替用户表引用订单表的方式。本文以一个用户-订单的实例来介绍使用mongoDB嵌套保存数据时如何结合spring mongo data 实现基本功能，并对不同方案做了性能对比。\n\n在用户-订单的例子中，订单作为数嵌套保存在用户信息中，对外提供了更新和分页查询订单的功能，查询返回的订单以时间倒序，数据格式如下：\n<!--more-->\n```\n{\n\t\"_id\" : ObjectId(\"5c209db62a14a9019787860b\"),\n\t\"userId\" : \"u1\",\n\t\"userType\" : \"TYPE\",\n\t\"name\" : \"user1545641398911\",\n\t\"orderList\" : [\n\t\t{\n\t\t\t\"_id\" : \"order1\",\n\t\t\t\"info\" : \"Info:order01545641398901\",\n\t\t\t\"createTime\" : NumberLong(\"1545641398901\")\n\t\t},\n\t\t{\n\t\t\t\"_id\" : \"order0\",\n\t\t\t\"info\" : \"Info:order11545641398900\",\n\t\t\t\"createTime\" : NumberLong(\"1545641398900\")\n\t\t}\n    ]\n}\n```\n### 更新用户订单接口\n**接口描述：**首先根据userId查找到用户，如果订单_id已存在则替换，否则插入新订单,如果用户不存在则插入新文档；\n\n我们习惯直接用新数据替换整个文档的内容，不过当用户订单很多时就需要订单数组做局部更新（减少发送数据的大小，\n可以用pull/push操作符来完成，假设要添加id为1,2,3的订单，mongo命令如下：\n```\n//删除_id相同的订单\ndb.user.update({\"userId\":\"user9\"},\n            {$pull:\n                {orderList:{\n                    _id:{$in:[\"1\",\"2\",\"3\"]}\n                }}\n            })\n//保存新数据\ndb.user.update(\n            {\"userId\":\"user9\"},\n            {\n                $push:{orderList:{$each:[{\"_id\":\"1\"},{\"_id\":\"2\"},{\"_id\":\"3\"}]}},\n                \"$set\":{\n                    \"userId\":\"user9\",\n                    \"userType\":\"C\",\n                    \"userName\":\"name\"}\n            },\n            {\"upsert\":true}\n        )\n```\n\n**注意问题**\nmongoDB不允许在更新时对某个属性执行多个操作，所以对orderList的pull和push操作只能分开执行\n\n### 订单查询和分页接口\n**接口描述：**查询指定用户，某个时间前的订单列表，支持分页，以时间倒序，返回结果包含订单和用户信息\n\n实现方式有两种，一个是用聚合查询，支持灵活的查询方式，不过耗时长，或者用slice对订单数组分页，不过不能按时间过滤订单且订单要先倒序保存好，耗时短；\n用聚合查询，mongo命令：\n```\n db.user.aggregate([\n       {\"$match\" : { \"userId\" : \"u1\", \"userType\" : \"TYPE\" }},\n       //把orderList打散为独立文档，方便后续查询，排序\n       { \"$unwind\" : \"$orderList\" },\n       //按时间过滤\n       { \"$match\" : { \"orderList.createTime\" : { \"$lte\" :  1545030349990}}},\n       //时间倒序\n       { \"$sort\" : { \"orderList.createTime\" : -1 } },\n       //分页大小\n       {\"$limit\" : 100},\n       //用group还原，如果只返回订单列表则不用这步\n       //$last操作符选择返回的用户属性，$push操作符恢复打散的orderList\n       { \"$group\" : {\n       \"_id\" : \"$_id\",\n       \"userType\" : { \"$last\" : \"$userType\" },\n       \"userId\" : { \"$last\" : \"$userId\" },\n       \"name\" : { \"$last\" : \"$name\" },\n       \"orderList\" : { \"$push\" : \"$orderList\" }\n       }}\n       ])\n```\n用slice命令：\n```\n//跳过20条，返回10条\ndb.user.find({userId:\"u1\"},{orderList:{$slice:[20,10]}}).pretty()\n```\n**注意问题**\n聚合查询最后的为什么group：\n这是执行unwind后的用户文档,原本一个文档安装orderList数组的数量被分成多个文档，用户的信息也被分散，所以最后需要group重新组合：\n```\n{ \"_id\" : ObjectId(\"5c209db62a14a9019787860b\"), \"userId\" : \"u1\", \"userType\" : \"TYPE\", \"name\" : \"user1545641398911\", \"orderList\" : { \"_id\" : \"order18\", \"info\" : \"Info:order181545641398918\", \"createTime\" : NumberLong(\"1545641398918\") }, \"_class\" : \"com.throwsnew.springbootstudy.accessdata.mongo.model.User\" }\n{ \"_id\" : ObjectId(\"5c209db62a14a9019787860b\"), \"userId\" : \"u1\", \"userType\" : \"TYPE\", \"name\" : \"user1545641398911\", \"orderList\" : { \"_id\" : \"order19\", \"info\" : \"Info:order191545641398919\", \"createTime\" : NumberLong(\"1545641398919\") }, \"_class\" : \"com.throwsnew.springbootstudy.accessdata.mongo.model.User\" }\n```\n### 使用spring-data实现接口\n个人感觉mongo这种json风格的命令并不是很好用，当嵌套多层时简直要晃瞎眼，而且在spring-data-mongodb的java驱动实现时使用的又是命令式的风格，所以即使熟悉了mongo命令也不能很快写出对应的java代码：\n#### 更新接口实现\n借助spring-data-mongodb 中的Update、PushOperatorBuilder类实现\n```\n        List<String> ids = orderList.stream().map(Order::getId).collect(Collectors.toList());\n        Query query = new Query();\n        query.addCriteria(Criteria.where(\"userId\").is(userId));\n        query.addCriteria(Criteria.where(\"userType\").is(userType));\n        Update updateOld = new Update();\n        updateOld.pull(\"orderList\", Query.query(Criteria.where(\"_id\").in(\n                ids)));\n        UpdateResult pullResult = mongoTemplate.updateFirst(query, updateOld, User.class);\n        \n        Update updateNew = new Update();\n        PushOperatorBuilder push = updateNew.push(\"orderList\");\n        push.each(orderList);\n        //push使用sort会让执行时间加倍\n//        push.sort(new Sort(Direction.DESC, \"createTime\"));\n        updateNew.set(\"userId\", userId);\n        updateNew.set(\"userType\", userType);\n        updateNew.set(\"userName\", \"name\");\n        UpdateResult pushResult = mongoTemplate\n                .upsert(query, updateNew, User.class);\n                \n       Assert.isTrue(pullResult.wasAcknowledged() && pushResult.wasAcknowledged());\n\n```\n#### 查询接口实现\n```\n        MatchOperation matchUser = match(Criteria.where(\"userId\").is(userId)\n                .and(\"userType\").is(userType));\n\n        GroupOperation groupOperation = group(\"_id\")\n                .last(\"userType\").as(\"userType\")\n                .last(\"userId\").as(\"userId\")\n                .last(\"name\").as(\"name\")\n                .push(\"orderList\").as(\"orderList\");\n        MatchOperation matchCreateTime;\n        if (maxCreateTime == 0L) {\n            matchCreateTime = match(Criteria.where(\"orderList.createTime\").gt(0L));\n        } else {\n            matchCreateTime = match(Criteria.where(\"orderList.createTime\").lte(maxCreateTime));\n        }\n\n        Aggregation aggregation = Aggregation.newAggregation(\n                matchUser,\n                unwind(\"orderList\"),\n                matchCreateTime,\n                sort(Direction.DESC, \"orderList.createTime\"),\n                limit(size),\n                groupOperation\n        );\n        AggregationResults<User> users = mongoTemplate\n                .aggregate(aggregation, User.class, User.class);\n        if (CollectionUtils.isEmpty(users.getMappedResults())) {\n            return null;\n        } else {\n            return users.getMappedResults().get(0);\n        }\n\n```\n### 性能测试\n用jmh框架对查询和更新两个接口做性能测试，mongoDB实例安装在本地，以副本集方式运行，测试数据量为5000用户 每个用户10000订单，本机配置16GB内存，8核CPU。[测试用例源码地址][1]\n\n这里的测试数据只能说明在指定数据量下接口的表现，随着数据量变化接口表现也不同。\n`关于jmh输出，以updateByPush为例，说明99.9%的请求耗时分布在50.013-6.460到50.013+6.460之间，cnt表示执行次数`\n#### 更新接口测试\n测试结果表明，在这个实例中通过push/pull更新（不排序）比替换整个文档更新耗时减少25ms（平均值），如果更新时排序则和替换文档耗时相近。\n\n通过push/pull更新(push时排序)\n```\nResult \"updateByPush\":\n  50.013 ±(99.9%) 6.460 ms/op [Average]\n  (min, avg, max) = (45.299, 50.013, 59.592), stdev = 4.273\n  CI (99.9%): [43.553, 56.473] (assumes normal distribution)\n\n\n# Run complete. Total time: 00:00:14\n\nBenchmark                  Mode  Cnt   Score   Error  Units\nJmhBenchmark.updateByPush  avgt   10  50.013 ± 6.460  ms/op\n\n```\n通过pull/push更新（push时不排序）\n```\nResult \"updateByPush\":\n  25.034 ±(99.9%) 22.153 ms/op [Average]\n  (min, avg, max) = (16.419, 25.034, 61.959), stdev = 14.653\n  CI (99.9%): [2.880, 47.187] (assumes normal distribution)\n\n\n# Run complete. Total time: 00:00:15\n\nBenchmark                  Mode  Cnt   Score    Error  Units\nJmhBenchmark.updateByPush  avgt   10  25.034 ± 22.153  ms/op\n```\n通过替换整个文档更新\n```\nResult \"updateByReplace\":\n  45.985 ±(99.9%) 17.885 ms/op [Average]\n  (min, avg, max) = (41.466, 45.985, 79.604), stdev = 11.830\n  CI (99.9%): [28.100, 63.869] (assumes normal distribution)\n\nBenchmark                     Mode  Cnt   Score    Error  Units\nJmhBenchmark.updateByReplace  avgt   10  45.985 ± 17.885  ms/op\n```\n\n#### 查询接口测试\n分别测试了slice查询，和聚合查询排序，聚合查询不排序三种。其中slice查询不代表实际的耗时，因为它不能实现按时间查询的功能。对于聚合查询，如果更新时排序则不需要再次排序。\n\nslice查询分页(不能设置分页查询条件，不能排序)\n```\nResult \"findBySlice\":\n  1.531 ±(99.9%) 0.128 ms/op [Average]\n  (min, avg, max) = (1.437, 1.531, 1.669), stdev = 0.085\n  CI (99.9%): [1.404, 1.659] (assumes normal distribution)\n\nBenchmark                 Mode  Cnt  Score   Error  Units\nJmhBenchmark.findBySlice  avgt   10  1.531 ± 0.128  ms/op\n```\naggregation查询分页(按时间查询并分页)\n```\nResult \"findByAggregation\":\n  7.612 ±(99.9%) 0.747 ms/op [Average]\n  (min, avg, max) = (6.986, 7.612, 8.697), stdev = 0.494\n  CI (99.9%): [6.865, 8.359] (assumes normal distribution)\n\nBenchmark                       Mode  Cnt  Score   Error  Units\nJmhBenchmark.findByAggregation  avgt   10  7.612 ± 0.747  ms/op\n```\naggregation查询分页(按时间查询并分页，添加了sort操作)\n```\nResult \"findByAggregation\":\n  15.609 ±(99.9%) 0.795 ms/op [Average]\n  (min, avg, max) = (14.731, 15.609, 16.237), stdev = 0.526\n  CI (99.9%): [14.814, 16.404] (assumes normal distribution)\n\n\nBenchmark                       Mode  Cnt   Score   Error  Units\nJmhBenchmark.findByAggregation  avgt   10  15.609 ± 0.795  ms/op\n```\n\n### 创建索引\n创建索引可以优化查询速度，在创建索引后再次对查询和更新接口做性能测试，在本例中创建索引后并没有明显的提升，\n而且**在嵌套文档上创建的索引在聚合查询中并没有用到，在聚合查询中只包含match和sort时才能使用索引，在unwind之前match或sort(orderList.createTime)会命中索引，但unwind执行后无法使用**\n\n>来自mongo权威指南的描述：管道如果不是直接从原先的集合中使用数据，那就无法在筛选和排序中使用索引。\n\n#### 对父文档创建索引\n```\ndb.user.createIndex({userId:1},{unique:true})\n```\n\n创建索引会加速对用户的查询，但是也会增加写数据时的操作；在测试中添加索引后查询时间略有减少，\n更新操作耗时也减少了(因为没有更新被索引字段)。\n\n加索引后聚合查询时间(执行sort)，pull/push时间（不sort)和通过替换更新的时间：\n\n\n```\nBenchmark                       Mode  Cnt   Score   Error  Units\nJmhBenchmark.findByAggregation  avgt   10  12.829 ± 0.592  ms/op\nJmhBenchmark.updateByPush       avgt   10  17.962 ± 4.572  ms/op\nJmhBenchmark.updateByReplace    avgt   10  41.691 ± 2.140  ms/op\n```\n\n#### 对子文档创建索引\n去掉父文档上的索引，在嵌套的文档上创建一个createTime字段的索引\n\n```\ndb.user.createIndex({\"orderList.createTime\":1})\ndb.user.getIndexes()\n```\n\n再执行测试结果如下：\n```\nBenchmark                       Mode  Cnt    Score     Error  Units\nJmhBenchmark.findByAggregation  avgt   10  15.866 ± 0.863  ms/op\nJmhBenchmark.updateByPush       avgt   10  172.905 ± 121.534  ms/op\nJmhBenchmark.updateByReplace    avgt   10  127.146 ± 84.696  ms/op\n```\n实际上在查询时索引并没有被使用(COLLSCAN)，反而更新子文档的耗时因为要更新索引大大增加；\n对聚合查询执行explain的输出也说明没有用到createTime索引：\n```\n\t\t\t\"$cursor\" : {\n\t\t\t\t\"query\" : {\n\t\t\t\t\t\"userId\" : \"u666\",\n\t\t\t\t\t\"userType\" : \"B\"\n\t\t\t\t},\n\t\t\t\t\"queryPlanner\" : {\n\t\t\t\t\t\"plannerVersion\" : 1,\n\t\t\t\t\t\"namespace\" : \"test.user\",\n\t\t\t\t\t\"indexFilterSet\" : false,\n\t\t\t\t\t\"parsedQuery\" : {\n\t\t\t\t\t\t\"$and\" : [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"userId\" : {\n\t\t\t\t\t\t\t\t\t\"$eq\" : \"u666\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"userType\" : {\n\t\t\t\t\t\t\t\t\t\"$eq\" : \"B\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t]\n\t\t\t\t\t},\n\t\t\t\t\t\"winningPlan\" : {\n\t\t\t\t\t\t\"stage\" : \"COLLSCAN\",\n```\n\n#### ttl索引不支持嵌套文档\n通常让mongo文档自动过期可以通过ttl索引实现，但是ttl索引在嵌套文档上无效，只能让父文档过期。\n在createTime上设置ttl索引，不会执行过期操作\n```\ndb.user.createIndex( { \"orderList.createTime\": 1 }, { expireAfterSeconds: 0 }\n```\n### 总结\n使用mongoDB保存嵌套文档时，在被嵌套文档上的CRUD操作会变得相对更复杂，查询一般要通过聚合来实现，带来的好处是mongodb可以保证对一个文档的操作是原子性的，如果分散到多个文档保存需要mongoDB的事务支持(升级到v4.0)。\n如果嵌套文档数组元素数量较多，还要注意最后单个文档大小不能超过16MB的限制。\nTTL索引和嵌套文档上创建的索引不能保证一定有效，需要手动验证。\n当嵌套文档较小时可以直接使用替换的方式更新，查询操作也可以直接返回整个文档，设计上避免了文档相互引用带来的复杂度。\n\n\n  [1]: https://github.com/xianfengsong/someDemo/tree/master/spring-boot-study","slug":"mongodb-使用spring-data处理嵌套文档的实践","published":1,"updated":"2019-03-13T16:11:38.018Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkqle1cp002ccynelxvvpg7g","content":"<h3 id=\"场景介绍\"><a href=\"#场景介绍\" class=\"headerlink\" title=\"场景介绍\"></a>场景介绍</h3><p>在使用mongoDB保存数据时，不需要再严格遵守数据库范式，比如在设计用户订单存储时，我们可以把用户和订单的信息保存在同一个文档当中，用嵌套的方式代替用户表引用订单表的方式。本文以一个用户-订单的实例来介绍使用mongoDB嵌套保存数据时如何结合spring mongo data 实现基本功能，并对不同方案做了性能对比。</p>\n<p>在用户-订单的例子中，订单作为数嵌套保存在用户信息中，对外提供了更新和分页查询订单的功能，查询返回的订单以时间倒序，数据格式如下：<br><a id=\"more\"></a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\t&quot;_id&quot; : ObjectId(&quot;5c209db62a14a9019787860b&quot;),</span><br><span class=\"line\">\t&quot;userId&quot; : &quot;u1&quot;,</span><br><span class=\"line\">\t&quot;userType&quot; : &quot;TYPE&quot;,</span><br><span class=\"line\">\t&quot;name&quot; : &quot;user1545641398911&quot;,</span><br><span class=\"line\">\t&quot;orderList&quot; : [</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t&quot;_id&quot; : &quot;order1&quot;,</span><br><span class=\"line\">\t\t\t&quot;info&quot; : &quot;Info:order01545641398901&quot;,</span><br><span class=\"line\">\t\t\t&quot;createTime&quot; : NumberLong(&quot;1545641398901&quot;)</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t&quot;_id&quot; : &quot;order0&quot;,</span><br><span class=\"line\">\t\t\t&quot;info&quot; : &quot;Info:order11545641398900&quot;,</span><br><span class=\"line\">\t\t\t&quot;createTime&quot; : NumberLong(&quot;1545641398900&quot;)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"更新用户订单接口\"><a href=\"#更新用户订单接口\" class=\"headerlink\" title=\"更新用户订单接口\"></a>更新用户订单接口</h3><p><strong>接口描述：</strong>首先根据userId查找到用户，如果订单_id已存在则替换，否则插入新订单,如果用户不存在则插入新文档；</p>\n<p>我们习惯直接用新数据替换整个文档的内容，不过当用户订单很多时就需要订单数组做局部更新（减少发送数据的大小，<br>可以用pull/push操作符来完成，假设要添加id为1,2,3的订单，mongo命令如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//删除_id相同的订单</span><br><span class=\"line\">db.user.update(&#123;&quot;userId&quot;:&quot;user9&quot;&#125;,</span><br><span class=\"line\">            &#123;$pull:</span><br><span class=\"line\">                &#123;orderList:&#123;</span><br><span class=\"line\">                    _id:&#123;$in:[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;]&#125;</span><br><span class=\"line\">                &#125;&#125;</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">//保存新数据</span><br><span class=\"line\">db.user.update(</span><br><span class=\"line\">            &#123;&quot;userId&quot;:&quot;user9&quot;&#125;,</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                $push:&#123;orderList:&#123;$each:[&#123;&quot;_id&quot;:&quot;1&quot;&#125;,&#123;&quot;_id&quot;:&quot;2&quot;&#125;,&#123;&quot;_id&quot;:&quot;3&quot;&#125;]&#125;&#125;,</span><br><span class=\"line\">                &quot;$set&quot;:&#123;</span><br><span class=\"line\">                    &quot;userId&quot;:&quot;user9&quot;,</span><br><span class=\"line\">                    &quot;userType&quot;:&quot;C&quot;,</span><br><span class=\"line\">                    &quot;userName&quot;:&quot;name&quot;&#125;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            &#123;&quot;upsert&quot;:true&#125;</span><br><span class=\"line\">        )</span><br></pre></td></tr></table></figure></p>\n<p><strong>注意问题</strong><br>mongoDB不允许在更新时对某个属性执行多个操作，所以对orderList的pull和push操作只能分开执行</p>\n<h3 id=\"订单查询和分页接口\"><a href=\"#订单查询和分页接口\" class=\"headerlink\" title=\"订单查询和分页接口\"></a>订单查询和分页接口</h3><p><strong>接口描述：</strong>查询指定用户，某个时间前的订单列表，支持分页，以时间倒序，返回结果包含订单和用户信息</p>\n<p>实现方式有两种，一个是用聚合查询，支持灵活的查询方式，不过耗时长，或者用slice对订单数组分页，不过不能按时间过滤订单且订单要先倒序保存好，耗时短；<br>用聚合查询，mongo命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.user.aggregate([</span><br><span class=\"line\">      &#123;&quot;$match&quot; : &#123; &quot;userId&quot; : &quot;u1&quot;, &quot;userType&quot; : &quot;TYPE&quot; &#125;&#125;,</span><br><span class=\"line\">      //把orderList打散为独立文档，方便后续查询，排序</span><br><span class=\"line\">      &#123; &quot;$unwind&quot; : &quot;$orderList&quot; &#125;,</span><br><span class=\"line\">      //按时间过滤</span><br><span class=\"line\">      &#123; &quot;$match&quot; : &#123; &quot;orderList.createTime&quot; : &#123; &quot;$lte&quot; :  1545030349990&#125;&#125;&#125;,</span><br><span class=\"line\">      //时间倒序</span><br><span class=\"line\">      &#123; &quot;$sort&quot; : &#123; &quot;orderList.createTime&quot; : -1 &#125; &#125;,</span><br><span class=\"line\">      //分页大小</span><br><span class=\"line\">      &#123;&quot;$limit&quot; : 100&#125;,</span><br><span class=\"line\">      //用group还原，如果只返回订单列表则不用这步</span><br><span class=\"line\">      //$last操作符选择返回的用户属性，$push操作符恢复打散的orderList</span><br><span class=\"line\">      &#123; &quot;$group&quot; : &#123;</span><br><span class=\"line\">      &quot;_id&quot; : &quot;$_id&quot;,</span><br><span class=\"line\">      &quot;userType&quot; : &#123; &quot;$last&quot; : &quot;$userType&quot; &#125;,</span><br><span class=\"line\">      &quot;userId&quot; : &#123; &quot;$last&quot; : &quot;$userId&quot; &#125;,</span><br><span class=\"line\">      &quot;name&quot; : &#123; &quot;$last&quot; : &quot;$name&quot; &#125;,</span><br><span class=\"line\">      &quot;orderList&quot; : &#123; &quot;$push&quot; : &quot;$orderList&quot; &#125;</span><br><span class=\"line\">      &#125;&#125;</span><br><span class=\"line\">      ])</span><br></pre></td></tr></table></figure></p>\n<p>用slice命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//跳过20条，返回10条</span><br><span class=\"line\">db.user.find(&#123;userId:&quot;u1&quot;&#125;,&#123;orderList:&#123;$slice:[20,10]&#125;&#125;).pretty()</span><br></pre></td></tr></table></figure></p>\n<p><strong>注意问题</strong><br>聚合查询最后的为什么group：<br>这是执行unwind后的用户文档,原本一个文档安装orderList数组的数量被分成多个文档，用户的信息也被分散，所以最后需要group重新组合：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; &quot;_id&quot; : ObjectId(&quot;5c209db62a14a9019787860b&quot;), &quot;userId&quot; : &quot;u1&quot;, &quot;userType&quot; : &quot;TYPE&quot;, &quot;name&quot; : &quot;user1545641398911&quot;, &quot;orderList&quot; : &#123; &quot;_id&quot; : &quot;order18&quot;, &quot;info&quot; : &quot;Info:order181545641398918&quot;, &quot;createTime&quot; : NumberLong(&quot;1545641398918&quot;) &#125;, &quot;_class&quot; : &quot;com.throwsnew.springbootstudy.accessdata.mongo.model.User&quot; &#125;</span><br><span class=\"line\">&#123; &quot;_id&quot; : ObjectId(&quot;5c209db62a14a9019787860b&quot;), &quot;userId&quot; : &quot;u1&quot;, &quot;userType&quot; : &quot;TYPE&quot;, &quot;name&quot; : &quot;user1545641398911&quot;, &quot;orderList&quot; : &#123; &quot;_id&quot; : &quot;order19&quot;, &quot;info&quot; : &quot;Info:order191545641398919&quot;, &quot;createTime&quot; : NumberLong(&quot;1545641398919&quot;) &#125;, &quot;_class&quot; : &quot;com.throwsnew.springbootstudy.accessdata.mongo.model.User&quot; &#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"使用spring-data实现接口\"><a href=\"#使用spring-data实现接口\" class=\"headerlink\" title=\"使用spring-data实现接口\"></a>使用spring-data实现接口</h3><p>个人感觉mongo这种json风格的命令并不是很好用，当嵌套多层时简直要晃瞎眼，而且在spring-data-mongodb的java驱动实现时使用的又是命令式的风格，所以即使熟悉了mongo命令也不能很快写出对应的java代码：</p>\n<h4 id=\"更新接口实现\"><a href=\"#更新接口实现\" class=\"headerlink\" title=\"更新接口实现\"></a>更新接口实现</h4><p>借助spring-data-mongodb 中的Update、PushOperatorBuilder类实现<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">        List&lt;String&gt; ids = orderList.stream().map(Order::getId).collect(Collectors.toList());</span><br><span class=\"line\">        Query query = new Query();</span><br><span class=\"line\">        query.addCriteria(Criteria.where(&quot;userId&quot;).is(userId));</span><br><span class=\"line\">        query.addCriteria(Criteria.where(&quot;userType&quot;).is(userType));</span><br><span class=\"line\">        Update updateOld = new Update();</span><br><span class=\"line\">        updateOld.pull(&quot;orderList&quot;, Query.query(Criteria.where(&quot;_id&quot;).in(</span><br><span class=\"line\">                ids)));</span><br><span class=\"line\">        UpdateResult pullResult = mongoTemplate.updateFirst(query, updateOld, User.class);</span><br><span class=\"line\">        </span><br><span class=\"line\">        Update updateNew = new Update();</span><br><span class=\"line\">        PushOperatorBuilder push = updateNew.push(&quot;orderList&quot;);</span><br><span class=\"line\">        push.each(orderList);</span><br><span class=\"line\">        //push使用sort会让执行时间加倍</span><br><span class=\"line\">//        push.sort(new Sort(Direction.DESC, &quot;createTime&quot;));</span><br><span class=\"line\">        updateNew.set(&quot;userId&quot;, userId);</span><br><span class=\"line\">        updateNew.set(&quot;userType&quot;, userType);</span><br><span class=\"line\">        updateNew.set(&quot;userName&quot;, &quot;name&quot;);</span><br><span class=\"line\">        UpdateResult pushResult = mongoTemplate</span><br><span class=\"line\">                .upsert(query, updateNew, User.class);</span><br><span class=\"line\">                </span><br><span class=\"line\">       Assert.isTrue(pullResult.wasAcknowledged() &amp;&amp; pushResult.wasAcknowledged());</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"查询接口实现\"><a href=\"#查询接口实现\" class=\"headerlink\" title=\"查询接口实现\"></a>查询接口实现</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MatchOperation matchUser = match(Criteria.where(&quot;userId&quot;).is(userId)</span><br><span class=\"line\">        .and(&quot;userType&quot;).is(userType));</span><br><span class=\"line\"></span><br><span class=\"line\">GroupOperation groupOperation = group(&quot;_id&quot;)</span><br><span class=\"line\">        .last(&quot;userType&quot;).as(&quot;userType&quot;)</span><br><span class=\"line\">        .last(&quot;userId&quot;).as(&quot;userId&quot;)</span><br><span class=\"line\">        .last(&quot;name&quot;).as(&quot;name&quot;)</span><br><span class=\"line\">        .push(&quot;orderList&quot;).as(&quot;orderList&quot;);</span><br><span class=\"line\">MatchOperation matchCreateTime;</span><br><span class=\"line\">if (maxCreateTime == 0L) &#123;</span><br><span class=\"line\">    matchCreateTime = match(Criteria.where(&quot;orderList.createTime&quot;).gt(0L));</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">    matchCreateTime = match(Criteria.where(&quot;orderList.createTime&quot;).lte(maxCreateTime));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Aggregation aggregation = Aggregation.newAggregation(</span><br><span class=\"line\">        matchUser,</span><br><span class=\"line\">        unwind(&quot;orderList&quot;),</span><br><span class=\"line\">        matchCreateTime,</span><br><span class=\"line\">        sort(Direction.DESC, &quot;orderList.createTime&quot;),</span><br><span class=\"line\">        limit(size),</span><br><span class=\"line\">        groupOperation</span><br><span class=\"line\">);</span><br><span class=\"line\">AggregationResults&lt;User&gt; users = mongoTemplate</span><br><span class=\"line\">        .aggregate(aggregation, User.class, User.class);</span><br><span class=\"line\">if (CollectionUtils.isEmpty(users.getMappedResults())) &#123;</span><br><span class=\"line\">    return null;</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">    return users.getMappedResults().get(0);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"性能测试\"><a href=\"#性能测试\" class=\"headerlink\" title=\"性能测试\"></a>性能测试</h3><p>用jmh框架对查询和更新两个接口做性能测试，mongoDB实例安装在本地，以副本集方式运行，测试数据量为5000用户 每个用户10000订单，本机配置16GB内存，8核CPU。<a href=\"https://github.com/xianfengsong/someDemo/tree/master/spring-boot-study\" target=\"_blank\" rel=\"noopener\">测试用例源码地址</a></p>\n<p>这里的测试数据只能说明在指定数据量下接口的表现，随着数据量变化接口表现也不同。<br><code>关于jmh输出，以updateByPush为例，说明99.9%的请求耗时分布在50.013-6.460到50.013+6.460之间，cnt表示执行次数</code></p>\n<h4 id=\"更新接口测试\"><a href=\"#更新接口测试\" class=\"headerlink\" title=\"更新接口测试\"></a>更新接口测试</h4><p>测试结果表明，在这个实例中通过push/pull更新（不排序）比替换整个文档更新耗时减少25ms（平均值），如果更新时排序则和替换文档耗时相近。</p>\n<p>通过push/pull更新(push时排序)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Result &quot;updateByPush&quot;:</span><br><span class=\"line\">  50.013 ±(99.9%) 6.460 ms/op [Average]</span><br><span class=\"line\">  (min, avg, max) = (45.299, 50.013, 59.592), stdev = 4.273</span><br><span class=\"line\">  CI (99.9%): [43.553, 56.473] (assumes normal distribution)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># Run complete. Total time: 00:00:14</span><br><span class=\"line\"></span><br><span class=\"line\">Benchmark                  Mode  Cnt   Score   Error  Units</span><br><span class=\"line\">JmhBenchmark.updateByPush  avgt   10  50.013 ± 6.460  ms/op</span><br></pre></td></tr></table></figure></p>\n<p>通过pull/push更新（push时不排序）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Result &quot;updateByPush&quot;:</span><br><span class=\"line\">  25.034 ±(99.9%) 22.153 ms/op [Average]</span><br><span class=\"line\">  (min, avg, max) = (16.419, 25.034, 61.959), stdev = 14.653</span><br><span class=\"line\">  CI (99.9%): [2.880, 47.187] (assumes normal distribution)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># Run complete. Total time: 00:00:15</span><br><span class=\"line\"></span><br><span class=\"line\">Benchmark                  Mode  Cnt   Score    Error  Units</span><br><span class=\"line\">JmhBenchmark.updateByPush  avgt   10  25.034 ± 22.153  ms/op</span><br></pre></td></tr></table></figure></p>\n<p>通过替换整个文档更新<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Result &quot;updateByReplace&quot;:</span><br><span class=\"line\">  45.985 ±(99.9%) 17.885 ms/op [Average]</span><br><span class=\"line\">  (min, avg, max) = (41.466, 45.985, 79.604), stdev = 11.830</span><br><span class=\"line\">  CI (99.9%): [28.100, 63.869] (assumes normal distribution)</span><br><span class=\"line\"></span><br><span class=\"line\">Benchmark                     Mode  Cnt   Score    Error  Units</span><br><span class=\"line\">JmhBenchmark.updateByReplace  avgt   10  45.985 ± 17.885  ms/op</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"查询接口测试\"><a href=\"#查询接口测试\" class=\"headerlink\" title=\"查询接口测试\"></a>查询接口测试</h4><p>分别测试了slice查询，和聚合查询排序，聚合查询不排序三种。其中slice查询不代表实际的耗时，因为它不能实现按时间查询的功能。对于聚合查询，如果更新时排序则不需要再次排序。</p>\n<p>slice查询分页(不能设置分页查询条件，不能排序)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Result &quot;findBySlice&quot;:</span><br><span class=\"line\">  1.531 ±(99.9%) 0.128 ms/op [Average]</span><br><span class=\"line\">  (min, avg, max) = (1.437, 1.531, 1.669), stdev = 0.085</span><br><span class=\"line\">  CI (99.9%): [1.404, 1.659] (assumes normal distribution)</span><br><span class=\"line\"></span><br><span class=\"line\">Benchmark                 Mode  Cnt  Score   Error  Units</span><br><span class=\"line\">JmhBenchmark.findBySlice  avgt   10  1.531 ± 0.128  ms/op</span><br></pre></td></tr></table></figure></p>\n<p>aggregation查询分页(按时间查询并分页)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Result &quot;findByAggregation&quot;:</span><br><span class=\"line\">  7.612 ±(99.9%) 0.747 ms/op [Average]</span><br><span class=\"line\">  (min, avg, max) = (6.986, 7.612, 8.697), stdev = 0.494</span><br><span class=\"line\">  CI (99.9%): [6.865, 8.359] (assumes normal distribution)</span><br><span class=\"line\"></span><br><span class=\"line\">Benchmark                       Mode  Cnt  Score   Error  Units</span><br><span class=\"line\">JmhBenchmark.findByAggregation  avgt   10  7.612 ± 0.747  ms/op</span><br></pre></td></tr></table></figure></p>\n<p>aggregation查询分页(按时间查询并分页，添加了sort操作)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Result &quot;findByAggregation&quot;:</span><br><span class=\"line\">  15.609 ±(99.9%) 0.795 ms/op [Average]</span><br><span class=\"line\">  (min, avg, max) = (14.731, 15.609, 16.237), stdev = 0.526</span><br><span class=\"line\">  CI (99.9%): [14.814, 16.404] (assumes normal distribution)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Benchmark                       Mode  Cnt   Score   Error  Units</span><br><span class=\"line\">JmhBenchmark.findByAggregation  avgt   10  15.609 ± 0.795  ms/op</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"创建索引\"><a href=\"#创建索引\" class=\"headerlink\" title=\"创建索引\"></a>创建索引</h3><p>创建索引可以优化查询速度，在创建索引后再次对查询和更新接口做性能测试，在本例中创建索引后并没有明显的提升，<br>而且<strong>在嵌套文档上创建的索引在聚合查询中并没有用到，在聚合查询中只包含match和sort时才能使用索引，在unwind之前match或sort(orderList.createTime)会命中索引，但unwind执行后无法使用</strong></p>\n<blockquote>\n<p>来自mongo权威指南的描述：管道如果不是直接从原先的集合中使用数据，那就无法在筛选和排序中使用索引。</p>\n</blockquote>\n<h4 id=\"对父文档创建索引\"><a href=\"#对父文档创建索引\" class=\"headerlink\" title=\"对父文档创建索引\"></a>对父文档创建索引</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.user.createIndex(&#123;userId:1&#125;,&#123;unique:true&#125;)</span><br></pre></td></tr></table></figure>\n<p>创建索引会加速对用户的查询，但是也会增加写数据时的操作；在测试中添加索引后查询时间略有减少，<br>更新操作耗时也减少了(因为没有更新被索引字段)。</p>\n<p>加索引后聚合查询时间(执行sort)，pull/push时间（不sort)和通过替换更新的时间：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Benchmark                       Mode  Cnt   Score   Error  Units</span><br><span class=\"line\">JmhBenchmark.findByAggregation  avgt   10  12.829 ± 0.592  ms/op</span><br><span class=\"line\">JmhBenchmark.updateByPush       avgt   10  17.962 ± 4.572  ms/op</span><br><span class=\"line\">JmhBenchmark.updateByReplace    avgt   10  41.691 ± 2.140  ms/op</span><br></pre></td></tr></table></figure>\n<h4 id=\"对子文档创建索引\"><a href=\"#对子文档创建索引\" class=\"headerlink\" title=\"对子文档创建索引\"></a>对子文档创建索引</h4><p>去掉父文档上的索引，在嵌套的文档上创建一个createTime字段的索引</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.user.createIndex(&#123;&quot;orderList.createTime&quot;:1&#125;)</span><br><span class=\"line\">db.user.getIndexes()</span><br></pre></td></tr></table></figure>\n<p>再执行测试结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Benchmark                       Mode  Cnt    Score     Error  Units</span><br><span class=\"line\">JmhBenchmark.findByAggregation  avgt   10  15.866 ± 0.863  ms/op</span><br><span class=\"line\">JmhBenchmark.updateByPush       avgt   10  172.905 ± 121.534  ms/op</span><br><span class=\"line\">JmhBenchmark.updateByReplace    avgt   10  127.146 ± 84.696  ms/op</span><br></pre></td></tr></table></figure></p>\n<p>实际上在查询时索引并没有被使用(COLLSCAN)，反而更新子文档的耗时因为要更新索引大大增加；<br>对聚合查询执行explain的输出也说明没有用到createTime索引：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;$cursor&quot; : &#123;</span><br><span class=\"line\">\t&quot;query&quot; : &#123;</span><br><span class=\"line\">\t\t&quot;userId&quot; : &quot;u666&quot;,</span><br><span class=\"line\">\t\t&quot;userType&quot; : &quot;B&quot;</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\t&quot;queryPlanner&quot; : &#123;</span><br><span class=\"line\">\t\t&quot;plannerVersion&quot; : 1,</span><br><span class=\"line\">\t\t&quot;namespace&quot; : &quot;test.user&quot;,</span><br><span class=\"line\">\t\t&quot;indexFilterSet&quot; : false,</span><br><span class=\"line\">\t\t&quot;parsedQuery&quot; : &#123;</span><br><span class=\"line\">\t\t\t&quot;$and&quot; : [</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\t&quot;userId&quot; : &#123;</span><br><span class=\"line\">\t\t\t\t\t\t&quot;$eq&quot; : &quot;u666&quot;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;,</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\t&quot;userType&quot; : &#123;</span><br><span class=\"line\">\t\t\t\t\t\t&quot;$eq&quot; : &quot;B&quot;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t]</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\t&quot;winningPlan&quot; : &#123;</span><br><span class=\"line\">\t\t\t&quot;stage&quot; : &quot;COLLSCAN&quot;,</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"ttl索引不支持嵌套文档\"><a href=\"#ttl索引不支持嵌套文档\" class=\"headerlink\" title=\"ttl索引不支持嵌套文档\"></a>ttl索引不支持嵌套文档</h4><p>通常让mongo文档自动过期可以通过ttl索引实现，但是ttl索引在嵌套文档上无效，只能让父文档过期。<br>在createTime上设置ttl索引，不会执行过期操作<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.user.createIndex( &#123; &quot;orderList.createTime&quot;: 1 &#125;, &#123; expireAfterSeconds: 0 &#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>使用mongoDB保存嵌套文档时，在被嵌套文档上的CRUD操作会变得相对更复杂，查询一般要通过聚合来实现，带来的好处是mongodb可以保证对一个文档的操作是原子性的，如果分散到多个文档保存需要mongoDB的事务支持(升级到v4.0)。<br>如果嵌套文档数组元素数量较多，还要注意最后单个文档大小不能超过16MB的限制。<br>TTL索引和嵌套文档上创建的索引不能保证一定有效，需要手动验证。<br>当嵌套文档较小时可以直接使用替换的方式更新，查询操作也可以直接返回整个文档，设计上避免了文档相互引用带来的复杂度。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"场景介绍\"><a href=\"#场景介绍\" class=\"headerlink\" title=\"场景介绍\"></a>场景介绍</h3><p>在使用mongoDB保存数据时，不需要再严格遵守数据库范式，比如在设计用户订单存储时，我们可以把用户和订单的信息保存在同一个文档当中，用嵌套的方式代替用户表引用订单表的方式。本文以一个用户-订单的实例来介绍使用mongoDB嵌套保存数据时如何结合spring mongo data 实现基本功能，并对不同方案做了性能对比。</p>\n<p>在用户-订单的例子中，订单作为数嵌套保存在用户信息中，对外提供了更新和分页查询订单的功能，查询返回的订单以时间倒序，数据格式如下：<br>","more":"<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\t&quot;_id&quot; : ObjectId(&quot;5c209db62a14a9019787860b&quot;),</span><br><span class=\"line\">\t&quot;userId&quot; : &quot;u1&quot;,</span><br><span class=\"line\">\t&quot;userType&quot; : &quot;TYPE&quot;,</span><br><span class=\"line\">\t&quot;name&quot; : &quot;user1545641398911&quot;,</span><br><span class=\"line\">\t&quot;orderList&quot; : [</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t&quot;_id&quot; : &quot;order1&quot;,</span><br><span class=\"line\">\t\t\t&quot;info&quot; : &quot;Info:order01545641398901&quot;,</span><br><span class=\"line\">\t\t\t&quot;createTime&quot; : NumberLong(&quot;1545641398901&quot;)</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t&quot;_id&quot; : &quot;order0&quot;,</span><br><span class=\"line\">\t\t\t&quot;info&quot; : &quot;Info:order11545641398900&quot;,</span><br><span class=\"line\">\t\t\t&quot;createTime&quot; : NumberLong(&quot;1545641398900&quot;)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"更新用户订单接口\"><a href=\"#更新用户订单接口\" class=\"headerlink\" title=\"更新用户订单接口\"></a>更新用户订单接口</h3><p><strong>接口描述：</strong>首先根据userId查找到用户，如果订单_id已存在则替换，否则插入新订单,如果用户不存在则插入新文档；</p>\n<p>我们习惯直接用新数据替换整个文档的内容，不过当用户订单很多时就需要订单数组做局部更新（减少发送数据的大小，<br>可以用pull/push操作符来完成，假设要添加id为1,2,3的订单，mongo命令如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//删除_id相同的订单</span><br><span class=\"line\">db.user.update(&#123;&quot;userId&quot;:&quot;user9&quot;&#125;,</span><br><span class=\"line\">            &#123;$pull:</span><br><span class=\"line\">                &#123;orderList:&#123;</span><br><span class=\"line\">                    _id:&#123;$in:[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;]&#125;</span><br><span class=\"line\">                &#125;&#125;</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">//保存新数据</span><br><span class=\"line\">db.user.update(</span><br><span class=\"line\">            &#123;&quot;userId&quot;:&quot;user9&quot;&#125;,</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                $push:&#123;orderList:&#123;$each:[&#123;&quot;_id&quot;:&quot;1&quot;&#125;,&#123;&quot;_id&quot;:&quot;2&quot;&#125;,&#123;&quot;_id&quot;:&quot;3&quot;&#125;]&#125;&#125;,</span><br><span class=\"line\">                &quot;$set&quot;:&#123;</span><br><span class=\"line\">                    &quot;userId&quot;:&quot;user9&quot;,</span><br><span class=\"line\">                    &quot;userType&quot;:&quot;C&quot;,</span><br><span class=\"line\">                    &quot;userName&quot;:&quot;name&quot;&#125;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            &#123;&quot;upsert&quot;:true&#125;</span><br><span class=\"line\">        )</span><br></pre></td></tr></table></figure></p>\n<p><strong>注意问题</strong><br>mongoDB不允许在更新时对某个属性执行多个操作，所以对orderList的pull和push操作只能分开执行</p>\n<h3 id=\"订单查询和分页接口\"><a href=\"#订单查询和分页接口\" class=\"headerlink\" title=\"订单查询和分页接口\"></a>订单查询和分页接口</h3><p><strong>接口描述：</strong>查询指定用户，某个时间前的订单列表，支持分页，以时间倒序，返回结果包含订单和用户信息</p>\n<p>实现方式有两种，一个是用聚合查询，支持灵活的查询方式，不过耗时长，或者用slice对订单数组分页，不过不能按时间过滤订单且订单要先倒序保存好，耗时短；<br>用聚合查询，mongo命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.user.aggregate([</span><br><span class=\"line\">      &#123;&quot;$match&quot; : &#123; &quot;userId&quot; : &quot;u1&quot;, &quot;userType&quot; : &quot;TYPE&quot; &#125;&#125;,</span><br><span class=\"line\">      //把orderList打散为独立文档，方便后续查询，排序</span><br><span class=\"line\">      &#123; &quot;$unwind&quot; : &quot;$orderList&quot; &#125;,</span><br><span class=\"line\">      //按时间过滤</span><br><span class=\"line\">      &#123; &quot;$match&quot; : &#123; &quot;orderList.createTime&quot; : &#123; &quot;$lte&quot; :  1545030349990&#125;&#125;&#125;,</span><br><span class=\"line\">      //时间倒序</span><br><span class=\"line\">      &#123; &quot;$sort&quot; : &#123; &quot;orderList.createTime&quot; : -1 &#125; &#125;,</span><br><span class=\"line\">      //分页大小</span><br><span class=\"line\">      &#123;&quot;$limit&quot; : 100&#125;,</span><br><span class=\"line\">      //用group还原，如果只返回订单列表则不用这步</span><br><span class=\"line\">      //$last操作符选择返回的用户属性，$push操作符恢复打散的orderList</span><br><span class=\"line\">      &#123; &quot;$group&quot; : &#123;</span><br><span class=\"line\">      &quot;_id&quot; : &quot;$_id&quot;,</span><br><span class=\"line\">      &quot;userType&quot; : &#123; &quot;$last&quot; : &quot;$userType&quot; &#125;,</span><br><span class=\"line\">      &quot;userId&quot; : &#123; &quot;$last&quot; : &quot;$userId&quot; &#125;,</span><br><span class=\"line\">      &quot;name&quot; : &#123; &quot;$last&quot; : &quot;$name&quot; &#125;,</span><br><span class=\"line\">      &quot;orderList&quot; : &#123; &quot;$push&quot; : &quot;$orderList&quot; &#125;</span><br><span class=\"line\">      &#125;&#125;</span><br><span class=\"line\">      ])</span><br></pre></td></tr></table></figure></p>\n<p>用slice命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//跳过20条，返回10条</span><br><span class=\"line\">db.user.find(&#123;userId:&quot;u1&quot;&#125;,&#123;orderList:&#123;$slice:[20,10]&#125;&#125;).pretty()</span><br></pre></td></tr></table></figure></p>\n<p><strong>注意问题</strong><br>聚合查询最后的为什么group：<br>这是执行unwind后的用户文档,原本一个文档安装orderList数组的数量被分成多个文档，用户的信息也被分散，所以最后需要group重新组合：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; &quot;_id&quot; : ObjectId(&quot;5c209db62a14a9019787860b&quot;), &quot;userId&quot; : &quot;u1&quot;, &quot;userType&quot; : &quot;TYPE&quot;, &quot;name&quot; : &quot;user1545641398911&quot;, &quot;orderList&quot; : &#123; &quot;_id&quot; : &quot;order18&quot;, &quot;info&quot; : &quot;Info:order181545641398918&quot;, &quot;createTime&quot; : NumberLong(&quot;1545641398918&quot;) &#125;, &quot;_class&quot; : &quot;com.throwsnew.springbootstudy.accessdata.mongo.model.User&quot; &#125;</span><br><span class=\"line\">&#123; &quot;_id&quot; : ObjectId(&quot;5c209db62a14a9019787860b&quot;), &quot;userId&quot; : &quot;u1&quot;, &quot;userType&quot; : &quot;TYPE&quot;, &quot;name&quot; : &quot;user1545641398911&quot;, &quot;orderList&quot; : &#123; &quot;_id&quot; : &quot;order19&quot;, &quot;info&quot; : &quot;Info:order191545641398919&quot;, &quot;createTime&quot; : NumberLong(&quot;1545641398919&quot;) &#125;, &quot;_class&quot; : &quot;com.throwsnew.springbootstudy.accessdata.mongo.model.User&quot; &#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"使用spring-data实现接口\"><a href=\"#使用spring-data实现接口\" class=\"headerlink\" title=\"使用spring-data实现接口\"></a>使用spring-data实现接口</h3><p>个人感觉mongo这种json风格的命令并不是很好用，当嵌套多层时简直要晃瞎眼，而且在spring-data-mongodb的java驱动实现时使用的又是命令式的风格，所以即使熟悉了mongo命令也不能很快写出对应的java代码：</p>\n<h4 id=\"更新接口实现\"><a href=\"#更新接口实现\" class=\"headerlink\" title=\"更新接口实现\"></a>更新接口实现</h4><p>借助spring-data-mongodb 中的Update、PushOperatorBuilder类实现<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">        List&lt;String&gt; ids = orderList.stream().map(Order::getId).collect(Collectors.toList());</span><br><span class=\"line\">        Query query = new Query();</span><br><span class=\"line\">        query.addCriteria(Criteria.where(&quot;userId&quot;).is(userId));</span><br><span class=\"line\">        query.addCriteria(Criteria.where(&quot;userType&quot;).is(userType));</span><br><span class=\"line\">        Update updateOld = new Update();</span><br><span class=\"line\">        updateOld.pull(&quot;orderList&quot;, Query.query(Criteria.where(&quot;_id&quot;).in(</span><br><span class=\"line\">                ids)));</span><br><span class=\"line\">        UpdateResult pullResult = mongoTemplate.updateFirst(query, updateOld, User.class);</span><br><span class=\"line\">        </span><br><span class=\"line\">        Update updateNew = new Update();</span><br><span class=\"line\">        PushOperatorBuilder push = updateNew.push(&quot;orderList&quot;);</span><br><span class=\"line\">        push.each(orderList);</span><br><span class=\"line\">        //push使用sort会让执行时间加倍</span><br><span class=\"line\">//        push.sort(new Sort(Direction.DESC, &quot;createTime&quot;));</span><br><span class=\"line\">        updateNew.set(&quot;userId&quot;, userId);</span><br><span class=\"line\">        updateNew.set(&quot;userType&quot;, userType);</span><br><span class=\"line\">        updateNew.set(&quot;userName&quot;, &quot;name&quot;);</span><br><span class=\"line\">        UpdateResult pushResult = mongoTemplate</span><br><span class=\"line\">                .upsert(query, updateNew, User.class);</span><br><span class=\"line\">                </span><br><span class=\"line\">       Assert.isTrue(pullResult.wasAcknowledged() &amp;&amp; pushResult.wasAcknowledged());</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"查询接口实现\"><a href=\"#查询接口实现\" class=\"headerlink\" title=\"查询接口实现\"></a>查询接口实现</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MatchOperation matchUser = match(Criteria.where(&quot;userId&quot;).is(userId)</span><br><span class=\"line\">        .and(&quot;userType&quot;).is(userType));</span><br><span class=\"line\"></span><br><span class=\"line\">GroupOperation groupOperation = group(&quot;_id&quot;)</span><br><span class=\"line\">        .last(&quot;userType&quot;).as(&quot;userType&quot;)</span><br><span class=\"line\">        .last(&quot;userId&quot;).as(&quot;userId&quot;)</span><br><span class=\"line\">        .last(&quot;name&quot;).as(&quot;name&quot;)</span><br><span class=\"line\">        .push(&quot;orderList&quot;).as(&quot;orderList&quot;);</span><br><span class=\"line\">MatchOperation matchCreateTime;</span><br><span class=\"line\">if (maxCreateTime == 0L) &#123;</span><br><span class=\"line\">    matchCreateTime = match(Criteria.where(&quot;orderList.createTime&quot;).gt(0L));</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">    matchCreateTime = match(Criteria.where(&quot;orderList.createTime&quot;).lte(maxCreateTime));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Aggregation aggregation = Aggregation.newAggregation(</span><br><span class=\"line\">        matchUser,</span><br><span class=\"line\">        unwind(&quot;orderList&quot;),</span><br><span class=\"line\">        matchCreateTime,</span><br><span class=\"line\">        sort(Direction.DESC, &quot;orderList.createTime&quot;),</span><br><span class=\"line\">        limit(size),</span><br><span class=\"line\">        groupOperation</span><br><span class=\"line\">);</span><br><span class=\"line\">AggregationResults&lt;User&gt; users = mongoTemplate</span><br><span class=\"line\">        .aggregate(aggregation, User.class, User.class);</span><br><span class=\"line\">if (CollectionUtils.isEmpty(users.getMappedResults())) &#123;</span><br><span class=\"line\">    return null;</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">    return users.getMappedResults().get(0);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"性能测试\"><a href=\"#性能测试\" class=\"headerlink\" title=\"性能测试\"></a>性能测试</h3><p>用jmh框架对查询和更新两个接口做性能测试，mongoDB实例安装在本地，以副本集方式运行，测试数据量为5000用户 每个用户10000订单，本机配置16GB内存，8核CPU。<a href=\"https://github.com/xianfengsong/someDemo/tree/master/spring-boot-study\" target=\"_blank\" rel=\"noopener\">测试用例源码地址</a></p>\n<p>这里的测试数据只能说明在指定数据量下接口的表现，随着数据量变化接口表现也不同。<br><code>关于jmh输出，以updateByPush为例，说明99.9%的请求耗时分布在50.013-6.460到50.013+6.460之间，cnt表示执行次数</code></p>\n<h4 id=\"更新接口测试\"><a href=\"#更新接口测试\" class=\"headerlink\" title=\"更新接口测试\"></a>更新接口测试</h4><p>测试结果表明，在这个实例中通过push/pull更新（不排序）比替换整个文档更新耗时减少25ms（平均值），如果更新时排序则和替换文档耗时相近。</p>\n<p>通过push/pull更新(push时排序)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Result &quot;updateByPush&quot;:</span><br><span class=\"line\">  50.013 ±(99.9%) 6.460 ms/op [Average]</span><br><span class=\"line\">  (min, avg, max) = (45.299, 50.013, 59.592), stdev = 4.273</span><br><span class=\"line\">  CI (99.9%): [43.553, 56.473] (assumes normal distribution)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># Run complete. Total time: 00:00:14</span><br><span class=\"line\"></span><br><span class=\"line\">Benchmark                  Mode  Cnt   Score   Error  Units</span><br><span class=\"line\">JmhBenchmark.updateByPush  avgt   10  50.013 ± 6.460  ms/op</span><br></pre></td></tr></table></figure></p>\n<p>通过pull/push更新（push时不排序）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Result &quot;updateByPush&quot;:</span><br><span class=\"line\">  25.034 ±(99.9%) 22.153 ms/op [Average]</span><br><span class=\"line\">  (min, avg, max) = (16.419, 25.034, 61.959), stdev = 14.653</span><br><span class=\"line\">  CI (99.9%): [2.880, 47.187] (assumes normal distribution)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># Run complete. Total time: 00:00:15</span><br><span class=\"line\"></span><br><span class=\"line\">Benchmark                  Mode  Cnt   Score    Error  Units</span><br><span class=\"line\">JmhBenchmark.updateByPush  avgt   10  25.034 ± 22.153  ms/op</span><br></pre></td></tr></table></figure></p>\n<p>通过替换整个文档更新<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Result &quot;updateByReplace&quot;:</span><br><span class=\"line\">  45.985 ±(99.9%) 17.885 ms/op [Average]</span><br><span class=\"line\">  (min, avg, max) = (41.466, 45.985, 79.604), stdev = 11.830</span><br><span class=\"line\">  CI (99.9%): [28.100, 63.869] (assumes normal distribution)</span><br><span class=\"line\"></span><br><span class=\"line\">Benchmark                     Mode  Cnt   Score    Error  Units</span><br><span class=\"line\">JmhBenchmark.updateByReplace  avgt   10  45.985 ± 17.885  ms/op</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"查询接口测试\"><a href=\"#查询接口测试\" class=\"headerlink\" title=\"查询接口测试\"></a>查询接口测试</h4><p>分别测试了slice查询，和聚合查询排序，聚合查询不排序三种。其中slice查询不代表实际的耗时，因为它不能实现按时间查询的功能。对于聚合查询，如果更新时排序则不需要再次排序。</p>\n<p>slice查询分页(不能设置分页查询条件，不能排序)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Result &quot;findBySlice&quot;:</span><br><span class=\"line\">  1.531 ±(99.9%) 0.128 ms/op [Average]</span><br><span class=\"line\">  (min, avg, max) = (1.437, 1.531, 1.669), stdev = 0.085</span><br><span class=\"line\">  CI (99.9%): [1.404, 1.659] (assumes normal distribution)</span><br><span class=\"line\"></span><br><span class=\"line\">Benchmark                 Mode  Cnt  Score   Error  Units</span><br><span class=\"line\">JmhBenchmark.findBySlice  avgt   10  1.531 ± 0.128  ms/op</span><br></pre></td></tr></table></figure></p>\n<p>aggregation查询分页(按时间查询并分页)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Result &quot;findByAggregation&quot;:</span><br><span class=\"line\">  7.612 ±(99.9%) 0.747 ms/op [Average]</span><br><span class=\"line\">  (min, avg, max) = (6.986, 7.612, 8.697), stdev = 0.494</span><br><span class=\"line\">  CI (99.9%): [6.865, 8.359] (assumes normal distribution)</span><br><span class=\"line\"></span><br><span class=\"line\">Benchmark                       Mode  Cnt  Score   Error  Units</span><br><span class=\"line\">JmhBenchmark.findByAggregation  avgt   10  7.612 ± 0.747  ms/op</span><br></pre></td></tr></table></figure></p>\n<p>aggregation查询分页(按时间查询并分页，添加了sort操作)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Result &quot;findByAggregation&quot;:</span><br><span class=\"line\">  15.609 ±(99.9%) 0.795 ms/op [Average]</span><br><span class=\"line\">  (min, avg, max) = (14.731, 15.609, 16.237), stdev = 0.526</span><br><span class=\"line\">  CI (99.9%): [14.814, 16.404] (assumes normal distribution)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Benchmark                       Mode  Cnt   Score   Error  Units</span><br><span class=\"line\">JmhBenchmark.findByAggregation  avgt   10  15.609 ± 0.795  ms/op</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"创建索引\"><a href=\"#创建索引\" class=\"headerlink\" title=\"创建索引\"></a>创建索引</h3><p>创建索引可以优化查询速度，在创建索引后再次对查询和更新接口做性能测试，在本例中创建索引后并没有明显的提升，<br>而且<strong>在嵌套文档上创建的索引在聚合查询中并没有用到，在聚合查询中只包含match和sort时才能使用索引，在unwind之前match或sort(orderList.createTime)会命中索引，但unwind执行后无法使用</strong></p>\n<blockquote>\n<p>来自mongo权威指南的描述：管道如果不是直接从原先的集合中使用数据，那就无法在筛选和排序中使用索引。</p>\n</blockquote>\n<h4 id=\"对父文档创建索引\"><a href=\"#对父文档创建索引\" class=\"headerlink\" title=\"对父文档创建索引\"></a>对父文档创建索引</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.user.createIndex(&#123;userId:1&#125;,&#123;unique:true&#125;)</span><br></pre></td></tr></table></figure>\n<p>创建索引会加速对用户的查询，但是也会增加写数据时的操作；在测试中添加索引后查询时间略有减少，<br>更新操作耗时也减少了(因为没有更新被索引字段)。</p>\n<p>加索引后聚合查询时间(执行sort)，pull/push时间（不sort)和通过替换更新的时间：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Benchmark                       Mode  Cnt   Score   Error  Units</span><br><span class=\"line\">JmhBenchmark.findByAggregation  avgt   10  12.829 ± 0.592  ms/op</span><br><span class=\"line\">JmhBenchmark.updateByPush       avgt   10  17.962 ± 4.572  ms/op</span><br><span class=\"line\">JmhBenchmark.updateByReplace    avgt   10  41.691 ± 2.140  ms/op</span><br></pre></td></tr></table></figure>\n<h4 id=\"对子文档创建索引\"><a href=\"#对子文档创建索引\" class=\"headerlink\" title=\"对子文档创建索引\"></a>对子文档创建索引</h4><p>去掉父文档上的索引，在嵌套的文档上创建一个createTime字段的索引</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.user.createIndex(&#123;&quot;orderList.createTime&quot;:1&#125;)</span><br><span class=\"line\">db.user.getIndexes()</span><br></pre></td></tr></table></figure>\n<p>再执行测试结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Benchmark                       Mode  Cnt    Score     Error  Units</span><br><span class=\"line\">JmhBenchmark.findByAggregation  avgt   10  15.866 ± 0.863  ms/op</span><br><span class=\"line\">JmhBenchmark.updateByPush       avgt   10  172.905 ± 121.534  ms/op</span><br><span class=\"line\">JmhBenchmark.updateByReplace    avgt   10  127.146 ± 84.696  ms/op</span><br></pre></td></tr></table></figure></p>\n<p>实际上在查询时索引并没有被使用(COLLSCAN)，反而更新子文档的耗时因为要更新索引大大增加；<br>对聚合查询执行explain的输出也说明没有用到createTime索引：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;$cursor&quot; : &#123;</span><br><span class=\"line\">\t&quot;query&quot; : &#123;</span><br><span class=\"line\">\t\t&quot;userId&quot; : &quot;u666&quot;,</span><br><span class=\"line\">\t\t&quot;userType&quot; : &quot;B&quot;</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\t&quot;queryPlanner&quot; : &#123;</span><br><span class=\"line\">\t\t&quot;plannerVersion&quot; : 1,</span><br><span class=\"line\">\t\t&quot;namespace&quot; : &quot;test.user&quot;,</span><br><span class=\"line\">\t\t&quot;indexFilterSet&quot; : false,</span><br><span class=\"line\">\t\t&quot;parsedQuery&quot; : &#123;</span><br><span class=\"line\">\t\t\t&quot;$and&quot; : [</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\t&quot;userId&quot; : &#123;</span><br><span class=\"line\">\t\t\t\t\t\t&quot;$eq&quot; : &quot;u666&quot;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;,</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\t&quot;userType&quot; : &#123;</span><br><span class=\"line\">\t\t\t\t\t\t&quot;$eq&quot; : &quot;B&quot;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t]</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\t&quot;winningPlan&quot; : &#123;</span><br><span class=\"line\">\t\t\t&quot;stage&quot; : &quot;COLLSCAN&quot;,</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"ttl索引不支持嵌套文档\"><a href=\"#ttl索引不支持嵌套文档\" class=\"headerlink\" title=\"ttl索引不支持嵌套文档\"></a>ttl索引不支持嵌套文档</h4><p>通常让mongo文档自动过期可以通过ttl索引实现，但是ttl索引在嵌套文档上无效，只能让父文档过期。<br>在createTime上设置ttl索引，不会执行过期操作<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.user.createIndex( &#123; &quot;orderList.createTime&quot;: 1 &#125;, &#123; expireAfterSeconds: 0 &#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>使用mongoDB保存嵌套文档时，在被嵌套文档上的CRUD操作会变得相对更复杂，查询一般要通过聚合来实现，带来的好处是mongodb可以保证对一个文档的操作是原子性的，如果分散到多个文档保存需要mongoDB的事务支持(升级到v4.0)。<br>如果嵌套文档数组元素数量较多，还要注意最后单个文档大小不能超过16MB的限制。<br>TTL索引和嵌套文档上创建的索引不能保证一定有效，需要手动验证。<br>当嵌套文档较小时可以直接使用替换的方式更新，查询操作也可以直接返回整个文档，设计上避免了文档相互引用带来的复杂度。</p>"},{"title":"thrift源码（四）非阻塞服务端","date":"2019-10-24T16:12:07.000Z","_content":"\n### 非阻塞服务端TNonblockingServer\nthrift的非阻塞服务端，采用还是类似Reactor的IO复用模型\n\n![reactor uml][4]\n对于TNonblockingServer，使用的是单线程的reactor模式，\n客户端的请求会被公平的处理(没有优先级，看哪个请求先触发selector)，使用TNonblockingServer时必须使用TFramedTransport，不然无法确定数据包何时读取完成(数据边界)。\n<!--more-->\n\n{% asset_img reactor-single.png image %}\n\n#### SelectThread\n\n{% asset_img SelectThread.png image %}\n\nselector工作线程，作用reactor模式中的dispatcher,分离IO事件，触发对应的handler。\nSelectThread的run方法：\n执行完select()，就会检查&更新FrameBuffers上关注的事件：\n```java\npublic void run() {\n      try {\n        while (!stopped_) {\n          select();\n          processInterestChanges();\n        }\n      } catch (Throwable t) {\n        LOGGER.error(\"run() exiting due to uncaught error\", t);\n      } finally {\n        stopped_ = true;\n      }\n    }\n```\nselect方法，根据不同的IO事件，执行对应调用：\n和上面Reactor的图片有点不同，这里没有单独的acceptor，也没有handler,都由SelectThread处理。\n```java\nprivate void select() {\n      try {\n        // wait for io events.\n        selector.select();\n\n        // process the io events we received\n        Iterator<SelectionKey> selectedKeys = selector.selectedKeys().iterator();\n        while (!stopped_ && selectedKeys.hasNext()) {\n          SelectionKey key = selectedKeys.next();\n          selectedKeys.remove();\n\n          // skip if not valid\n          if (!key.isValid()) {\n            cleanupSelectionkey(key);\n            continue;\n          }\n\n          // if the key is marked Accept, then it has to be the server\n          // transport.\n          if (key.isAcceptable()) {\n            handleAccept();\n          } else if (key.isReadable()) {\n            // deal with reads\n            handleRead(key);\n          } else if (key.isWritable()) {\n            // deal with writes\n            handleWrite(key);\n          } else {\n            LOGGER.warn(\"Unexpected state in select! \" + key.interestOps());\n          }\n        }\n      } catch (IOException e) {\n        LOGGER.warn(\"Got an IOException while selecting!\", e);\n      }\n    }\n```\nSelectThread中除了serverTransport和selector还有一个属性selectInterestChanges，用来保存需要改变关注事件的FrameBuffer\n```java\nprivate final TNonblockingServerTransport serverTransport;\nprivate final Selector selector;\n\n// List of FrameBuffers that want to change their selection interests.\nprivate final Set<FrameBuffer> selectInterestChanges =\n      new HashSet<FrameBuffer>();\n```\n为了管理这些FrameBuffer，SelectThread提供两个方法，**processInterestChanges()**函数遍历FrameBuffer触发他们更新关注的IO事件并注册，然后清空集合。\n**requestSelectInterestChange()**函数，允许向集合添加新的需要改变关注事件的FrameBuffer.\n**这俩函数不是同步执行的**，主要是为了多线程版本的服务端使用，同时对selectInterestChanges集合加锁，也是因为TNonblockingServer的子类(THsHaServer)，使用了多线程的reactor模型，在这里不会起作用。\n```java\n\n/**\n    * Check to see if there are any FrameBuffers that have switched their\n    * interest type from read to write or vice versa.\n*/\nprivate void processInterestChanges() {\n      synchronized (selectInterestChanges) {\n        for (FrameBuffer fb : selectInterestChanges) {\n          fb.changeSelectInterests();\n        }\n        selectInterestChanges.clear();\n      }\n    }\n    \n/**\n     * Add FrameBuffer to the list of select interest changes and wake up the\n     * selector if it's blocked. When the select() call exits, it'll give the\n     * FrameBuffer a chance to change its interests.\n     */\npublic void requestSelectInterestChange(FrameBuffer frameBuffer) {\n      synchronized (selectInterestChanges) {\n        selectInterestChanges.add(frameBuffer);\n      }\n      // wakeup the selector, if it's currently blocked.\n      selector.wakeup();\n    }\n```\n#### FrameBuffer\n\n**看名字你会以为这是一个数据缓冲区（类似ByteBuffer），但实际上FrameBuffer做的更多，这就是thrift的神奇命名。。**\n{% asset_img FrameBuffer.png image %}\n\nFrameBuffer内部是一个类似状态机的设计，ta负责数据的读写，修改selector关注事件，发起接口调用，返回结果等操作。服务端IO的具体细节都由它来完成。\nFrameBuffer定义的状态:\n```java\n    // in the midst of reading the frame size off the wire\n    private static final int READING_FRAME_SIZE = 1;\n    // reading the actual frame data now, but not all the way done yet\n    private static final int READING_FRAME = 2;\n    // completely read the frame, so an invocation can now happen\n    private static final int READ_FRAME_COMPLETE = 3;\n    // waiting to get switched to listening for write events\n    private static final int AWAITING_REGISTER_WRITE = 4;\n    // started writing response data, not fully complete yet\n    private static final int WRITING = 6;\n    // another thread wants this framebuffer to go back to reading\n    private static final int AWAITING_REGISTER_READ = 7;\n    // we want our transport and selection key invalidated in the selector thread\n    private static final int AWAITING_CLOSE = 8;\n```\nFrameBuffer状态图：\n{% asset_img FrameBufferState.png image %}\n状态由**READING_FRAME_SIZE**开始(此时bufferSize大小只有4字节)，如果buffer读取完成，变**成READING_FRAME**（此时buffer被初始化为frameSize大小），如果buffer又读取完成，变成\n**READ_FRAME_COMPLETE**状态，这时selectThread会执行requestInvoke()方法:\n```java\nprivate void handleRead(SelectionKey key) {\n...\n// if the buffer's frame read is complete, invoke the method.\n      if (buffer.isFrameFullyRead()) {\n        if (!requestInvoke(buffer)) {\n          cleanupSelectionkey(key);\n        }\n      }\n...\n}\n```\n然后调用FrameBuffer的invoke方法，frameBuffer会调用服务端本地的接口实现类，执行完成后调用responseReady()准备返回调用结果，如果接口实现执行失败，状态由**READ_FRAME_COMPLETE**变成**AWAITING_CLOSE**，随后socket会被关闭。\n```java\npublic void invoke() {\n      TTransport inTrans = getInputTransport();\n      TProtocol inProt = inputProtocolFactory_.getProtocol(inTrans);\n      TProtocol outProt = outputProtocolFactory_.getProtocol(getOutputTransport());\n\n      try {\n        outProt.setServerSide(true);\n        processorFactory_.getProcessor(inTrans).process(inProt, outProt);\n        responseReady();\n        return;\n      } catch (TException te) {\n        LOGGER.warn(\"Exception while invoking!\", te);\n      } catch (Exception e) {\n        LOGGER.error(\"Unexpected exception while invoking!\", e);\n\n      } catch (Throwable t) {\n        LOGGER.error(\"Unexpected throwable while invoking!\", t);\n      }\n      // This will only be reached when there is an exception.\n      state_ = AWAITING_CLOSE;\n      requestSelectInterestChange();\n    }\n```\nresponseReady方法中，状态可能由**READ_FRAME_COMPLETE**变成**AWAITING_REGISTER_READ**(不需要向客户端返回结果)，或者变成**AWAITING_REGISTER_WRITE**（准备发送结果到客户端）：\n```java\npublic void responseReady() {\n      // the read buffer is definitely no longer in use, so we will decrement\n      // our read buffer count. we do this here as well as in close because\n      // we'd like to free this read memory up as quickly as possible for other\n      // clients.\n      readBufferBytesAllocated.addAndGet(-buffer_.array().length);\n\n      if (response_.len() == 0) {\n        // go straight to reading again. this was probably an oneway method\n        state_ = AWAITING_REGISTER_READ;\n        buffer_ = null;\n      } else {\n        buffer_ = ByteBuffer.wrap(response_.get(), 0, response_.len());\n\n        // set state that we're waiting to be switched to write. we do this\n        // asynchronously through requestSelectInterestChange() because there is a\n        // possibility that we're not in the main thread, and thus currently\n        // blocked in select(). (this functionality is in place for the sake of\n        // the HsHa server.)\n        state_ = AWAITING_REGISTER_WRITE;\n      }\n      requestSelectInterestChange();\n    }\n```\n如同注释所说，函数requestSelectInterestChange()告知selectThread_我要改变关注的IO事件然后就返回，是一种异步的方式，然后在函数requestSelectInterestChange中，会检查当前线程，如果就是selectThread_那就直接改变关注的IO事件，否则通过TNonblockingServer调用selectThread_执行：\n```java\nprivate void requestSelectInterestChange() {\n      if (Thread.currentThread() == selectThread_) {\n        changeSelectInterests();\n      } else {\n        TNonblockingServer.this.requestSelectInterestChange(this);\n      }\n    }\n```\n在changeSelectInterests方法中，状态可能由**AWAITING_REGISTER_WRITE**变成**WRITING**，或者由**AWAITING_REGISTER_READ**变成**READING_FRAME_SIZE**，如果是**AWAITING_CLOSE**那么直接关闭连接，取消关注的事件：\n```java\n/**\n     * Give this FrameBuffer a chance to set its interest to write, once data\n     * has come in.\n     */\n    public void changeSelectInterests() {\n      if (state_ == AWAITING_REGISTER_WRITE) {\n        // set the OP_WRITE interest\n        selectionKey_.interestOps(SelectionKey.OP_WRITE);\n        state_ = WRITING;\n      } else if (state_ == AWAITING_REGISTER_READ) {\n        prepareRead();\n      } else if (state_ == AWAITING_CLOSE){\n        close();\n        selectionKey_.cancel();\n      } else {\n        LOGGER.error(\n          \"changeSelectInterest was called, but state is invalid (\"\n          + state_ + \")\");\n      }\n    }\n```\n\n#### 时序图\n非阻塞服务端的初始化代码：\n```java\nTNonblockingServerTransport serverTransport = new TNonblockingServerSocket(7911);\n                HelloService.Processor processor = new HelloService.Processor(new HelloServiceImpl());\n                TServer server = new TNonblockingServer(processor, serverTransport);\n                server.serve();\n```\n时序图包含了异步服务端启动和响应请求的过程(不包括异常)：\n**1,2,3,4** \n执行Server的初始化，和上面的代码一致\n**5,5.1,5.2.1** \n开始准备响应客户端请求，监听端口，创建SelectThread线程并启动\n**5.2.1.1 , 5.2.1.2** SelectThread在构造函数中已经打开selector并注册ACCEPT事件\n**5.2.2.1和灰色部分**\nselector执行select()方法，灰色部分是select()返回的IO事件集合的遍历循环。\n**2.x** 处理accept事件，获得客户端的连接(TNonblockTransport) ，注册READ事件，创建FrameBuffer,准备读取客户端发送的数据。\n**3.x** 处理READ事件，调用服务端的接口实现类\n**4.x** 处理WRITE事件，向客户端发送调用结果\n**5.2.2.2**\n遍历 selectInterestChanges，注册FrameBuffer现在要关注的IO事件。\n**5.3 5.4**\n等待SelectThread退出，停止监听端口，服务结束。\n\n\n{% asset_img serverflow.png image %}\n\n\n  [1]: https://www.ibm.com/developerworks/cn/java/j-lo-apachethrift/image003.jpg\n  [2]: https://www.ibm.com/developerworks/cn/java/j-lo-apachethrift/image006.png\n  [3]: https://www.ibm.com/developerworks/cn/java/j-lo-apachethrift/image004.png\n  [4]: https://www.2cto.com/uploadfile/2012/0816/20120816083811838.jpg\n  [5]: https://upload-images.jianshu.io/upload_images/4235178-4047d3c78bb467c9.png\n  [6]: https://upload-images.jianshu.io/upload_images/3169646-6eddb6e230677349.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/692\n  [7]: http://zhangtielei.com/posts/blog-rxjava-backpressure.html\n  [8]: https://baike.baidu.com/item/%E8%83%8C%E5%8E%8B%E9%98%80\n  [9]: https://github.com/apache/thrift/blob/0.8.x/lib/java/src/org/apache/thrift/server/TThreadedSelectorServer.java\n  [10]: https://upload-images.jianshu.io/upload_images/3169646-eedd2295dcc12725.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/688\n  [11]: https://static.oschina.net/uploads/space/2016/0224/192255_iHyl_1469576.png\n  [12]: https://static.oschina.net/uploads/space/2016/0224/192347_Vfen_1469576.png\n  [13]: https://static.oschina.net/uploads/space/2016/0224/192513_tzOg_1469576.png\n  [14]: https://static.oschina.net/uploads/space/2016/0224/192544_xSFh_1469576.png\n  [15]: https://static.oschina.net/uploads/space/2016/0224/192757_XK9n_1469576.png\n  [16]: https://static.oschina.net/uploads/space/2016/0224/192757_toBx_1469576.png\n  [17]: https://upload.wikimedia.org/wikipedia/commons/thumb/5/54/Big-Endian.svg/200px-Big-Endian.svg.png\n  [18]: https://upload.wikimedia.org/wikipedia/commons/thumb/e/ed/Little-Endian.svg/200px-Little-Endian.svg.png\n  [19]: https://jin-yang.github.io/post/network-tcpip-timewait.html","source":"_posts/thrift源码（四）非阻塞服务端.md","raw":"---\ntitle: thrift源码（四）非阻塞服务端\ndate: 2019-10-25 00:12:07\ncategories: thrift源码\ntags: [thrift,rpc框架]\n---\n\n### 非阻塞服务端TNonblockingServer\nthrift的非阻塞服务端，采用还是类似Reactor的IO复用模型\n\n![reactor uml][4]\n对于TNonblockingServer，使用的是单线程的reactor模式，\n客户端的请求会被公平的处理(没有优先级，看哪个请求先触发selector)，使用TNonblockingServer时必须使用TFramedTransport，不然无法确定数据包何时读取完成(数据边界)。\n<!--more-->\n\n{% asset_img reactor-single.png image %}\n\n#### SelectThread\n\n{% asset_img SelectThread.png image %}\n\nselector工作线程，作用reactor模式中的dispatcher,分离IO事件，触发对应的handler。\nSelectThread的run方法：\n执行完select()，就会检查&更新FrameBuffers上关注的事件：\n```java\npublic void run() {\n      try {\n        while (!stopped_) {\n          select();\n          processInterestChanges();\n        }\n      } catch (Throwable t) {\n        LOGGER.error(\"run() exiting due to uncaught error\", t);\n      } finally {\n        stopped_ = true;\n      }\n    }\n```\nselect方法，根据不同的IO事件，执行对应调用：\n和上面Reactor的图片有点不同，这里没有单独的acceptor，也没有handler,都由SelectThread处理。\n```java\nprivate void select() {\n      try {\n        // wait for io events.\n        selector.select();\n\n        // process the io events we received\n        Iterator<SelectionKey> selectedKeys = selector.selectedKeys().iterator();\n        while (!stopped_ && selectedKeys.hasNext()) {\n          SelectionKey key = selectedKeys.next();\n          selectedKeys.remove();\n\n          // skip if not valid\n          if (!key.isValid()) {\n            cleanupSelectionkey(key);\n            continue;\n          }\n\n          // if the key is marked Accept, then it has to be the server\n          // transport.\n          if (key.isAcceptable()) {\n            handleAccept();\n          } else if (key.isReadable()) {\n            // deal with reads\n            handleRead(key);\n          } else if (key.isWritable()) {\n            // deal with writes\n            handleWrite(key);\n          } else {\n            LOGGER.warn(\"Unexpected state in select! \" + key.interestOps());\n          }\n        }\n      } catch (IOException e) {\n        LOGGER.warn(\"Got an IOException while selecting!\", e);\n      }\n    }\n```\nSelectThread中除了serverTransport和selector还有一个属性selectInterestChanges，用来保存需要改变关注事件的FrameBuffer\n```java\nprivate final TNonblockingServerTransport serverTransport;\nprivate final Selector selector;\n\n// List of FrameBuffers that want to change their selection interests.\nprivate final Set<FrameBuffer> selectInterestChanges =\n      new HashSet<FrameBuffer>();\n```\n为了管理这些FrameBuffer，SelectThread提供两个方法，**processInterestChanges()**函数遍历FrameBuffer触发他们更新关注的IO事件并注册，然后清空集合。\n**requestSelectInterestChange()**函数，允许向集合添加新的需要改变关注事件的FrameBuffer.\n**这俩函数不是同步执行的**，主要是为了多线程版本的服务端使用，同时对selectInterestChanges集合加锁，也是因为TNonblockingServer的子类(THsHaServer)，使用了多线程的reactor模型，在这里不会起作用。\n```java\n\n/**\n    * Check to see if there are any FrameBuffers that have switched their\n    * interest type from read to write or vice versa.\n*/\nprivate void processInterestChanges() {\n      synchronized (selectInterestChanges) {\n        for (FrameBuffer fb : selectInterestChanges) {\n          fb.changeSelectInterests();\n        }\n        selectInterestChanges.clear();\n      }\n    }\n    \n/**\n     * Add FrameBuffer to the list of select interest changes and wake up the\n     * selector if it's blocked. When the select() call exits, it'll give the\n     * FrameBuffer a chance to change its interests.\n     */\npublic void requestSelectInterestChange(FrameBuffer frameBuffer) {\n      synchronized (selectInterestChanges) {\n        selectInterestChanges.add(frameBuffer);\n      }\n      // wakeup the selector, if it's currently blocked.\n      selector.wakeup();\n    }\n```\n#### FrameBuffer\n\n**看名字你会以为这是一个数据缓冲区（类似ByteBuffer），但实际上FrameBuffer做的更多，这就是thrift的神奇命名。。**\n{% asset_img FrameBuffer.png image %}\n\nFrameBuffer内部是一个类似状态机的设计，ta负责数据的读写，修改selector关注事件，发起接口调用，返回结果等操作。服务端IO的具体细节都由它来完成。\nFrameBuffer定义的状态:\n```java\n    // in the midst of reading the frame size off the wire\n    private static final int READING_FRAME_SIZE = 1;\n    // reading the actual frame data now, but not all the way done yet\n    private static final int READING_FRAME = 2;\n    // completely read the frame, so an invocation can now happen\n    private static final int READ_FRAME_COMPLETE = 3;\n    // waiting to get switched to listening for write events\n    private static final int AWAITING_REGISTER_WRITE = 4;\n    // started writing response data, not fully complete yet\n    private static final int WRITING = 6;\n    // another thread wants this framebuffer to go back to reading\n    private static final int AWAITING_REGISTER_READ = 7;\n    // we want our transport and selection key invalidated in the selector thread\n    private static final int AWAITING_CLOSE = 8;\n```\nFrameBuffer状态图：\n{% asset_img FrameBufferState.png image %}\n状态由**READING_FRAME_SIZE**开始(此时bufferSize大小只有4字节)，如果buffer读取完成，变**成READING_FRAME**（此时buffer被初始化为frameSize大小），如果buffer又读取完成，变成\n**READ_FRAME_COMPLETE**状态，这时selectThread会执行requestInvoke()方法:\n```java\nprivate void handleRead(SelectionKey key) {\n...\n// if the buffer's frame read is complete, invoke the method.\n      if (buffer.isFrameFullyRead()) {\n        if (!requestInvoke(buffer)) {\n          cleanupSelectionkey(key);\n        }\n      }\n...\n}\n```\n然后调用FrameBuffer的invoke方法，frameBuffer会调用服务端本地的接口实现类，执行完成后调用responseReady()准备返回调用结果，如果接口实现执行失败，状态由**READ_FRAME_COMPLETE**变成**AWAITING_CLOSE**，随后socket会被关闭。\n```java\npublic void invoke() {\n      TTransport inTrans = getInputTransport();\n      TProtocol inProt = inputProtocolFactory_.getProtocol(inTrans);\n      TProtocol outProt = outputProtocolFactory_.getProtocol(getOutputTransport());\n\n      try {\n        outProt.setServerSide(true);\n        processorFactory_.getProcessor(inTrans).process(inProt, outProt);\n        responseReady();\n        return;\n      } catch (TException te) {\n        LOGGER.warn(\"Exception while invoking!\", te);\n      } catch (Exception e) {\n        LOGGER.error(\"Unexpected exception while invoking!\", e);\n\n      } catch (Throwable t) {\n        LOGGER.error(\"Unexpected throwable while invoking!\", t);\n      }\n      // This will only be reached when there is an exception.\n      state_ = AWAITING_CLOSE;\n      requestSelectInterestChange();\n    }\n```\nresponseReady方法中，状态可能由**READ_FRAME_COMPLETE**变成**AWAITING_REGISTER_READ**(不需要向客户端返回结果)，或者变成**AWAITING_REGISTER_WRITE**（准备发送结果到客户端）：\n```java\npublic void responseReady() {\n      // the read buffer is definitely no longer in use, so we will decrement\n      // our read buffer count. we do this here as well as in close because\n      // we'd like to free this read memory up as quickly as possible for other\n      // clients.\n      readBufferBytesAllocated.addAndGet(-buffer_.array().length);\n\n      if (response_.len() == 0) {\n        // go straight to reading again. this was probably an oneway method\n        state_ = AWAITING_REGISTER_READ;\n        buffer_ = null;\n      } else {\n        buffer_ = ByteBuffer.wrap(response_.get(), 0, response_.len());\n\n        // set state that we're waiting to be switched to write. we do this\n        // asynchronously through requestSelectInterestChange() because there is a\n        // possibility that we're not in the main thread, and thus currently\n        // blocked in select(). (this functionality is in place for the sake of\n        // the HsHa server.)\n        state_ = AWAITING_REGISTER_WRITE;\n      }\n      requestSelectInterestChange();\n    }\n```\n如同注释所说，函数requestSelectInterestChange()告知selectThread_我要改变关注的IO事件然后就返回，是一种异步的方式，然后在函数requestSelectInterestChange中，会检查当前线程，如果就是selectThread_那就直接改变关注的IO事件，否则通过TNonblockingServer调用selectThread_执行：\n```java\nprivate void requestSelectInterestChange() {\n      if (Thread.currentThread() == selectThread_) {\n        changeSelectInterests();\n      } else {\n        TNonblockingServer.this.requestSelectInterestChange(this);\n      }\n    }\n```\n在changeSelectInterests方法中，状态可能由**AWAITING_REGISTER_WRITE**变成**WRITING**，或者由**AWAITING_REGISTER_READ**变成**READING_FRAME_SIZE**，如果是**AWAITING_CLOSE**那么直接关闭连接，取消关注的事件：\n```java\n/**\n     * Give this FrameBuffer a chance to set its interest to write, once data\n     * has come in.\n     */\n    public void changeSelectInterests() {\n      if (state_ == AWAITING_REGISTER_WRITE) {\n        // set the OP_WRITE interest\n        selectionKey_.interestOps(SelectionKey.OP_WRITE);\n        state_ = WRITING;\n      } else if (state_ == AWAITING_REGISTER_READ) {\n        prepareRead();\n      } else if (state_ == AWAITING_CLOSE){\n        close();\n        selectionKey_.cancel();\n      } else {\n        LOGGER.error(\n          \"changeSelectInterest was called, but state is invalid (\"\n          + state_ + \")\");\n      }\n    }\n```\n\n#### 时序图\n非阻塞服务端的初始化代码：\n```java\nTNonblockingServerTransport serverTransport = new TNonblockingServerSocket(7911);\n                HelloService.Processor processor = new HelloService.Processor(new HelloServiceImpl());\n                TServer server = new TNonblockingServer(processor, serverTransport);\n                server.serve();\n```\n时序图包含了异步服务端启动和响应请求的过程(不包括异常)：\n**1,2,3,4** \n执行Server的初始化，和上面的代码一致\n**5,5.1,5.2.1** \n开始准备响应客户端请求，监听端口，创建SelectThread线程并启动\n**5.2.1.1 , 5.2.1.2** SelectThread在构造函数中已经打开selector并注册ACCEPT事件\n**5.2.2.1和灰色部分**\nselector执行select()方法，灰色部分是select()返回的IO事件集合的遍历循环。\n**2.x** 处理accept事件，获得客户端的连接(TNonblockTransport) ，注册READ事件，创建FrameBuffer,准备读取客户端发送的数据。\n**3.x** 处理READ事件，调用服务端的接口实现类\n**4.x** 处理WRITE事件，向客户端发送调用结果\n**5.2.2.2**\n遍历 selectInterestChanges，注册FrameBuffer现在要关注的IO事件。\n**5.3 5.4**\n等待SelectThread退出，停止监听端口，服务结束。\n\n\n{% asset_img serverflow.png image %}\n\n\n  [1]: https://www.ibm.com/developerworks/cn/java/j-lo-apachethrift/image003.jpg\n  [2]: https://www.ibm.com/developerworks/cn/java/j-lo-apachethrift/image006.png\n  [3]: https://www.ibm.com/developerworks/cn/java/j-lo-apachethrift/image004.png\n  [4]: https://www.2cto.com/uploadfile/2012/0816/20120816083811838.jpg\n  [5]: https://upload-images.jianshu.io/upload_images/4235178-4047d3c78bb467c9.png\n  [6]: https://upload-images.jianshu.io/upload_images/3169646-6eddb6e230677349.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/692\n  [7]: http://zhangtielei.com/posts/blog-rxjava-backpressure.html\n  [8]: https://baike.baidu.com/item/%E8%83%8C%E5%8E%8B%E9%98%80\n  [9]: https://github.com/apache/thrift/blob/0.8.x/lib/java/src/org/apache/thrift/server/TThreadedSelectorServer.java\n  [10]: https://upload-images.jianshu.io/upload_images/3169646-eedd2295dcc12725.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/688\n  [11]: https://static.oschina.net/uploads/space/2016/0224/192255_iHyl_1469576.png\n  [12]: https://static.oschina.net/uploads/space/2016/0224/192347_Vfen_1469576.png\n  [13]: https://static.oschina.net/uploads/space/2016/0224/192513_tzOg_1469576.png\n  [14]: https://static.oschina.net/uploads/space/2016/0224/192544_xSFh_1469576.png\n  [15]: https://static.oschina.net/uploads/space/2016/0224/192757_XK9n_1469576.png\n  [16]: https://static.oschina.net/uploads/space/2016/0224/192757_toBx_1469576.png\n  [17]: https://upload.wikimedia.org/wikipedia/commons/thumb/5/54/Big-Endian.svg/200px-Big-Endian.svg.png\n  [18]: https://upload.wikimedia.org/wikipedia/commons/thumb/e/ed/Little-Endian.svg/200px-Little-Endian.svg.png\n  [19]: https://jin-yang.github.io/post/network-tcpip-timewait.html","slug":"thrift源码（四）非阻塞服务端","published":1,"updated":"2019-11-18T15:19:40.117Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkqle1cr002dcyneu1joz8ig","content":"<h3 id=\"非阻塞服务端TNonblockingServer\"><a href=\"#非阻塞服务端TNonblockingServer\" class=\"headerlink\" title=\"非阻塞服务端TNonblockingServer\"></a>非阻塞服务端TNonblockingServer</h3><p>thrift的非阻塞服务端，采用还是类似Reactor的IO复用模型</p>\n<p><img src=\"https://www.2cto.com/uploadfile/2012/0816/20120816083811838.jpg\" alt=\"reactor uml\"><br>对于TNonblockingServer，使用的是单线程的reactor模式，<br>客户端的请求会被公平的处理(没有优先级，看哪个请求先触发selector)，使用TNonblockingServer时必须使用TFramedTransport，不然无法确定数据包何时读取完成(数据边界)。<br><a id=\"more\"></a></p>\n<img src=\"/2019/10/25/thrift源码（四）非阻塞服务端/reactor-single.png\" title=\"image\">\n<h4 id=\"SelectThread\"><a href=\"#SelectThread\" class=\"headerlink\" title=\"SelectThread\"></a>SelectThread</h4><img src=\"/2019/10/25/thrift源码（四）非阻塞服务端/SelectThread.png\" title=\"image\">\n<p>selector工作线程，作用reactor模式中的dispatcher,分离IO事件，触发对应的handler。<br>SelectThread的run方法：<br>执行完select()，就会检查&amp;更新FrameBuffers上关注的事件：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!stopped_) &#123;</span><br><span class=\"line\">          select();</span><br><span class=\"line\">          processInterestChanges();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">        LOGGER.error(<span class=\"string\">\"run() exiting due to uncaught error\"</span>, t);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        stopped_ = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>select方法，根据不同的IO事件，执行对应调用：<br>和上面Reactor的图片有点不同，这里没有单独的acceptor，也没有handler,都由SelectThread处理。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">select</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// wait for io events.</span></span><br><span class=\"line\">        selector.select();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// process the io events we received</span></span><br><span class=\"line\">        Iterator&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys().iterator();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!stopped_ &amp;&amp; selectedKeys.hasNext()) &#123;</span><br><span class=\"line\">          SelectionKey key = selectedKeys.next();</span><br><span class=\"line\">          selectedKeys.remove();</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"comment\">// skip if not valid</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (!key.isValid()) &#123;</span><br><span class=\"line\">            cleanupSelectionkey(key);</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"comment\">// if the key is marked Accept, then it has to be the server</span></span><br><span class=\"line\">          <span class=\"comment\">// transport.</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (key.isAcceptable()) &#123;</span><br><span class=\"line\">            handleAccept();</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key.isReadable()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// deal with reads</span></span><br><span class=\"line\">            handleRead(key);</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key.isWritable()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// deal with writes</span></span><br><span class=\"line\">            handleWrite(key);</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            LOGGER.warn(<span class=\"string\">\"Unexpected state in select! \"</span> + key.interestOps());</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">        LOGGER.warn(<span class=\"string\">\"Got an IOException while selecting!\"</span>, e);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>SelectThread中除了serverTransport和selector还有一个属性selectInterestChanges，用来保存需要改变关注事件的FrameBuffer<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> TNonblockingServerTransport serverTransport;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Selector selector;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// List of FrameBuffers that want to change their selection interests.</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Set&lt;FrameBuffer&gt; selectInterestChanges =</span><br><span class=\"line\">      <span class=\"keyword\">new</span> HashSet&lt;FrameBuffer&gt;();</span><br></pre></td></tr></table></figure></p>\n<p>为了管理这些FrameBuffer，SelectThread提供两个方法，<strong>processInterestChanges()</strong>函数遍历FrameBuffer触发他们更新关注的IO事件并注册，然后清空集合。<br><strong>requestSelectInterestChange()</strong>函数，允许向集合添加新的需要改变关注事件的FrameBuffer.<br><strong>这俩函数不是同步执行的</strong>，主要是为了多线程版本的服务端使用，同时对selectInterestChanges集合加锁，也是因为TNonblockingServer的子类(THsHaServer)，使用了多线程的reactor模型，在这里不会起作用。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * Check to see if there are any FrameBuffers that have switched their</span></span><br><span class=\"line\"><span class=\"comment\">    * interest type from read to write or vice versa.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">processInterestChanges</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">synchronized</span> (selectInterestChanges) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (FrameBuffer fb : selectInterestChanges) &#123;</span><br><span class=\"line\">          fb.changeSelectInterests();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        selectInterestChanges.clear();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Add FrameBuffer to the list of select interest changes and wake up the</span></span><br><span class=\"line\"><span class=\"comment\">     * selector if it's blocked. When the select() call exits, it'll give the</span></span><br><span class=\"line\"><span class=\"comment\">     * FrameBuffer a chance to change its interests.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">requestSelectInterestChange</span><span class=\"params\">(FrameBuffer frameBuffer)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">synchronized</span> (selectInterestChanges) &#123;</span><br><span class=\"line\">        selectInterestChanges.add(frameBuffer);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// wakeup the selector, if it's currently blocked.</span></span><br><span class=\"line\">      selector.wakeup();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"FrameBuffer\"><a href=\"#FrameBuffer\" class=\"headerlink\" title=\"FrameBuffer\"></a>FrameBuffer</h4><p><strong>看名字你会以为这是一个数据缓冲区（类似ByteBuffer），但实际上FrameBuffer做的更多，这就是thrift的神奇命名。。</strong><br><img src=\"/2019/10/25/thrift源码（四）非阻塞服务端/FrameBuffer.png\" title=\"image\"></p>\n<p>FrameBuffer内部是一个类似状态机的设计，ta负责数据的读写，修改selector关注事件，发起接口调用，返回结果等操作。服务端IO的具体细节都由它来完成。<br>FrameBuffer定义的状态:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// in the midst of reading the frame size off the wire</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> READING_FRAME_SIZE = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"comment\">// reading the actual frame data now, but not all the way done yet</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> READING_FRAME = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"comment\">// completely read the frame, so an invocation can now happen</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> READ_FRAME_COMPLETE = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"comment\">// waiting to get switched to listening for write events</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> AWAITING_REGISTER_WRITE = <span class=\"number\">4</span>;</span><br><span class=\"line\"><span class=\"comment\">// started writing response data, not fully complete yet</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> WRITING = <span class=\"number\">6</span>;</span><br><span class=\"line\"><span class=\"comment\">// another thread wants this framebuffer to go back to reading</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> AWAITING_REGISTER_READ = <span class=\"number\">7</span>;</span><br><span class=\"line\"><span class=\"comment\">// we want our transport and selection key invalidated in the selector thread</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> AWAITING_CLOSE = <span class=\"number\">8</span>;</span><br></pre></td></tr></table></figure></p>\n<p>FrameBuffer状态图：<br><img src=\"/2019/10/25/thrift源码（四）非阻塞服务端/FrameBufferState.png\" title=\"image\"><br>状态由<strong>READING_FRAME_SIZE</strong>开始(此时bufferSize大小只有4字节)，如果buffer读取完成，变<strong>成READING_FRAME</strong>（此时buffer被初始化为frameSize大小），如果buffer又读取完成，变成<br><strong>READ_FRAME_COMPLETE</strong>状态，这时selectThread会执行requestInvoke()方法:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">handleRead</span><span class=\"params\">(SelectionKey key)</span> </span>&#123;</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"comment\">// if the buffer's frame read is complete, invoke the method.</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (buffer.isFrameFullyRead()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!requestInvoke(buffer)) &#123;</span><br><span class=\"line\">          cleanupSelectionkey(key);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后调用FrameBuffer的invoke方法，frameBuffer会调用服务端本地的接口实现类，执行完成后调用responseReady()准备返回调用结果，如果接口实现执行失败，状态由<strong>READ_FRAME_COMPLETE</strong>变成<strong>AWAITING_CLOSE</strong>，随后socket会被关闭。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">invoke</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      TTransport inTrans = getInputTransport();</span><br><span class=\"line\">      TProtocol inProt = inputProtocolFactory_.getProtocol(inTrans);</span><br><span class=\"line\">      TProtocol outProt = outputProtocolFactory_.getProtocol(getOutputTransport());</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        outProt.setServerSide(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        processorFactory_.getProcessor(inTrans).process(inProt, outProt);</span><br><span class=\"line\">        responseReady();</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (TException te) &#123;</span><br><span class=\"line\">        LOGGER.warn(<span class=\"string\">\"Exception while invoking!\"</span>, te);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        LOGGER.error(<span class=\"string\">\"Unexpected exception while invoking!\"</span>, e);</span><br><span class=\"line\"></span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">        LOGGER.error(<span class=\"string\">\"Unexpected throwable while invoking!\"</span>, t);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// This will only be reached when there is an exception.</span></span><br><span class=\"line\">      state_ = AWAITING_CLOSE;</span><br><span class=\"line\">      requestSelectInterestChange();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>responseReady方法中，状态可能由<strong>READ_FRAME_COMPLETE</strong>变成<strong>AWAITING_REGISTER_READ</strong>(不需要向客户端返回结果)，或者变成<strong>AWAITING_REGISTER_WRITE</strong>（准备发送结果到客户端）：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">responseReady</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">// the read buffer is definitely no longer in use, so we will decrement</span></span><br><span class=\"line\">      <span class=\"comment\">// our read buffer count. we do this here as well as in close because</span></span><br><span class=\"line\">      <span class=\"comment\">// we'd like to free this read memory up as quickly as possible for other</span></span><br><span class=\"line\">      <span class=\"comment\">// clients.</span></span><br><span class=\"line\">      readBufferBytesAllocated.addAndGet(-buffer_.array().length);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (response_.len() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// go straight to reading again. this was probably an oneway method</span></span><br><span class=\"line\">        state_ = AWAITING_REGISTER_READ;</span><br><span class=\"line\">        buffer_ = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        buffer_ = ByteBuffer.wrap(response_.get(), <span class=\"number\">0</span>, response_.len());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// set state that we're waiting to be switched to write. we do this</span></span><br><span class=\"line\">        <span class=\"comment\">// asynchronously through requestSelectInterestChange() because there is a</span></span><br><span class=\"line\">        <span class=\"comment\">// possibility that we're not in the main thread, and thus currently</span></span><br><span class=\"line\">        <span class=\"comment\">// blocked in select(). (this functionality is in place for the sake of</span></span><br><span class=\"line\">        <span class=\"comment\">// the HsHa server.)</span></span><br><span class=\"line\">        state_ = AWAITING_REGISTER_WRITE;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      requestSelectInterestChange();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>如同注释所说，函数requestSelectInterestChange()告知selectThread_我要改变关注的IO事件然后就返回，是一种异步的方式，然后在函数requestSelectInterestChange中，会检查当前线程，如果就是selectThread_那就直接改变关注的IO事件，否则通过TNonblockingServer调用selectThread_执行：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">requestSelectInterestChange</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (Thread.currentThread() == selectThread_) &#123;</span><br><span class=\"line\">        changeSelectInterests();</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        TNonblockingServer.<span class=\"keyword\">this</span>.requestSelectInterestChange(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>在changeSelectInterests方法中，状态可能由<strong>AWAITING_REGISTER_WRITE</strong>变成<strong>WRITING</strong>，或者由<strong>AWAITING_REGISTER_READ</strong>变成<strong>READING_FRAME_SIZE</strong>，如果是<strong>AWAITING_CLOSE</strong>那么直接关闭连接，取消关注的事件：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Give this FrameBuffer a chance to set its interest to write, once data</span></span><br><span class=\"line\"><span class=\"comment\">     * has come in.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">changeSelectInterests</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (state_ == AWAITING_REGISTER_WRITE) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// set the OP_WRITE interest</span></span><br><span class=\"line\">        selectionKey_.interestOps(SelectionKey.OP_WRITE);</span><br><span class=\"line\">        state_ = WRITING;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (state_ == AWAITING_REGISTER_READ) &#123;</span><br><span class=\"line\">        prepareRead();</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (state_ == AWAITING_CLOSE)&#123;</span><br><span class=\"line\">        close();</span><br><span class=\"line\">        selectionKey_.cancel();</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        LOGGER.error(</span><br><span class=\"line\">          <span class=\"string\">\"changeSelectInterest was called, but state is invalid (\"</span></span><br><span class=\"line\">          + state_ + <span class=\"string\">\")\"</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"时序图\"><a href=\"#时序图\" class=\"headerlink\" title=\"时序图\"></a>时序图</h4><p>非阻塞服务端的初始化代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TNonblockingServerTransport serverTransport = <span class=\"keyword\">new</span> TNonblockingServerSocket(<span class=\"number\">7911</span>);</span><br><span class=\"line\">                HelloService.Processor processor = <span class=\"keyword\">new</span> HelloService.Processor(<span class=\"keyword\">new</span> HelloServiceImpl());</span><br><span class=\"line\">                TServer server = <span class=\"keyword\">new</span> TNonblockingServer(processor, serverTransport);</span><br><span class=\"line\">                server.serve();</span><br></pre></td></tr></table></figure></p>\n<p>时序图包含了异步服务端启动和响应请求的过程(不包括异常)：<br><strong>1,2,3,4</strong><br>执行Server的初始化，和上面的代码一致<br><strong>5,5.1,5.2.1</strong><br>开始准备响应客户端请求，监听端口，创建SelectThread线程并启动<br><strong>5.2.1.1 , 5.2.1.2</strong> SelectThread在构造函数中已经打开selector并注册ACCEPT事件<br><strong>5.2.2.1和灰色部分</strong><br>selector执行select()方法，灰色部分是select()返回的IO事件集合的遍历循环。<br><strong>2.x</strong> 处理accept事件，获得客户端的连接(TNonblockTransport) ，注册READ事件，创建FrameBuffer,准备读取客户端发送的数据。<br><strong>3.x</strong> 处理READ事件，调用服务端的接口实现类<br><strong>4.x</strong> 处理WRITE事件，向客户端发送调用结果<br><strong>5.2.2.2</strong><br>遍历 selectInterestChanges，注册FrameBuffer现在要关注的IO事件。<br><strong>5.3 5.4</strong><br>等待SelectThread退出，停止监听端口，服务结束。</p>\n<img src=\"/2019/10/25/thrift源码（四）非阻塞服务端/serverflow.png\" title=\"image\">\n","site":{"data":{}},"excerpt":"<h3 id=\"非阻塞服务端TNonblockingServer\"><a href=\"#非阻塞服务端TNonblockingServer\" class=\"headerlink\" title=\"非阻塞服务端TNonblockingServer\"></a>非阻塞服务端TNonblockingServer</h3><p>thrift的非阻塞服务端，采用还是类似Reactor的IO复用模型</p>\n<p><img src=\"https://www.2cto.com/uploadfile/2012/0816/20120816083811838.jpg\" alt=\"reactor uml\"><br>对于TNonblockingServer，使用的是单线程的reactor模式，<br>客户端的请求会被公平的处理(没有优先级，看哪个请求先触发selector)，使用TNonblockingServer时必须使用TFramedTransport，不然无法确定数据包何时读取完成(数据边界)。<br>","more":"</p>\n<img src=\"/2019/10/25/thrift源码（四）非阻塞服务端/reactor-single.png\" title=\"image\">\n<h4 id=\"SelectThread\"><a href=\"#SelectThread\" class=\"headerlink\" title=\"SelectThread\"></a>SelectThread</h4><img src=\"/2019/10/25/thrift源码（四）非阻塞服务端/SelectThread.png\" title=\"image\">\n<p>selector工作线程，作用reactor模式中的dispatcher,分离IO事件，触发对应的handler。<br>SelectThread的run方法：<br>执行完select()，就会检查&amp;更新FrameBuffers上关注的事件：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!stopped_) &#123;</span><br><span class=\"line\">          select();</span><br><span class=\"line\">          processInterestChanges();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">        LOGGER.error(<span class=\"string\">\"run() exiting due to uncaught error\"</span>, t);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        stopped_ = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>select方法，根据不同的IO事件，执行对应调用：<br>和上面Reactor的图片有点不同，这里没有单独的acceptor，也没有handler,都由SelectThread处理。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">select</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// wait for io events.</span></span><br><span class=\"line\">        selector.select();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// process the io events we received</span></span><br><span class=\"line\">        Iterator&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys().iterator();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!stopped_ &amp;&amp; selectedKeys.hasNext()) &#123;</span><br><span class=\"line\">          SelectionKey key = selectedKeys.next();</span><br><span class=\"line\">          selectedKeys.remove();</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"comment\">// skip if not valid</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (!key.isValid()) &#123;</span><br><span class=\"line\">            cleanupSelectionkey(key);</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"comment\">// if the key is marked Accept, then it has to be the server</span></span><br><span class=\"line\">          <span class=\"comment\">// transport.</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (key.isAcceptable()) &#123;</span><br><span class=\"line\">            handleAccept();</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key.isReadable()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// deal with reads</span></span><br><span class=\"line\">            handleRead(key);</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key.isWritable()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// deal with writes</span></span><br><span class=\"line\">            handleWrite(key);</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            LOGGER.warn(<span class=\"string\">\"Unexpected state in select! \"</span> + key.interestOps());</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">        LOGGER.warn(<span class=\"string\">\"Got an IOException while selecting!\"</span>, e);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>SelectThread中除了serverTransport和selector还有一个属性selectInterestChanges，用来保存需要改变关注事件的FrameBuffer<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> TNonblockingServerTransport serverTransport;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Selector selector;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// List of FrameBuffers that want to change their selection interests.</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Set&lt;FrameBuffer&gt; selectInterestChanges =</span><br><span class=\"line\">      <span class=\"keyword\">new</span> HashSet&lt;FrameBuffer&gt;();</span><br></pre></td></tr></table></figure></p>\n<p>为了管理这些FrameBuffer，SelectThread提供两个方法，<strong>processInterestChanges()</strong>函数遍历FrameBuffer触发他们更新关注的IO事件并注册，然后清空集合。<br><strong>requestSelectInterestChange()</strong>函数，允许向集合添加新的需要改变关注事件的FrameBuffer.<br><strong>这俩函数不是同步执行的</strong>，主要是为了多线程版本的服务端使用，同时对selectInterestChanges集合加锁，也是因为TNonblockingServer的子类(THsHaServer)，使用了多线程的reactor模型，在这里不会起作用。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * Check to see if there are any FrameBuffers that have switched their</span></span><br><span class=\"line\"><span class=\"comment\">    * interest type from read to write or vice versa.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">processInterestChanges</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">synchronized</span> (selectInterestChanges) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (FrameBuffer fb : selectInterestChanges) &#123;</span><br><span class=\"line\">          fb.changeSelectInterests();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        selectInterestChanges.clear();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Add FrameBuffer to the list of select interest changes and wake up the</span></span><br><span class=\"line\"><span class=\"comment\">     * selector if it's blocked. When the select() call exits, it'll give the</span></span><br><span class=\"line\"><span class=\"comment\">     * FrameBuffer a chance to change its interests.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">requestSelectInterestChange</span><span class=\"params\">(FrameBuffer frameBuffer)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">synchronized</span> (selectInterestChanges) &#123;</span><br><span class=\"line\">        selectInterestChanges.add(frameBuffer);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// wakeup the selector, if it's currently blocked.</span></span><br><span class=\"line\">      selector.wakeup();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"FrameBuffer\"><a href=\"#FrameBuffer\" class=\"headerlink\" title=\"FrameBuffer\"></a>FrameBuffer</h4><p><strong>看名字你会以为这是一个数据缓冲区（类似ByteBuffer），但实际上FrameBuffer做的更多，这就是thrift的神奇命名。。</strong><br><img src=\"/2019/10/25/thrift源码（四）非阻塞服务端/FrameBuffer.png\" title=\"image\"></p>\n<p>FrameBuffer内部是一个类似状态机的设计，ta负责数据的读写，修改selector关注事件，发起接口调用，返回结果等操作。服务端IO的具体细节都由它来完成。<br>FrameBuffer定义的状态:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// in the midst of reading the frame size off the wire</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> READING_FRAME_SIZE = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"comment\">// reading the actual frame data now, but not all the way done yet</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> READING_FRAME = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"comment\">// completely read the frame, so an invocation can now happen</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> READ_FRAME_COMPLETE = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"comment\">// waiting to get switched to listening for write events</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> AWAITING_REGISTER_WRITE = <span class=\"number\">4</span>;</span><br><span class=\"line\"><span class=\"comment\">// started writing response data, not fully complete yet</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> WRITING = <span class=\"number\">6</span>;</span><br><span class=\"line\"><span class=\"comment\">// another thread wants this framebuffer to go back to reading</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> AWAITING_REGISTER_READ = <span class=\"number\">7</span>;</span><br><span class=\"line\"><span class=\"comment\">// we want our transport and selection key invalidated in the selector thread</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> AWAITING_CLOSE = <span class=\"number\">8</span>;</span><br></pre></td></tr></table></figure></p>\n<p>FrameBuffer状态图：<br><img src=\"/2019/10/25/thrift源码（四）非阻塞服务端/FrameBufferState.png\" title=\"image\"><br>状态由<strong>READING_FRAME_SIZE</strong>开始(此时bufferSize大小只有4字节)，如果buffer读取完成，变<strong>成READING_FRAME</strong>（此时buffer被初始化为frameSize大小），如果buffer又读取完成，变成<br><strong>READ_FRAME_COMPLETE</strong>状态，这时selectThread会执行requestInvoke()方法:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">handleRead</span><span class=\"params\">(SelectionKey key)</span> </span>&#123;</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"comment\">// if the buffer's frame read is complete, invoke the method.</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (buffer.isFrameFullyRead()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!requestInvoke(buffer)) &#123;</span><br><span class=\"line\">          cleanupSelectionkey(key);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后调用FrameBuffer的invoke方法，frameBuffer会调用服务端本地的接口实现类，执行完成后调用responseReady()准备返回调用结果，如果接口实现执行失败，状态由<strong>READ_FRAME_COMPLETE</strong>变成<strong>AWAITING_CLOSE</strong>，随后socket会被关闭。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">invoke</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      TTransport inTrans = getInputTransport();</span><br><span class=\"line\">      TProtocol inProt = inputProtocolFactory_.getProtocol(inTrans);</span><br><span class=\"line\">      TProtocol outProt = outputProtocolFactory_.getProtocol(getOutputTransport());</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        outProt.setServerSide(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        processorFactory_.getProcessor(inTrans).process(inProt, outProt);</span><br><span class=\"line\">        responseReady();</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (TException te) &#123;</span><br><span class=\"line\">        LOGGER.warn(<span class=\"string\">\"Exception while invoking!\"</span>, te);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        LOGGER.error(<span class=\"string\">\"Unexpected exception while invoking!\"</span>, e);</span><br><span class=\"line\"></span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">        LOGGER.error(<span class=\"string\">\"Unexpected throwable while invoking!\"</span>, t);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// This will only be reached when there is an exception.</span></span><br><span class=\"line\">      state_ = AWAITING_CLOSE;</span><br><span class=\"line\">      requestSelectInterestChange();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>responseReady方法中，状态可能由<strong>READ_FRAME_COMPLETE</strong>变成<strong>AWAITING_REGISTER_READ</strong>(不需要向客户端返回结果)，或者变成<strong>AWAITING_REGISTER_WRITE</strong>（准备发送结果到客户端）：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">responseReady</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">// the read buffer is definitely no longer in use, so we will decrement</span></span><br><span class=\"line\">      <span class=\"comment\">// our read buffer count. we do this here as well as in close because</span></span><br><span class=\"line\">      <span class=\"comment\">// we'd like to free this read memory up as quickly as possible for other</span></span><br><span class=\"line\">      <span class=\"comment\">// clients.</span></span><br><span class=\"line\">      readBufferBytesAllocated.addAndGet(-buffer_.array().length);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (response_.len() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// go straight to reading again. this was probably an oneway method</span></span><br><span class=\"line\">        state_ = AWAITING_REGISTER_READ;</span><br><span class=\"line\">        buffer_ = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        buffer_ = ByteBuffer.wrap(response_.get(), <span class=\"number\">0</span>, response_.len());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// set state that we're waiting to be switched to write. we do this</span></span><br><span class=\"line\">        <span class=\"comment\">// asynchronously through requestSelectInterestChange() because there is a</span></span><br><span class=\"line\">        <span class=\"comment\">// possibility that we're not in the main thread, and thus currently</span></span><br><span class=\"line\">        <span class=\"comment\">// blocked in select(). (this functionality is in place for the sake of</span></span><br><span class=\"line\">        <span class=\"comment\">// the HsHa server.)</span></span><br><span class=\"line\">        state_ = AWAITING_REGISTER_WRITE;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      requestSelectInterestChange();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>如同注释所说，函数requestSelectInterestChange()告知selectThread_我要改变关注的IO事件然后就返回，是一种异步的方式，然后在函数requestSelectInterestChange中，会检查当前线程，如果就是selectThread_那就直接改变关注的IO事件，否则通过TNonblockingServer调用selectThread_执行：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">requestSelectInterestChange</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (Thread.currentThread() == selectThread_) &#123;</span><br><span class=\"line\">        changeSelectInterests();</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        TNonblockingServer.<span class=\"keyword\">this</span>.requestSelectInterestChange(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>在changeSelectInterests方法中，状态可能由<strong>AWAITING_REGISTER_WRITE</strong>变成<strong>WRITING</strong>，或者由<strong>AWAITING_REGISTER_READ</strong>变成<strong>READING_FRAME_SIZE</strong>，如果是<strong>AWAITING_CLOSE</strong>那么直接关闭连接，取消关注的事件：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Give this FrameBuffer a chance to set its interest to write, once data</span></span><br><span class=\"line\"><span class=\"comment\">     * has come in.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">changeSelectInterests</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (state_ == AWAITING_REGISTER_WRITE) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// set the OP_WRITE interest</span></span><br><span class=\"line\">        selectionKey_.interestOps(SelectionKey.OP_WRITE);</span><br><span class=\"line\">        state_ = WRITING;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (state_ == AWAITING_REGISTER_READ) &#123;</span><br><span class=\"line\">        prepareRead();</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (state_ == AWAITING_CLOSE)&#123;</span><br><span class=\"line\">        close();</span><br><span class=\"line\">        selectionKey_.cancel();</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        LOGGER.error(</span><br><span class=\"line\">          <span class=\"string\">\"changeSelectInterest was called, but state is invalid (\"</span></span><br><span class=\"line\">          + state_ + <span class=\"string\">\")\"</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"时序图\"><a href=\"#时序图\" class=\"headerlink\" title=\"时序图\"></a>时序图</h4><p>非阻塞服务端的初始化代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TNonblockingServerTransport serverTransport = <span class=\"keyword\">new</span> TNonblockingServerSocket(<span class=\"number\">7911</span>);</span><br><span class=\"line\">                HelloService.Processor processor = <span class=\"keyword\">new</span> HelloService.Processor(<span class=\"keyword\">new</span> HelloServiceImpl());</span><br><span class=\"line\">                TServer server = <span class=\"keyword\">new</span> TNonblockingServer(processor, serverTransport);</span><br><span class=\"line\">                server.serve();</span><br></pre></td></tr></table></figure></p>\n<p>时序图包含了异步服务端启动和响应请求的过程(不包括异常)：<br><strong>1,2,3,4</strong><br>执行Server的初始化，和上面的代码一致<br><strong>5,5.1,5.2.1</strong><br>开始准备响应客户端请求，监听端口，创建SelectThread线程并启动<br><strong>5.2.1.1 , 5.2.1.2</strong> SelectThread在构造函数中已经打开selector并注册ACCEPT事件<br><strong>5.2.2.1和灰色部分</strong><br>selector执行select()方法，灰色部分是select()返回的IO事件集合的遍历循环。<br><strong>2.x</strong> 处理accept事件，获得客户端的连接(TNonblockTransport) ，注册READ事件，创建FrameBuffer,准备读取客户端发送的数据。<br><strong>3.x</strong> 处理READ事件，调用服务端的接口实现类<br><strong>4.x</strong> 处理WRITE事件，向客户端发送调用结果<br><strong>5.2.2.2</strong><br>遍历 selectInterestChanges，注册FrameBuffer现在要关注的IO事件。<br><strong>5.3 5.4</strong><br>等待SelectThread退出，停止监听端口，服务结束。</p>\n<img src=\"/2019/10/25/thrift源码（四）非阻塞服务端/serverflow.png\" title=\"image\">"},{"title":"thrift源码（五）非阻塞服务端其他实现","date":"2019-11-18T15:35:19.000Z","_content":"\n### THsHaServer\n\nHsHa=HalfSync HalfAsync 半同步，半异步\n在处理IO事件时是同步的，在执行invoke方法时是在线程池异步执行的。\n本质上是一个添加了工作线程池的Reactor模型：\n{% asset_img reactor-pool.png image %}\n\n内部使用了一个自定义的线程池ExecutorService，用线程池中的线程执行FrameBuffer的Invoke方法，非常简单。上面已经说明invoke()方法只执行了服务端本地的接口实现类，并没有做IO操作，所以在THsHaServer中IO操作还是在SelectThread线程内完成的。\n<!--more-->\n\n```java\n  //线程池 invoker\n  private ExecutorService invoker;\n\n/**\n   * 重写了requestInvoke方法\n   */\n  @Override\n  protected boolean requestInvoke(FrameBuffer frameBuffer) {\n    try {\n      invoker.execute(new Invocation(frameBuffer));\n      return true;\n    } catch (RejectedExecutionException rx) {\n      LOGGER.warn(\"ExecutorService rejected execution!\", rx);\n      return false;\n    }\n  }\n\n  /**\n   * final修饰的FrameBuffer\n   */\n  private class Invocation implements Runnable {\n\n    private final FrameBuffer frameBuffer;\n\n    public Invocation(final FrameBuffer frameBuffer) {\n      this.frameBuffer = frameBuffer;\n    }\n\n    public void run() {\n      frameBuffer.invoke();\n    }\n  }\n```\n\n下面是THsHaServer对线程池的创建和销毁代码：\nOptions的默认配置是5个线程，60s空闲时间。\n\n```java\n //创建线程池\n protected static ExecutorService createInvokerPool(Options options) {\n    int workerThreads = options.workerThreads;\n    int stopTimeoutVal = options.stopTimeoutVal;\n    TimeUnit stopTimeoutUnit = options.stopTimeoutUnit;\n\n    LinkedBlockingQueue<Runnable> queue = new LinkedBlockingQueue<Runnable>();\n    ExecutorService invoker = new ThreadPoolExecutor(workerThreads, workerThreads,\n      stopTimeoutVal, stopTimeoutUnit, queue);\n\n    return invoker;\n  }\n //等待线程池退出,只要线程池没彻底关闭,即使被中断也要等待足够的时间再退出\n protected void gracefullyShutdownInvokerPool() {\n    // try to gracefully shut down the executor service\n    invoker.shutdown();\n\n    // Loop until awaitTermination finally does return without a interrupted\n    // exception. If we don't do this, then we'll shut down prematurely. We want\n    // to let the executorService clear it's task queue, closing client sockets\n    // appropriately.\n    long timeoutMS = 10000;\n    long now = System.currentTimeMillis();\n    while (timeoutMS >= 0) {\n      try {\n        invoker.awaitTermination(timeoutMS, TimeUnit.MILLISECONDS);\n        break;\n      } catch (InterruptedException ix) {\n        long newnow = System.currentTimeMillis();\n        timeoutMS -= (newnow - now);\n        now = newnow;\n      }\n    }\n  }\n```\n\n### TThreadSelectorServer\n\n我使用的0.5.x版本没有这个server实现，在0.8.x版本thrift添加了TThreadedSelectorServer\n\n据thrift描述：\n在多核环境中，如果瓶颈是单线程的selector获得的CPU计算能力不足, 那么它的性能要优于TNonblockingServer/THsHaServer。\n\n而且because the accept handling is decoupled from\n  reads/writes and invocation, the server has better ability to handle back-pressure from new connections\n  (backpress背压，是一个很有意思的名词，在很多地方有用到 [比如RxJava][7] 或者[背压阀][8])\n\n[TThreadedSelectorServer源码地址][9]\n\nTThreadSelectorServer是**Multiple Reactors**模式的实现，\nmainReactor只负责完成accept操作，子reactor处理读、写事件。图中只画出来一个subReactor线程的情况，实际可能配置多个线程运行subReactor。\n\n{% asset_img reactor-pool.png image %}\n\n在实现**Multiple Reactors**时，TThreadSelectorServer的AcceptThread相当于MainReactor,SelectorThread相当于subReactor,下面只选择部分代码做介绍：\n\n#### TThreadedSelectorServer.java\n\n```java\n//startThreads()方法,初始化AcceptThread和SelectorThread(集合)：\nfor (int i = 0; i < args.selectorThreads; ++i) {\n        selectorThreads.add(new SelectorThread(args.acceptQueueSizePerThread));\n      }\n      acceptThread = new AcceptThread((TNonblockingServerTransport) serverTransport_,\n        createSelectorThreadLoadBalancer(selectorThreads));\n      stopped_ = false;\n      for (SelectorThread thread : selectorThreads) {\n        thread.start();\n      }\n      acceptThread.start();\nreturn true;\n```\n\n#### AcceptThread.java\n\n**run()**方法里只执行select()操作：\n\n```java\npublic void run() {\n      try {\n        while (!stopped_) {\n          select();\n        }\n      } catch (Throwable t) {\n        LOGGER.error(\"run() exiting due to uncaught error\", t);\n      } finally {\n        // This will wake up the selector threads\n        TThreadedSelectorServer.this.stop();\n      }\n}\n```\n\n在**handleAccept()**方法中，处理客户端的建立连接的请求：\nAcceptThread有两种工作模式，FAST_ACCEPT是收到连接请求就接受，FAIR_ACCEPT是把连接请求丢到工作线程池invoker中，这样会等之前的连接请求被工作线程执行后，才会处理后来的连接请求：\n\n```java\nprivate void handleAccept() {\n      final TNonblockingTransport client = doAccept();\n      if (client != null) {\n        // Pass this connection to a selector thread\n        final SelectorThread targetThread = threadChooser.nextThread();\n\n        if (args.acceptPolicy == Args.AcceptPolicy.FAST_ACCEPT || invoker == null) {\n          doAddAccept(targetThread, client);\n        } else {\n          // FAIR_ACCEPT\n          try {\n            invoker.submit(new Runnable() {\n              public void run() {\n                doAddAccept(targetThread, client);\n              }\n            });\n          } catch (RejectedExecutionException rx) {\n            ...\n          }\n        }\n      }\n}\n```\n\n**doAddAccept()**方法，把client连接交给SelectorThread处理，后续的其他操作就和AcceptThread无关了：\n\n```java\nprivate void doAddAccept(SelectorThread thread, TNonblockingTransport client) {\n      if (!thread.addAcceptedConnection(client)) {\n        client.close();\n      }\n}\n```\n\n#### SelectorThread.java\n\n**addAcceptedConnection()**方法\n\nAcceptThread调用它把任务交给SelectorThread处理，客户端连接会被放入SelectorThread的acceptedQueue等待处理：\n\n```java\npublic boolean addAcceptedConnection(TNonblockingTransport accepted) {\n      try {\n        acceptedQueue.put(accepted);\n      } catch (InterruptedException e) {\n        LOGGER.warn(\"Interrupted while adding accepted connection!\", e);\n        return false;\n      }\n      selector.wakeup();\n      return true;\n}\n```\n\n在SelectorThread的**run()**方法\n\n完成对读/写IO事件的select(),处理acceptQueue中的任务，执行processInterestChanges（之前介绍过，触发FrameBuffer的关注事件更新）\n\n```java\nwhile (!stopped_) {\n          select();\n          processAcceptedConnections();\n          processInterestChanges();\n}\n```\n\n**processAcceptedConnections()**方法\n\n从acceptQueue队列取出客户端连接，向selector注册OP_READ事件\n\n```java\nprivate void processAcceptedConnections() {\n      // Register accepted connections\n      while (!stopped_) {\n        TNonblockingTransport accepted = acceptedQueue.poll();\n        if (accepted == null) {\n          break;\n        }\n        registerAccepted(accepted);\n      }\n}\nprivate void registerAccepted(TNonblockingTransport accepted) {\n      SelectionKey clientKey = null;\n      try {\n        clientKey = accepted.registerSelector(selector, SelectionKey.OP_READ);\n\n        FrameBuffer frameBuffer = new FrameBuffer(accepted, clientKey, SelectorThread.this);\n        clientKey.attach(frameBuffer);\n      } catch (IOException e) {\n        ...\n      }\n}\n```\n\n[1]: https://www.ibm.com/developerworks/cn/java/j-lo-apachethrift/image003.jpg\n[2]: https://www.ibm.com/developerworks/cn/java/j-lo-apachethrift/image006.png\n  [3]: https://www.ibm.com/developerworks/cn/java/j-lo-apachethrift/image004.png\n  [4]: http://upload-images.jianshu.io/upload_images/1452123-35a5505c0d9928f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\n  [5]: http://upload-images.jianshu.io/upload_images/1452123-bfb7ef28b21ba29e?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\n  [6]: https://upload-images.jianshu.io/upload_images/3169646-6eddb6e230677349.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/692\n  [7]: http://zhangtielei.com/posts/blog-rxjava-backpressure.html\n  [8]: https://baike.baidu.com/item/%E8%83%8C%E5%8E%8B%E9%98%80\n  [9]: https://github.com/apache/thrift/blob/0.8.x/lib/java/src/org/apache/thrift/server/TThreadedSelectorServer.java\n  [10]: https://upload-images.jianshu.io/upload_images/3169646-eedd2295dcc12725.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/688\n  [11]: https://static.oschina.net/uploads/space/2016/0224/192255_iHyl_1469576.png\n  [12]: https://static.oschina.net/uploads/space/2016/0224/192347_Vfen_1469576.png\n  [13]: https://static.oschina.net/uploads/space/2016/0224/192513_tzOg_1469576.png\n  [14]: https://static.oschina.net/uploads/space/2016/0224/192544_xSFh_1469576.png\n  [15]: https://static.oschina.net/uploads/space/2016/0224/192757_XK9n_1469576.png\n  [16]: https://static.oschina.net/uploads/space/2016/0224/192757_toBx_1469576.png\n  [17]: https://upload.wikimedia.org/wikipedia/commons/thumb/5/54/Big-Endian.svg/200px-Big-Endian.svg.png\n  [18]: https://upload.wikimedia.org/wikipedia/commons/thumb/e/ed/Little-Endian.svg/200px-Little-Endian.svg.png\n  [19]: https://en.wikipedia.org/wiki/Variable-length_quantity\n  [20]: https://upload.wikimedia.org/wikipedia/commons/thumb/c/c6/Uintvar_coding.svg/1920px-Uintvar_coding.svg.png\n  [21]: https://www.cnblogs.com/en-heng/p/5570609.html\n  [22]: http://jnb.ociweb.com/jnb/jnbJun2009_files/jnbJun2009_size_comparison.png\n  [23]: https://jin-yang.github.io/post/network-tcpip-timewait.html\n","source":"_posts/thrift源码（五）非阻塞服务端其他实现.md","raw":"---\ntitle: thrift源码（五）非阻塞服务端其他实现\ndate: 2019-11-18 23:35:19\ncategories: thrift源码\ntags: [thrift,rpc框架]\n---\n\n### THsHaServer\n\nHsHa=HalfSync HalfAsync 半同步，半异步\n在处理IO事件时是同步的，在执行invoke方法时是在线程池异步执行的。\n本质上是一个添加了工作线程池的Reactor模型：\n{% asset_img reactor-pool.png image %}\n\n内部使用了一个自定义的线程池ExecutorService，用线程池中的线程执行FrameBuffer的Invoke方法，非常简单。上面已经说明invoke()方法只执行了服务端本地的接口实现类，并没有做IO操作，所以在THsHaServer中IO操作还是在SelectThread线程内完成的。\n<!--more-->\n\n```java\n  //线程池 invoker\n  private ExecutorService invoker;\n\n/**\n   * 重写了requestInvoke方法\n   */\n  @Override\n  protected boolean requestInvoke(FrameBuffer frameBuffer) {\n    try {\n      invoker.execute(new Invocation(frameBuffer));\n      return true;\n    } catch (RejectedExecutionException rx) {\n      LOGGER.warn(\"ExecutorService rejected execution!\", rx);\n      return false;\n    }\n  }\n\n  /**\n   * final修饰的FrameBuffer\n   */\n  private class Invocation implements Runnable {\n\n    private final FrameBuffer frameBuffer;\n\n    public Invocation(final FrameBuffer frameBuffer) {\n      this.frameBuffer = frameBuffer;\n    }\n\n    public void run() {\n      frameBuffer.invoke();\n    }\n  }\n```\n\n下面是THsHaServer对线程池的创建和销毁代码：\nOptions的默认配置是5个线程，60s空闲时间。\n\n```java\n //创建线程池\n protected static ExecutorService createInvokerPool(Options options) {\n    int workerThreads = options.workerThreads;\n    int stopTimeoutVal = options.stopTimeoutVal;\n    TimeUnit stopTimeoutUnit = options.stopTimeoutUnit;\n\n    LinkedBlockingQueue<Runnable> queue = new LinkedBlockingQueue<Runnable>();\n    ExecutorService invoker = new ThreadPoolExecutor(workerThreads, workerThreads,\n      stopTimeoutVal, stopTimeoutUnit, queue);\n\n    return invoker;\n  }\n //等待线程池退出,只要线程池没彻底关闭,即使被中断也要等待足够的时间再退出\n protected void gracefullyShutdownInvokerPool() {\n    // try to gracefully shut down the executor service\n    invoker.shutdown();\n\n    // Loop until awaitTermination finally does return without a interrupted\n    // exception. If we don't do this, then we'll shut down prematurely. We want\n    // to let the executorService clear it's task queue, closing client sockets\n    // appropriately.\n    long timeoutMS = 10000;\n    long now = System.currentTimeMillis();\n    while (timeoutMS >= 0) {\n      try {\n        invoker.awaitTermination(timeoutMS, TimeUnit.MILLISECONDS);\n        break;\n      } catch (InterruptedException ix) {\n        long newnow = System.currentTimeMillis();\n        timeoutMS -= (newnow - now);\n        now = newnow;\n      }\n    }\n  }\n```\n\n### TThreadSelectorServer\n\n我使用的0.5.x版本没有这个server实现，在0.8.x版本thrift添加了TThreadedSelectorServer\n\n据thrift描述：\n在多核环境中，如果瓶颈是单线程的selector获得的CPU计算能力不足, 那么它的性能要优于TNonblockingServer/THsHaServer。\n\n而且because the accept handling is decoupled from\n  reads/writes and invocation, the server has better ability to handle back-pressure from new connections\n  (backpress背压，是一个很有意思的名词，在很多地方有用到 [比如RxJava][7] 或者[背压阀][8])\n\n[TThreadedSelectorServer源码地址][9]\n\nTThreadSelectorServer是**Multiple Reactors**模式的实现，\nmainReactor只负责完成accept操作，子reactor处理读、写事件。图中只画出来一个subReactor线程的情况，实际可能配置多个线程运行subReactor。\n\n{% asset_img reactor-pool.png image %}\n\n在实现**Multiple Reactors**时，TThreadSelectorServer的AcceptThread相当于MainReactor,SelectorThread相当于subReactor,下面只选择部分代码做介绍：\n\n#### TThreadedSelectorServer.java\n\n```java\n//startThreads()方法,初始化AcceptThread和SelectorThread(集合)：\nfor (int i = 0; i < args.selectorThreads; ++i) {\n        selectorThreads.add(new SelectorThread(args.acceptQueueSizePerThread));\n      }\n      acceptThread = new AcceptThread((TNonblockingServerTransport) serverTransport_,\n        createSelectorThreadLoadBalancer(selectorThreads));\n      stopped_ = false;\n      for (SelectorThread thread : selectorThreads) {\n        thread.start();\n      }\n      acceptThread.start();\nreturn true;\n```\n\n#### AcceptThread.java\n\n**run()**方法里只执行select()操作：\n\n```java\npublic void run() {\n      try {\n        while (!stopped_) {\n          select();\n        }\n      } catch (Throwable t) {\n        LOGGER.error(\"run() exiting due to uncaught error\", t);\n      } finally {\n        // This will wake up the selector threads\n        TThreadedSelectorServer.this.stop();\n      }\n}\n```\n\n在**handleAccept()**方法中，处理客户端的建立连接的请求：\nAcceptThread有两种工作模式，FAST_ACCEPT是收到连接请求就接受，FAIR_ACCEPT是把连接请求丢到工作线程池invoker中，这样会等之前的连接请求被工作线程执行后，才会处理后来的连接请求：\n\n```java\nprivate void handleAccept() {\n      final TNonblockingTransport client = doAccept();\n      if (client != null) {\n        // Pass this connection to a selector thread\n        final SelectorThread targetThread = threadChooser.nextThread();\n\n        if (args.acceptPolicy == Args.AcceptPolicy.FAST_ACCEPT || invoker == null) {\n          doAddAccept(targetThread, client);\n        } else {\n          // FAIR_ACCEPT\n          try {\n            invoker.submit(new Runnable() {\n              public void run() {\n                doAddAccept(targetThread, client);\n              }\n            });\n          } catch (RejectedExecutionException rx) {\n            ...\n          }\n        }\n      }\n}\n```\n\n**doAddAccept()**方法，把client连接交给SelectorThread处理，后续的其他操作就和AcceptThread无关了：\n\n```java\nprivate void doAddAccept(SelectorThread thread, TNonblockingTransport client) {\n      if (!thread.addAcceptedConnection(client)) {\n        client.close();\n      }\n}\n```\n\n#### SelectorThread.java\n\n**addAcceptedConnection()**方法\n\nAcceptThread调用它把任务交给SelectorThread处理，客户端连接会被放入SelectorThread的acceptedQueue等待处理：\n\n```java\npublic boolean addAcceptedConnection(TNonblockingTransport accepted) {\n      try {\n        acceptedQueue.put(accepted);\n      } catch (InterruptedException e) {\n        LOGGER.warn(\"Interrupted while adding accepted connection!\", e);\n        return false;\n      }\n      selector.wakeup();\n      return true;\n}\n```\n\n在SelectorThread的**run()**方法\n\n完成对读/写IO事件的select(),处理acceptQueue中的任务，执行processInterestChanges（之前介绍过，触发FrameBuffer的关注事件更新）\n\n```java\nwhile (!stopped_) {\n          select();\n          processAcceptedConnections();\n          processInterestChanges();\n}\n```\n\n**processAcceptedConnections()**方法\n\n从acceptQueue队列取出客户端连接，向selector注册OP_READ事件\n\n```java\nprivate void processAcceptedConnections() {\n      // Register accepted connections\n      while (!stopped_) {\n        TNonblockingTransport accepted = acceptedQueue.poll();\n        if (accepted == null) {\n          break;\n        }\n        registerAccepted(accepted);\n      }\n}\nprivate void registerAccepted(TNonblockingTransport accepted) {\n      SelectionKey clientKey = null;\n      try {\n        clientKey = accepted.registerSelector(selector, SelectionKey.OP_READ);\n\n        FrameBuffer frameBuffer = new FrameBuffer(accepted, clientKey, SelectorThread.this);\n        clientKey.attach(frameBuffer);\n      } catch (IOException e) {\n        ...\n      }\n}\n```\n\n[1]: https://www.ibm.com/developerworks/cn/java/j-lo-apachethrift/image003.jpg\n[2]: https://www.ibm.com/developerworks/cn/java/j-lo-apachethrift/image006.png\n  [3]: https://www.ibm.com/developerworks/cn/java/j-lo-apachethrift/image004.png\n  [4]: http://upload-images.jianshu.io/upload_images/1452123-35a5505c0d9928f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\n  [5]: http://upload-images.jianshu.io/upload_images/1452123-bfb7ef28b21ba29e?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\n  [6]: https://upload-images.jianshu.io/upload_images/3169646-6eddb6e230677349.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/692\n  [7]: http://zhangtielei.com/posts/blog-rxjava-backpressure.html\n  [8]: https://baike.baidu.com/item/%E8%83%8C%E5%8E%8B%E9%98%80\n  [9]: https://github.com/apache/thrift/blob/0.8.x/lib/java/src/org/apache/thrift/server/TThreadedSelectorServer.java\n  [10]: https://upload-images.jianshu.io/upload_images/3169646-eedd2295dcc12725.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/688\n  [11]: https://static.oschina.net/uploads/space/2016/0224/192255_iHyl_1469576.png\n  [12]: https://static.oschina.net/uploads/space/2016/0224/192347_Vfen_1469576.png\n  [13]: https://static.oschina.net/uploads/space/2016/0224/192513_tzOg_1469576.png\n  [14]: https://static.oschina.net/uploads/space/2016/0224/192544_xSFh_1469576.png\n  [15]: https://static.oschina.net/uploads/space/2016/0224/192757_XK9n_1469576.png\n  [16]: https://static.oschina.net/uploads/space/2016/0224/192757_toBx_1469576.png\n  [17]: https://upload.wikimedia.org/wikipedia/commons/thumb/5/54/Big-Endian.svg/200px-Big-Endian.svg.png\n  [18]: https://upload.wikimedia.org/wikipedia/commons/thumb/e/ed/Little-Endian.svg/200px-Little-Endian.svg.png\n  [19]: https://en.wikipedia.org/wiki/Variable-length_quantity\n  [20]: https://upload.wikimedia.org/wikipedia/commons/thumb/c/c6/Uintvar_coding.svg/1920px-Uintvar_coding.svg.png\n  [21]: https://www.cnblogs.com/en-heng/p/5570609.html\n  [22]: http://jnb.ociweb.com/jnb/jnbJun2009_files/jnbJun2009_size_comparison.png\n  [23]: https://jin-yang.github.io/post/network-tcpip-timewait.html\n","slug":"thrift源码（五）非阻塞服务端其他实现","published":1,"updated":"2020-01-30T12:34:03.109Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkqle1cs002fcynecr3b0s3q","content":"<h3 id=\"THsHaServer\"><a href=\"#THsHaServer\" class=\"headerlink\" title=\"THsHaServer\"></a>THsHaServer</h3><p>HsHa=HalfSync HalfAsync 半同步，半异步<br>在处理IO事件时是同步的，在执行invoke方法时是在线程池异步执行的。<br>本质上是一个添加了工作线程池的Reactor模型：<br><img src=\"/2019/11/18/thrift源码（五）非阻塞服务端其他实现/reactor-pool.png\" title=\"image\"></p>\n<p>内部使用了一个自定义的线程池ExecutorService，用线程池中的线程执行FrameBuffer的Invoke方法，非常简单。上面已经说明invoke()方法只执行了服务端本地的接口实现类，并没有做IO操作，所以在THsHaServer中IO操作还是在SelectThread线程内完成的。<br><a id=\"more\"></a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"comment\">//线程池 invoker</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> ExecutorService invoker;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 重写了requestInvoke方法</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">requestInvoke</span><span class=\"params\">(FrameBuffer frameBuffer)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      invoker.execute(<span class=\"keyword\">new</span> Invocation(frameBuffer));</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (RejectedExecutionException rx) &#123;</span><br><span class=\"line\">      LOGGER.warn(<span class=\"string\">\"ExecutorService rejected execution!\"</span>, rx);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * final修饰的FrameBuffer</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Invocation</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> FrameBuffer frameBuffer;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Invocation</span><span class=\"params\">(<span class=\"keyword\">final</span> FrameBuffer frameBuffer)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.frameBuffer = frameBuffer;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      frameBuffer.invoke();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>下面是THsHaServer对线程池的创建和销毁代码：<br>Options的默认配置是5个线程，60s空闲时间。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//创建线程池</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">createInvokerPool</span><span class=\"params\">(Options options)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> workerThreads = options.workerThreads;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> stopTimeoutVal = options.stopTimeoutVal;</span><br><span class=\"line\">   TimeUnit stopTimeoutUnit = options.stopTimeoutUnit;</span><br><span class=\"line\"></span><br><span class=\"line\">   LinkedBlockingQueue&lt;Runnable&gt; queue = <span class=\"keyword\">new</span> LinkedBlockingQueue&lt;Runnable&gt;();</span><br><span class=\"line\">   ExecutorService invoker = <span class=\"keyword\">new</span> ThreadPoolExecutor(workerThreads, workerThreads,</span><br><span class=\"line\">     stopTimeoutVal, stopTimeoutUnit, queue);</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> invoker;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"><span class=\"comment\">//等待线程池退出,只要线程池没彻底关闭,即使被中断也要等待足够的时间再退出</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">gracefullyShutdownInvokerPool</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// try to gracefully shut down the executor service</span></span><br><span class=\"line\">   invoker.shutdown();</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// Loop until awaitTermination finally does return without a interrupted</span></span><br><span class=\"line\">   <span class=\"comment\">// exception. If we don't do this, then we'll shut down prematurely. We want</span></span><br><span class=\"line\">   <span class=\"comment\">// to let the executorService clear it's task queue, closing client sockets</span></span><br><span class=\"line\">   <span class=\"comment\">// appropriately.</span></span><br><span class=\"line\">   <span class=\"keyword\">long</span> timeoutMS = <span class=\"number\">10000</span>;</span><br><span class=\"line\">   <span class=\"keyword\">long</span> now = System.currentTimeMillis();</span><br><span class=\"line\">   <span class=\"keyword\">while</span> (timeoutMS &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">     <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">       invoker.awaitTermination(timeoutMS, TimeUnit.MILLISECONDS);</span><br><span class=\"line\">       <span class=\"keyword\">break</span>;</span><br><span class=\"line\">     &#125; <span class=\"keyword\">catch</span> (InterruptedException ix) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">long</span> newnow = System.currentTimeMillis();</span><br><span class=\"line\">       timeoutMS -= (newnow - now);</span><br><span class=\"line\">       now = newnow;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"TThreadSelectorServer\"><a href=\"#TThreadSelectorServer\" class=\"headerlink\" title=\"TThreadSelectorServer\"></a>TThreadSelectorServer</h3><p>我使用的0.5.x版本没有这个server实现，在0.8.x版本thrift添加了TThreadedSelectorServer</p>\n<p>据thrift描述：<br>在多核环境中，如果瓶颈是单线程的selector获得的CPU计算能力不足, 那么它的性能要优于TNonblockingServer/THsHaServer。</p>\n<p>而且because the accept handling is decoupled from<br>  reads/writes and invocation, the server has better ability to handle back-pressure from new connections<br>  (backpress背压，是一个很有意思的名词，在很多地方有用到 <a href=\"http://zhangtielei.com/posts/blog-rxjava-backpressure.html\" target=\"_blank\" rel=\"noopener\">比如RxJava</a> 或者<a href=\"https://baike.baidu.com/item/%E8%83%8C%E5%8E%8B%E9%98%80\" target=\"_blank\" rel=\"noopener\">背压阀</a>)</p>\n<p><a href=\"https://github.com/apache/thrift/blob/0.8.x/lib/java/src/org/apache/thrift/server/TThreadedSelectorServer.java\" target=\"_blank\" rel=\"noopener\">TThreadedSelectorServer源码地址</a></p>\n<p>TThreadSelectorServer是<strong>Multiple Reactors</strong>模式的实现，<br>mainReactor只负责完成accept操作，子reactor处理读、写事件。图中只画出来一个subReactor线程的情况，实际可能配置多个线程运行subReactor。</p>\n<img src=\"/2019/11/18/thrift源码（五）非阻塞服务端其他实现/reactor-pool.png\" title=\"image\">\n<p>在实现<strong>Multiple Reactors</strong>时，TThreadSelectorServer的AcceptThread相当于MainReactor,SelectorThread相当于subReactor,下面只选择部分代码做介绍：</p>\n<h4 id=\"TThreadedSelectorServer-java\"><a href=\"#TThreadedSelectorServer-java\" class=\"headerlink\" title=\"TThreadedSelectorServer.java\"></a>TThreadedSelectorServer.java</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//startThreads()方法,初始化AcceptThread和SelectorThread(集合)：</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; args.selectorThreads; ++i) &#123;</span><br><span class=\"line\">        selectorThreads.add(<span class=\"keyword\">new</span> SelectorThread(args.acceptQueueSizePerThread));</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      acceptThread = <span class=\"keyword\">new</span> AcceptThread((TNonblockingServerTransport) serverTransport_,</span><br><span class=\"line\">        createSelectorThreadLoadBalancer(selectorThreads));</span><br><span class=\"line\">      stopped_ = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (SelectorThread thread : selectorThreads) &#123;</span><br><span class=\"line\">        thread.start();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      acceptThread.start();</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"AcceptThread-java\"><a href=\"#AcceptThread-java\" class=\"headerlink\" title=\"AcceptThread.java\"></a>AcceptThread.java</h4><p><strong>run()</strong>方法里只执行select()操作：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!stopped_) &#123;</span><br><span class=\"line\">          select();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">        LOGGER.error(<span class=\"string\">\"run() exiting due to uncaught error\"</span>, t);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// This will wake up the selector threads</span></span><br><span class=\"line\">        TThreadedSelectorServer.<span class=\"keyword\">this</span>.stop();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在<strong>handleAccept()</strong>方法中，处理客户端的建立连接的请求：<br>AcceptThread有两种工作模式，FAST_ACCEPT是收到连接请求就接受，FAIR_ACCEPT是把连接请求丢到工作线程池invoker中，这样会等之前的连接请求被工作线程执行后，才会处理后来的连接请求：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">handleAccept</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">final</span> TNonblockingTransport client = doAccept();</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (client != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Pass this connection to a selector thread</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> SelectorThread targetThread = threadChooser.nextThread();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (args.acceptPolicy == Args.AcceptPolicy.FAST_ACCEPT || invoker == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">          doAddAccept(targetThread, client);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          <span class=\"comment\">// FAIR_ACCEPT</span></span><br><span class=\"line\">          <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            invoker.submit(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">              <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                doAddAccept(targetThread, client);</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">          &#125; <span class=\"keyword\">catch</span> (RejectedExecutionException rx) &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>doAddAccept()</strong>方法，把client连接交给SelectorThread处理，后续的其他操作就和AcceptThread无关了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">doAddAccept</span><span class=\"params\">(SelectorThread thread, TNonblockingTransport client)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!thread.addAcceptedConnection(client)) &#123;</span><br><span class=\"line\">        client.close();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"SelectorThread-java\"><a href=\"#SelectorThread-java\" class=\"headerlink\" title=\"SelectorThread.java\"></a>SelectorThread.java</h4><p><strong>addAcceptedConnection()</strong>方法</p>\n<p>AcceptThread调用它把任务交给SelectorThread处理，客户端连接会被放入SelectorThread的acceptedQueue等待处理：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">addAcceptedConnection</span><span class=\"params\">(TNonblockingTransport accepted)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        acceptedQueue.put(accepted);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">        LOGGER.warn(<span class=\"string\">\"Interrupted while adding accepted connection!\"</span>, e);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      selector.wakeup();</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在SelectorThread的<strong>run()</strong>方法</p>\n<p>完成对读/写IO事件的select(),处理acceptQueue中的任务，执行processInterestChanges（之前介绍过，触发FrameBuffer的关注事件更新）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (!stopped_) &#123;</span><br><span class=\"line\">          select();</span><br><span class=\"line\">          processAcceptedConnections();</span><br><span class=\"line\">          processInterestChanges();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>processAcceptedConnections()</strong>方法</p>\n<p>从acceptQueue队列取出客户端连接，向selector注册OP_READ事件</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">processAcceptedConnections</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">// Register accepted connections</span></span><br><span class=\"line\">      <span class=\"keyword\">while</span> (!stopped_) &#123;</span><br><span class=\"line\">        TNonblockingTransport accepted = acceptedQueue.poll();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (accepted == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        registerAccepted(accepted);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">registerAccepted</span><span class=\"params\">(TNonblockingTransport accepted)</span> </span>&#123;</span><br><span class=\"line\">      SelectionKey clientKey = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        clientKey = accepted.registerSelector(selector, SelectionKey.OP_READ);</span><br><span class=\"line\"></span><br><span class=\"line\">        FrameBuffer frameBuffer = <span class=\"keyword\">new</span> FrameBuffer(accepted, clientKey, SelectorThread.<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        clientKey.attach(frameBuffer);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h3 id=\"THsHaServer\"><a href=\"#THsHaServer\" class=\"headerlink\" title=\"THsHaServer\"></a>THsHaServer</h3><p>HsHa=HalfSync HalfAsync 半同步，半异步<br>在处理IO事件时是同步的，在执行invoke方法时是在线程池异步执行的。<br>本质上是一个添加了工作线程池的Reactor模型：<br><img src=\"/2019/11/18/thrift源码（五）非阻塞服务端其他实现/reactor-pool.png\" title=\"image\"></p>\n<p>内部使用了一个自定义的线程池ExecutorService，用线程池中的线程执行FrameBuffer的Invoke方法，非常简单。上面已经说明invoke()方法只执行了服务端本地的接口实现类，并没有做IO操作，所以在THsHaServer中IO操作还是在SelectThread线程内完成的。<br>","more":"</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"comment\">//线程池 invoker</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> ExecutorService invoker;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 重写了requestInvoke方法</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">requestInvoke</span><span class=\"params\">(FrameBuffer frameBuffer)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      invoker.execute(<span class=\"keyword\">new</span> Invocation(frameBuffer));</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (RejectedExecutionException rx) &#123;</span><br><span class=\"line\">      LOGGER.warn(<span class=\"string\">\"ExecutorService rejected execution!\"</span>, rx);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * final修饰的FrameBuffer</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Invocation</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> FrameBuffer frameBuffer;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Invocation</span><span class=\"params\">(<span class=\"keyword\">final</span> FrameBuffer frameBuffer)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.frameBuffer = frameBuffer;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      frameBuffer.invoke();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>下面是THsHaServer对线程池的创建和销毁代码：<br>Options的默认配置是5个线程，60s空闲时间。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//创建线程池</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">createInvokerPool</span><span class=\"params\">(Options options)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> workerThreads = options.workerThreads;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> stopTimeoutVal = options.stopTimeoutVal;</span><br><span class=\"line\">   TimeUnit stopTimeoutUnit = options.stopTimeoutUnit;</span><br><span class=\"line\"></span><br><span class=\"line\">   LinkedBlockingQueue&lt;Runnable&gt; queue = <span class=\"keyword\">new</span> LinkedBlockingQueue&lt;Runnable&gt;();</span><br><span class=\"line\">   ExecutorService invoker = <span class=\"keyword\">new</span> ThreadPoolExecutor(workerThreads, workerThreads,</span><br><span class=\"line\">     stopTimeoutVal, stopTimeoutUnit, queue);</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> invoker;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"><span class=\"comment\">//等待线程池退出,只要线程池没彻底关闭,即使被中断也要等待足够的时间再退出</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">gracefullyShutdownInvokerPool</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// try to gracefully shut down the executor service</span></span><br><span class=\"line\">   invoker.shutdown();</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// Loop until awaitTermination finally does return without a interrupted</span></span><br><span class=\"line\">   <span class=\"comment\">// exception. If we don't do this, then we'll shut down prematurely. We want</span></span><br><span class=\"line\">   <span class=\"comment\">// to let the executorService clear it's task queue, closing client sockets</span></span><br><span class=\"line\">   <span class=\"comment\">// appropriately.</span></span><br><span class=\"line\">   <span class=\"keyword\">long</span> timeoutMS = <span class=\"number\">10000</span>;</span><br><span class=\"line\">   <span class=\"keyword\">long</span> now = System.currentTimeMillis();</span><br><span class=\"line\">   <span class=\"keyword\">while</span> (timeoutMS &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">     <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">       invoker.awaitTermination(timeoutMS, TimeUnit.MILLISECONDS);</span><br><span class=\"line\">       <span class=\"keyword\">break</span>;</span><br><span class=\"line\">     &#125; <span class=\"keyword\">catch</span> (InterruptedException ix) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">long</span> newnow = System.currentTimeMillis();</span><br><span class=\"line\">       timeoutMS -= (newnow - now);</span><br><span class=\"line\">       now = newnow;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"TThreadSelectorServer\"><a href=\"#TThreadSelectorServer\" class=\"headerlink\" title=\"TThreadSelectorServer\"></a>TThreadSelectorServer</h3><p>我使用的0.5.x版本没有这个server实现，在0.8.x版本thrift添加了TThreadedSelectorServer</p>\n<p>据thrift描述：<br>在多核环境中，如果瓶颈是单线程的selector获得的CPU计算能力不足, 那么它的性能要优于TNonblockingServer/THsHaServer。</p>\n<p>而且because the accept handling is decoupled from<br>  reads/writes and invocation, the server has better ability to handle back-pressure from new connections<br>  (backpress背压，是一个很有意思的名词，在很多地方有用到 <a href=\"http://zhangtielei.com/posts/blog-rxjava-backpressure.html\" target=\"_blank\" rel=\"noopener\">比如RxJava</a> 或者<a href=\"https://baike.baidu.com/item/%E8%83%8C%E5%8E%8B%E9%98%80\" target=\"_blank\" rel=\"noopener\">背压阀</a>)</p>\n<p><a href=\"https://github.com/apache/thrift/blob/0.8.x/lib/java/src/org/apache/thrift/server/TThreadedSelectorServer.java\" target=\"_blank\" rel=\"noopener\">TThreadedSelectorServer源码地址</a></p>\n<p>TThreadSelectorServer是<strong>Multiple Reactors</strong>模式的实现，<br>mainReactor只负责完成accept操作，子reactor处理读、写事件。图中只画出来一个subReactor线程的情况，实际可能配置多个线程运行subReactor。</p>\n<img src=\"/2019/11/18/thrift源码（五）非阻塞服务端其他实现/reactor-pool.png\" title=\"image\">\n<p>在实现<strong>Multiple Reactors</strong>时，TThreadSelectorServer的AcceptThread相当于MainReactor,SelectorThread相当于subReactor,下面只选择部分代码做介绍：</p>\n<h4 id=\"TThreadedSelectorServer-java\"><a href=\"#TThreadedSelectorServer-java\" class=\"headerlink\" title=\"TThreadedSelectorServer.java\"></a>TThreadedSelectorServer.java</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//startThreads()方法,初始化AcceptThread和SelectorThread(集合)：</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; args.selectorThreads; ++i) &#123;</span><br><span class=\"line\">        selectorThreads.add(<span class=\"keyword\">new</span> SelectorThread(args.acceptQueueSizePerThread));</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      acceptThread = <span class=\"keyword\">new</span> AcceptThread((TNonblockingServerTransport) serverTransport_,</span><br><span class=\"line\">        createSelectorThreadLoadBalancer(selectorThreads));</span><br><span class=\"line\">      stopped_ = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (SelectorThread thread : selectorThreads) &#123;</span><br><span class=\"line\">        thread.start();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      acceptThread.start();</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"AcceptThread-java\"><a href=\"#AcceptThread-java\" class=\"headerlink\" title=\"AcceptThread.java\"></a>AcceptThread.java</h4><p><strong>run()</strong>方法里只执行select()操作：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!stopped_) &#123;</span><br><span class=\"line\">          select();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">        LOGGER.error(<span class=\"string\">\"run() exiting due to uncaught error\"</span>, t);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// This will wake up the selector threads</span></span><br><span class=\"line\">        TThreadedSelectorServer.<span class=\"keyword\">this</span>.stop();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在<strong>handleAccept()</strong>方法中，处理客户端的建立连接的请求：<br>AcceptThread有两种工作模式，FAST_ACCEPT是收到连接请求就接受，FAIR_ACCEPT是把连接请求丢到工作线程池invoker中，这样会等之前的连接请求被工作线程执行后，才会处理后来的连接请求：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">handleAccept</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">final</span> TNonblockingTransport client = doAccept();</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (client != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Pass this connection to a selector thread</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> SelectorThread targetThread = threadChooser.nextThread();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (args.acceptPolicy == Args.AcceptPolicy.FAST_ACCEPT || invoker == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">          doAddAccept(targetThread, client);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          <span class=\"comment\">// FAIR_ACCEPT</span></span><br><span class=\"line\">          <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            invoker.submit(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">              <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                doAddAccept(targetThread, client);</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">          &#125; <span class=\"keyword\">catch</span> (RejectedExecutionException rx) &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>doAddAccept()</strong>方法，把client连接交给SelectorThread处理，后续的其他操作就和AcceptThread无关了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">doAddAccept</span><span class=\"params\">(SelectorThread thread, TNonblockingTransport client)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!thread.addAcceptedConnection(client)) &#123;</span><br><span class=\"line\">        client.close();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"SelectorThread-java\"><a href=\"#SelectorThread-java\" class=\"headerlink\" title=\"SelectorThread.java\"></a>SelectorThread.java</h4><p><strong>addAcceptedConnection()</strong>方法</p>\n<p>AcceptThread调用它把任务交给SelectorThread处理，客户端连接会被放入SelectorThread的acceptedQueue等待处理：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">addAcceptedConnection</span><span class=\"params\">(TNonblockingTransport accepted)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        acceptedQueue.put(accepted);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">        LOGGER.warn(<span class=\"string\">\"Interrupted while adding accepted connection!\"</span>, e);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      selector.wakeup();</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在SelectorThread的<strong>run()</strong>方法</p>\n<p>完成对读/写IO事件的select(),处理acceptQueue中的任务，执行processInterestChanges（之前介绍过，触发FrameBuffer的关注事件更新）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (!stopped_) &#123;</span><br><span class=\"line\">          select();</span><br><span class=\"line\">          processAcceptedConnections();</span><br><span class=\"line\">          processInterestChanges();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>processAcceptedConnections()</strong>方法</p>\n<p>从acceptQueue队列取出客户端连接，向selector注册OP_READ事件</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">processAcceptedConnections</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">// Register accepted connections</span></span><br><span class=\"line\">      <span class=\"keyword\">while</span> (!stopped_) &#123;</span><br><span class=\"line\">        TNonblockingTransport accepted = acceptedQueue.poll();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (accepted == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        registerAccepted(accepted);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">registerAccepted</span><span class=\"params\">(TNonblockingTransport accepted)</span> </span>&#123;</span><br><span class=\"line\">      SelectionKey clientKey = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        clientKey = accepted.registerSelector(selector, SelectionKey.OP_READ);</span><br><span class=\"line\"></span><br><span class=\"line\">        FrameBuffer frameBuffer = <span class=\"keyword\">new</span> FrameBuffer(accepted, clientKey, SelectorThread.<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        clientKey.attach(frameBuffer);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"为什么Redis使用ziplist能节省内存？","date":"2017-09-12T13:15:46.000Z","_content":"\n\n**环境准备:**\nredis 2.8.19 单机模式\n保存500万条用户信息数据，key是用户名 ，value是json格式字符串，包含邮箱等信息，内容如下:\n`userid:  \"tomcat125\"\ninfo:  \"[null,\\\"tomcat125@gmail.com\\\",188XXXXXXXX,\\\"\\\",null,null,\\\"\\xe9\\x9c\\x8d\\xe6\\xb3\\x13\\xx4\\xb8\\xs0\\\",\\\"1\\\",null,\\\"tom123321\\\"]\"`\n\n\nredis和ziplist配置有关的有这几个，默认值如下：\n<!--more-->\n\n`config get *ziplist*`\n >1) \"hash-max-ziplist-entries\"\n 2) \"512\"\n 3) \"hash-max-ziplist-value\"\n 4) \"64\"\n 5) \"list-max-ziplist-entries\"\n 6) \"512\"\n 7) \"list-max-ziplist-value\"\n 8) \"64\"\n 9) \"zset-max-ziplist-entries\"\n10) \"128\"\n11) \"zset-max-ziplist-value\"\n12) \"64\"\n\n\n-entries表示ziplsit对多保存数据项的个数，超出之后不能再使用ziplist\n-value表示每个数据项的最大字节数，超出之后不能再使用ziplist\n\n## 一.使用ziplist真的能节省内存吗？\n\n在这我用hash对象用户信息，对比一下使用ziplist前后的内存差异：\n为了使用hash保存，对用户名做hash然后取模得到一个hashkey\n然后保存时执行命令：`hset hashkey username info`\n\n### 使用hashtable保存：\nziplist设置：\n>config get hash*\n1) \"hash-max-ziplist-entries\"\n2) \"512\"\n3) \"hash-max-ziplist-value\"\n4) \"64\"\n\nhash对象信息(hashtable保存)：\n>“debug object nozip:3134”\nValue at:0x7f4957621d40 refcount:1 \n**encoding**:**hashtable** \n**serializedlength:39927** \nlru:3356615 lru_seconds_idle:24\n\n\n\n内存占用：\n>“dbsize”\n(integer) 12000\ninfo Memory\n\\# Memory\nused_memory:1102326968\n**used_memory_human:1.03G**\nused_memory_rss:1150930944\nused_memory_peak:1102463200\nused_memory_peak_human:1.03G\nused_memory_lua:35840\nmem_fragmentation_ratio:1.04\n\n\n\n清理内存，重启redis\n```bash\nredis>flushall\nsystemctl stop redis.service\nsystemctl start redis.service\n```\n\n\n### 使用ziplist保存:\n修改ziplist设置(json串平均长度150)：\n>\"config get hash*\"\n1) \"hash-max-ziplist-entries\"\n2) \"1000\"\n3) \"hash-max-ziplist-value\"\n4) \"250\"\n\n\nhash对象信息（ziplist保存）：\n>\"debug object nozip:3134\"\nValue at:0x7f490d21c150 refcount:1\n**encoding:ziplist** \n**serializedlength:18713** \nlru:3360532 lru_seconds_idle:93\n\n\n\n内存占用：\n\n>\"dbsize\"\n(integer) 12000\ninfo Memory\n\\# Memory\nused_memory:573333824\n**used_memory_human:546.77M**\nused_memory_rss:633442304\nused_memory_peak:1102178520\nused_memory_peak_human:1.03G\nused_memory_lua:35840\nmem_fragmentation_ratio:1.10\n\n\n\n\n在上面的例子中可以看到利用ziplist在保存12000个hash对象时，**used_memory节省了近50%**\n同一个key的serializedlength也差不多是原来的一半(39927-18731)，但是serializedLength表示的不是key的实际内存占用，而是保存到rdb文件之后key的占用字节数，小于key的实际内存占用。\n（[参考serializedLength源][1]）\n\n## 二.ziplist为什么能节省内存？\n\n从debug object的输出信息来看，两次分别是使用hashtable和ziplist保存的，为什么ziplist会比hashtable节省内存呢，这要从二者的数据结构说起。\n### 1.hashtable结构：\nhashtable使用字典保存，字典包含两个hashtable,hashtable由entry数组构成，数组中的节点包含一个next指针，形成一个单向链表。\nredis字典定义：\n```c\n//dict.h\n//字典\ntypedef struct dict {\n    dictType *type;\n    void *privdata;\n    dictht ht[2];\n    int rehashidx; /* rehashing not in progress if rehashidx == -1 */\n    int iterators; /* number of iterators currently running */\n} dict;\n//字典内部hashtable\ntypedef struct dictht {\n    dictEntry **table;\n    unsigned long size;\n    unsigned long sizemask;\n    unsigned long used;\n} dictht;\n//hashtable节点\ntypedef struct dictEntry {\n    void *key;\n    union {\n        void *val;\n        uint64_t u64;\n        int64_t s64;\n    } v;\n    struct dictEntry *next;\n} dictEntry;\n```\n下图展示了一个普通状态下的字典,数据保存在ht[0]，ht[1]在扩容时使用：\n![ht][2]\n### 2.ziplist结构：\n**zlbytes**：表示ziplist占用字节数，在执行resize操作时使用\n**zltail**：表示最后节点的偏移量，也是避免了整体遍历list\n**zllen**：表示ziplist节点个数（节点数超过65535,zllen字段值无效,需要遍历才能得到真实数量）\n**zlend**：表示ziplist结束的标识符\n\n**ziplist节点数据结构（抽象）：**\n每个压缩列表节点都由previous_entry_length、encoding、content三个部分组成（不是指实际结构体的字段）\n**previous_entry_length**：前一个节点的长度，用来由后向前遍历，根据前一个节点的长度，可能需要一个或五个字节。\n**encoding**：记录节点保存的数据类型和数据长度。\n**content**：节点保存的数据内容。\nziplist节点结构体（和上面的有点不一样）:\n```c\n//ziplist.c\ntypedef struct zlentry {\n    unsigned int prevrawlensize, prevrawlen;\n    unsigned int lensize, len;\n    unsigned int headersize;\n    unsigned char encoding;\n    unsigned char *p;\n} zlentry;\n```\n下图展示了一个ziplist的基本结构：\n![ziplist][3]\n\n可以看到，ziplist采用了一段连续的内存来存储数据，相比hashtable减少了内存碎片，和指针的内存占用。而且当节点较少时，ziplist更容易被加载到CPU缓存中。\n\n## 三，调试源码\n眼见为实，现在通过vs2012启动redis server，调试redis源码对比hashtable和ziplist的处理过程。\n\n### 调试hashtable保存hash对象\nserver启动后，首先在t_hash.c 的hsetCommand函数打断点\n```c\n//t_hash.c\nvoid hsetCommand(redisClient *c) {\n    int update;\n    robj *o;\n\n    if ((o = hashTypeLookupWriteOrCreate(c,c->argv[1])) == NULL) return;\n    hashTypeTryConversion(o,c->argv,2,3);\n    hashTypeTryObjectEncoding(o,&c->argv[2], &c->argv[3]);\n    update = hashTypeSet(o,c->argv[2],c->argv[3]);\n    addReply(c, update ? shared.czero : shared.cone);\n    signalModifiedKey(c->db,c->argv[1]);\n    server.dirty++;\n}\n```\n在客户端执行命令,修改ziplist配置最大长度改成10，然后添加一个value长度超过10的hash对象：\n```\n127.0.0.1:6379> config set hash-max-ziplist-value 10\n127.0.0.1:6379> hset hash_key fieldkey abcdefghijklmn\n```\n\n进入t_hash.c文件的函数hashTypeSet,在这里redis判断对象编码为hashtable，使用字典保存:\n```c\n//t_hash.c\nelse if (o->encoding == REDIS_ENCODING_HT) {\n        if (dictReplace(o->ptr, field, value)) { /* Insert */\n            incrRefCount(field);\n        } else { /* Update */\n            update = 1;\n        }\n        incrRefCount(value);\n```\n在dict.c文件dictAdd标记断点，开始分别保存key&value到dict：\n```c\n//dict.c\nint dictAdd(dict *d, void *key, void *val)\n{\n    //往字典中添加一个只有key的dictEntry\n    dictEntry *entry = dictAddRaw(d,key);\n\n    if (!entry) return DICT_ERR;\n    //保存entry值的内容\n    dictSetVal(d, entry, val);\n    return DICT_OK;\n}\n```\n首先redis调用函数dictAddRaw()保存hash key\n```c\n//dict.c\ndictEntry *dictAddRaw(dict *d, void *key)\n{\n    int index;\n    dictEntry *entry;\n    dictht *ht;\n    //因为redis采用渐进式rehash，首先要做rehash检查\n    if (dictIsRehashing(d)) _dictRehashStep(d);\n\n    /* Get the index of the new element, or -1 if\n     * the element already exists. */\n    if ((index = _dictKeyIndex(d, key)) == -1)\n        return NULL;\n\n    // 如果字典正在rehash，则插入到新表ht[1]，否则到旧表ht[0]\n    ht = dictIsRehashing(d) ? &d->ht[1] : &d->ht[0];\n    /* 申请内存 保存新的entry节点*/\n    entry = zmalloc(sizeof(*entry));\n    entry->next = ht->table[index];\n    ht->table[index] = entry;\n    ht->used++;\n\n    /* 保存entry key的内容 */\n    dictSetKey(d, entry, key);\n    return entry;\n}\n```\n**估算内存**\n因为内存对齐的原因，sizeof(dictEntry)=24，为entry申请了24字节内存。估算一个节点的字节数 **47byte**(key 9bytes,val 14bytes,entry 24bytes)\n### 调试ziplist保存hash对象\n首先清理数据，修改ziplist配置放宽value长度限制，保存同样内容：\n```\n127.0.0.1:6379> flushall\n127.0.0.1:6379> config set hash-max-ziplist-value 15\n127.0.0.1:6379> hset hash_key fieldkey abcdefghijklmn\n```\n此时还是在t_hash.c文件的函数hashTypeSet打断点,redis选择用ziplist编码保存hash对象\n```c\n//t_hash.c hashTypeSet()\nif (o->encoding == REDIS_ENCODING_ZIPLIST) {\n        unsigned char *zl, *fptr, *vptr;\n\n        field = getDecodedObject(field);\n        value = getDecodedObject(value);\n\n        zl = o->ptr;\n        fptr = ziplistIndex(zl, ZIPLIST_HEAD);\n        if (fptr != NULL) {\n            //略\n        }\n\n        if (!update) {\n            /* Push new field/value pair onto the tail of the ziplist */\n            zl = ziplistPush(zl, field->ptr, (unsigned int)sdslen(field->ptr), ZIPLIST_TAIL);\n            zl = ziplistPush(zl, value->ptr, (unsigned int)sdslen(value->ptr), ZIPLIST_TAIL);\n        }\n        o->ptr = zl;\n        //引用计数\n        decrRefCount(field);\n        decrRefCount(value);\n\n        /*检查是否要换成hashtable编码*/\n        if (hashTypeLength(o) > server.hash_max_ziplist_entries)\n            hashTypeConvert(o, REDIS_ENCODING_HT);\n    }\n```\n在ziplistPush内部调用了 ziplistInsert()函数，打开ziplist.c文件，在__ziplistInsert()函数打断点：\n\n```c   \n//ziplist.c\nstatic unsigned char *__ziplistInsert(unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen) {\n    //当前ziplist的长度\n    size_t curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), reqlen;\n    unsigned int prevlensize, prevlen = 0;\n    size_t offset;\n    int nextdiff = 0;\n    unsigned char encoding = 0;\n    long long value = 123456789; \n    zlentry tail;\n\n    if (p[0] != ZIP_END) {\n        // 如果p节点后面还有节点，取出p节点前一个节点的长度信息和存储该长度值所需要的字节数信息\n        ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);\n    } else {\n        // 如果p节点为ziplist结束标识，则取出尾节点，即最后一个节点\n        unsigned char *ptail = ZIPLIST_ENTRY_TAIL(zl);\n        if (ptail[0] != ZIP_END) {\n            prevlen = zipRawEntryLength(ptail);\n        }\n    }\n\n    // 尝试看能否将s保存为整数，如果可以则返回1，且value和encoding分别保存新值和编码信息\n    if (zipTryEncoding(s,slen,&value,&encoding)) {\n        // 如果s可以保存为整数，则进一步计算保存该数值所需要的字节数\n        reqlen = zipIntSize(encoding);\n    } else {\n        // 如果s不能保存为整数，则直接使用其字符串长度\n        reqlen = slen;\n    }\n    \n    // 计算编码prevlen所需要的字节数，prevlen用于保存前一个节点的长度\n    reqlen += zipPrevEncodeLength(NULL,prevlen);\n    // 计算编码slen所需要的长度\n    reqlen += zipEncodeLength(NULL,encoding,slen);\n\n    \n    // 当插入的位置不是ziplist尾部时，需要确保下一个节点（即p节点）的prevlen能够用来保存即将插入节点的长度\n    // 这里计算两者差值\n    nextdiff = (p[0] != ZIP_END) ? zipPrevLenByteDiff(p,reqlen) : 0;\n\n    // ziplistResize操作会重新分配空间，需要事前记录p节点偏移量\n    offset = p-zl;\n    zl = ziplistResize(zl,curlen+reqlen+nextdiff);\n    // 重新取得p节点\n    p = zl+offset;\n\n    /* Apply memory move when necessary and update tail offset. */\n    if (p[0] != ZIP_END) {\n        /* 将原来 p-nextdiff 开始的数据全部后移，中间出现reqlen个字节保存即将插入的数据 \n            主要需要考虑一下几种情况：\n            nextdiff == 0：p节点中用来存储原先前一个节点长度信息的数据区域正好保存待插入节点的长度\n            nextdiff == 4：原先p节点只需要1个字节来存储上一个节点的长度，现在需要5个字节。那就将p-4后面的数据偏移到p+reqlen\n            nextdiff == -4：原先p节点需要5个字节来存储上一个节点的长度，现在只需要1个字节。那就将p+4后面的数据偏移到p+reqlen\n        */\n        memmove(p+reqlen,p-nextdiff,curlen-offset-1+nextdiff);\n\n        // 为p节点的prevlen设置新值，即待插入节点的长度\n        zipPrevEncodeLength(p+reqlen,reqlen);\n\n        // 更新尾节点偏移量\n        ZIPLIST_TAIL_OFFSET(zl) =\n            intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+reqlen);\n\n        tail = zipEntry(p+reqlen);\n        // 同样，如果p节点不是尾节点，尾节点的偏移量还需要加上nextdiff值\n        if (p[reqlen+tail.headersize+tail.len] != ZIP_END) {\n            ZIPLIST_TAIL_OFFSET(zl) =\n                intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+nextdiff);\n        }\n    } else {\n        // 如果p节点指向zlend，更新zltail值，待添加节点为尾部节点\n        ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(p-zl);\n    }\n    \n    // 同样，如果nextdiff的值不为0，说明原节点（此时的首地址为p+reqlen）的长度发生改变，需要执行级联更新操作\n    if (nextdiff != 0) {\n        offset = p-zl;\n        //这里可能造成连锁更新\n        zl = __ziplistCascadeUpdate(zl,p+reqlen);\n        p = zl+offset;\n    }\n\n    // 下面才是真正执行插入操作\n    /* Write the entry */\n    // 填写上一节点的长度\n    p += zipPrevEncodeLength(p,prevlen);\n    // 填写当前节点的长度\n    p += zipEncodeLength(p,encoding,slen);\n    // 根据编码方式执行相应的插入操作\n    if (ZIP_IS_STR(encoding)) {\n        memcpy(p,s,slen);\n    } else {\n        zipSaveInteger(p,value,encoding);\n    }\n    // 长度加1\n    ZIPLIST_INCR_LENGTH(zl,1);\n    return zl;\n}\n\n```\n**估算内存**\ncurlen表示当前ziplist的占用字节数,curlen初始值11，保存\"fieldkey\"后变为21，保存\"abcdefghijklmn\"变成38，估计一个节点占用**27字节**。\n\n**注意：**当在ziplist头部执行增加或删除操作时，如果节点长度过长（超过255），previous_entry_length要使用5个字节保存，这时会执行__ziplistCascadeUpdate()函数，可能触发连锁更新，最坏情况要更新每一个后继节点（previous_entry_length从一个字节变成5个字节后，所有节点长度都超过了255）。\n\n## 总结\n**ziplist的优点**\n内存占用少 容易被加载到CPU缓存\n结构紧凑 减少内存碎片\n\n**ziplist的缺点**\n连锁更新（头部插入 或 删除，对头部的操作主要是在用ziplist保存list类型对象时发送，保存hash对象不需要在头部更新。）\n查询复杂度从O（1）变成O（N）（保存hash对象时）\n\n\t\n\n参考：\n[Redis内置数据结构之压缩列表ziplist][4]\n[vs2012调试redis][5]\n[《redis设计与实现》][6]\n\n\n  [1]: https://github.com/antirez/redis/blob/4082c38a60eedd524c78ef48c1b241105f4ddc50/src/debug.c#L337-L343\n  [2]: /images/redis/ht.png\n  [3]: /images/redis/ziplist.png\n  [4]: http://blog.csdn.net/xiejingfa/article/details/51072326\n  [5]: http://blog.csdn.net/Rongbo_J/article/details/45288223\n  [6]: http://www.duokan.com/book/53962","source":"_posts/为什么Redis使用ziplist能节省内存.md","raw":"\ntitle: 为什么Redis使用ziplist能节省内存？\ndate: 2017-09-12 21:15:46\ncategories: redis进阶\ntags: [redis,源码,nosql]\n\n---\n\n\n**环境准备:**\nredis 2.8.19 单机模式\n保存500万条用户信息数据，key是用户名 ，value是json格式字符串，包含邮箱等信息，内容如下:\n`userid:  \"tomcat125\"\ninfo:  \"[null,\\\"tomcat125@gmail.com\\\",188XXXXXXXX,\\\"\\\",null,null,\\\"\\xe9\\x9c\\x8d\\xe6\\xb3\\x13\\xx4\\xb8\\xs0\\\",\\\"1\\\",null,\\\"tom123321\\\"]\"`\n\n\nredis和ziplist配置有关的有这几个，默认值如下：\n<!--more-->\n\n`config get *ziplist*`\n >1) \"hash-max-ziplist-entries\"\n 2) \"512\"\n 3) \"hash-max-ziplist-value\"\n 4) \"64\"\n 5) \"list-max-ziplist-entries\"\n 6) \"512\"\n 7) \"list-max-ziplist-value\"\n 8) \"64\"\n 9) \"zset-max-ziplist-entries\"\n10) \"128\"\n11) \"zset-max-ziplist-value\"\n12) \"64\"\n\n\n-entries表示ziplsit对多保存数据项的个数，超出之后不能再使用ziplist\n-value表示每个数据项的最大字节数，超出之后不能再使用ziplist\n\n## 一.使用ziplist真的能节省内存吗？\n\n在这我用hash对象用户信息，对比一下使用ziplist前后的内存差异：\n为了使用hash保存，对用户名做hash然后取模得到一个hashkey\n然后保存时执行命令：`hset hashkey username info`\n\n### 使用hashtable保存：\nziplist设置：\n>config get hash*\n1) \"hash-max-ziplist-entries\"\n2) \"512\"\n3) \"hash-max-ziplist-value\"\n4) \"64\"\n\nhash对象信息(hashtable保存)：\n>“debug object nozip:3134”\nValue at:0x7f4957621d40 refcount:1 \n**encoding**:**hashtable** \n**serializedlength:39927** \nlru:3356615 lru_seconds_idle:24\n\n\n\n内存占用：\n>“dbsize”\n(integer) 12000\ninfo Memory\n\\# Memory\nused_memory:1102326968\n**used_memory_human:1.03G**\nused_memory_rss:1150930944\nused_memory_peak:1102463200\nused_memory_peak_human:1.03G\nused_memory_lua:35840\nmem_fragmentation_ratio:1.04\n\n\n\n清理内存，重启redis\n```bash\nredis>flushall\nsystemctl stop redis.service\nsystemctl start redis.service\n```\n\n\n### 使用ziplist保存:\n修改ziplist设置(json串平均长度150)：\n>\"config get hash*\"\n1) \"hash-max-ziplist-entries\"\n2) \"1000\"\n3) \"hash-max-ziplist-value\"\n4) \"250\"\n\n\nhash对象信息（ziplist保存）：\n>\"debug object nozip:3134\"\nValue at:0x7f490d21c150 refcount:1\n**encoding:ziplist** \n**serializedlength:18713** \nlru:3360532 lru_seconds_idle:93\n\n\n\n内存占用：\n\n>\"dbsize\"\n(integer) 12000\ninfo Memory\n\\# Memory\nused_memory:573333824\n**used_memory_human:546.77M**\nused_memory_rss:633442304\nused_memory_peak:1102178520\nused_memory_peak_human:1.03G\nused_memory_lua:35840\nmem_fragmentation_ratio:1.10\n\n\n\n\n在上面的例子中可以看到利用ziplist在保存12000个hash对象时，**used_memory节省了近50%**\n同一个key的serializedlength也差不多是原来的一半(39927-18731)，但是serializedLength表示的不是key的实际内存占用，而是保存到rdb文件之后key的占用字节数，小于key的实际内存占用。\n（[参考serializedLength源][1]）\n\n## 二.ziplist为什么能节省内存？\n\n从debug object的输出信息来看，两次分别是使用hashtable和ziplist保存的，为什么ziplist会比hashtable节省内存呢，这要从二者的数据结构说起。\n### 1.hashtable结构：\nhashtable使用字典保存，字典包含两个hashtable,hashtable由entry数组构成，数组中的节点包含一个next指针，形成一个单向链表。\nredis字典定义：\n```c\n//dict.h\n//字典\ntypedef struct dict {\n    dictType *type;\n    void *privdata;\n    dictht ht[2];\n    int rehashidx; /* rehashing not in progress if rehashidx == -1 */\n    int iterators; /* number of iterators currently running */\n} dict;\n//字典内部hashtable\ntypedef struct dictht {\n    dictEntry **table;\n    unsigned long size;\n    unsigned long sizemask;\n    unsigned long used;\n} dictht;\n//hashtable节点\ntypedef struct dictEntry {\n    void *key;\n    union {\n        void *val;\n        uint64_t u64;\n        int64_t s64;\n    } v;\n    struct dictEntry *next;\n} dictEntry;\n```\n下图展示了一个普通状态下的字典,数据保存在ht[0]，ht[1]在扩容时使用：\n![ht][2]\n### 2.ziplist结构：\n**zlbytes**：表示ziplist占用字节数，在执行resize操作时使用\n**zltail**：表示最后节点的偏移量，也是避免了整体遍历list\n**zllen**：表示ziplist节点个数（节点数超过65535,zllen字段值无效,需要遍历才能得到真实数量）\n**zlend**：表示ziplist结束的标识符\n\n**ziplist节点数据结构（抽象）：**\n每个压缩列表节点都由previous_entry_length、encoding、content三个部分组成（不是指实际结构体的字段）\n**previous_entry_length**：前一个节点的长度，用来由后向前遍历，根据前一个节点的长度，可能需要一个或五个字节。\n**encoding**：记录节点保存的数据类型和数据长度。\n**content**：节点保存的数据内容。\nziplist节点结构体（和上面的有点不一样）:\n```c\n//ziplist.c\ntypedef struct zlentry {\n    unsigned int prevrawlensize, prevrawlen;\n    unsigned int lensize, len;\n    unsigned int headersize;\n    unsigned char encoding;\n    unsigned char *p;\n} zlentry;\n```\n下图展示了一个ziplist的基本结构：\n![ziplist][3]\n\n可以看到，ziplist采用了一段连续的内存来存储数据，相比hashtable减少了内存碎片，和指针的内存占用。而且当节点较少时，ziplist更容易被加载到CPU缓存中。\n\n## 三，调试源码\n眼见为实，现在通过vs2012启动redis server，调试redis源码对比hashtable和ziplist的处理过程。\n\n### 调试hashtable保存hash对象\nserver启动后，首先在t_hash.c 的hsetCommand函数打断点\n```c\n//t_hash.c\nvoid hsetCommand(redisClient *c) {\n    int update;\n    robj *o;\n\n    if ((o = hashTypeLookupWriteOrCreate(c,c->argv[1])) == NULL) return;\n    hashTypeTryConversion(o,c->argv,2,3);\n    hashTypeTryObjectEncoding(o,&c->argv[2], &c->argv[3]);\n    update = hashTypeSet(o,c->argv[2],c->argv[3]);\n    addReply(c, update ? shared.czero : shared.cone);\n    signalModifiedKey(c->db,c->argv[1]);\n    server.dirty++;\n}\n```\n在客户端执行命令,修改ziplist配置最大长度改成10，然后添加一个value长度超过10的hash对象：\n```\n127.0.0.1:6379> config set hash-max-ziplist-value 10\n127.0.0.1:6379> hset hash_key fieldkey abcdefghijklmn\n```\n\n进入t_hash.c文件的函数hashTypeSet,在这里redis判断对象编码为hashtable，使用字典保存:\n```c\n//t_hash.c\nelse if (o->encoding == REDIS_ENCODING_HT) {\n        if (dictReplace(o->ptr, field, value)) { /* Insert */\n            incrRefCount(field);\n        } else { /* Update */\n            update = 1;\n        }\n        incrRefCount(value);\n```\n在dict.c文件dictAdd标记断点，开始分别保存key&value到dict：\n```c\n//dict.c\nint dictAdd(dict *d, void *key, void *val)\n{\n    //往字典中添加一个只有key的dictEntry\n    dictEntry *entry = dictAddRaw(d,key);\n\n    if (!entry) return DICT_ERR;\n    //保存entry值的内容\n    dictSetVal(d, entry, val);\n    return DICT_OK;\n}\n```\n首先redis调用函数dictAddRaw()保存hash key\n```c\n//dict.c\ndictEntry *dictAddRaw(dict *d, void *key)\n{\n    int index;\n    dictEntry *entry;\n    dictht *ht;\n    //因为redis采用渐进式rehash，首先要做rehash检查\n    if (dictIsRehashing(d)) _dictRehashStep(d);\n\n    /* Get the index of the new element, or -1 if\n     * the element already exists. */\n    if ((index = _dictKeyIndex(d, key)) == -1)\n        return NULL;\n\n    // 如果字典正在rehash，则插入到新表ht[1]，否则到旧表ht[0]\n    ht = dictIsRehashing(d) ? &d->ht[1] : &d->ht[0];\n    /* 申请内存 保存新的entry节点*/\n    entry = zmalloc(sizeof(*entry));\n    entry->next = ht->table[index];\n    ht->table[index] = entry;\n    ht->used++;\n\n    /* 保存entry key的内容 */\n    dictSetKey(d, entry, key);\n    return entry;\n}\n```\n**估算内存**\n因为内存对齐的原因，sizeof(dictEntry)=24，为entry申请了24字节内存。估算一个节点的字节数 **47byte**(key 9bytes,val 14bytes,entry 24bytes)\n### 调试ziplist保存hash对象\n首先清理数据，修改ziplist配置放宽value长度限制，保存同样内容：\n```\n127.0.0.1:6379> flushall\n127.0.0.1:6379> config set hash-max-ziplist-value 15\n127.0.0.1:6379> hset hash_key fieldkey abcdefghijklmn\n```\n此时还是在t_hash.c文件的函数hashTypeSet打断点,redis选择用ziplist编码保存hash对象\n```c\n//t_hash.c hashTypeSet()\nif (o->encoding == REDIS_ENCODING_ZIPLIST) {\n        unsigned char *zl, *fptr, *vptr;\n\n        field = getDecodedObject(field);\n        value = getDecodedObject(value);\n\n        zl = o->ptr;\n        fptr = ziplistIndex(zl, ZIPLIST_HEAD);\n        if (fptr != NULL) {\n            //略\n        }\n\n        if (!update) {\n            /* Push new field/value pair onto the tail of the ziplist */\n            zl = ziplistPush(zl, field->ptr, (unsigned int)sdslen(field->ptr), ZIPLIST_TAIL);\n            zl = ziplistPush(zl, value->ptr, (unsigned int)sdslen(value->ptr), ZIPLIST_TAIL);\n        }\n        o->ptr = zl;\n        //引用计数\n        decrRefCount(field);\n        decrRefCount(value);\n\n        /*检查是否要换成hashtable编码*/\n        if (hashTypeLength(o) > server.hash_max_ziplist_entries)\n            hashTypeConvert(o, REDIS_ENCODING_HT);\n    }\n```\n在ziplistPush内部调用了 ziplistInsert()函数，打开ziplist.c文件，在__ziplistInsert()函数打断点：\n\n```c   \n//ziplist.c\nstatic unsigned char *__ziplistInsert(unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen) {\n    //当前ziplist的长度\n    size_t curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), reqlen;\n    unsigned int prevlensize, prevlen = 0;\n    size_t offset;\n    int nextdiff = 0;\n    unsigned char encoding = 0;\n    long long value = 123456789; \n    zlentry tail;\n\n    if (p[0] != ZIP_END) {\n        // 如果p节点后面还有节点，取出p节点前一个节点的长度信息和存储该长度值所需要的字节数信息\n        ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);\n    } else {\n        // 如果p节点为ziplist结束标识，则取出尾节点，即最后一个节点\n        unsigned char *ptail = ZIPLIST_ENTRY_TAIL(zl);\n        if (ptail[0] != ZIP_END) {\n            prevlen = zipRawEntryLength(ptail);\n        }\n    }\n\n    // 尝试看能否将s保存为整数，如果可以则返回1，且value和encoding分别保存新值和编码信息\n    if (zipTryEncoding(s,slen,&value,&encoding)) {\n        // 如果s可以保存为整数，则进一步计算保存该数值所需要的字节数\n        reqlen = zipIntSize(encoding);\n    } else {\n        // 如果s不能保存为整数，则直接使用其字符串长度\n        reqlen = slen;\n    }\n    \n    // 计算编码prevlen所需要的字节数，prevlen用于保存前一个节点的长度\n    reqlen += zipPrevEncodeLength(NULL,prevlen);\n    // 计算编码slen所需要的长度\n    reqlen += zipEncodeLength(NULL,encoding,slen);\n\n    \n    // 当插入的位置不是ziplist尾部时，需要确保下一个节点（即p节点）的prevlen能够用来保存即将插入节点的长度\n    // 这里计算两者差值\n    nextdiff = (p[0] != ZIP_END) ? zipPrevLenByteDiff(p,reqlen) : 0;\n\n    // ziplistResize操作会重新分配空间，需要事前记录p节点偏移量\n    offset = p-zl;\n    zl = ziplistResize(zl,curlen+reqlen+nextdiff);\n    // 重新取得p节点\n    p = zl+offset;\n\n    /* Apply memory move when necessary and update tail offset. */\n    if (p[0] != ZIP_END) {\n        /* 将原来 p-nextdiff 开始的数据全部后移，中间出现reqlen个字节保存即将插入的数据 \n            主要需要考虑一下几种情况：\n            nextdiff == 0：p节点中用来存储原先前一个节点长度信息的数据区域正好保存待插入节点的长度\n            nextdiff == 4：原先p节点只需要1个字节来存储上一个节点的长度，现在需要5个字节。那就将p-4后面的数据偏移到p+reqlen\n            nextdiff == -4：原先p节点需要5个字节来存储上一个节点的长度，现在只需要1个字节。那就将p+4后面的数据偏移到p+reqlen\n        */\n        memmove(p+reqlen,p-nextdiff,curlen-offset-1+nextdiff);\n\n        // 为p节点的prevlen设置新值，即待插入节点的长度\n        zipPrevEncodeLength(p+reqlen,reqlen);\n\n        // 更新尾节点偏移量\n        ZIPLIST_TAIL_OFFSET(zl) =\n            intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+reqlen);\n\n        tail = zipEntry(p+reqlen);\n        // 同样，如果p节点不是尾节点，尾节点的偏移量还需要加上nextdiff值\n        if (p[reqlen+tail.headersize+tail.len] != ZIP_END) {\n            ZIPLIST_TAIL_OFFSET(zl) =\n                intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+nextdiff);\n        }\n    } else {\n        // 如果p节点指向zlend，更新zltail值，待添加节点为尾部节点\n        ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(p-zl);\n    }\n    \n    // 同样，如果nextdiff的值不为0，说明原节点（此时的首地址为p+reqlen）的长度发生改变，需要执行级联更新操作\n    if (nextdiff != 0) {\n        offset = p-zl;\n        //这里可能造成连锁更新\n        zl = __ziplistCascadeUpdate(zl,p+reqlen);\n        p = zl+offset;\n    }\n\n    // 下面才是真正执行插入操作\n    /* Write the entry */\n    // 填写上一节点的长度\n    p += zipPrevEncodeLength(p,prevlen);\n    // 填写当前节点的长度\n    p += zipEncodeLength(p,encoding,slen);\n    // 根据编码方式执行相应的插入操作\n    if (ZIP_IS_STR(encoding)) {\n        memcpy(p,s,slen);\n    } else {\n        zipSaveInteger(p,value,encoding);\n    }\n    // 长度加1\n    ZIPLIST_INCR_LENGTH(zl,1);\n    return zl;\n}\n\n```\n**估算内存**\ncurlen表示当前ziplist的占用字节数,curlen初始值11，保存\"fieldkey\"后变为21，保存\"abcdefghijklmn\"变成38，估计一个节点占用**27字节**。\n\n**注意：**当在ziplist头部执行增加或删除操作时，如果节点长度过长（超过255），previous_entry_length要使用5个字节保存，这时会执行__ziplistCascadeUpdate()函数，可能触发连锁更新，最坏情况要更新每一个后继节点（previous_entry_length从一个字节变成5个字节后，所有节点长度都超过了255）。\n\n## 总结\n**ziplist的优点**\n内存占用少 容易被加载到CPU缓存\n结构紧凑 减少内存碎片\n\n**ziplist的缺点**\n连锁更新（头部插入 或 删除，对头部的操作主要是在用ziplist保存list类型对象时发送，保存hash对象不需要在头部更新。）\n查询复杂度从O（1）变成O（N）（保存hash对象时）\n\n\t\n\n参考：\n[Redis内置数据结构之压缩列表ziplist][4]\n[vs2012调试redis][5]\n[《redis设计与实现》][6]\n\n\n  [1]: https://github.com/antirez/redis/blob/4082c38a60eedd524c78ef48c1b241105f4ddc50/src/debug.c#L337-L343\n  [2]: /images/redis/ht.png\n  [3]: /images/redis/ziplist.png\n  [4]: http://blog.csdn.net/xiejingfa/article/details/51072326\n  [5]: http://blog.csdn.net/Rongbo_J/article/details/45288223\n  [6]: http://www.duokan.com/book/53962","slug":"为什么Redis使用ziplist能节省内存","published":1,"updated":"2019-05-04T15:56:14.635Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkqle1ct002jcynec1hkbd76","content":"<p><strong>环境准备:</strong><br>redis 2.8.19 单机模式<br>保存500万条用户信息数据，key是用户名 ，value是json格式字符串，包含邮箱等信息，内容如下:<br><code>userid:  &quot;tomcat125&quot;\ninfo:  &quot;[null,\\&quot;tomcat125@gmail.com\\&quot;,188XXXXXXXX,\\&quot;\\&quot;,null,null,\\&quot;\\xe9\\x9c\\x8d\\xe6\\xb3\\x13\\xx4\\xb8\\xs0\\&quot;,\\&quot;1\\&quot;,null,\\&quot;tom123321\\&quot;]&quot;</code></p>\n<p>redis和ziplist配置有关的有这几个，默认值如下：<br><a id=\"more\"></a></p>\n<p><code>config get *ziplist*</code></p>\n<blockquote>\n<p>1) “hash-max-ziplist-entries”<br> 2) “512”<br> 3) “hash-max-ziplist-value”<br> 4) “64”<br> 5) “list-max-ziplist-entries”<br> 6) “512”<br> 7) “list-max-ziplist-value”<br> 8) “64”<br> 9) “zset-max-ziplist-entries”<br>10) “128”<br>11) “zset-max-ziplist-value”<br>12) “64”</p>\n</blockquote>\n<p>-entries表示ziplsit对多保存数据项的个数，超出之后不能再使用ziplist<br>-value表示每个数据项的最大字节数，超出之后不能再使用ziplist</p>\n<h2 id=\"一-使用ziplist真的能节省内存吗？\"><a href=\"#一-使用ziplist真的能节省内存吗？\" class=\"headerlink\" title=\"一.使用ziplist真的能节省内存吗？\"></a>一.使用ziplist真的能节省内存吗？</h2><p>在这我用hash对象用户信息，对比一下使用ziplist前后的内存差异：<br>为了使用hash保存，对用户名做hash然后取模得到一个hashkey<br>然后保存时执行命令：<code>hset hashkey username info</code></p>\n<h3 id=\"使用hashtable保存：\"><a href=\"#使用hashtable保存：\" class=\"headerlink\" title=\"使用hashtable保存：\"></a>使用hashtable保存：</h3><p>ziplist设置：</p>\n<blockquote>\n<p>config get hash*<br>1) “hash-max-ziplist-entries”<br>2) “512”<br>3) “hash-max-ziplist-value”<br>4) “64”</p>\n</blockquote>\n<p>hash对象信息(hashtable保存)：</p>\n<blockquote>\n<p>“debug object nozip:3134”<br>Value at:0x7f4957621d40 refcount:1<br><strong>encoding</strong>:<strong>hashtable</strong><br><strong>serializedlength:39927</strong><br>lru:3356615 lru_seconds_idle:24</p>\n</blockquote>\n<p>内存占用：</p>\n<blockquote>\n<p>“dbsize”<br>(integer) 12000<br>info Memory<br># Memory<br>used_memory:1102326968<br><strong>used_memory_human:1.03G</strong><br>used_memory_rss:1150930944<br>used_memory_peak:1102463200<br>used_memory_peak_human:1.03G<br>used_memory_lua:35840<br>mem_fragmentation_ratio:1.04</p>\n</blockquote>\n<p>清理内存，重启redis<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt;flushall</span><br><span class=\"line\">systemctl stop redis.service</span><br><span class=\"line\">systemctl start redis.service</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"使用ziplist保存\"><a href=\"#使用ziplist保存\" class=\"headerlink\" title=\"使用ziplist保存:\"></a>使用ziplist保存:</h3><p>修改ziplist设置(json串平均长度150)：</p>\n<blockquote>\n<p>“config get hash*”<br>1) “hash-max-ziplist-entries”<br>2) “1000”<br>3) “hash-max-ziplist-value”<br>4) “250”</p>\n</blockquote>\n<p>hash对象信息（ziplist保存）：</p>\n<blockquote>\n<p>“debug object nozip:3134”<br>Value at:0x7f490d21c150 refcount:1<br><strong>encoding:ziplist</strong><br><strong>serializedlength:18713</strong><br>lru:3360532 lru_seconds_idle:93</p>\n</blockquote>\n<p>内存占用：</p>\n<blockquote>\n<p>“dbsize”<br>(integer) 12000<br>info Memory<br># Memory<br>used_memory:573333824<br><strong>used_memory_human:546.77M</strong><br>used_memory_rss:633442304<br>used_memory_peak:1102178520<br>used_memory_peak_human:1.03G<br>used_memory_lua:35840<br>mem_fragmentation_ratio:1.10</p>\n</blockquote>\n<p>在上面的例子中可以看到利用ziplist在保存12000个hash对象时，<strong>used_memory节省了近50%</strong><br>同一个key的serializedlength也差不多是原来的一半(39927-18731)，但是serializedLength表示的不是key的实际内存占用，而是保存到rdb文件之后key的占用字节数，小于key的实际内存占用。<br>（<a href=\"https://github.com/antirez/redis/blob/4082c38a60eedd524c78ef48c1b241105f4ddc50/src/debug.c#L337-L343\" target=\"_blank\" rel=\"noopener\">参考serializedLength源</a>）</p>\n<h2 id=\"二-ziplist为什么能节省内存？\"><a href=\"#二-ziplist为什么能节省内存？\" class=\"headerlink\" title=\"二.ziplist为什么能节省内存？\"></a>二.ziplist为什么能节省内存？</h2><p>从debug object的输出信息来看，两次分别是使用hashtable和ziplist保存的，为什么ziplist会比hashtable节省内存呢，这要从二者的数据结构说起。</p>\n<h3 id=\"1-hashtable结构：\"><a href=\"#1-hashtable结构：\" class=\"headerlink\" title=\"1.hashtable结构：\"></a>1.hashtable结构：</h3><p>hashtable使用字典保存，字典包含两个hashtable,hashtable由entry数组构成，数组中的节点包含一个next指针，形成一个单向链表。<br>redis字典定义：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//dict.h</span></span><br><span class=\"line\"><span class=\"comment\">//字典</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dict</span> &#123;</span></span><br><span class=\"line\">    dictType *type;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> *privdata;</span><br><span class=\"line\">    dictht ht[<span class=\"number\">2</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> rehashidx; <span class=\"comment\">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> iterators; <span class=\"comment\">/* number of iterators currently running */</span></span><br><span class=\"line\">&#125; dict;</span><br><span class=\"line\"><span class=\"comment\">//字典内部hashtable</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictht</span> &#123;</span></span><br><span class=\"line\">    dictEntry **table;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> size;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> sizemask;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> used;</span><br><span class=\"line\">&#125; dictht;</span><br><span class=\"line\"><span class=\"comment\">//hashtable节点</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictEntry</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *key;</span><br><span class=\"line\">    <span class=\"keyword\">union</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">void</span> *val;</span><br><span class=\"line\">        <span class=\"keyword\">uint64_t</span> u64;</span><br><span class=\"line\">        <span class=\"keyword\">int64_t</span> s64;</span><br><span class=\"line\">    &#125; v;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictEntry</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125; dictEntry;</span><br></pre></td></tr></table></figure></p>\n<p>下图展示了一个普通状态下的字典,数据保存在ht[0]，ht<a href=\"https://github.com/antirez/redis/blob/4082c38a60eedd524c78ef48c1b241105f4ddc50/src/debug.c#L337-L343\" target=\"_blank\" rel=\"noopener\">1</a>在扩容时使用：<br><img src=\"/images/redis/ht.png\" alt=\"ht\"></p>\n<h3 id=\"2-ziplist结构：\"><a href=\"#2-ziplist结构：\" class=\"headerlink\" title=\"2.ziplist结构：\"></a>2.ziplist结构：</h3><p><strong>zlbytes</strong>：表示ziplist占用字节数，在执行resize操作时使用<br><strong>zltail</strong>：表示最后节点的偏移量，也是避免了整体遍历list<br><strong>zllen</strong>：表示ziplist节点个数（节点数超过65535,zllen字段值无效,需要遍历才能得到真实数量）<br><strong>zlend</strong>：表示ziplist结束的标识符</p>\n<p><strong>ziplist节点数据结构（抽象）：</strong><br>每个压缩列表节点都由previous_entry_length、encoding、content三个部分组成（不是指实际结构体的字段）<br><strong>previous_entry_length</strong>：前一个节点的长度，用来由后向前遍历，根据前一个节点的长度，可能需要一个或五个字节。<br><strong>encoding</strong>：记录节点保存的数据类型和数据长度。<br><strong>content</strong>：节点保存的数据内容。<br>ziplist节点结构体（和上面的有点不一样）:<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//ziplist.c</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zlentry</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> prevrawlensize, prevrawlen;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> lensize, len;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> headersize;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> encoding;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *p;</span><br><span class=\"line\">&#125; zlentry;</span><br></pre></td></tr></table></figure></p>\n<p>下图展示了一个ziplist的基本结构：<br><img src=\"/images/redis/ziplist.png\" alt=\"ziplist\"></p>\n<p>可以看到，ziplist采用了一段连续的内存来存储数据，相比hashtable减少了内存碎片，和指针的内存占用。而且当节点较少时，ziplist更容易被加载到CPU缓存中。</p>\n<h2 id=\"三，调试源码\"><a href=\"#三，调试源码\" class=\"headerlink\" title=\"三，调试源码\"></a>三，调试源码</h2><p>眼见为实，现在通过vs2012启动redis server，调试redis源码对比hashtable和ziplist的处理过程。</p>\n<h3 id=\"调试hashtable保存hash对象\"><a href=\"#调试hashtable保存hash对象\" class=\"headerlink\" title=\"调试hashtable保存hash对象\"></a>调试hashtable保存hash对象</h3><p>server启动后，首先在t_hash.c 的hsetCommand函数打断点<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//t_hash.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">hsetCommand</span><span class=\"params\">(redisClient *c)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> update;</span><br><span class=\"line\">    robj *o;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((o = hashTypeLookupWriteOrCreate(c,c-&gt;argv[<span class=\"number\">1</span>])) == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    hashTypeTryConversion(o,c-&gt;argv,<span class=\"number\">2</span>,<span class=\"number\">3</span>);</span><br><span class=\"line\">    hashTypeTryObjectEncoding(o,&amp;c-&gt;argv[<span class=\"number\">2</span>], &amp;c-&gt;argv[<span class=\"number\">3</span>]);</span><br><span class=\"line\">    update = hashTypeSet(o,c-&gt;argv[<span class=\"number\">2</span>],c-&gt;argv[<span class=\"number\">3</span>]);</span><br><span class=\"line\">    addReply(c, update ? shared.czero : shared.cone);</span><br><span class=\"line\">    signalModifiedKey(c-&gt;db,c-&gt;argv[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    server.dirty++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在客户端执行命令,修改ziplist配置最大长度改成10，然后添加一个value长度超过10的hash对象：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; config set hash-max-ziplist-value 10</span><br><span class=\"line\">127.0.0.1:6379&gt; hset hash_key fieldkey abcdefghijklmn</span><br></pre></td></tr></table></figure></p>\n<p>进入t_hash.c文件的函数hashTypeSet,在这里redis判断对象编码为hashtable，使用字典保存:<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//t_hash.c</span></span><br><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (o-&gt;encoding == REDIS_ENCODING_HT) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dictReplace(o-&gt;ptr, field, value)) &#123; <span class=\"comment\">/* Insert */</span></span><br><span class=\"line\">            incrRefCount(field);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">/* Update */</span></span><br><span class=\"line\">            update = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        incrRefCount(value);</span><br></pre></td></tr></table></figure></p>\n<p>在dict.c文件dictAdd标记断点，开始分别保存key&amp;value到dict：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//dict.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dictAdd</span><span class=\"params\">(dict *d, <span class=\"keyword\">void</span> *key, <span class=\"keyword\">void</span> *val)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//往字典中添加一个只有key的dictEntry</span></span><br><span class=\"line\">    dictEntry *entry = dictAddRaw(d,key);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!entry) <span class=\"keyword\">return</span> DICT_ERR;</span><br><span class=\"line\">    <span class=\"comment\">//保存entry值的内容</span></span><br><span class=\"line\">    dictSetVal(d, entry, val);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> DICT_OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>首先redis调用函数dictAddRaw()保存hash key<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//dict.c</span></span><br><span class=\"line\"><span class=\"function\">dictEntry *<span class=\"title\">dictAddRaw</span><span class=\"params\">(dict *d, <span class=\"keyword\">void</span> *key)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> index;</span><br><span class=\"line\">    dictEntry *entry;</span><br><span class=\"line\">    dictht *ht;</span><br><span class=\"line\">    <span class=\"comment\">//因为redis采用渐进式rehash，首先要做rehash检查</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dictIsRehashing(d)) _dictRehashStep(d);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Get the index of the new element, or -1 if</span></span><br><span class=\"line\"><span class=\"comment\">     * the element already exists. */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((index = _dictKeyIndex(d, key)) == <span class=\"number\">-1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果字典正在rehash，则插入到新表ht[1]，否则到旧表ht[0]</span></span><br><span class=\"line\">    ht = dictIsRehashing(d) ? &amp;d-&gt;ht[<span class=\"number\">1</span>] : &amp;d-&gt;ht[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"comment\">/* 申请内存 保存新的entry节点*/</span></span><br><span class=\"line\">    entry = zmalloc(<span class=\"keyword\">sizeof</span>(*entry));</span><br><span class=\"line\">    entry-&gt;next = ht-&gt;table[index];</span><br><span class=\"line\">    ht-&gt;table[index] = entry;</span><br><span class=\"line\">    ht-&gt;used++;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* 保存entry key的内容 */</span></span><br><span class=\"line\">    dictSetKey(d, entry, key);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> entry;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>估算内存</strong><br>因为内存对齐的原因，sizeof(dictEntry)=24，为entry申请了24字节内存。估算一个节点的字节数 <strong>47byte</strong>(key 9bytes,val 14bytes,entry 24bytes)</p>\n<h3 id=\"调试ziplist保存hash对象\"><a href=\"#调试ziplist保存hash对象\" class=\"headerlink\" title=\"调试ziplist保存hash对象\"></a>调试ziplist保存hash对象</h3><p>首先清理数据，修改ziplist配置放宽value长度限制，保存同样内容：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; flushall</span><br><span class=\"line\">127.0.0.1:6379&gt; config set hash-max-ziplist-value 15</span><br><span class=\"line\">127.0.0.1:6379&gt; hset hash_key fieldkey abcdefghijklmn</span><br></pre></td></tr></table></figure></p>\n<p>此时还是在t_hash.c文件的函数hashTypeSet打断点,redis选择用ziplist编码保存hash对象<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//t_hash.c hashTypeSet()</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (o-&gt;encoding == REDIS_ENCODING_ZIPLIST) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *zl, *fptr, *vptr;</span><br><span class=\"line\"></span><br><span class=\"line\">        field = getDecodedObject(field);</span><br><span class=\"line\">        value = getDecodedObject(value);</span><br><span class=\"line\"></span><br><span class=\"line\">        zl = o-&gt;ptr;</span><br><span class=\"line\">        fptr = ziplistIndex(zl, ZIPLIST_HEAD);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (fptr != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//略</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!update) &#123;</span><br><span class=\"line\">            <span class=\"comment\">/* Push new field/value pair onto the tail of the ziplist */</span></span><br><span class=\"line\">            zl = ziplistPush(zl, field-&gt;ptr, (<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>)sdslen(field-&gt;ptr), ZIPLIST_TAIL);</span><br><span class=\"line\">            zl = ziplistPush(zl, value-&gt;ptr, (<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>)sdslen(value-&gt;ptr), ZIPLIST_TAIL);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        o-&gt;ptr = zl;</span><br><span class=\"line\">        <span class=\"comment\">//引用计数</span></span><br><span class=\"line\">        decrRefCount(field);</span><br><span class=\"line\">        decrRefCount(value);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*检查是否要换成hashtable编码*/</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (hashTypeLength(o) &gt; server.hash_max_ziplist_entries)</span><br><span class=\"line\">            hashTypeConvert(o, REDIS_ENCODING_HT);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>在ziplistPush内部调用了 ziplistInsert()函数，打开ziplist.c文件，在__ziplistInsert()函数打断点：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//ziplist.c</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *__ziplistInsert(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *zl, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *p, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *s, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> slen) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//当前ziplist的长度</span></span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), reqlen;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> prevlensize, prevlen = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> offset;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> nextdiff = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> encoding = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> value = <span class=\"number\">123456789</span>; </span><br><span class=\"line\">    zlentry tail;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p[<span class=\"number\">0</span>] != ZIP_END) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果p节点后面还有节点，取出p节点前一个节点的长度信息和存储该长度值所需要的字节数信息</span></span><br><span class=\"line\">        ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果p节点为ziplist结束标识，则取出尾节点，即最后一个节点</span></span><br><span class=\"line\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *ptail = ZIPLIST_ENTRY_TAIL(zl);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ptail[<span class=\"number\">0</span>] != ZIP_END) &#123;</span><br><span class=\"line\">            prevlen = zipRawEntryLength(ptail);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 尝试看能否将s保存为整数，如果可以则返回1，且value和encoding分别保存新值和编码信息</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (zipTryEncoding(s,slen,&amp;value,&amp;encoding)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果s可以保存为整数，则进一步计算保存该数值所需要的字节数</span></span><br><span class=\"line\">        reqlen = zipIntSize(encoding);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果s不能保存为整数，则直接使用其字符串长度</span></span><br><span class=\"line\">        reqlen = slen;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 计算编码prevlen所需要的字节数，prevlen用于保存前一个节点的长度</span></span><br><span class=\"line\">    reqlen += zipPrevEncodeLength(<span class=\"literal\">NULL</span>,prevlen);</span><br><span class=\"line\">    <span class=\"comment\">// 计算编码slen所需要的长度</span></span><br><span class=\"line\">    reqlen += zipEncodeLength(<span class=\"literal\">NULL</span>,encoding,slen);</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 当插入的位置不是ziplist尾部时，需要确保下一个节点（即p节点）的prevlen能够用来保存即将插入节点的长度</span></span><br><span class=\"line\">    <span class=\"comment\">// 这里计算两者差值</span></span><br><span class=\"line\">    nextdiff = (p[<span class=\"number\">0</span>] != ZIP_END) ? zipPrevLenByteDiff(p,reqlen) : <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ziplistResize操作会重新分配空间，需要事前记录p节点偏移量</span></span><br><span class=\"line\">    offset = p-zl;</span><br><span class=\"line\">    zl = ziplistResize(zl,curlen+reqlen+nextdiff);</span><br><span class=\"line\">    <span class=\"comment\">// 重新取得p节点</span></span><br><span class=\"line\">    p = zl+offset;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Apply memory move when necessary and update tail offset. */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p[<span class=\"number\">0</span>] != ZIP_END) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/* 将原来 p-nextdiff 开始的数据全部后移，中间出现reqlen个字节保存即将插入的数据 </span></span><br><span class=\"line\"><span class=\"comment\">            主要需要考虑一下几种情况：</span></span><br><span class=\"line\"><span class=\"comment\">            nextdiff == 0：p节点中用来存储原先前一个节点长度信息的数据区域正好保存待插入节点的长度</span></span><br><span class=\"line\"><span class=\"comment\">            nextdiff == 4：原先p节点只需要1个字节来存储上一个节点的长度，现在需要5个字节。那就将p-4后面的数据偏移到p+reqlen</span></span><br><span class=\"line\"><span class=\"comment\">            nextdiff == -4：原先p节点需要5个字节来存储上一个节点的长度，现在只需要1个字节。那就将p+4后面的数据偏移到p+reqlen</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">        memmove(p+reqlen,p-nextdiff,curlen-offset<span class=\"number\">-1</span>+nextdiff);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 为p节点的prevlen设置新值，即待插入节点的长度</span></span><br><span class=\"line\">        zipPrevEncodeLength(p+reqlen,reqlen);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 更新尾节点偏移量</span></span><br><span class=\"line\">        ZIPLIST_TAIL_OFFSET(zl) =</span><br><span class=\"line\">            intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+reqlen);</span><br><span class=\"line\"></span><br><span class=\"line\">        tail = zipEntry(p+reqlen);</span><br><span class=\"line\">        <span class=\"comment\">// 同样，如果p节点不是尾节点，尾节点的偏移量还需要加上nextdiff值</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p[reqlen+tail.headersize+tail.len] != ZIP_END) &#123;</span><br><span class=\"line\">            ZIPLIST_TAIL_OFFSET(zl) =</span><br><span class=\"line\">                intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+nextdiff);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果p节点指向zlend，更新zltail值，待添加节点为尾部节点</span></span><br><span class=\"line\">        ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(p-zl);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 同样，如果nextdiff的值不为0，说明原节点（此时的首地址为p+reqlen）的长度发生改变，需要执行级联更新操作</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nextdiff != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        offset = p-zl;</span><br><span class=\"line\">        <span class=\"comment\">//这里可能造成连锁更新</span></span><br><span class=\"line\">        zl = __ziplistCascadeUpdate(zl,p+reqlen);</span><br><span class=\"line\">        p = zl+offset;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 下面才是真正执行插入操作</span></span><br><span class=\"line\">    <span class=\"comment\">/* Write the entry */</span></span><br><span class=\"line\">    <span class=\"comment\">// 填写上一节点的长度</span></span><br><span class=\"line\">    p += zipPrevEncodeLength(p,prevlen);</span><br><span class=\"line\">    <span class=\"comment\">// 填写当前节点的长度</span></span><br><span class=\"line\">    p += zipEncodeLength(p,encoding,slen);</span><br><span class=\"line\">    <span class=\"comment\">// 根据编码方式执行相应的插入操作</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ZIP_IS_STR(encoding)) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">memcpy</span>(p,s,slen);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        zipSaveInteger(p,value,encoding);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 长度加1</span></span><br><span class=\"line\">    ZIPLIST_INCR_LENGTH(zl,<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> zl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>估算内存</strong><br>curlen表示当前ziplist的占用字节数,curlen初始值11，保存”fieldkey”后变为21，保存”abcdefghijklmn”变成38，估计一个节点占用<strong>27字节</strong>。</p>\n<p><strong>注意：</strong>当在ziplist头部执行增加或删除操作时，如果节点长度过长（超过255），previous_entry_length要使用5个字节保存，这时会执行__ziplistCascadeUpdate()函数，可能触发连锁更新，最坏情况要更新每一个后继节点（previous_entry_length从一个字节变成5个字节后，所有节点长度都超过了255）。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p><strong>ziplist的优点</strong><br>内存占用少 容易被加载到CPU缓存<br>结构紧凑 减少内存碎片</p>\n<p><strong>ziplist的缺点</strong><br>连锁更新（头部插入 或 删除，对头部的操作主要是在用ziplist保存list类型对象时发送，保存hash对象不需要在头部更新。）<br>查询复杂度从O（1）变成O（N）（保存hash对象时）</p>\n<p>参考：<br><a href=\"http://blog.csdn.net/xiejingfa/article/details/51072326\" target=\"_blank\" rel=\"noopener\">Redis内置数据结构之压缩列表ziplist</a><br><a href=\"http://blog.csdn.net/Rongbo_J/article/details/45288223\" target=\"_blank\" rel=\"noopener\">vs2012调试redis</a><br><a href=\"http://www.duokan.com/book/53962\" target=\"_blank\" rel=\"noopener\">《redis设计与实现》</a></p>\n","site":{"data":{}},"excerpt":"<p><strong>环境准备:</strong><br>redis 2.8.19 单机模式<br>保存500万条用户信息数据，key是用户名 ，value是json格式字符串，包含邮箱等信息，内容如下:<br><code>userid:  &quot;tomcat125&quot;\ninfo:  &quot;[null,\\&quot;tomcat125@gmail.com\\&quot;,188XXXXXXXX,\\&quot;\\&quot;,null,null,\\&quot;\\xe9\\x9c\\x8d\\xe6\\xb3\\x13\\xx4\\xb8\\xs0\\&quot;,\\&quot;1\\&quot;,null,\\&quot;tom123321\\&quot;]&quot;</code></p>\n<p>redis和ziplist配置有关的有这几个，默认值如下：<br>","more":"</p>\n<p><code>config get *ziplist*</code></p>\n<blockquote>\n<p>1) “hash-max-ziplist-entries”<br> 2) “512”<br> 3) “hash-max-ziplist-value”<br> 4) “64”<br> 5) “list-max-ziplist-entries”<br> 6) “512”<br> 7) “list-max-ziplist-value”<br> 8) “64”<br> 9) “zset-max-ziplist-entries”<br>10) “128”<br>11) “zset-max-ziplist-value”<br>12) “64”</p>\n</blockquote>\n<p>-entries表示ziplsit对多保存数据项的个数，超出之后不能再使用ziplist<br>-value表示每个数据项的最大字节数，超出之后不能再使用ziplist</p>\n<h2 id=\"一-使用ziplist真的能节省内存吗？\"><a href=\"#一-使用ziplist真的能节省内存吗？\" class=\"headerlink\" title=\"一.使用ziplist真的能节省内存吗？\"></a>一.使用ziplist真的能节省内存吗？</h2><p>在这我用hash对象用户信息，对比一下使用ziplist前后的内存差异：<br>为了使用hash保存，对用户名做hash然后取模得到一个hashkey<br>然后保存时执行命令：<code>hset hashkey username info</code></p>\n<h3 id=\"使用hashtable保存：\"><a href=\"#使用hashtable保存：\" class=\"headerlink\" title=\"使用hashtable保存：\"></a>使用hashtable保存：</h3><p>ziplist设置：</p>\n<blockquote>\n<p>config get hash*<br>1) “hash-max-ziplist-entries”<br>2) “512”<br>3) “hash-max-ziplist-value”<br>4) “64”</p>\n</blockquote>\n<p>hash对象信息(hashtable保存)：</p>\n<blockquote>\n<p>“debug object nozip:3134”<br>Value at:0x7f4957621d40 refcount:1<br><strong>encoding</strong>:<strong>hashtable</strong><br><strong>serializedlength:39927</strong><br>lru:3356615 lru_seconds_idle:24</p>\n</blockquote>\n<p>内存占用：</p>\n<blockquote>\n<p>“dbsize”<br>(integer) 12000<br>info Memory<br># Memory<br>used_memory:1102326968<br><strong>used_memory_human:1.03G</strong><br>used_memory_rss:1150930944<br>used_memory_peak:1102463200<br>used_memory_peak_human:1.03G<br>used_memory_lua:35840<br>mem_fragmentation_ratio:1.04</p>\n</blockquote>\n<p>清理内存，重启redis<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt;flushall</span><br><span class=\"line\">systemctl stop redis.service</span><br><span class=\"line\">systemctl start redis.service</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"使用ziplist保存\"><a href=\"#使用ziplist保存\" class=\"headerlink\" title=\"使用ziplist保存:\"></a>使用ziplist保存:</h3><p>修改ziplist设置(json串平均长度150)：</p>\n<blockquote>\n<p>“config get hash*”<br>1) “hash-max-ziplist-entries”<br>2) “1000”<br>3) “hash-max-ziplist-value”<br>4) “250”</p>\n</blockquote>\n<p>hash对象信息（ziplist保存）：</p>\n<blockquote>\n<p>“debug object nozip:3134”<br>Value at:0x7f490d21c150 refcount:1<br><strong>encoding:ziplist</strong><br><strong>serializedlength:18713</strong><br>lru:3360532 lru_seconds_idle:93</p>\n</blockquote>\n<p>内存占用：</p>\n<blockquote>\n<p>“dbsize”<br>(integer) 12000<br>info Memory<br># Memory<br>used_memory:573333824<br><strong>used_memory_human:546.77M</strong><br>used_memory_rss:633442304<br>used_memory_peak:1102178520<br>used_memory_peak_human:1.03G<br>used_memory_lua:35840<br>mem_fragmentation_ratio:1.10</p>\n</blockquote>\n<p>在上面的例子中可以看到利用ziplist在保存12000个hash对象时，<strong>used_memory节省了近50%</strong><br>同一个key的serializedlength也差不多是原来的一半(39927-18731)，但是serializedLength表示的不是key的实际内存占用，而是保存到rdb文件之后key的占用字节数，小于key的实际内存占用。<br>（<a href=\"https://github.com/antirez/redis/blob/4082c38a60eedd524c78ef48c1b241105f4ddc50/src/debug.c#L337-L343\" target=\"_blank\" rel=\"noopener\">参考serializedLength源</a>）</p>\n<h2 id=\"二-ziplist为什么能节省内存？\"><a href=\"#二-ziplist为什么能节省内存？\" class=\"headerlink\" title=\"二.ziplist为什么能节省内存？\"></a>二.ziplist为什么能节省内存？</h2><p>从debug object的输出信息来看，两次分别是使用hashtable和ziplist保存的，为什么ziplist会比hashtable节省内存呢，这要从二者的数据结构说起。</p>\n<h3 id=\"1-hashtable结构：\"><a href=\"#1-hashtable结构：\" class=\"headerlink\" title=\"1.hashtable结构：\"></a>1.hashtable结构：</h3><p>hashtable使用字典保存，字典包含两个hashtable,hashtable由entry数组构成，数组中的节点包含一个next指针，形成一个单向链表。<br>redis字典定义：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//dict.h</span></span><br><span class=\"line\"><span class=\"comment\">//字典</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dict</span> &#123;</span></span><br><span class=\"line\">    dictType *type;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> *privdata;</span><br><span class=\"line\">    dictht ht[<span class=\"number\">2</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> rehashidx; <span class=\"comment\">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> iterators; <span class=\"comment\">/* number of iterators currently running */</span></span><br><span class=\"line\">&#125; dict;</span><br><span class=\"line\"><span class=\"comment\">//字典内部hashtable</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictht</span> &#123;</span></span><br><span class=\"line\">    dictEntry **table;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> size;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> sizemask;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> used;</span><br><span class=\"line\">&#125; dictht;</span><br><span class=\"line\"><span class=\"comment\">//hashtable节点</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictEntry</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *key;</span><br><span class=\"line\">    <span class=\"keyword\">union</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">void</span> *val;</span><br><span class=\"line\">        <span class=\"keyword\">uint64_t</span> u64;</span><br><span class=\"line\">        <span class=\"keyword\">int64_t</span> s64;</span><br><span class=\"line\">    &#125; v;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictEntry</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125; dictEntry;</span><br></pre></td></tr></table></figure></p>\n<p>下图展示了一个普通状态下的字典,数据保存在ht[0]，ht<a href=\"https://github.com/antirez/redis/blob/4082c38a60eedd524c78ef48c1b241105f4ddc50/src/debug.c#L337-L343\" target=\"_blank\" rel=\"noopener\">1</a>在扩容时使用：<br><img src=\"/images/redis/ht.png\" alt=\"ht\"></p>\n<h3 id=\"2-ziplist结构：\"><a href=\"#2-ziplist结构：\" class=\"headerlink\" title=\"2.ziplist结构：\"></a>2.ziplist结构：</h3><p><strong>zlbytes</strong>：表示ziplist占用字节数，在执行resize操作时使用<br><strong>zltail</strong>：表示最后节点的偏移量，也是避免了整体遍历list<br><strong>zllen</strong>：表示ziplist节点个数（节点数超过65535,zllen字段值无效,需要遍历才能得到真实数量）<br><strong>zlend</strong>：表示ziplist结束的标识符</p>\n<p><strong>ziplist节点数据结构（抽象）：</strong><br>每个压缩列表节点都由previous_entry_length、encoding、content三个部分组成（不是指实际结构体的字段）<br><strong>previous_entry_length</strong>：前一个节点的长度，用来由后向前遍历，根据前一个节点的长度，可能需要一个或五个字节。<br><strong>encoding</strong>：记录节点保存的数据类型和数据长度。<br><strong>content</strong>：节点保存的数据内容。<br>ziplist节点结构体（和上面的有点不一样）:<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//ziplist.c</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zlentry</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> prevrawlensize, prevrawlen;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> lensize, len;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> headersize;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> encoding;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *p;</span><br><span class=\"line\">&#125; zlentry;</span><br></pre></td></tr></table></figure></p>\n<p>下图展示了一个ziplist的基本结构：<br><img src=\"/images/redis/ziplist.png\" alt=\"ziplist\"></p>\n<p>可以看到，ziplist采用了一段连续的内存来存储数据，相比hashtable减少了内存碎片，和指针的内存占用。而且当节点较少时，ziplist更容易被加载到CPU缓存中。</p>\n<h2 id=\"三，调试源码\"><a href=\"#三，调试源码\" class=\"headerlink\" title=\"三，调试源码\"></a>三，调试源码</h2><p>眼见为实，现在通过vs2012启动redis server，调试redis源码对比hashtable和ziplist的处理过程。</p>\n<h3 id=\"调试hashtable保存hash对象\"><a href=\"#调试hashtable保存hash对象\" class=\"headerlink\" title=\"调试hashtable保存hash对象\"></a>调试hashtable保存hash对象</h3><p>server启动后，首先在t_hash.c 的hsetCommand函数打断点<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//t_hash.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">hsetCommand</span><span class=\"params\">(redisClient *c)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> update;</span><br><span class=\"line\">    robj *o;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((o = hashTypeLookupWriteOrCreate(c,c-&gt;argv[<span class=\"number\">1</span>])) == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    hashTypeTryConversion(o,c-&gt;argv,<span class=\"number\">2</span>,<span class=\"number\">3</span>);</span><br><span class=\"line\">    hashTypeTryObjectEncoding(o,&amp;c-&gt;argv[<span class=\"number\">2</span>], &amp;c-&gt;argv[<span class=\"number\">3</span>]);</span><br><span class=\"line\">    update = hashTypeSet(o,c-&gt;argv[<span class=\"number\">2</span>],c-&gt;argv[<span class=\"number\">3</span>]);</span><br><span class=\"line\">    addReply(c, update ? shared.czero : shared.cone);</span><br><span class=\"line\">    signalModifiedKey(c-&gt;db,c-&gt;argv[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    server.dirty++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在客户端执行命令,修改ziplist配置最大长度改成10，然后添加一个value长度超过10的hash对象：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; config set hash-max-ziplist-value 10</span><br><span class=\"line\">127.0.0.1:6379&gt; hset hash_key fieldkey abcdefghijklmn</span><br></pre></td></tr></table></figure></p>\n<p>进入t_hash.c文件的函数hashTypeSet,在这里redis判断对象编码为hashtable，使用字典保存:<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//t_hash.c</span></span><br><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (o-&gt;encoding == REDIS_ENCODING_HT) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dictReplace(o-&gt;ptr, field, value)) &#123; <span class=\"comment\">/* Insert */</span></span><br><span class=\"line\">            incrRefCount(field);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">/* Update */</span></span><br><span class=\"line\">            update = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        incrRefCount(value);</span><br></pre></td></tr></table></figure></p>\n<p>在dict.c文件dictAdd标记断点，开始分别保存key&amp;value到dict：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//dict.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dictAdd</span><span class=\"params\">(dict *d, <span class=\"keyword\">void</span> *key, <span class=\"keyword\">void</span> *val)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//往字典中添加一个只有key的dictEntry</span></span><br><span class=\"line\">    dictEntry *entry = dictAddRaw(d,key);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!entry) <span class=\"keyword\">return</span> DICT_ERR;</span><br><span class=\"line\">    <span class=\"comment\">//保存entry值的内容</span></span><br><span class=\"line\">    dictSetVal(d, entry, val);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> DICT_OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>首先redis调用函数dictAddRaw()保存hash key<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//dict.c</span></span><br><span class=\"line\"><span class=\"function\">dictEntry *<span class=\"title\">dictAddRaw</span><span class=\"params\">(dict *d, <span class=\"keyword\">void</span> *key)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> index;</span><br><span class=\"line\">    dictEntry *entry;</span><br><span class=\"line\">    dictht *ht;</span><br><span class=\"line\">    <span class=\"comment\">//因为redis采用渐进式rehash，首先要做rehash检查</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dictIsRehashing(d)) _dictRehashStep(d);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Get the index of the new element, or -1 if</span></span><br><span class=\"line\"><span class=\"comment\">     * the element already exists. */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((index = _dictKeyIndex(d, key)) == <span class=\"number\">-1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果字典正在rehash，则插入到新表ht[1]，否则到旧表ht[0]</span></span><br><span class=\"line\">    ht = dictIsRehashing(d) ? &amp;d-&gt;ht[<span class=\"number\">1</span>] : &amp;d-&gt;ht[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"comment\">/* 申请内存 保存新的entry节点*/</span></span><br><span class=\"line\">    entry = zmalloc(<span class=\"keyword\">sizeof</span>(*entry));</span><br><span class=\"line\">    entry-&gt;next = ht-&gt;table[index];</span><br><span class=\"line\">    ht-&gt;table[index] = entry;</span><br><span class=\"line\">    ht-&gt;used++;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* 保存entry key的内容 */</span></span><br><span class=\"line\">    dictSetKey(d, entry, key);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> entry;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>估算内存</strong><br>因为内存对齐的原因，sizeof(dictEntry)=24，为entry申请了24字节内存。估算一个节点的字节数 <strong>47byte</strong>(key 9bytes,val 14bytes,entry 24bytes)</p>\n<h3 id=\"调试ziplist保存hash对象\"><a href=\"#调试ziplist保存hash对象\" class=\"headerlink\" title=\"调试ziplist保存hash对象\"></a>调试ziplist保存hash对象</h3><p>首先清理数据，修改ziplist配置放宽value长度限制，保存同样内容：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; flushall</span><br><span class=\"line\">127.0.0.1:6379&gt; config set hash-max-ziplist-value 15</span><br><span class=\"line\">127.0.0.1:6379&gt; hset hash_key fieldkey abcdefghijklmn</span><br></pre></td></tr></table></figure></p>\n<p>此时还是在t_hash.c文件的函数hashTypeSet打断点,redis选择用ziplist编码保存hash对象<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//t_hash.c hashTypeSet()</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (o-&gt;encoding == REDIS_ENCODING_ZIPLIST) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *zl, *fptr, *vptr;</span><br><span class=\"line\"></span><br><span class=\"line\">        field = getDecodedObject(field);</span><br><span class=\"line\">        value = getDecodedObject(value);</span><br><span class=\"line\"></span><br><span class=\"line\">        zl = o-&gt;ptr;</span><br><span class=\"line\">        fptr = ziplistIndex(zl, ZIPLIST_HEAD);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (fptr != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//略</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!update) &#123;</span><br><span class=\"line\">            <span class=\"comment\">/* Push new field/value pair onto the tail of the ziplist */</span></span><br><span class=\"line\">            zl = ziplistPush(zl, field-&gt;ptr, (<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>)sdslen(field-&gt;ptr), ZIPLIST_TAIL);</span><br><span class=\"line\">            zl = ziplistPush(zl, value-&gt;ptr, (<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>)sdslen(value-&gt;ptr), ZIPLIST_TAIL);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        o-&gt;ptr = zl;</span><br><span class=\"line\">        <span class=\"comment\">//引用计数</span></span><br><span class=\"line\">        decrRefCount(field);</span><br><span class=\"line\">        decrRefCount(value);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*检查是否要换成hashtable编码*/</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (hashTypeLength(o) &gt; server.hash_max_ziplist_entries)</span><br><span class=\"line\">            hashTypeConvert(o, REDIS_ENCODING_HT);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>在ziplistPush内部调用了 ziplistInsert()函数，打开ziplist.c文件，在__ziplistInsert()函数打断点：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//ziplist.c</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *__ziplistInsert(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *zl, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *p, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *s, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> slen) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//当前ziplist的长度</span></span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), reqlen;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> prevlensize, prevlen = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> offset;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> nextdiff = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> encoding = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> value = <span class=\"number\">123456789</span>; </span><br><span class=\"line\">    zlentry tail;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p[<span class=\"number\">0</span>] != ZIP_END) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果p节点后面还有节点，取出p节点前一个节点的长度信息和存储该长度值所需要的字节数信息</span></span><br><span class=\"line\">        ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果p节点为ziplist结束标识，则取出尾节点，即最后一个节点</span></span><br><span class=\"line\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *ptail = ZIPLIST_ENTRY_TAIL(zl);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ptail[<span class=\"number\">0</span>] != ZIP_END) &#123;</span><br><span class=\"line\">            prevlen = zipRawEntryLength(ptail);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 尝试看能否将s保存为整数，如果可以则返回1，且value和encoding分别保存新值和编码信息</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (zipTryEncoding(s,slen,&amp;value,&amp;encoding)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果s可以保存为整数，则进一步计算保存该数值所需要的字节数</span></span><br><span class=\"line\">        reqlen = zipIntSize(encoding);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果s不能保存为整数，则直接使用其字符串长度</span></span><br><span class=\"line\">        reqlen = slen;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 计算编码prevlen所需要的字节数，prevlen用于保存前一个节点的长度</span></span><br><span class=\"line\">    reqlen += zipPrevEncodeLength(<span class=\"literal\">NULL</span>,prevlen);</span><br><span class=\"line\">    <span class=\"comment\">// 计算编码slen所需要的长度</span></span><br><span class=\"line\">    reqlen += zipEncodeLength(<span class=\"literal\">NULL</span>,encoding,slen);</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 当插入的位置不是ziplist尾部时，需要确保下一个节点（即p节点）的prevlen能够用来保存即将插入节点的长度</span></span><br><span class=\"line\">    <span class=\"comment\">// 这里计算两者差值</span></span><br><span class=\"line\">    nextdiff = (p[<span class=\"number\">0</span>] != ZIP_END) ? zipPrevLenByteDiff(p,reqlen) : <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ziplistResize操作会重新分配空间，需要事前记录p节点偏移量</span></span><br><span class=\"line\">    offset = p-zl;</span><br><span class=\"line\">    zl = ziplistResize(zl,curlen+reqlen+nextdiff);</span><br><span class=\"line\">    <span class=\"comment\">// 重新取得p节点</span></span><br><span class=\"line\">    p = zl+offset;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Apply memory move when necessary and update tail offset. */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p[<span class=\"number\">0</span>] != ZIP_END) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/* 将原来 p-nextdiff 开始的数据全部后移，中间出现reqlen个字节保存即将插入的数据 </span></span><br><span class=\"line\"><span class=\"comment\">            主要需要考虑一下几种情况：</span></span><br><span class=\"line\"><span class=\"comment\">            nextdiff == 0：p节点中用来存储原先前一个节点长度信息的数据区域正好保存待插入节点的长度</span></span><br><span class=\"line\"><span class=\"comment\">            nextdiff == 4：原先p节点只需要1个字节来存储上一个节点的长度，现在需要5个字节。那就将p-4后面的数据偏移到p+reqlen</span></span><br><span class=\"line\"><span class=\"comment\">            nextdiff == -4：原先p节点需要5个字节来存储上一个节点的长度，现在只需要1个字节。那就将p+4后面的数据偏移到p+reqlen</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">        memmove(p+reqlen,p-nextdiff,curlen-offset<span class=\"number\">-1</span>+nextdiff);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 为p节点的prevlen设置新值，即待插入节点的长度</span></span><br><span class=\"line\">        zipPrevEncodeLength(p+reqlen,reqlen);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 更新尾节点偏移量</span></span><br><span class=\"line\">        ZIPLIST_TAIL_OFFSET(zl) =</span><br><span class=\"line\">            intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+reqlen);</span><br><span class=\"line\"></span><br><span class=\"line\">        tail = zipEntry(p+reqlen);</span><br><span class=\"line\">        <span class=\"comment\">// 同样，如果p节点不是尾节点，尾节点的偏移量还需要加上nextdiff值</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p[reqlen+tail.headersize+tail.len] != ZIP_END) &#123;</span><br><span class=\"line\">            ZIPLIST_TAIL_OFFSET(zl) =</span><br><span class=\"line\">                intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+nextdiff);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果p节点指向zlend，更新zltail值，待添加节点为尾部节点</span></span><br><span class=\"line\">        ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(p-zl);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 同样，如果nextdiff的值不为0，说明原节点（此时的首地址为p+reqlen）的长度发生改变，需要执行级联更新操作</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nextdiff != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        offset = p-zl;</span><br><span class=\"line\">        <span class=\"comment\">//这里可能造成连锁更新</span></span><br><span class=\"line\">        zl = __ziplistCascadeUpdate(zl,p+reqlen);</span><br><span class=\"line\">        p = zl+offset;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 下面才是真正执行插入操作</span></span><br><span class=\"line\">    <span class=\"comment\">/* Write the entry */</span></span><br><span class=\"line\">    <span class=\"comment\">// 填写上一节点的长度</span></span><br><span class=\"line\">    p += zipPrevEncodeLength(p,prevlen);</span><br><span class=\"line\">    <span class=\"comment\">// 填写当前节点的长度</span></span><br><span class=\"line\">    p += zipEncodeLength(p,encoding,slen);</span><br><span class=\"line\">    <span class=\"comment\">// 根据编码方式执行相应的插入操作</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ZIP_IS_STR(encoding)) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">memcpy</span>(p,s,slen);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        zipSaveInteger(p,value,encoding);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 长度加1</span></span><br><span class=\"line\">    ZIPLIST_INCR_LENGTH(zl,<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> zl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>估算内存</strong><br>curlen表示当前ziplist的占用字节数,curlen初始值11，保存”fieldkey”后变为21，保存”abcdefghijklmn”变成38，估计一个节点占用<strong>27字节</strong>。</p>\n<p><strong>注意：</strong>当在ziplist头部执行增加或删除操作时，如果节点长度过长（超过255），previous_entry_length要使用5个字节保存，这时会执行__ziplistCascadeUpdate()函数，可能触发连锁更新，最坏情况要更新每一个后继节点（previous_entry_length从一个字节变成5个字节后，所有节点长度都超过了255）。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p><strong>ziplist的优点</strong><br>内存占用少 容易被加载到CPU缓存<br>结构紧凑 减少内存碎片</p>\n<p><strong>ziplist的缺点</strong><br>连锁更新（头部插入 或 删除，对头部的操作主要是在用ziplist保存list类型对象时发送，保存hash对象不需要在头部更新。）<br>查询复杂度从O（1）变成O（N）（保存hash对象时）</p>\n<p>参考：<br><a href=\"http://blog.csdn.net/xiejingfa/article/details/51072326\" target=\"_blank\" rel=\"noopener\">Redis内置数据结构之压缩列表ziplist</a><br><a href=\"http://blog.csdn.net/Rongbo_J/article/details/45288223\" target=\"_blank\" rel=\"noopener\">vs2012调试redis</a><br><a href=\"http://www.duokan.com/book/53962\" target=\"_blank\" rel=\"noopener\">《redis设计与实现》</a></p>"},{"title":"图解redis sentinel","date":"2017-11-21T15:15:46.000Z","_content":"\nredis sentinel是redis为支持自动failover的主从模式开发的功能，sentinel实际上也是一个redis实例，不过它只支持部分特有命令，通过`redis-server /path/to/sentinel.conf --sentinel`启动sentinel实例。\n<!--more-->\n\n### 整体视图\nsentinel服务由多个节点组成，当进行容灾操作时需要多数节点达成一致，因此sentinel节点之间需要建立通信（蓝色部分）。同时为了监控redis节点状态，每个sentinel节点都会和redis实例建立命令连接（图中虚线），sentinel节点还会通过publish命令向其他节点（包括master/slave/sentinel）发送\"hello msg\"(参考[^sentinelSendPeriodicCommands]）\n，通过redis的发布/订阅功能来交换信息。\n\n注意：sentinel接收publish命令时执行的是fake publish\n![overview][1]\n\n继续下面的内容前，需要了解sentinel的几个重要配置参数：\n\n>**monitor** master_name,master_ip,master_port,quorum\n (master信息客观下线需要的票数)\n**down-after-milliseconds** master_name XXms (失联多久被视为主观下线)\n**failover-timeout** master_name XXms (处理故障的超时时间)\n**parallel-syncs**  master_name number (执行故障转移时，可以同时从新的master同步数据的slave数量）\n\n### 发现新redis实例\n可以发现配置sentinel时不需要填写slave节点的信息，这是因为sentinel可以从它监视的master发送INFO命令获得对应的slave信息，然后再与slave建立连接。通过这种方式sentinel也能够发现新加入的slave节点，过程如图所示：\n![1][2]\n### 发现新sentinel实例\n类似地，一个sentinel实例也能够自主的发现其他sentinel实例，不过这是通过channel接收其他sentinel实例发送的消息实现的，每个sentinel实例会定时所有节点发送PUBLISH命令来向channel投递消息，内容主要是sentinel自己和信息和它保存的master的信息，格式如下：\n```\nPUBLISH __sentinel__:hello sentinel_ip,sentinel_port,sentinel_runid,current_epoch,\nmaster_name,master_ip,master_port,master_config_epoch.\n```\n消息会由redis实例的频道发送给所有监视实例的sentinel，其他sentinel收到信息后，如果自己没有保存消息中的sentinel会保存下来，同时epoch如果小于消息中epoch也会自我更新：\n![step2][3]\n\n### 判断节点下线过程\nsentinel会通过定时向监视的redis实例发送ping命令，检查redis的状态，当redis回复异常或者在超时时间内没有回复时sentinel会将节点设置为主观下线（subjectively down）。而且如果节点是master的话，sentinel需要判断节点是否能设置为客观下线（Objectively down）,过程如图所示：\n（1）节点回复不正常，sentinel把节点置为主观下线\n（2）给其他sentinel发送`is-master-down-by-addr`命令，格式如下`IS-MASTER-DOWN-BY-ADDR <master_ip> <master_port> <sentinel:current-epoch> <sentinel:runid>`\n（只有当发起投票时才会发送runid,此时runid内容为*）\n（3）收到`is-master-down-by-addr`的sentinel检查对应redis实例的状态（实际不会发送ping命令，只是检查保存的节点状态是不是主观下线）\n（4）发现节点下线回复消息，回复内容如下，后两个是投票时用到的`down state, leader, vote epoch`\n（5）当sentinel1 收到足够多的“节点下线”的回复后（大于配置的quorum），将master状态设置为客观下线，然后failover流程才开始进行。\n\n![s3][4]\n\n### failover第一步:选举leader\nfailover操作只能由一个sentinel节点来执行，因此开始failover首先要选举出一个Leader,sentinel的选举采用的是[Raft算法][5]中的领导人选举机制。在这里确认master客观下线的sentinel会成为候选人，等待failover_start_time（一个随机时间，为了避免候选人同时开始选举导致平票），然后开始向其他实例发起投票请求，依然是使用`is-master-down-by-addr`命令，投票时主要依据是epoch字段。具体流程如图所示：\n![s4][6]\n\n### failover第二步：执行故障转移\nLeader选举成功之后，会在slave中选择一个最优的，然后“提拔”这个slave作为新的master,然后其他redis实例会来同步新master的数据，具体过程如下：\n![dofailover][7]\n### sentinel的整体执行流程\n上面描述的行为都是通过redis定时任务来驱动的，特别的，sentinel中定义了一个状态机（switch-case代码块）来根据此时master的failover_state执行不同的操作，下面的图从外向内展示了sentinel主要功能的调用过程：\n>（1）servCron函数(在server.c)负责执行redis的定时任务，包括过期键，写AOF文件等等，同时包括执行sentinel定时任务\n（2）sentinelTimer(sentinel.c)是sentinel模式的定时任务，执行[TILT模式][8]的检查，执行脚本，还有就是处理RedisInstance（集群中所有的master/slave/sentinel实例）\n（3）在sentinelHandleRedisInstance函数中，会依次执行reconnect函数维护与其他实例的连接（命令连接和pub/sub）,定期发送命令（info/ping/hello）,判断主观下线\n（4）当实例是master时会执行客观下线的检查，在StartFailoverIfNeeded函数中，如果满足条件会开始failover的过程（master会变成SENTINEL_FAILOVER_STATE_WAIT_START，然后还会向其他sentinel确认master状态，使用force模式才会发送is-master-down命令，此时可能也会发起投票）\n（5）状态机逻辑的执行在StartFailoverIfNeeded执行之后（和上一步结果无关），状态机就是在每次定时任务循环中检查当前master的状态然后执行不同阶段的failover操作，最后会执行askOther的步骤，本次定时任务结束。\n\n\n![state][9]\n### 附录\n\n**1、完整的failoverstate**\n```c \n/* Failover machine different states. */\n#define SENTINEL_FAILOVER_STATE_NONE 0  /* No failover in progress. */\n#define SENTINEL_FAILOVER_STATE_WAIT_START 1  /* Wait for failover_start_time*/\n#define SENTINEL_FAILOVER_STATE_SELECT_SLAVE 2 /* Select slave to promote */\n#define SENTINEL_FAILOVER_STATE_SEND_SLAVEOF_NOONE 3 /* Slave -> Master */\n#define SENTINEL_FAILOVER_STATE_WAIT_PROMOTION 4 /* Wait slave to change role */\n#define SENTINEL_FAILOVER_STATE_RECONF_SLAVES 5 /* SLAVEOF newmaster */\n#define SENTINEL_FAILOVER_STATE_UPDATE_CONFIG 6 /* Monitor promoted slave.master配置更新为新的master */\n```\n**2、redis实例收到的sentinel消息**\n集群中一台slave的hello频道中传播的消息，此时master端口是6380：\n```\n127.0.0.1:6379> psubscribe *\n1) \"pmessage\"\n2) \"*\"\n3) \"__sentinel__:hello\"\n4) \"127.0.0.1,26380,299da3eb5862baf267d16e36306defe7517bab5b,3,mymaster,127.0.0.1,6380,3\"\n1) \"pmessage\"\n2) \"*\"\n3) \"__sentinel__:hello\"\n4) \"127.0.0.1,26381,bf3ac725160092d5db0fefdcc4814379003a75a8,3,mymaster,127.0.0.1,6380,3\"\n1) \"pmessage\"\n2) \"*\"\n3) \"__sentinel__:hello\"\n4) \"127.0.0.1,26379,9e47039b5fd9735296df2340e54a4c37caeabbb2,3,mymaster,127.0.0.1,6380,3\"\n```\n**3、一次failover的日志**\nmaster port:6380\nLeader port:26380\nLeader run_id:299da3eb5862baf267d16e36306defe7517bab5b\n**follower sentinel收到的消息:**\n```\n127.0.0.1:26379> psubscribe *\nReading messages... (press Ctrl-C to quit)\n1) \"psubscribe\"\n2) \"*\"\n3) (integer) 1\n1) \"pmessage\"\n2) \"*\"\n3) \"+new-epoch\"\n4) \"2\"\n1) \"pmessage\"\n2) \"*\"\n3) \"+vote-for-leader\"\n4) \"299da3eb5862baf267d16e36306defe7517bab5b 2\"\n1) \"pmessage\"\n2) \"*\"\n3) \"+sdown\"\n4) \"master mymaster 127.0.0.1 6380\"\n1) \"pmessage\"\n2) \"*\"\n3) \"+odown\"\n4) \"master mymaster 127.0.0.1 6380 #quorum 3/2\"\n1) \"pmessage\"\n2) \"*\"\n3) \"+config-update-from\"\n4) \"sentinel 127.0.0.1:26380 127.0.0.1 26380 @ mymaster 127.0.0.1 6380\"\n1) \"pmessage\"\n2) \"*\"\n3) \"+switch-master\"\n4) \"mymaster 127.0.0.1 6380 127.0.0.1 6381\"\n1) \"pmessage\"\n2) \"*\"\n3) \"+slave\"\n4) \"slave 127.0.0.1:6379 127.0.0.1 6379 @ mymaster 127.0.0.1 6381\"\n1) \"pmessage\"\n2) \"*\"\n3) \"+slave\"\n4) \"slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6381\"\n1) \"pmessage\"\n2) \"*\"\n3) \"+sdown\"\n4) \"slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6381\"\n1) \"pmessage\"\n2) \"*\"\n3) \"-role-change\"\n4) \"slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6381 new reported role is master\"\n1) \"pmessage\"\n2) \"*\"\n3) \"-sdown\"\n4) \"slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6381\"\n1) \"pmessage\"\n2) \"*\"\n3) \"+role-change\"\n4) \"slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6381 new reported role is slave\"\n\n```\nsentinel消息各种 + - 标识的含义:\n>+reset-master <instance details> -- The master was reset.\n    +slave <instance details> -- A new slave was detected and attached.\n    +failover-state-reconf-slaves <instance details> -- Failover state changed to reconf-slaves state.\n    +failover-detected <instance details> -- A failover started by another Sentinel or any other external entity was detected (An attached slave turned into a master).\n    +slave-reconf-sent <instance details> -- The leader sentinel sent the SLAVEOF command to this instance in order to reconfigure it for the new slave.\n    +slave-reconf-inprog <instance details> -- The slave being reconfigured showed to be a slave of the new master ip:port pair, but the synchronization process is not yet complete.\n    +slave-reconf-done <instance details> -- The slave is now synchronized with the new master.\n    -dup-sentinel <instance details> -- One or more sentinels for the specified master were removed as duplicated (this happens for instance when a Sentinel instance is restarted).\n    +sentinel <instance details> -- A new sentinel for this master was detected and attached.\n    +sdown <instance details> -- The specified instance is now in Subjectively Down state.\n    -sdown <instance details> -- The specified instance is no longer in Subjectively Down state.\n    +odown <instance details> -- The specified instance is now in Objectively Down state.\n    -odown <instance details> -- The specified instance is no longer in Objectively Down state.\n    +new-epoch <instance details> -- The current epoch was updated.\n    +try-failover <instance details> -- New failover in progress, waiting to be elected by the majority.\n    +elected-leader <instance details> -- Won the election for the specified epoch, can do the failover.\n    +failover-state-select-slave <instance details> -- New failover state is select-slave: we are trying to find a suitable slave for promotion.\n    no-good-slave <instance details> -- There is no good slave to promote. Currently we'll try after some time, but probably this will change and the state machine will abort the failover at all in this case.\n    selected-slave <instance details> -- We found the specified good slave to promote.\n    failover-state-send-slaveof-noone <instance details> -- We are trying to reconfigure the promoted slave as master, waiting for it to switch.\n    failover-end-for-timeout <instance details> -- The failover terminated for timeout, slaves will eventually be configured to replicate with the new master anyway.\n    failover-end <instance details> -- The failover terminated with success. All the slaves appears to be reconfigured to replicate with the new master.\n    switch-master <master name> <oldip> <oldport> <newip> <newport> -- The master new IP and address is the specified one after a configuration change. This is the message most external users are interested in.\n    +tilt -- Tilt mode entered.\n    -tilt -- Tilt mode exited.\n\n**leader 日志**\n```\n[30369] 13 Jan 20:21:06.701 # +sdown master mymaster 127.0.0.1 6380\n[30369] 13 Jan 20:21:06.768 # +odown master mymaster 127.0.0.1 6380 #quorum 2/2\n[30369] 13 Jan 20:21:06.768 # +new-epoch 2\n[30369] 13 Jan 20:21:06.768 # +try-failover master mymaster 127.0.0.1 6380\n[30369] 13 Jan 20:21:06.782 # +vote-for-leader 299da3eb5862baf267d16e36306defe7517bab5b 2\n[30369] 13 Jan 20:21:06.821 # 127.0.0.1:26381 voted for 299da3eb5862baf267d16e36306defe7517bab5b 2\n[30369] 13 Jan 20:21:06.821 # 127.0.0.1:26379 voted for 299da3eb5862baf267d16e36306defe7517bab5b 2\n[30369] 13 Jan 20:21:06.844 # +elected-leader master mymaster 127.0.0.1 6380\n[30369] 13 Jan 20:21:06.844 # +failover-state-select-slave master mymaster 127.0.0.1 6380\n[30369] 13 Jan 20:21:06.902 # +selected-slave slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6380\n[30369] 13 Jan 20:21:06.902 * +failover-state-send-slaveof-noone slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6380\n[30369] 13 Jan 20:21:06.965 * +failover-state-wait-promotion slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6380\n[30369] 13 Jan 20:21:07.830 # +promoted-slave slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6380\n[30369] 13 Jan 20:21:07.830 # +failover-state-reconf-slaves master mymaster 127.0.0.1 6380\n[30369] 13 Jan 20:21:07.872 * +slave-reconf-sent slave 127.0.0.1:6379 127.0.0.1 6379 @ mymaster 127.0.0.1 6380\n[30369] 13 Jan 20:21:08.852 * +slave-reconf-inprog slave 127.0.0.1:6379 127.0.0.1 6379 @ mymaster 127.0.0.1 6380\n[30369] 13 Jan 20:21:08.976 # -odown master mymaster 127.0.0.1 6380\n[30369] 13 Jan 20:22:53.198 * +reboot master mymaster 127.0.0.1 6380\n[30369] 13 Jan 20:22:53.249 # -sdown master mymaster 127.0.0.1 6380\n\n```\n**follower 日志**\n```\n[29838] 13 Jan 20:21:06.803 # +new-epoch 2\n[29838] 13 Jan 20:21:06.821 # +vote-for-leader 299da3eb5862baf267d16e36306defe7517bab5b 2\n[29838] 13 Jan 20:21:06.821 # +sdown master mymaster 127.0.0.1 6380\n[29838] 13 Jan 20:21:06.898 # +odown master mymaster 127.0.0.1 6380 #quorum 3/2\n[29838] 13 Jan 20:21:06.898 # Next failover delay: I will not start a failover before Sat Jan 13 20:27:07 2018\n[29838] 13 Jan 20:21:07.874 # +config-update-from sentinel 127.0.0.1:26380 127.0.0.1 26380 @ mymaster 127.0.0.1 6380\n[29838] 13 Jan 20:21:07.874 # +switch-master mymaster 127.0.0.1 6380 127.0.0.1 6381\n[29838] 13 Jan 20:21:07.874 * +slave slave 127.0.0.1:6379 127.0.0.1 6379 @ mymaster 127.0.0.1 6381\n[29838] 13 Jan 20:21:07.894 * +slave slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6381\n[29838] 13 Jan 20:21:37.913 # +sdown slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6381\n[29838] 13 Jan 20:22:53.322 # -sdown slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6381\n```\n[^sentinelSendPeriodicCommands]:https://github.com/antirez/redis/blob/3.0/src/sentinel.c sentinelSendPeriodicCommands()\n\n\n  [1]: /images/redis/sentinel.png\n  [2]: /images/redis/s1.png\n  [3]: /images/redis/s2.png\n  [4]: /images/redis/s3.png\n  [5]: http://www.infoq.com/cn/articles/raft-paper\n  [6]: /images/redis/s4.png\n  [7]: /images/redis/s5.png\n  [8]: http://doc.redisfans.com/topic/sentinel.html#tilt\n  [9]: /images/redis/state.png","source":"_posts/图解redis sentinel.md","raw":"title: 图解redis sentinel\ndate: 2017-11-21 23:15:46\ncategories: redis进阶\ntags: [redis,nosql,源码]\n---\n\nredis sentinel是redis为支持自动failover的主从模式开发的功能，sentinel实际上也是一个redis实例，不过它只支持部分特有命令，通过`redis-server /path/to/sentinel.conf --sentinel`启动sentinel实例。\n<!--more-->\n\n### 整体视图\nsentinel服务由多个节点组成，当进行容灾操作时需要多数节点达成一致，因此sentinel节点之间需要建立通信（蓝色部分）。同时为了监控redis节点状态，每个sentinel节点都会和redis实例建立命令连接（图中虚线），sentinel节点还会通过publish命令向其他节点（包括master/slave/sentinel）发送\"hello msg\"(参考[^sentinelSendPeriodicCommands]）\n，通过redis的发布/订阅功能来交换信息。\n\n注意：sentinel接收publish命令时执行的是fake publish\n![overview][1]\n\n继续下面的内容前，需要了解sentinel的几个重要配置参数：\n\n>**monitor** master_name,master_ip,master_port,quorum\n (master信息客观下线需要的票数)\n**down-after-milliseconds** master_name XXms (失联多久被视为主观下线)\n**failover-timeout** master_name XXms (处理故障的超时时间)\n**parallel-syncs**  master_name number (执行故障转移时，可以同时从新的master同步数据的slave数量）\n\n### 发现新redis实例\n可以发现配置sentinel时不需要填写slave节点的信息，这是因为sentinel可以从它监视的master发送INFO命令获得对应的slave信息，然后再与slave建立连接。通过这种方式sentinel也能够发现新加入的slave节点，过程如图所示：\n![1][2]\n### 发现新sentinel实例\n类似地，一个sentinel实例也能够自主的发现其他sentinel实例，不过这是通过channel接收其他sentinel实例发送的消息实现的，每个sentinel实例会定时所有节点发送PUBLISH命令来向channel投递消息，内容主要是sentinel自己和信息和它保存的master的信息，格式如下：\n```\nPUBLISH __sentinel__:hello sentinel_ip,sentinel_port,sentinel_runid,current_epoch,\nmaster_name,master_ip,master_port,master_config_epoch.\n```\n消息会由redis实例的频道发送给所有监视实例的sentinel，其他sentinel收到信息后，如果自己没有保存消息中的sentinel会保存下来，同时epoch如果小于消息中epoch也会自我更新：\n![step2][3]\n\n### 判断节点下线过程\nsentinel会通过定时向监视的redis实例发送ping命令，检查redis的状态，当redis回复异常或者在超时时间内没有回复时sentinel会将节点设置为主观下线（subjectively down）。而且如果节点是master的话，sentinel需要判断节点是否能设置为客观下线（Objectively down）,过程如图所示：\n（1）节点回复不正常，sentinel把节点置为主观下线\n（2）给其他sentinel发送`is-master-down-by-addr`命令，格式如下`IS-MASTER-DOWN-BY-ADDR <master_ip> <master_port> <sentinel:current-epoch> <sentinel:runid>`\n（只有当发起投票时才会发送runid,此时runid内容为*）\n（3）收到`is-master-down-by-addr`的sentinel检查对应redis实例的状态（实际不会发送ping命令，只是检查保存的节点状态是不是主观下线）\n（4）发现节点下线回复消息，回复内容如下，后两个是投票时用到的`down state, leader, vote epoch`\n（5）当sentinel1 收到足够多的“节点下线”的回复后（大于配置的quorum），将master状态设置为客观下线，然后failover流程才开始进行。\n\n![s3][4]\n\n### failover第一步:选举leader\nfailover操作只能由一个sentinel节点来执行，因此开始failover首先要选举出一个Leader,sentinel的选举采用的是[Raft算法][5]中的领导人选举机制。在这里确认master客观下线的sentinel会成为候选人，等待failover_start_time（一个随机时间，为了避免候选人同时开始选举导致平票），然后开始向其他实例发起投票请求，依然是使用`is-master-down-by-addr`命令，投票时主要依据是epoch字段。具体流程如图所示：\n![s4][6]\n\n### failover第二步：执行故障转移\nLeader选举成功之后，会在slave中选择一个最优的，然后“提拔”这个slave作为新的master,然后其他redis实例会来同步新master的数据，具体过程如下：\n![dofailover][7]\n### sentinel的整体执行流程\n上面描述的行为都是通过redis定时任务来驱动的，特别的，sentinel中定义了一个状态机（switch-case代码块）来根据此时master的failover_state执行不同的操作，下面的图从外向内展示了sentinel主要功能的调用过程：\n>（1）servCron函数(在server.c)负责执行redis的定时任务，包括过期键，写AOF文件等等，同时包括执行sentinel定时任务\n（2）sentinelTimer(sentinel.c)是sentinel模式的定时任务，执行[TILT模式][8]的检查，执行脚本，还有就是处理RedisInstance（集群中所有的master/slave/sentinel实例）\n（3）在sentinelHandleRedisInstance函数中，会依次执行reconnect函数维护与其他实例的连接（命令连接和pub/sub）,定期发送命令（info/ping/hello）,判断主观下线\n（4）当实例是master时会执行客观下线的检查，在StartFailoverIfNeeded函数中，如果满足条件会开始failover的过程（master会变成SENTINEL_FAILOVER_STATE_WAIT_START，然后还会向其他sentinel确认master状态，使用force模式才会发送is-master-down命令，此时可能也会发起投票）\n（5）状态机逻辑的执行在StartFailoverIfNeeded执行之后（和上一步结果无关），状态机就是在每次定时任务循环中检查当前master的状态然后执行不同阶段的failover操作，最后会执行askOther的步骤，本次定时任务结束。\n\n\n![state][9]\n### 附录\n\n**1、完整的failoverstate**\n```c \n/* Failover machine different states. */\n#define SENTINEL_FAILOVER_STATE_NONE 0  /* No failover in progress. */\n#define SENTINEL_FAILOVER_STATE_WAIT_START 1  /* Wait for failover_start_time*/\n#define SENTINEL_FAILOVER_STATE_SELECT_SLAVE 2 /* Select slave to promote */\n#define SENTINEL_FAILOVER_STATE_SEND_SLAVEOF_NOONE 3 /* Slave -> Master */\n#define SENTINEL_FAILOVER_STATE_WAIT_PROMOTION 4 /* Wait slave to change role */\n#define SENTINEL_FAILOVER_STATE_RECONF_SLAVES 5 /* SLAVEOF newmaster */\n#define SENTINEL_FAILOVER_STATE_UPDATE_CONFIG 6 /* Monitor promoted slave.master配置更新为新的master */\n```\n**2、redis实例收到的sentinel消息**\n集群中一台slave的hello频道中传播的消息，此时master端口是6380：\n```\n127.0.0.1:6379> psubscribe *\n1) \"pmessage\"\n2) \"*\"\n3) \"__sentinel__:hello\"\n4) \"127.0.0.1,26380,299da3eb5862baf267d16e36306defe7517bab5b,3,mymaster,127.0.0.1,6380,3\"\n1) \"pmessage\"\n2) \"*\"\n3) \"__sentinel__:hello\"\n4) \"127.0.0.1,26381,bf3ac725160092d5db0fefdcc4814379003a75a8,3,mymaster,127.0.0.1,6380,3\"\n1) \"pmessage\"\n2) \"*\"\n3) \"__sentinel__:hello\"\n4) \"127.0.0.1,26379,9e47039b5fd9735296df2340e54a4c37caeabbb2,3,mymaster,127.0.0.1,6380,3\"\n```\n**3、一次failover的日志**\nmaster port:6380\nLeader port:26380\nLeader run_id:299da3eb5862baf267d16e36306defe7517bab5b\n**follower sentinel收到的消息:**\n```\n127.0.0.1:26379> psubscribe *\nReading messages... (press Ctrl-C to quit)\n1) \"psubscribe\"\n2) \"*\"\n3) (integer) 1\n1) \"pmessage\"\n2) \"*\"\n3) \"+new-epoch\"\n4) \"2\"\n1) \"pmessage\"\n2) \"*\"\n3) \"+vote-for-leader\"\n4) \"299da3eb5862baf267d16e36306defe7517bab5b 2\"\n1) \"pmessage\"\n2) \"*\"\n3) \"+sdown\"\n4) \"master mymaster 127.0.0.1 6380\"\n1) \"pmessage\"\n2) \"*\"\n3) \"+odown\"\n4) \"master mymaster 127.0.0.1 6380 #quorum 3/2\"\n1) \"pmessage\"\n2) \"*\"\n3) \"+config-update-from\"\n4) \"sentinel 127.0.0.1:26380 127.0.0.1 26380 @ mymaster 127.0.0.1 6380\"\n1) \"pmessage\"\n2) \"*\"\n3) \"+switch-master\"\n4) \"mymaster 127.0.0.1 6380 127.0.0.1 6381\"\n1) \"pmessage\"\n2) \"*\"\n3) \"+slave\"\n4) \"slave 127.0.0.1:6379 127.0.0.1 6379 @ mymaster 127.0.0.1 6381\"\n1) \"pmessage\"\n2) \"*\"\n3) \"+slave\"\n4) \"slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6381\"\n1) \"pmessage\"\n2) \"*\"\n3) \"+sdown\"\n4) \"slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6381\"\n1) \"pmessage\"\n2) \"*\"\n3) \"-role-change\"\n4) \"slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6381 new reported role is master\"\n1) \"pmessage\"\n2) \"*\"\n3) \"-sdown\"\n4) \"slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6381\"\n1) \"pmessage\"\n2) \"*\"\n3) \"+role-change\"\n4) \"slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6381 new reported role is slave\"\n\n```\nsentinel消息各种 + - 标识的含义:\n>+reset-master <instance details> -- The master was reset.\n    +slave <instance details> -- A new slave was detected and attached.\n    +failover-state-reconf-slaves <instance details> -- Failover state changed to reconf-slaves state.\n    +failover-detected <instance details> -- A failover started by another Sentinel or any other external entity was detected (An attached slave turned into a master).\n    +slave-reconf-sent <instance details> -- The leader sentinel sent the SLAVEOF command to this instance in order to reconfigure it for the new slave.\n    +slave-reconf-inprog <instance details> -- The slave being reconfigured showed to be a slave of the new master ip:port pair, but the synchronization process is not yet complete.\n    +slave-reconf-done <instance details> -- The slave is now synchronized with the new master.\n    -dup-sentinel <instance details> -- One or more sentinels for the specified master were removed as duplicated (this happens for instance when a Sentinel instance is restarted).\n    +sentinel <instance details> -- A new sentinel for this master was detected and attached.\n    +sdown <instance details> -- The specified instance is now in Subjectively Down state.\n    -sdown <instance details> -- The specified instance is no longer in Subjectively Down state.\n    +odown <instance details> -- The specified instance is now in Objectively Down state.\n    -odown <instance details> -- The specified instance is no longer in Objectively Down state.\n    +new-epoch <instance details> -- The current epoch was updated.\n    +try-failover <instance details> -- New failover in progress, waiting to be elected by the majority.\n    +elected-leader <instance details> -- Won the election for the specified epoch, can do the failover.\n    +failover-state-select-slave <instance details> -- New failover state is select-slave: we are trying to find a suitable slave for promotion.\n    no-good-slave <instance details> -- There is no good slave to promote. Currently we'll try after some time, but probably this will change and the state machine will abort the failover at all in this case.\n    selected-slave <instance details> -- We found the specified good slave to promote.\n    failover-state-send-slaveof-noone <instance details> -- We are trying to reconfigure the promoted slave as master, waiting for it to switch.\n    failover-end-for-timeout <instance details> -- The failover terminated for timeout, slaves will eventually be configured to replicate with the new master anyway.\n    failover-end <instance details> -- The failover terminated with success. All the slaves appears to be reconfigured to replicate with the new master.\n    switch-master <master name> <oldip> <oldport> <newip> <newport> -- The master new IP and address is the specified one after a configuration change. This is the message most external users are interested in.\n    +tilt -- Tilt mode entered.\n    -tilt -- Tilt mode exited.\n\n**leader 日志**\n```\n[30369] 13 Jan 20:21:06.701 # +sdown master mymaster 127.0.0.1 6380\n[30369] 13 Jan 20:21:06.768 # +odown master mymaster 127.0.0.1 6380 #quorum 2/2\n[30369] 13 Jan 20:21:06.768 # +new-epoch 2\n[30369] 13 Jan 20:21:06.768 # +try-failover master mymaster 127.0.0.1 6380\n[30369] 13 Jan 20:21:06.782 # +vote-for-leader 299da3eb5862baf267d16e36306defe7517bab5b 2\n[30369] 13 Jan 20:21:06.821 # 127.0.0.1:26381 voted for 299da3eb5862baf267d16e36306defe7517bab5b 2\n[30369] 13 Jan 20:21:06.821 # 127.0.0.1:26379 voted for 299da3eb5862baf267d16e36306defe7517bab5b 2\n[30369] 13 Jan 20:21:06.844 # +elected-leader master mymaster 127.0.0.1 6380\n[30369] 13 Jan 20:21:06.844 # +failover-state-select-slave master mymaster 127.0.0.1 6380\n[30369] 13 Jan 20:21:06.902 # +selected-slave slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6380\n[30369] 13 Jan 20:21:06.902 * +failover-state-send-slaveof-noone slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6380\n[30369] 13 Jan 20:21:06.965 * +failover-state-wait-promotion slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6380\n[30369] 13 Jan 20:21:07.830 # +promoted-slave slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6380\n[30369] 13 Jan 20:21:07.830 # +failover-state-reconf-slaves master mymaster 127.0.0.1 6380\n[30369] 13 Jan 20:21:07.872 * +slave-reconf-sent slave 127.0.0.1:6379 127.0.0.1 6379 @ mymaster 127.0.0.1 6380\n[30369] 13 Jan 20:21:08.852 * +slave-reconf-inprog slave 127.0.0.1:6379 127.0.0.1 6379 @ mymaster 127.0.0.1 6380\n[30369] 13 Jan 20:21:08.976 # -odown master mymaster 127.0.0.1 6380\n[30369] 13 Jan 20:22:53.198 * +reboot master mymaster 127.0.0.1 6380\n[30369] 13 Jan 20:22:53.249 # -sdown master mymaster 127.0.0.1 6380\n\n```\n**follower 日志**\n```\n[29838] 13 Jan 20:21:06.803 # +new-epoch 2\n[29838] 13 Jan 20:21:06.821 # +vote-for-leader 299da3eb5862baf267d16e36306defe7517bab5b 2\n[29838] 13 Jan 20:21:06.821 # +sdown master mymaster 127.0.0.1 6380\n[29838] 13 Jan 20:21:06.898 # +odown master mymaster 127.0.0.1 6380 #quorum 3/2\n[29838] 13 Jan 20:21:06.898 # Next failover delay: I will not start a failover before Sat Jan 13 20:27:07 2018\n[29838] 13 Jan 20:21:07.874 # +config-update-from sentinel 127.0.0.1:26380 127.0.0.1 26380 @ mymaster 127.0.0.1 6380\n[29838] 13 Jan 20:21:07.874 # +switch-master mymaster 127.0.0.1 6380 127.0.0.1 6381\n[29838] 13 Jan 20:21:07.874 * +slave slave 127.0.0.1:6379 127.0.0.1 6379 @ mymaster 127.0.0.1 6381\n[29838] 13 Jan 20:21:07.894 * +slave slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6381\n[29838] 13 Jan 20:21:37.913 # +sdown slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6381\n[29838] 13 Jan 20:22:53.322 # -sdown slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6381\n```\n[^sentinelSendPeriodicCommands]:https://github.com/antirez/redis/blob/3.0/src/sentinel.c sentinelSendPeriodicCommands()\n\n\n  [1]: /images/redis/sentinel.png\n  [2]: /images/redis/s1.png\n  [3]: /images/redis/s2.png\n  [4]: /images/redis/s3.png\n  [5]: http://www.infoq.com/cn/articles/raft-paper\n  [6]: /images/redis/s4.png\n  [7]: /images/redis/s5.png\n  [8]: http://doc.redisfans.com/topic/sentinel.html#tilt\n  [9]: /images/redis/state.png","slug":"图解redis sentinel","published":1,"updated":"2019-05-04T16:00:47.392Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkqle1cv002lcyneg7x68vue","content":"<p>redis sentinel是redis为支持自动failover的主从模式开发的功能，sentinel实际上也是一个redis实例，不过它只支持部分特有命令，通过<code>redis-server /path/to/sentinel.conf --sentinel</code>启动sentinel实例。<br><a id=\"more\"></a></p>\n<h3 id=\"整体视图\"><a href=\"#整体视图\" class=\"headerlink\" title=\"整体视图\"></a>整体视图</h3><p>sentinel服务由多个节点组成，当进行容灾操作时需要多数节点达成一致，因此sentinel节点之间需要建立通信（蓝色部分）。同时为了监控redis节点状态，每个sentinel节点都会和redis实例建立命令连接（图中虚线），sentinel节点还会通过publish命令向其他节点（包括master/slave/sentinel）发送”hello msg”(参考[^sentinelSendPeriodicCommands]）<br>，通过redis的发布/订阅功能来交换信息。</p>\n<p>注意：sentinel接收publish命令时执行的是fake publish<br><img src=\"/images/redis/sentinel.png\" alt=\"overview\"></p>\n<p>继续下面的内容前，需要了解sentinel的几个重要配置参数：</p>\n<blockquote>\n<p><strong>monitor</strong> master_name,master_ip,master_port,quorum<br> (master信息客观下线需要的票数)<br><strong>down-after-milliseconds</strong> master_name XXms (失联多久被视为主观下线)<br><strong>failover-timeout</strong> master_name XXms (处理故障的超时时间)<br><strong>parallel-syncs</strong>  master_name number (执行故障转移时，可以同时从新的master同步数据的slave数量）</p>\n</blockquote>\n<h3 id=\"发现新redis实例\"><a href=\"#发现新redis实例\" class=\"headerlink\" title=\"发现新redis实例\"></a>发现新redis实例</h3><p>可以发现配置sentinel时不需要填写slave节点的信息，这是因为sentinel可以从它监视的master发送INFO命令获得对应的slave信息，然后再与slave建立连接。通过这种方式sentinel也能够发现新加入的slave节点，过程如图所示：<br><img src=\"/images/redis/s1.png\" alt=\"1\"></p>\n<h3 id=\"发现新sentinel实例\"><a href=\"#发现新sentinel实例\" class=\"headerlink\" title=\"发现新sentinel实例\"></a>发现新sentinel实例</h3><p>类似地，一个sentinel实例也能够自主的发现其他sentinel实例，不过这是通过channel接收其他sentinel实例发送的消息实现的，每个sentinel实例会定时所有节点发送PUBLISH命令来向channel投递消息，内容主要是sentinel自己和信息和它保存的master的信息，格式如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PUBLISH __sentinel__:hello sentinel_ip,sentinel_port,sentinel_runid,current_epoch,</span><br><span class=\"line\">master_name,master_ip,master_port,master_config_epoch.</span><br></pre></td></tr></table></figure></p>\n<p>消息会由redis实例的频道发送给所有监视实例的sentinel，其他sentinel收到信息后，如果自己没有保存消息中的sentinel会保存下来，同时epoch如果小于消息中epoch也会自我更新：<br><img src=\"/images/redis/s2.png\" alt=\"step2\"></p>\n<h3 id=\"判断节点下线过程\"><a href=\"#判断节点下线过程\" class=\"headerlink\" title=\"判断节点下线过程\"></a>判断节点下线过程</h3><p>sentinel会通过定时向监视的redis实例发送ping命令，检查redis的状态，当redis回复异常或者在超时时间内没有回复时sentinel会将节点设置为主观下线（subjectively down）。而且如果节点是master的话，sentinel需要判断节点是否能设置为客观下线（Objectively down）,过程如图所示：<br>（1）节点回复不正常，sentinel把节点置为主观下线<br>（2）给其他sentinel发送<code>is-master-down-by-addr</code>命令，格式如下<code>IS-MASTER-DOWN-BY-ADDR &lt;master_ip&gt; &lt;master_port&gt; &lt;sentinel:current-epoch&gt; &lt;sentinel:runid&gt;</code><br>（只有当发起投票时才会发送runid,此时runid内容为*）<br>（3）收到<code>is-master-down-by-addr</code>的sentinel检查对应redis实例的状态（实际不会发送ping命令，只是检查保存的节点状态是不是主观下线）<br>（4）发现节点下线回复消息，回复内容如下，后两个是投票时用到的<code>down state, leader, vote epoch</code><br>（5）当sentinel1 收到足够多的“节点下线”的回复后（大于配置的quorum），将master状态设置为客观下线，然后failover流程才开始进行。</p>\n<p><img src=\"/images/redis/s3.png\" alt=\"s3\"></p>\n<h3 id=\"failover第一步-选举leader\"><a href=\"#failover第一步-选举leader\" class=\"headerlink\" title=\"failover第一步:选举leader\"></a>failover第一步:选举leader</h3><p>failover操作只能由一个sentinel节点来执行，因此开始failover首先要选举出一个Leader,sentinel的选举采用的是<a href=\"http://www.infoq.com/cn/articles/raft-paper\" target=\"_blank\" rel=\"noopener\">Raft算法</a>中的领导人选举机制。在这里确认master客观下线的sentinel会成为候选人，等待failover_start_time（一个随机时间，为了避免候选人同时开始选举导致平票），然后开始向其他实例发起投票请求，依然是使用<code>is-master-down-by-addr</code>命令，投票时主要依据是epoch字段。具体流程如图所示：<br><img src=\"/images/redis/s4.png\" alt=\"s4\"></p>\n<h3 id=\"failover第二步：执行故障转移\"><a href=\"#failover第二步：执行故障转移\" class=\"headerlink\" title=\"failover第二步：执行故障转移\"></a>failover第二步：执行故障转移</h3><p>Leader选举成功之后，会在slave中选择一个最优的，然后“提拔”这个slave作为新的master,然后其他redis实例会来同步新master的数据，具体过程如下：<br><img src=\"/images/redis/s5.png\" alt=\"dofailover\"></p>\n<h3 id=\"sentinel的整体执行流程\"><a href=\"#sentinel的整体执行流程\" class=\"headerlink\" title=\"sentinel的整体执行流程\"></a>sentinel的整体执行流程</h3><p>上面描述的行为都是通过redis定时任务来驱动的，特别的，sentinel中定义了一个状态机（switch-case代码块）来根据此时master的failover_state执行不同的操作，下面的图从外向内展示了sentinel主要功能的调用过程：</p>\n<blockquote>\n<p>（1）servCron函数(在server.c)负责执行redis的定时任务，包括过期键，写AOF文件等等，同时包括执行sentinel定时任务<br>（2）sentinelTimer(sentinel.c)是sentinel模式的定时任务，执行<a href=\"http://doc.redisfans.com/topic/sentinel.html#tilt\" target=\"_blank\" rel=\"noopener\">TILT模式</a>的检查，执行脚本，还有就是处理RedisInstance（集群中所有的master/slave/sentinel实例）<br>（3）在sentinelHandleRedisInstance函数中，会依次执行reconnect函数维护与其他实例的连接（命令连接和pub/sub）,定期发送命令（info/ping/hello）,判断主观下线<br>（4）当实例是master时会执行客观下线的检查，在StartFailoverIfNeeded函数中，如果满足条件会开始failover的过程（master会变成SENTINEL_FAILOVER_STATE_WAIT_START，然后还会向其他sentinel确认master状态，使用force模式才会发送is-master-down命令，此时可能也会发起投票）<br>（5）状态机逻辑的执行在StartFailoverIfNeeded执行之后（和上一步结果无关），状态机就是在每次定时任务循环中检查当前master的状态然后执行不同阶段的failover操作，最后会执行askOther的步骤，本次定时任务结束。</p>\n</blockquote>\n<p><img src=\"/images/redis/state.png\" alt=\"state\"></p>\n<h3 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h3><p><strong>1、完整的failoverstate</strong><br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Failover machine different states. */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SENTINEL_FAILOVER_STATE_NONE 0  <span class=\"comment\">/* No failover in progress. */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SENTINEL_FAILOVER_STATE_WAIT_START 1  <span class=\"comment\">/* Wait for failover_start_time*/</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SENTINEL_FAILOVER_STATE_SELECT_SLAVE 2 <span class=\"comment\">/* Select slave to promote */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SENTINEL_FAILOVER_STATE_SEND_SLAVEOF_NOONE 3 <span class=\"comment\">/* Slave -&gt; Master */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SENTINEL_FAILOVER_STATE_WAIT_PROMOTION 4 <span class=\"comment\">/* Wait slave to change role */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SENTINEL_FAILOVER_STATE_RECONF_SLAVES 5 <span class=\"comment\">/* SLAVEOF newmaster */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SENTINEL_FAILOVER_STATE_UPDATE_CONFIG 6 <span class=\"comment\">/* Monitor promoted slave.master配置更新为新的master */</span></span></span><br></pre></td></tr></table></figure></p>\n<p><strong>2、redis实例收到的sentinel消息</strong><br>集群中一台slave的hello频道中传播的消息，此时master端口是6380：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; psubscribe *</span><br><span class=\"line\">1) &quot;pmessage&quot;</span><br><span class=\"line\">2) &quot;*&quot;</span><br><span class=\"line\">3) &quot;__sentinel__:hello&quot;</span><br><span class=\"line\">4) &quot;127.0.0.1,26380,299da3eb5862baf267d16e36306defe7517bab5b,3,mymaster,127.0.0.1,6380,3&quot;</span><br><span class=\"line\">1) &quot;pmessage&quot;</span><br><span class=\"line\">2) &quot;*&quot;</span><br><span class=\"line\">3) &quot;__sentinel__:hello&quot;</span><br><span class=\"line\">4) &quot;127.0.0.1,26381,bf3ac725160092d5db0fefdcc4814379003a75a8,3,mymaster,127.0.0.1,6380,3&quot;</span><br><span class=\"line\">1) &quot;pmessage&quot;</span><br><span class=\"line\">2) &quot;*&quot;</span><br><span class=\"line\">3) &quot;__sentinel__:hello&quot;</span><br><span class=\"line\">4) &quot;127.0.0.1,26379,9e47039b5fd9735296df2340e54a4c37caeabbb2,3,mymaster,127.0.0.1,6380,3&quot;</span><br></pre></td></tr></table></figure></p>\n<p><strong>3、一次failover的日志</strong><br>master port:6380<br>Leader port:26380<br>Leader run_id:299da3eb5862baf267d16e36306defe7517bab5b<br><strong>follower sentinel收到的消息:</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:26379&gt; psubscribe *</span><br><span class=\"line\">Reading messages... (press Ctrl-C to quit)</span><br><span class=\"line\">1) &quot;psubscribe&quot;</span><br><span class=\"line\">2) &quot;*&quot;</span><br><span class=\"line\">3) (integer) 1</span><br><span class=\"line\">1) &quot;pmessage&quot;</span><br><span class=\"line\">2) &quot;*&quot;</span><br><span class=\"line\">3) &quot;+new-epoch&quot;</span><br><span class=\"line\">4) &quot;2&quot;</span><br><span class=\"line\">1) &quot;pmessage&quot;</span><br><span class=\"line\">2) &quot;*&quot;</span><br><span class=\"line\">3) &quot;+vote-for-leader&quot;</span><br><span class=\"line\">4) &quot;299da3eb5862baf267d16e36306defe7517bab5b 2&quot;</span><br><span class=\"line\">1) &quot;pmessage&quot;</span><br><span class=\"line\">2) &quot;*&quot;</span><br><span class=\"line\">3) &quot;+sdown&quot;</span><br><span class=\"line\">4) &quot;master mymaster 127.0.0.1 6380&quot;</span><br><span class=\"line\">1) &quot;pmessage&quot;</span><br><span class=\"line\">2) &quot;*&quot;</span><br><span class=\"line\">3) &quot;+odown&quot;</span><br><span class=\"line\">4) &quot;master mymaster 127.0.0.1 6380 #quorum 3/2&quot;</span><br><span class=\"line\">1) &quot;pmessage&quot;</span><br><span class=\"line\">2) &quot;*&quot;</span><br><span class=\"line\">3) &quot;+config-update-from&quot;</span><br><span class=\"line\">4) &quot;sentinel 127.0.0.1:26380 127.0.0.1 26380 @ mymaster 127.0.0.1 6380&quot;</span><br><span class=\"line\">1) &quot;pmessage&quot;</span><br><span class=\"line\">2) &quot;*&quot;</span><br><span class=\"line\">3) &quot;+switch-master&quot;</span><br><span class=\"line\">4) &quot;mymaster 127.0.0.1 6380 127.0.0.1 6381&quot;</span><br><span class=\"line\">1) &quot;pmessage&quot;</span><br><span class=\"line\">2) &quot;*&quot;</span><br><span class=\"line\">3) &quot;+slave&quot;</span><br><span class=\"line\">4) &quot;slave 127.0.0.1:6379 127.0.0.1 6379 @ mymaster 127.0.0.1 6381&quot;</span><br><span class=\"line\">1) &quot;pmessage&quot;</span><br><span class=\"line\">2) &quot;*&quot;</span><br><span class=\"line\">3) &quot;+slave&quot;</span><br><span class=\"line\">4) &quot;slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6381&quot;</span><br><span class=\"line\">1) &quot;pmessage&quot;</span><br><span class=\"line\">2) &quot;*&quot;</span><br><span class=\"line\">3) &quot;+sdown&quot;</span><br><span class=\"line\">4) &quot;slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6381&quot;</span><br><span class=\"line\">1) &quot;pmessage&quot;</span><br><span class=\"line\">2) &quot;*&quot;</span><br><span class=\"line\">3) &quot;-role-change&quot;</span><br><span class=\"line\">4) &quot;slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6381 new reported role is master&quot;</span><br><span class=\"line\">1) &quot;pmessage&quot;</span><br><span class=\"line\">2) &quot;*&quot;</span><br><span class=\"line\">3) &quot;-sdown&quot;</span><br><span class=\"line\">4) &quot;slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6381&quot;</span><br><span class=\"line\">1) &quot;pmessage&quot;</span><br><span class=\"line\">2) &quot;*&quot;</span><br><span class=\"line\">3) &quot;+role-change&quot;</span><br><span class=\"line\">4) &quot;slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6381 new reported role is slave&quot;</span><br></pre></td></tr></table></figure></p>\n<p>sentinel消息各种 + - 标识的含义:</p>\n<blockquote>\n<p>+reset-master <instance details=\"\"> – The master was reset.<br>    +slave <instance details=\"\"> – A new slave was detected and attached.<br>    +failover-state-reconf-slaves <instance details=\"\"> – Failover state changed to reconf-slaves state.<br>    +failover-detected <instance details=\"\"> – A failover started by another Sentinel or any other external entity was detected (An attached slave turned into a master).<br>    +slave-reconf-sent <instance details=\"\"> – The leader sentinel sent the SLAVEOF command to this instance in order to reconfigure it for the new slave.<br>    +slave-reconf-inprog <instance details=\"\"> – The slave being reconfigured showed to be a slave of the new master ip:port pair, but the synchronization process is not yet complete.<br>    +slave-reconf-done <instance details=\"\"> – The slave is now synchronized with the new master.<br>    -dup-sentinel <instance details=\"\"> – One or more sentinels for the specified master were removed as duplicated (this happens for instance when a Sentinel instance is restarted).<br>    +sentinel <instance details=\"\"> – A new sentinel for this master was detected and attached.<br>    +sdown <instance details=\"\"> – The specified instance is now in Subjectively Down state.<br>    -sdown <instance details=\"\"> – The specified instance is no longer in Subjectively Down state.<br>    +odown <instance details=\"\"> – The specified instance is now in Objectively Down state.<br>    -odown <instance details=\"\"> – The specified instance is no longer in Objectively Down state.<br>    +new-epoch <instance details=\"\"> – The current epoch was updated.<br>    +try-failover <instance details=\"\"> – New failover in progress, waiting to be elected by the majority.<br>    +elected-leader <instance details=\"\"> – Won the election for the specified epoch, can do the failover.<br>    +failover-state-select-slave <instance details=\"\"> – New failover state is select-slave: we are trying to find a suitable slave for promotion.<br>    no-good-slave <instance details=\"\"> – There is no good slave to promote. Currently we’ll try after some time, but probably this will change and the state machine will abort the failover at all in this case.<br>    selected-slave <instance details=\"\"> – We found the specified good slave to promote.<br>    failover-state-send-slaveof-noone <instance details=\"\"> – We are trying to reconfigure the promoted slave as master, waiting for it to switch.<br>    failover-end-for-timeout <instance details=\"\"> – The failover terminated for timeout, slaves will eventually be configured to replicate with the new master anyway.<br>    failover-end <instance details=\"\"> – The failover terminated with success. All the slaves appears to be reconfigured to replicate with the new master.<br>    switch-master <master name=\"\"> <oldip> <oldport> <newip> <newport> – The master new IP and address is the specified one after a configuration change. This is the message most external users are interested in.<br>    +tilt – Tilt mode entered.<br>    -tilt – Tilt mode exited.</newport></newip></oldport></oldip></master></instance></instance></instance></instance></instance></instance></instance></instance></instance></instance></instance></instance></instance></instance></instance></instance></instance></instance></instance></instance></instance></instance></p>\n</blockquote>\n<p><strong>leader 日志</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[30369] 13 Jan 20:21:06.701 # +sdown master mymaster 127.0.0.1 6380</span><br><span class=\"line\">[30369] 13 Jan 20:21:06.768 # +odown master mymaster 127.0.0.1 6380 #quorum 2/2</span><br><span class=\"line\">[30369] 13 Jan 20:21:06.768 # +new-epoch 2</span><br><span class=\"line\">[30369] 13 Jan 20:21:06.768 # +try-failover master mymaster 127.0.0.1 6380</span><br><span class=\"line\">[30369] 13 Jan 20:21:06.782 # +vote-for-leader 299da3eb5862baf267d16e36306defe7517bab5b 2</span><br><span class=\"line\">[30369] 13 Jan 20:21:06.821 # 127.0.0.1:26381 voted for 299da3eb5862baf267d16e36306defe7517bab5b 2</span><br><span class=\"line\">[30369] 13 Jan 20:21:06.821 # 127.0.0.1:26379 voted for 299da3eb5862baf267d16e36306defe7517bab5b 2</span><br><span class=\"line\">[30369] 13 Jan 20:21:06.844 # +elected-leader master mymaster 127.0.0.1 6380</span><br><span class=\"line\">[30369] 13 Jan 20:21:06.844 # +failover-state-select-slave master mymaster 127.0.0.1 6380</span><br><span class=\"line\">[30369] 13 Jan 20:21:06.902 # +selected-slave slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6380</span><br><span class=\"line\">[30369] 13 Jan 20:21:06.902 * +failover-state-send-slaveof-noone slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6380</span><br><span class=\"line\">[30369] 13 Jan 20:21:06.965 * +failover-state-wait-promotion slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6380</span><br><span class=\"line\">[30369] 13 Jan 20:21:07.830 # +promoted-slave slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6380</span><br><span class=\"line\">[30369] 13 Jan 20:21:07.830 # +failover-state-reconf-slaves master mymaster 127.0.0.1 6380</span><br><span class=\"line\">[30369] 13 Jan 20:21:07.872 * +slave-reconf-sent slave 127.0.0.1:6379 127.0.0.1 6379 @ mymaster 127.0.0.1 6380</span><br><span class=\"line\">[30369] 13 Jan 20:21:08.852 * +slave-reconf-inprog slave 127.0.0.1:6379 127.0.0.1 6379 @ mymaster 127.0.0.1 6380</span><br><span class=\"line\">[30369] 13 Jan 20:21:08.976 # -odown master mymaster 127.0.0.1 6380</span><br><span class=\"line\">[30369] 13 Jan 20:22:53.198 * +reboot master mymaster 127.0.0.1 6380</span><br><span class=\"line\">[30369] 13 Jan 20:22:53.249 # -sdown master mymaster 127.0.0.1 6380</span><br></pre></td></tr></table></figure></p>\n<p><strong>follower 日志</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[29838] 13 Jan 20:21:06.803 # +new-epoch 2</span><br><span class=\"line\">[29838] 13 Jan 20:21:06.821 # +vote-for-leader 299da3eb5862baf267d16e36306defe7517bab5b 2</span><br><span class=\"line\">[29838] 13 Jan 20:21:06.821 # +sdown master mymaster 127.0.0.1 6380</span><br><span class=\"line\">[29838] 13 Jan 20:21:06.898 # +odown master mymaster 127.0.0.1 6380 #quorum 3/2</span><br><span class=\"line\">[29838] 13 Jan 20:21:06.898 # Next failover delay: I will not start a failover before Sat Jan 13 20:27:07 2018</span><br><span class=\"line\">[29838] 13 Jan 20:21:07.874 # +config-update-from sentinel 127.0.0.1:26380 127.0.0.1 26380 @ mymaster 127.0.0.1 6380</span><br><span class=\"line\">[29838] 13 Jan 20:21:07.874 # +switch-master mymaster 127.0.0.1 6380 127.0.0.1 6381</span><br><span class=\"line\">[29838] 13 Jan 20:21:07.874 * +slave slave 127.0.0.1:6379 127.0.0.1 6379 @ mymaster 127.0.0.1 6381</span><br><span class=\"line\">[29838] 13 Jan 20:21:07.894 * +slave slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6381</span><br><span class=\"line\">[29838] 13 Jan 20:21:37.913 # +sdown slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6381</span><br><span class=\"line\">[29838] 13 Jan 20:22:53.322 # -sdown slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6381</span><br></pre></td></tr></table></figure></p>\n<p>[^sentinelSendPeriodicCommands]:<a href=\"https://github.com/antirez/redis/blob/3.0/src/sentinel.c\" target=\"_blank\" rel=\"noopener\">https://github.com/antirez/redis/blob/3.0/src/sentinel.c</a> sentinelSendPeriodicCommands()</p>\n","site":{"data":{}},"excerpt":"<p>redis sentinel是redis为支持自动failover的主从模式开发的功能，sentinel实际上也是一个redis实例，不过它只支持部分特有命令，通过<code>redis-server /path/to/sentinel.conf --sentinel</code>启动sentinel实例。<br>","more":"</p>\n<h3 id=\"整体视图\"><a href=\"#整体视图\" class=\"headerlink\" title=\"整体视图\"></a>整体视图</h3><p>sentinel服务由多个节点组成，当进行容灾操作时需要多数节点达成一致，因此sentinel节点之间需要建立通信（蓝色部分）。同时为了监控redis节点状态，每个sentinel节点都会和redis实例建立命令连接（图中虚线），sentinel节点还会通过publish命令向其他节点（包括master/slave/sentinel）发送”hello msg”(参考[^sentinelSendPeriodicCommands]）<br>，通过redis的发布/订阅功能来交换信息。</p>\n<p>注意：sentinel接收publish命令时执行的是fake publish<br><img src=\"/images/redis/sentinel.png\" alt=\"overview\"></p>\n<p>继续下面的内容前，需要了解sentinel的几个重要配置参数：</p>\n<blockquote>\n<p><strong>monitor</strong> master_name,master_ip,master_port,quorum<br> (master信息客观下线需要的票数)<br><strong>down-after-milliseconds</strong> master_name XXms (失联多久被视为主观下线)<br><strong>failover-timeout</strong> master_name XXms (处理故障的超时时间)<br><strong>parallel-syncs</strong>  master_name number (执行故障转移时，可以同时从新的master同步数据的slave数量）</p>\n</blockquote>\n<h3 id=\"发现新redis实例\"><a href=\"#发现新redis实例\" class=\"headerlink\" title=\"发现新redis实例\"></a>发现新redis实例</h3><p>可以发现配置sentinel时不需要填写slave节点的信息，这是因为sentinel可以从它监视的master发送INFO命令获得对应的slave信息，然后再与slave建立连接。通过这种方式sentinel也能够发现新加入的slave节点，过程如图所示：<br><img src=\"/images/redis/s1.png\" alt=\"1\"></p>\n<h3 id=\"发现新sentinel实例\"><a href=\"#发现新sentinel实例\" class=\"headerlink\" title=\"发现新sentinel实例\"></a>发现新sentinel实例</h3><p>类似地，一个sentinel实例也能够自主的发现其他sentinel实例，不过这是通过channel接收其他sentinel实例发送的消息实现的，每个sentinel实例会定时所有节点发送PUBLISH命令来向channel投递消息，内容主要是sentinel自己和信息和它保存的master的信息，格式如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PUBLISH __sentinel__:hello sentinel_ip,sentinel_port,sentinel_runid,current_epoch,</span><br><span class=\"line\">master_name,master_ip,master_port,master_config_epoch.</span><br></pre></td></tr></table></figure></p>\n<p>消息会由redis实例的频道发送给所有监视实例的sentinel，其他sentinel收到信息后，如果自己没有保存消息中的sentinel会保存下来，同时epoch如果小于消息中epoch也会自我更新：<br><img src=\"/images/redis/s2.png\" alt=\"step2\"></p>\n<h3 id=\"判断节点下线过程\"><a href=\"#判断节点下线过程\" class=\"headerlink\" title=\"判断节点下线过程\"></a>判断节点下线过程</h3><p>sentinel会通过定时向监视的redis实例发送ping命令，检查redis的状态，当redis回复异常或者在超时时间内没有回复时sentinel会将节点设置为主观下线（subjectively down）。而且如果节点是master的话，sentinel需要判断节点是否能设置为客观下线（Objectively down）,过程如图所示：<br>（1）节点回复不正常，sentinel把节点置为主观下线<br>（2）给其他sentinel发送<code>is-master-down-by-addr</code>命令，格式如下<code>IS-MASTER-DOWN-BY-ADDR &lt;master_ip&gt; &lt;master_port&gt; &lt;sentinel:current-epoch&gt; &lt;sentinel:runid&gt;</code><br>（只有当发起投票时才会发送runid,此时runid内容为*）<br>（3）收到<code>is-master-down-by-addr</code>的sentinel检查对应redis实例的状态（实际不会发送ping命令，只是检查保存的节点状态是不是主观下线）<br>（4）发现节点下线回复消息，回复内容如下，后两个是投票时用到的<code>down state, leader, vote epoch</code><br>（5）当sentinel1 收到足够多的“节点下线”的回复后（大于配置的quorum），将master状态设置为客观下线，然后failover流程才开始进行。</p>\n<p><img src=\"/images/redis/s3.png\" alt=\"s3\"></p>\n<h3 id=\"failover第一步-选举leader\"><a href=\"#failover第一步-选举leader\" class=\"headerlink\" title=\"failover第一步:选举leader\"></a>failover第一步:选举leader</h3><p>failover操作只能由一个sentinel节点来执行，因此开始failover首先要选举出一个Leader,sentinel的选举采用的是<a href=\"http://www.infoq.com/cn/articles/raft-paper\" target=\"_blank\" rel=\"noopener\">Raft算法</a>中的领导人选举机制。在这里确认master客观下线的sentinel会成为候选人，等待failover_start_time（一个随机时间，为了避免候选人同时开始选举导致平票），然后开始向其他实例发起投票请求，依然是使用<code>is-master-down-by-addr</code>命令，投票时主要依据是epoch字段。具体流程如图所示：<br><img src=\"/images/redis/s4.png\" alt=\"s4\"></p>\n<h3 id=\"failover第二步：执行故障转移\"><a href=\"#failover第二步：执行故障转移\" class=\"headerlink\" title=\"failover第二步：执行故障转移\"></a>failover第二步：执行故障转移</h3><p>Leader选举成功之后，会在slave中选择一个最优的，然后“提拔”这个slave作为新的master,然后其他redis实例会来同步新master的数据，具体过程如下：<br><img src=\"/images/redis/s5.png\" alt=\"dofailover\"></p>\n<h3 id=\"sentinel的整体执行流程\"><a href=\"#sentinel的整体执行流程\" class=\"headerlink\" title=\"sentinel的整体执行流程\"></a>sentinel的整体执行流程</h3><p>上面描述的行为都是通过redis定时任务来驱动的，特别的，sentinel中定义了一个状态机（switch-case代码块）来根据此时master的failover_state执行不同的操作，下面的图从外向内展示了sentinel主要功能的调用过程：</p>\n<blockquote>\n<p>（1）servCron函数(在server.c)负责执行redis的定时任务，包括过期键，写AOF文件等等，同时包括执行sentinel定时任务<br>（2）sentinelTimer(sentinel.c)是sentinel模式的定时任务，执行<a href=\"http://doc.redisfans.com/topic/sentinel.html#tilt\" target=\"_blank\" rel=\"noopener\">TILT模式</a>的检查，执行脚本，还有就是处理RedisInstance（集群中所有的master/slave/sentinel实例）<br>（3）在sentinelHandleRedisInstance函数中，会依次执行reconnect函数维护与其他实例的连接（命令连接和pub/sub）,定期发送命令（info/ping/hello）,判断主观下线<br>（4）当实例是master时会执行客观下线的检查，在StartFailoverIfNeeded函数中，如果满足条件会开始failover的过程（master会变成SENTINEL_FAILOVER_STATE_WAIT_START，然后还会向其他sentinel确认master状态，使用force模式才会发送is-master-down命令，此时可能也会发起投票）<br>（5）状态机逻辑的执行在StartFailoverIfNeeded执行之后（和上一步结果无关），状态机就是在每次定时任务循环中检查当前master的状态然后执行不同阶段的failover操作，最后会执行askOther的步骤，本次定时任务结束。</p>\n</blockquote>\n<p><img src=\"/images/redis/state.png\" alt=\"state\"></p>\n<h3 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h3><p><strong>1、完整的failoverstate</strong><br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Failover machine different states. */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SENTINEL_FAILOVER_STATE_NONE 0  <span class=\"comment\">/* No failover in progress. */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SENTINEL_FAILOVER_STATE_WAIT_START 1  <span class=\"comment\">/* Wait for failover_start_time*/</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SENTINEL_FAILOVER_STATE_SELECT_SLAVE 2 <span class=\"comment\">/* Select slave to promote */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SENTINEL_FAILOVER_STATE_SEND_SLAVEOF_NOONE 3 <span class=\"comment\">/* Slave -&gt; Master */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SENTINEL_FAILOVER_STATE_WAIT_PROMOTION 4 <span class=\"comment\">/* Wait slave to change role */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SENTINEL_FAILOVER_STATE_RECONF_SLAVES 5 <span class=\"comment\">/* SLAVEOF newmaster */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SENTINEL_FAILOVER_STATE_UPDATE_CONFIG 6 <span class=\"comment\">/* Monitor promoted slave.master配置更新为新的master */</span></span></span><br></pre></td></tr></table></figure></p>\n<p><strong>2、redis实例收到的sentinel消息</strong><br>集群中一台slave的hello频道中传播的消息，此时master端口是6380：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; psubscribe *</span><br><span class=\"line\">1) &quot;pmessage&quot;</span><br><span class=\"line\">2) &quot;*&quot;</span><br><span class=\"line\">3) &quot;__sentinel__:hello&quot;</span><br><span class=\"line\">4) &quot;127.0.0.1,26380,299da3eb5862baf267d16e36306defe7517bab5b,3,mymaster,127.0.0.1,6380,3&quot;</span><br><span class=\"line\">1) &quot;pmessage&quot;</span><br><span class=\"line\">2) &quot;*&quot;</span><br><span class=\"line\">3) &quot;__sentinel__:hello&quot;</span><br><span class=\"line\">4) &quot;127.0.0.1,26381,bf3ac725160092d5db0fefdcc4814379003a75a8,3,mymaster,127.0.0.1,6380,3&quot;</span><br><span class=\"line\">1) &quot;pmessage&quot;</span><br><span class=\"line\">2) &quot;*&quot;</span><br><span class=\"line\">3) &quot;__sentinel__:hello&quot;</span><br><span class=\"line\">4) &quot;127.0.0.1,26379,9e47039b5fd9735296df2340e54a4c37caeabbb2,3,mymaster,127.0.0.1,6380,3&quot;</span><br></pre></td></tr></table></figure></p>\n<p><strong>3、一次failover的日志</strong><br>master port:6380<br>Leader port:26380<br>Leader run_id:299da3eb5862baf267d16e36306defe7517bab5b<br><strong>follower sentinel收到的消息:</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:26379&gt; psubscribe *</span><br><span class=\"line\">Reading messages... (press Ctrl-C to quit)</span><br><span class=\"line\">1) &quot;psubscribe&quot;</span><br><span class=\"line\">2) &quot;*&quot;</span><br><span class=\"line\">3) (integer) 1</span><br><span class=\"line\">1) &quot;pmessage&quot;</span><br><span class=\"line\">2) &quot;*&quot;</span><br><span class=\"line\">3) &quot;+new-epoch&quot;</span><br><span class=\"line\">4) &quot;2&quot;</span><br><span class=\"line\">1) &quot;pmessage&quot;</span><br><span class=\"line\">2) &quot;*&quot;</span><br><span class=\"line\">3) &quot;+vote-for-leader&quot;</span><br><span class=\"line\">4) &quot;299da3eb5862baf267d16e36306defe7517bab5b 2&quot;</span><br><span class=\"line\">1) &quot;pmessage&quot;</span><br><span class=\"line\">2) &quot;*&quot;</span><br><span class=\"line\">3) &quot;+sdown&quot;</span><br><span class=\"line\">4) &quot;master mymaster 127.0.0.1 6380&quot;</span><br><span class=\"line\">1) &quot;pmessage&quot;</span><br><span class=\"line\">2) &quot;*&quot;</span><br><span class=\"line\">3) &quot;+odown&quot;</span><br><span class=\"line\">4) &quot;master mymaster 127.0.0.1 6380 #quorum 3/2&quot;</span><br><span class=\"line\">1) &quot;pmessage&quot;</span><br><span class=\"line\">2) &quot;*&quot;</span><br><span class=\"line\">3) &quot;+config-update-from&quot;</span><br><span class=\"line\">4) &quot;sentinel 127.0.0.1:26380 127.0.0.1 26380 @ mymaster 127.0.0.1 6380&quot;</span><br><span class=\"line\">1) &quot;pmessage&quot;</span><br><span class=\"line\">2) &quot;*&quot;</span><br><span class=\"line\">3) &quot;+switch-master&quot;</span><br><span class=\"line\">4) &quot;mymaster 127.0.0.1 6380 127.0.0.1 6381&quot;</span><br><span class=\"line\">1) &quot;pmessage&quot;</span><br><span class=\"line\">2) &quot;*&quot;</span><br><span class=\"line\">3) &quot;+slave&quot;</span><br><span class=\"line\">4) &quot;slave 127.0.0.1:6379 127.0.0.1 6379 @ mymaster 127.0.0.1 6381&quot;</span><br><span class=\"line\">1) &quot;pmessage&quot;</span><br><span class=\"line\">2) &quot;*&quot;</span><br><span class=\"line\">3) &quot;+slave&quot;</span><br><span class=\"line\">4) &quot;slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6381&quot;</span><br><span class=\"line\">1) &quot;pmessage&quot;</span><br><span class=\"line\">2) &quot;*&quot;</span><br><span class=\"line\">3) &quot;+sdown&quot;</span><br><span class=\"line\">4) &quot;slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6381&quot;</span><br><span class=\"line\">1) &quot;pmessage&quot;</span><br><span class=\"line\">2) &quot;*&quot;</span><br><span class=\"line\">3) &quot;-role-change&quot;</span><br><span class=\"line\">4) &quot;slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6381 new reported role is master&quot;</span><br><span class=\"line\">1) &quot;pmessage&quot;</span><br><span class=\"line\">2) &quot;*&quot;</span><br><span class=\"line\">3) &quot;-sdown&quot;</span><br><span class=\"line\">4) &quot;slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6381&quot;</span><br><span class=\"line\">1) &quot;pmessage&quot;</span><br><span class=\"line\">2) &quot;*&quot;</span><br><span class=\"line\">3) &quot;+role-change&quot;</span><br><span class=\"line\">4) &quot;slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6381 new reported role is slave&quot;</span><br></pre></td></tr></table></figure></p>\n<p>sentinel消息各种 + - 标识的含义:</p>\n<blockquote>\n<p>+reset-master <instance details=\"\"> – The master was reset.<br>    +slave <instance details=\"\"> – A new slave was detected and attached.<br>    +failover-state-reconf-slaves <instance details=\"\"> – Failover state changed to reconf-slaves state.<br>    +failover-detected <instance details=\"\"> – A failover started by another Sentinel or any other external entity was detected (An attached slave turned into a master).<br>    +slave-reconf-sent <instance details=\"\"> – The leader sentinel sent the SLAVEOF command to this instance in order to reconfigure it for the new slave.<br>    +slave-reconf-inprog <instance details=\"\"> – The slave being reconfigured showed to be a slave of the new master ip:port pair, but the synchronization process is not yet complete.<br>    +slave-reconf-done <instance details=\"\"> – The slave is now synchronized with the new master.<br>    -dup-sentinel <instance details=\"\"> – One or more sentinels for the specified master were removed as duplicated (this happens for instance when a Sentinel instance is restarted).<br>    +sentinel <instance details=\"\"> – A new sentinel for this master was detected and attached.<br>    +sdown <instance details=\"\"> – The specified instance is now in Subjectively Down state.<br>    -sdown <instance details=\"\"> – The specified instance is no longer in Subjectively Down state.<br>    +odown <instance details=\"\"> – The specified instance is now in Objectively Down state.<br>    -odown <instance details=\"\"> – The specified instance is no longer in Objectively Down state.<br>    +new-epoch <instance details=\"\"> – The current epoch was updated.<br>    +try-failover <instance details=\"\"> – New failover in progress, waiting to be elected by the majority.<br>    +elected-leader <instance details=\"\"> – Won the election for the specified epoch, can do the failover.<br>    +failover-state-select-slave <instance details=\"\"> – New failover state is select-slave: we are trying to find a suitable slave for promotion.<br>    no-good-slave <instance details=\"\"> – There is no good slave to promote. Currently we’ll try after some time, but probably this will change and the state machine will abort the failover at all in this case.<br>    selected-slave <instance details=\"\"> – We found the specified good slave to promote.<br>    failover-state-send-slaveof-noone <instance details=\"\"> – We are trying to reconfigure the promoted slave as master, waiting for it to switch.<br>    failover-end-for-timeout <instance details=\"\"> – The failover terminated for timeout, slaves will eventually be configured to replicate with the new master anyway.<br>    failover-end <instance details=\"\"> – The failover terminated with success. All the slaves appears to be reconfigured to replicate with the new master.<br>    switch-master <master name=\"\"> <oldip> <oldport> <newip> <newport> – The master new IP and address is the specified one after a configuration change. This is the message most external users are interested in.<br>    +tilt – Tilt mode entered.<br>    -tilt – Tilt mode exited.</newport></newip></oldport></oldip></master></instance></instance></instance></instance></instance></instance></instance></instance></instance></instance></instance></instance></instance></instance></instance></instance></instance></instance></instance></instance></instance></instance></p>\n</blockquote>\n<p><strong>leader 日志</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[30369] 13 Jan 20:21:06.701 # +sdown master mymaster 127.0.0.1 6380</span><br><span class=\"line\">[30369] 13 Jan 20:21:06.768 # +odown master mymaster 127.0.0.1 6380 #quorum 2/2</span><br><span class=\"line\">[30369] 13 Jan 20:21:06.768 # +new-epoch 2</span><br><span class=\"line\">[30369] 13 Jan 20:21:06.768 # +try-failover master mymaster 127.0.0.1 6380</span><br><span class=\"line\">[30369] 13 Jan 20:21:06.782 # +vote-for-leader 299da3eb5862baf267d16e36306defe7517bab5b 2</span><br><span class=\"line\">[30369] 13 Jan 20:21:06.821 # 127.0.0.1:26381 voted for 299da3eb5862baf267d16e36306defe7517bab5b 2</span><br><span class=\"line\">[30369] 13 Jan 20:21:06.821 # 127.0.0.1:26379 voted for 299da3eb5862baf267d16e36306defe7517bab5b 2</span><br><span class=\"line\">[30369] 13 Jan 20:21:06.844 # +elected-leader master mymaster 127.0.0.1 6380</span><br><span class=\"line\">[30369] 13 Jan 20:21:06.844 # +failover-state-select-slave master mymaster 127.0.0.1 6380</span><br><span class=\"line\">[30369] 13 Jan 20:21:06.902 # +selected-slave slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6380</span><br><span class=\"line\">[30369] 13 Jan 20:21:06.902 * +failover-state-send-slaveof-noone slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6380</span><br><span class=\"line\">[30369] 13 Jan 20:21:06.965 * +failover-state-wait-promotion slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6380</span><br><span class=\"line\">[30369] 13 Jan 20:21:07.830 # +promoted-slave slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6380</span><br><span class=\"line\">[30369] 13 Jan 20:21:07.830 # +failover-state-reconf-slaves master mymaster 127.0.0.1 6380</span><br><span class=\"line\">[30369] 13 Jan 20:21:07.872 * +slave-reconf-sent slave 127.0.0.1:6379 127.0.0.1 6379 @ mymaster 127.0.0.1 6380</span><br><span class=\"line\">[30369] 13 Jan 20:21:08.852 * +slave-reconf-inprog slave 127.0.0.1:6379 127.0.0.1 6379 @ mymaster 127.0.0.1 6380</span><br><span class=\"line\">[30369] 13 Jan 20:21:08.976 # -odown master mymaster 127.0.0.1 6380</span><br><span class=\"line\">[30369] 13 Jan 20:22:53.198 * +reboot master mymaster 127.0.0.1 6380</span><br><span class=\"line\">[30369] 13 Jan 20:22:53.249 # -sdown master mymaster 127.0.0.1 6380</span><br></pre></td></tr></table></figure></p>\n<p><strong>follower 日志</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[29838] 13 Jan 20:21:06.803 # +new-epoch 2</span><br><span class=\"line\">[29838] 13 Jan 20:21:06.821 # +vote-for-leader 299da3eb5862baf267d16e36306defe7517bab5b 2</span><br><span class=\"line\">[29838] 13 Jan 20:21:06.821 # +sdown master mymaster 127.0.0.1 6380</span><br><span class=\"line\">[29838] 13 Jan 20:21:06.898 # +odown master mymaster 127.0.0.1 6380 #quorum 3/2</span><br><span class=\"line\">[29838] 13 Jan 20:21:06.898 # Next failover delay: I will not start a failover before Sat Jan 13 20:27:07 2018</span><br><span class=\"line\">[29838] 13 Jan 20:21:07.874 # +config-update-from sentinel 127.0.0.1:26380 127.0.0.1 26380 @ mymaster 127.0.0.1 6380</span><br><span class=\"line\">[29838] 13 Jan 20:21:07.874 # +switch-master mymaster 127.0.0.1 6380 127.0.0.1 6381</span><br><span class=\"line\">[29838] 13 Jan 20:21:07.874 * +slave slave 127.0.0.1:6379 127.0.0.1 6379 @ mymaster 127.0.0.1 6381</span><br><span class=\"line\">[29838] 13 Jan 20:21:07.894 * +slave slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6381</span><br><span class=\"line\">[29838] 13 Jan 20:21:37.913 # +sdown slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6381</span><br><span class=\"line\">[29838] 13 Jan 20:22:53.322 # -sdown slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6381</span><br></pre></td></tr></table></figure></p>\n<p>[^sentinelSendPeriodicCommands]:<a href=\"https://github.com/antirez/redis/blob/3.0/src/sentinel.c\" target=\"_blank\" rel=\"noopener\">https://github.com/antirez/redis/blob/3.0/src/sentinel.c</a> sentinelSendPeriodicCommands()</p>"},{"title":"理解CMS回收器的preclean阶段","date":"2020-06-21T05:11:23.000Z","_content":"\n\n在《深入理解Java虚拟机：JVM高级特性与最佳实践（第二版）》里这样介绍CMS回收器的工作过程:\n>CMS收集器是基于“标记—清除”算法实现的，它的运作过程相对于前面几种收集器来说更复杂一些，整个过程分为4个步骤，包括：   •初始标记（CMS initial mark）   •并发标记（CMS concurrent mark）   •重新标记（CMS remark）   •并发清除（CMS concurrent sweep）\n\n很多人可能只看了这本书的介绍（实际这应该只是作者的概括），就认为CMS回收器就只有这4个阶段，看一下这里的gc log:\n<!--more-->\n```java\n0.245: [GC (CMS Initial Mark) [1 CMS-initial-mark: 32776K(53248K)] 41701K(99328K), 0.0061676 secs] [Times: user=0.01 sys=0.00, real=0.01 secs] \n0.251: [CMS-concurrent-mark-start]\n0.270: [CMS-concurrent-mark: 0.004/0.020 secs] [Times: user=0.08 sys=0.01, real=0.02 secs] \n0.270: [CMS-concurrent-preclean-start]\n0.272: [CMS-concurrent-preclean: 0.001/0.001 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] \n0.272: [CMS-concurrent-abortable-preclean-start]\n0.291: [CMS-concurrent-abortable-preclean: 0.004/0.019 secs] [Times: user=0.09 sys=0.00, real=0.02 secs] \n0.291: [GC (CMS Final Remark) [YG occupancy: 17928 K (46080 K)]0.291: [Rescan (parallel) , 0.0082702 secs]0.299: [weak refs processing, 0.0000475 secs]0.299: [class unloading, 0.0002451 secs]0.299: [scrub symbol table, 0.0003183 secs]0.300: [scrub string table, 0.0001611 secs][1 CMS-remark: 49164K(53248K)] 67093K(99328K), 0.0091462 secs] [Times: user=0.04 sys=0.00, real=0.01 secs] \n0.300: [CMS-concurrent-sweep-start]\n0.300: [CMS-concurrent-sweep: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] \n0.300: [CMS-concurrent-reset-start]\n0.300: [CMS-concurrent-reset: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] \n```\n\n注意日志中“增加”了concurrent-preclean，concurrent-abortable-preclean，concurrent-reset三个阶段，其中concurrent-reset主要是CMS为了下次gc做准备，而重置内部数据结构的过程，这里不做过多介绍。本文主要分享一下我对**concurrent-preclean** 和 **concurrent-abortable-preclean**两个阶段的理解。\n\n## concurrent-preclean\n\n### 分代的理想状态\n\n我们知道jvm利用**分治**的思想，把内存分为老年代和年轻代，在理想情况下，不同分代中的对象彼此不会有引用关系，属于老死不相往来的状态。\n\n{% asset_img gen1.png image %}\n\n在gc开始时，为了标记存活对象，gc线程需要沿着对象引用路径从gc root遍历（可达性分析），这时为了得到正确的引用关系，需要暂停应用线程，所以遍历对象的代价很高。因此，每个分代的垃圾回收器都希望**各扫门前雪**，只标记自己分代的存活对象，比如young gc时，当gc线程遇到引用指向老年代时就会停止遍历，因为它只负责回收年轻代内存空间，不需要去访问老年代对象。\n\n{% asset_img gc.jpg image %}\n\n但是实际上，年轻代和老年代的对象并不会100%的彼此隔离，会有一些对象引用其他分代对象，这被称为**跨代引用**。如果young gc线程只遍历年轻代内的对象引用，那么老年代到年轻代的跨代引用就会被忽略，被老年代存活对象跨代引用的年轻代对象会被回收，这样就破坏了应用程序的运行。下图展示了实际的对象引用情况，红色箭头代表跨代引用，在young gc时需要标记出来：\n\n{% asset_img gen2.png image %}\n\n### Card Marking\n\n在young gc时，为了**找到跨代引用**，通常有这几个方法：\n\n1. 当对象引用路径指向老年代时继续遍历老年代对象找到跨代引用\n2. 线性地扫描老年代对象，标记跨代引用，用顺序读代替离散读\n3. 从程序开始运行，就使用一个集合记录所有跨代引用的创建，在young gc时扫描这个集合里指向年轻代的跨代引用\n\n\n前两种方式都需要在young gc时去遍历老年代对象，因为老年代存活对象多，工作量太大，jvm使用的是第三种方式。\n\n首先分析**跨代引用如何产生的**：对于老年代到年轻代的跨代引用（a->b），产生条件有两种，一是gc线程把对象a从年轻代移动到了老年代，二是a本身是老年代对象，应用线程修改了a的引用指向了年轻代的b（\n对于年轻代到老年代的跨代引用就只有第二种情况）。\n\n对于gc线程本身创建的跨代引用，可以直接由gc线程在创建时记录，所以问题就变成了：**如何记录应用线程修改对象引用时创建的跨代引用？**。\n\n在jvm中再次使用分治法，将老年代划分成多个card（和linux内存page类似），只要card内对象引用被应用线程修改，就把card标记为dirty。然后young gc时会扫描老年代中dirty card对应的内存区域，记录其中的跨代引用，这种方式被称为**Card Marking**。\n\njvm通过写屏障（write barrier）来实现监控程序线程对引用的修改，并且标记对应card，写屏障工作方式和**代理模式**类似，具体来说是通过在引用赋值指令执行时，添加对了card table的修改指令。以最简单的`setFoo(Object bar)` 方法为例，[jvm编译的汇编指令如下](http://psy-lob-saw.blogspot.com/2014/10/the-jvm-write-barrier-card-marking.html),第一行是赋值指令，后面几行标记被修改的引用所在的card为脏页，即`CARD_TABLE[this address >> 9] = 0`：\n\n\n```c\n; rsi is 'this' address\n; rdx is setter param, reference to bar\n; JDK6:\nmov    QWORD PTR [rsi+0x20],rdx  ; this.foo = bar\nmov    r10,rsi                   ; r10 = rsi = this\nshr    r10,0x9                   ; r10 = r10 >> 9;\nmov    r11,0x7ebdfcff7f00        ; r11 is base of card table, imagine byte[] CARD_TABLE\nmov    BYTE PTR [r11+r10*1],0x0  ; Mark 'this' card as dirty, CARD_TABLE[this address >> 9] = 0\n```\n\n\n**小结**：jvm使用card marking的方式，避免了young gc时扫描整个老年代存活对象，付出的代价是在每次修改引用时添加额外的汇编指令实现写屏障，和额外的内存来保存card table。\n\n\n### preclean做了什么\n\n现在回到cms回收器，在老年代gc时，同样使用到了card marking，目的不是找到跨代引用（年轻代到老年代的跨代引用是通过从gc root遍历对象标记的），而是找到前面concurrent-marking阶段被应用线程并发修改的对象引用。\n\npreclean阶段是**对这些card marking产生的dirty card进行clean**，cms gc线程会扫描dirty card对应的内存区域，更新之前记录的过时的引用信息，并且去掉dirty card的标记，如下图所示：\n\n![引用自https://plumbr.io/](https://plumbr.io/app/uploads/2015/06/g1-08.png)\n\n在preclean执行后，dirty card被清理，被修改的引用信息也被更新。\n\n![引用自https://plumbr.io/](https://plumbr.io/app/uploads/2015/06/g1-09.png)\n\n## concurrent-abortable-preclean\n\nconcurrent-abortable-preclean阶段目的是减轻final remark阶段（会暂停应用线程）的负担，这个阶段同样会对dirty card的扫描/清理，和concurrent-preclean的区别在于，concurrent-abortable-preclean会重复地以迭代的方式执行，直到满足退出条件。**但是concurrent-preclean已经处理过dirty card,为什么jvm还需要再执行一个类似的阶段呢？**\n\n### 连续STW\n\n首先我们考虑下这个情况：如果final-remark阶段开始时刚好进行了young gc（比如ParNew）,应用程序刚因为young gc暂停，然后又会因为final-remark暂停，造成**连续的长暂停**。除此之外，因为young gc线程修改了存活对象的引用地址，会产生很多需要重新扫描的对象，增加了final-remark的工作量。\n所以concurrent-abortable-preclean除了clean card的作用，还有**调度final-remark开始时机**的作用[参考](https://blogs.oracle.com/poonam/understanding-cms-gc-logs)。cms回收器认为，final-remark最理想的执行时机就是年轻代占用在50%时，这时刚好处于上次young gc完成（0%）和下次young gc开始（100%）的中间节点，如图所示：\n\n{% asset_img abpreclean.png image %}\n\n### 配置参数\n\nabortable-preclean的**中断条件**，配置参数是`-XX:CMSScheduleRemarkEdenPenetration=50`（默认值），表示当eden区内存占用到达50%时，中断abortable-preclean，开始执行final-remark，对应[jvm源码](https://github.com/JetBrains/jdk8u_hotspot/blob/12d02c91b0b4c63d04daff4e36a79bb6045b2c7f/src/share/vm/gc_implementation/concurrentMarkSweep/concurrentMarkSweepGeneration.cpp)片段如下：\n\n```c\n//当eden占用比例超过配置，将_abort_preclean标记赋值为true\nif ((_collectorState == AbortablePreclean) && !_abort_preclean) {\n    size_t used = get_eden_used();\n    size_t capacity = get_eden_capacity();\n    assert(used <= capacity, \"Unexpected state of Eden\");\n    if (used >  (capacity/100 * CMSScheduleRemarkEdenPenetration)) {\n      _abort_preclean = true;\n    }\n  }\n```\n\nabortable-preclean的**触发条件**配置， `-XX:CMSScheduleRemarkEdenSizeThreshold=2m`（默认值），表示当eden内存占用超过2mb时才会执行abortable-preclean，否则没有执行的必要。\n\n\nabortable-preclean的**主动退出条件**配置，`-XX:CMSMaxAbortablePrecleanTime=5000`和CMSMaxAbortablePrecleanLoops，主要因为如果年轻代内存占用增长缓慢，那么abortable-preclean要长时间执行，可能因为preclean赶不上应用线程创造dirty card的速度导致dirty card越来越多，此时还不如执行一个final-remark,对应jvm源码片段如下：\n\n```c\n// Try and schedule the remark such that young gen\n// occupancy is CMSScheduleRemarkEdenPenetration %.\n// 保留原始注释，看下abortable_preclean的定位\nvoid CMSCollector::abortable_preclean() {\n  //校验触发条件\n  if (get_eden_used() > CMSScheduleRemarkEdenSizeThreshold) {\n\n    // 感受一下作者的纠结，他认为目前的主动退出条件有点蠢，FIX ME!!! 哈哈\n    // One, admittedly dumb, strategy is to give up\n    // after a certain number of abortable precleaning loops\n    // or after a certain maximum time. We want to make\n    // this smarter in the next iteration.\n    // XXX FIX ME!!! YSR\n    size_t loops = 0, workdone = 0, cumworkdone = 0, waited = 0;\n    //should_abort_preclean会检查上面说的_abort_preclean是否为true\n    while (!(should_abort_preclean() ||\n             ConcurrentMarkSweepThread::should_terminate())) {\n      workdone = preclean_work(CMSPrecleanRefLists2, CMSPrecleanSurvivors2);\n      cumworkdone += workdone;\n      loops++;\n      // 主动停止执行\n      if ((CMSMaxAbortablePrecleanLoops != 0) &&\n          loops >= CMSMaxAbortablePrecleanLoops) {\n        if (PrintGCDetails) {\n          gclog_or_tty->print(\" CMS: abort preclean due to loops \");\n        }\n        break;\n      }\n      if (pa.wallclock_millis() > CMSMaxAbortablePrecleanTime) {\n        if (PrintGCDetails) {\n          gclog_or_tty->print(\" CMS: abort preclean due to time \");\n        }\n        break;\n      }\n      // 如果工作效率不高，主动暂停一会儿\n      if (workdone < CMSAbortablePrecleanMinWorkPerIteration) {\n        // Sleep for some time, waiting for work to accumulate\n        stopTimer();\n        cmsThread()->wait_on_cms_lock(CMSAbortablePrecleanWaitMillis);\n        startTimer();\n        waited++;\n      }\n    }\n    //打印工作情况\n    if (PrintCMSStatistics > 0) {\n      gclog_or_tty->print(\" [%d iterations, %d waits, %d cards)] \",\n                          loops, waited, cumworkdone);\n    }\n  }\n  return;\n}\n```\n\n## 实践验证\n\njava代码如下：\n\n```java\n\n public class DumbObj {\n    public DumbObj(int sizeM,DumbObj next) {\n        this.data = getM(sizeM);\n        this.next = next;\n    }\n    private Byte[] getM(int m) {\n        return new Byte[1024 * 1024 * m];\n    }\n    private DumbObj next;\n    private Byte [] data;\n }\n //存活对象\n private static List<DumbObj> liveObjs = new ArrayList<>(5);\n public static void main(String[] args) throws InterruptedException {\n        //创建新对象触发gc\n        for(int i=0;i<25;i++){\n            DumbObj dumb = new DumbObj(1, null);\n            if(liveObjs.size()<5){\n                liveObjs.add(new DumbObj(1, dumb));\n            }else{\n                dumb.setNext(liveObjs.get(i%5));\n            }\n        }\n        //等待gc线程工作\n        TimeUnit.SECONDS.sleep(20);\n    }\n\n```\n在jvm参数里添加-XX:PrintCMSStatistics=1，通过gc日志可以看到cms回收器在preclean阶段执行的操作：\n>-Xms101m\n-Xmn50m\n-Xmx101m\n-verbose:gc\n-XX:MetaspaceSize=1m\n-XX:+UseConcMarkSweepGC\n-Xloggc:/tmp/gc.log\n-XX:+PrintGCCause\n-XX:+PrintGCTimeStamps\n-XX:+PrintGCDetails\n-XX:PrintCMSStatistics=1\n-XX:CMSScheduleRemarkEdenPenetration=50\n-XX:CMSScheduleRemarkEdenSizeThreshold=2m\n-XX:CMSMaxAbortablePrecleanTime=5000\n-XX:+UseCMSInitiatingOccupancyOnly\n-XX:CMSInitiatingOccupancyFraction=50\n\n运行程序，查看gc日志:在时间0.303，concurrent-preclean开始，重新扫描了5个card,在0.304时，开始abortable-preclean-start，多个线程又进行了一次迭代，扫描dirty card,在5秒后，5.324时，因为达到最大运行时间主动退出，开始remark阶段。\n\n```java\n0.303: [CMS-concurrent-mark: 0.010/0.010 secs] (CMS-concurrent-mark yielded 0 times)\n [Times: user=0.02 sys=0.00, real=0.01 secs] \n0.303: [CMS-concurrent-preclean-start]\n (cardTable: 5 cards, re-scanned 5 cards, 1 iterations)\n0.304: [CMS-concurrent-preclean: 0.000/0.000 secs] (CMS-concurrent-preclean yielded 0 times)\n [Times: user=0.00 sys=0.00, real=0.00 secs] \n0.304: [CMS-concurrent-abortable-preclean-start]\n (cardTable: 0 cards, re-scanned 0 cards, 1 iterations)\n (cardTable: 0 cards, re-scanned 0 cards, 1 iterations)\n (cardTable: 0 cards, re-scanned 0 cards, 1 iterations)\n (cardTable: 0 cards, re-scanned 0 cards, 1 iterations)\n (cardTable: 0 cards, re-scanned 0 cards, 1 iterations)\n (cardTable: 0 cards, re-scanned 0 cards, 1 iterations)\n (cardTable: 0 cards, re-scanned 0 cards, 1 iterations)\n //有省略\n CMS: abort preclean due to time  [50 iterations, 49 waits, 0 cards)] 5.324: [CMS-concurrent-abortable-preclean: 0.012/5.020 secs] (CMS-concurrent-abortable-preclean yielded 0 times)\n [Times: user=0.02 sys=0.00, real=5.02 secs] \n5.324: [GC (CMS Final Remark) [YG occupancy: 17157 K (46080 K)]5.324: [Rescan (parallel)  (Survivor:0chunks) Finished young gen rescan work in 4th thread: 0.000 sec\n```\n修改-XX:CMSScheduleRemarkEdenSizeThreshold=50m,和年轻代大小相等，再观察gc日志，不会出现concurrent-abortable-preclean阶段：\n\n```java\n2.296: [CMS-concurrent-mark: 0.010/0.010 secs] (CMS-concurrent-mark yielded 0 times)\n [Times: user=0.02 sys=0.00, real=0.01 secs] \n2.296: [CMS-concurrent-preclean-start]\n (cardTable: 1 cards, re-scanned 1 cards, 1 iterations)\n2.296: [CMS-concurrent-preclean: 0.000/0.000 secs] (CMS-concurrent-preclean yielded 0 times)\n [Times: user=0.00 sys=0.00, real=0.00 secs] \n2.296: [GC (CMS Final Remark) [YG occupancy: 17157 K (46080 K)]2.296: [Rescan (parallel)  (Survivor:0chunks) Finished young gen rescan work in 4th thread: 0.000 sec\n```\n\n## 总结\n跨代引用和card marking:\n{% asset_img summary.png image %}\n\n\npreclean: 清理card marking标记的dirty card，更新引用记录\n\nabortable-preclean: 调节final-remark阶段的运行时机\n\n参考文章：\n\nBrian Goetz的文章: https://www.ibm.com/developerworks/library/j-jtp11253/index.html\ncard mark介绍: http://psy-lob-saw.blogspot.com/2014/10/the-jvm-write-barrier-card-marking.html\n理解preclean: https://stackoverflow.com/questions/44182733/can-someone-explain-what-happens-in-the-concurrent-abortable-preclean-phase-of\njvm源码： https://github.com/JetBrains/jdk8u_hotspot\n\n[1]: https://github.com/JetBrains/jdk8u_hotspot/blob/12d02c91b0b4c63d04daff4e36a79bb6045b2c7f/src/share/vm/gc_implementation/concurrentMarkSweep/concurrentMarkSweepGeneration.cpp 'git'\n\n\n\n\n","source":"_posts/理解CMS回收器的preclean阶段.md","raw":"---\ntitle: 理解CMS回收器的preclean阶段\ndate: 2020-06-21 13:11:23\ntags:\n---\n\n\n在《深入理解Java虚拟机：JVM高级特性与最佳实践（第二版）》里这样介绍CMS回收器的工作过程:\n>CMS收集器是基于“标记—清除”算法实现的，它的运作过程相对于前面几种收集器来说更复杂一些，整个过程分为4个步骤，包括：   •初始标记（CMS initial mark）   •并发标记（CMS concurrent mark）   •重新标记（CMS remark）   •并发清除（CMS concurrent sweep）\n\n很多人可能只看了这本书的介绍（实际这应该只是作者的概括），就认为CMS回收器就只有这4个阶段，看一下这里的gc log:\n<!--more-->\n```java\n0.245: [GC (CMS Initial Mark) [1 CMS-initial-mark: 32776K(53248K)] 41701K(99328K), 0.0061676 secs] [Times: user=0.01 sys=0.00, real=0.01 secs] \n0.251: [CMS-concurrent-mark-start]\n0.270: [CMS-concurrent-mark: 0.004/0.020 secs] [Times: user=0.08 sys=0.01, real=0.02 secs] \n0.270: [CMS-concurrent-preclean-start]\n0.272: [CMS-concurrent-preclean: 0.001/0.001 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] \n0.272: [CMS-concurrent-abortable-preclean-start]\n0.291: [CMS-concurrent-abortable-preclean: 0.004/0.019 secs] [Times: user=0.09 sys=0.00, real=0.02 secs] \n0.291: [GC (CMS Final Remark) [YG occupancy: 17928 K (46080 K)]0.291: [Rescan (parallel) , 0.0082702 secs]0.299: [weak refs processing, 0.0000475 secs]0.299: [class unloading, 0.0002451 secs]0.299: [scrub symbol table, 0.0003183 secs]0.300: [scrub string table, 0.0001611 secs][1 CMS-remark: 49164K(53248K)] 67093K(99328K), 0.0091462 secs] [Times: user=0.04 sys=0.00, real=0.01 secs] \n0.300: [CMS-concurrent-sweep-start]\n0.300: [CMS-concurrent-sweep: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] \n0.300: [CMS-concurrent-reset-start]\n0.300: [CMS-concurrent-reset: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] \n```\n\n注意日志中“增加”了concurrent-preclean，concurrent-abortable-preclean，concurrent-reset三个阶段，其中concurrent-reset主要是CMS为了下次gc做准备，而重置内部数据结构的过程，这里不做过多介绍。本文主要分享一下我对**concurrent-preclean** 和 **concurrent-abortable-preclean**两个阶段的理解。\n\n## concurrent-preclean\n\n### 分代的理想状态\n\n我们知道jvm利用**分治**的思想，把内存分为老年代和年轻代，在理想情况下，不同分代中的对象彼此不会有引用关系，属于老死不相往来的状态。\n\n{% asset_img gen1.png image %}\n\n在gc开始时，为了标记存活对象，gc线程需要沿着对象引用路径从gc root遍历（可达性分析），这时为了得到正确的引用关系，需要暂停应用线程，所以遍历对象的代价很高。因此，每个分代的垃圾回收器都希望**各扫门前雪**，只标记自己分代的存活对象，比如young gc时，当gc线程遇到引用指向老年代时就会停止遍历，因为它只负责回收年轻代内存空间，不需要去访问老年代对象。\n\n{% asset_img gc.jpg image %}\n\n但是实际上，年轻代和老年代的对象并不会100%的彼此隔离，会有一些对象引用其他分代对象，这被称为**跨代引用**。如果young gc线程只遍历年轻代内的对象引用，那么老年代到年轻代的跨代引用就会被忽略，被老年代存活对象跨代引用的年轻代对象会被回收，这样就破坏了应用程序的运行。下图展示了实际的对象引用情况，红色箭头代表跨代引用，在young gc时需要标记出来：\n\n{% asset_img gen2.png image %}\n\n### Card Marking\n\n在young gc时，为了**找到跨代引用**，通常有这几个方法：\n\n1. 当对象引用路径指向老年代时继续遍历老年代对象找到跨代引用\n2. 线性地扫描老年代对象，标记跨代引用，用顺序读代替离散读\n3. 从程序开始运行，就使用一个集合记录所有跨代引用的创建，在young gc时扫描这个集合里指向年轻代的跨代引用\n\n\n前两种方式都需要在young gc时去遍历老年代对象，因为老年代存活对象多，工作量太大，jvm使用的是第三种方式。\n\n首先分析**跨代引用如何产生的**：对于老年代到年轻代的跨代引用（a->b），产生条件有两种，一是gc线程把对象a从年轻代移动到了老年代，二是a本身是老年代对象，应用线程修改了a的引用指向了年轻代的b（\n对于年轻代到老年代的跨代引用就只有第二种情况）。\n\n对于gc线程本身创建的跨代引用，可以直接由gc线程在创建时记录，所以问题就变成了：**如何记录应用线程修改对象引用时创建的跨代引用？**。\n\n在jvm中再次使用分治法，将老年代划分成多个card（和linux内存page类似），只要card内对象引用被应用线程修改，就把card标记为dirty。然后young gc时会扫描老年代中dirty card对应的内存区域，记录其中的跨代引用，这种方式被称为**Card Marking**。\n\njvm通过写屏障（write barrier）来实现监控程序线程对引用的修改，并且标记对应card，写屏障工作方式和**代理模式**类似，具体来说是通过在引用赋值指令执行时，添加对了card table的修改指令。以最简单的`setFoo(Object bar)` 方法为例，[jvm编译的汇编指令如下](http://psy-lob-saw.blogspot.com/2014/10/the-jvm-write-barrier-card-marking.html),第一行是赋值指令，后面几行标记被修改的引用所在的card为脏页，即`CARD_TABLE[this address >> 9] = 0`：\n\n\n```c\n; rsi is 'this' address\n; rdx is setter param, reference to bar\n; JDK6:\nmov    QWORD PTR [rsi+0x20],rdx  ; this.foo = bar\nmov    r10,rsi                   ; r10 = rsi = this\nshr    r10,0x9                   ; r10 = r10 >> 9;\nmov    r11,0x7ebdfcff7f00        ; r11 is base of card table, imagine byte[] CARD_TABLE\nmov    BYTE PTR [r11+r10*1],0x0  ; Mark 'this' card as dirty, CARD_TABLE[this address >> 9] = 0\n```\n\n\n**小结**：jvm使用card marking的方式，避免了young gc时扫描整个老年代存活对象，付出的代价是在每次修改引用时添加额外的汇编指令实现写屏障，和额外的内存来保存card table。\n\n\n### preclean做了什么\n\n现在回到cms回收器，在老年代gc时，同样使用到了card marking，目的不是找到跨代引用（年轻代到老年代的跨代引用是通过从gc root遍历对象标记的），而是找到前面concurrent-marking阶段被应用线程并发修改的对象引用。\n\npreclean阶段是**对这些card marking产生的dirty card进行clean**，cms gc线程会扫描dirty card对应的内存区域，更新之前记录的过时的引用信息，并且去掉dirty card的标记，如下图所示：\n\n![引用自https://plumbr.io/](https://plumbr.io/app/uploads/2015/06/g1-08.png)\n\n在preclean执行后，dirty card被清理，被修改的引用信息也被更新。\n\n![引用自https://plumbr.io/](https://plumbr.io/app/uploads/2015/06/g1-09.png)\n\n## concurrent-abortable-preclean\n\nconcurrent-abortable-preclean阶段目的是减轻final remark阶段（会暂停应用线程）的负担，这个阶段同样会对dirty card的扫描/清理，和concurrent-preclean的区别在于，concurrent-abortable-preclean会重复地以迭代的方式执行，直到满足退出条件。**但是concurrent-preclean已经处理过dirty card,为什么jvm还需要再执行一个类似的阶段呢？**\n\n### 连续STW\n\n首先我们考虑下这个情况：如果final-remark阶段开始时刚好进行了young gc（比如ParNew）,应用程序刚因为young gc暂停，然后又会因为final-remark暂停，造成**连续的长暂停**。除此之外，因为young gc线程修改了存活对象的引用地址，会产生很多需要重新扫描的对象，增加了final-remark的工作量。\n所以concurrent-abortable-preclean除了clean card的作用，还有**调度final-remark开始时机**的作用[参考](https://blogs.oracle.com/poonam/understanding-cms-gc-logs)。cms回收器认为，final-remark最理想的执行时机就是年轻代占用在50%时，这时刚好处于上次young gc完成（0%）和下次young gc开始（100%）的中间节点，如图所示：\n\n{% asset_img abpreclean.png image %}\n\n### 配置参数\n\nabortable-preclean的**中断条件**，配置参数是`-XX:CMSScheduleRemarkEdenPenetration=50`（默认值），表示当eden区内存占用到达50%时，中断abortable-preclean，开始执行final-remark，对应[jvm源码](https://github.com/JetBrains/jdk8u_hotspot/blob/12d02c91b0b4c63d04daff4e36a79bb6045b2c7f/src/share/vm/gc_implementation/concurrentMarkSweep/concurrentMarkSweepGeneration.cpp)片段如下：\n\n```c\n//当eden占用比例超过配置，将_abort_preclean标记赋值为true\nif ((_collectorState == AbortablePreclean) && !_abort_preclean) {\n    size_t used = get_eden_used();\n    size_t capacity = get_eden_capacity();\n    assert(used <= capacity, \"Unexpected state of Eden\");\n    if (used >  (capacity/100 * CMSScheduleRemarkEdenPenetration)) {\n      _abort_preclean = true;\n    }\n  }\n```\n\nabortable-preclean的**触发条件**配置， `-XX:CMSScheduleRemarkEdenSizeThreshold=2m`（默认值），表示当eden内存占用超过2mb时才会执行abortable-preclean，否则没有执行的必要。\n\n\nabortable-preclean的**主动退出条件**配置，`-XX:CMSMaxAbortablePrecleanTime=5000`和CMSMaxAbortablePrecleanLoops，主要因为如果年轻代内存占用增长缓慢，那么abortable-preclean要长时间执行，可能因为preclean赶不上应用线程创造dirty card的速度导致dirty card越来越多，此时还不如执行一个final-remark,对应jvm源码片段如下：\n\n```c\n// Try and schedule the remark such that young gen\n// occupancy is CMSScheduleRemarkEdenPenetration %.\n// 保留原始注释，看下abortable_preclean的定位\nvoid CMSCollector::abortable_preclean() {\n  //校验触发条件\n  if (get_eden_used() > CMSScheduleRemarkEdenSizeThreshold) {\n\n    // 感受一下作者的纠结，他认为目前的主动退出条件有点蠢，FIX ME!!! 哈哈\n    // One, admittedly dumb, strategy is to give up\n    // after a certain number of abortable precleaning loops\n    // or after a certain maximum time. We want to make\n    // this smarter in the next iteration.\n    // XXX FIX ME!!! YSR\n    size_t loops = 0, workdone = 0, cumworkdone = 0, waited = 0;\n    //should_abort_preclean会检查上面说的_abort_preclean是否为true\n    while (!(should_abort_preclean() ||\n             ConcurrentMarkSweepThread::should_terminate())) {\n      workdone = preclean_work(CMSPrecleanRefLists2, CMSPrecleanSurvivors2);\n      cumworkdone += workdone;\n      loops++;\n      // 主动停止执行\n      if ((CMSMaxAbortablePrecleanLoops != 0) &&\n          loops >= CMSMaxAbortablePrecleanLoops) {\n        if (PrintGCDetails) {\n          gclog_or_tty->print(\" CMS: abort preclean due to loops \");\n        }\n        break;\n      }\n      if (pa.wallclock_millis() > CMSMaxAbortablePrecleanTime) {\n        if (PrintGCDetails) {\n          gclog_or_tty->print(\" CMS: abort preclean due to time \");\n        }\n        break;\n      }\n      // 如果工作效率不高，主动暂停一会儿\n      if (workdone < CMSAbortablePrecleanMinWorkPerIteration) {\n        // Sleep for some time, waiting for work to accumulate\n        stopTimer();\n        cmsThread()->wait_on_cms_lock(CMSAbortablePrecleanWaitMillis);\n        startTimer();\n        waited++;\n      }\n    }\n    //打印工作情况\n    if (PrintCMSStatistics > 0) {\n      gclog_or_tty->print(\" [%d iterations, %d waits, %d cards)] \",\n                          loops, waited, cumworkdone);\n    }\n  }\n  return;\n}\n```\n\n## 实践验证\n\njava代码如下：\n\n```java\n\n public class DumbObj {\n    public DumbObj(int sizeM,DumbObj next) {\n        this.data = getM(sizeM);\n        this.next = next;\n    }\n    private Byte[] getM(int m) {\n        return new Byte[1024 * 1024 * m];\n    }\n    private DumbObj next;\n    private Byte [] data;\n }\n //存活对象\n private static List<DumbObj> liveObjs = new ArrayList<>(5);\n public static void main(String[] args) throws InterruptedException {\n        //创建新对象触发gc\n        for(int i=0;i<25;i++){\n            DumbObj dumb = new DumbObj(1, null);\n            if(liveObjs.size()<5){\n                liveObjs.add(new DumbObj(1, dumb));\n            }else{\n                dumb.setNext(liveObjs.get(i%5));\n            }\n        }\n        //等待gc线程工作\n        TimeUnit.SECONDS.sleep(20);\n    }\n\n```\n在jvm参数里添加-XX:PrintCMSStatistics=1，通过gc日志可以看到cms回收器在preclean阶段执行的操作：\n>-Xms101m\n-Xmn50m\n-Xmx101m\n-verbose:gc\n-XX:MetaspaceSize=1m\n-XX:+UseConcMarkSweepGC\n-Xloggc:/tmp/gc.log\n-XX:+PrintGCCause\n-XX:+PrintGCTimeStamps\n-XX:+PrintGCDetails\n-XX:PrintCMSStatistics=1\n-XX:CMSScheduleRemarkEdenPenetration=50\n-XX:CMSScheduleRemarkEdenSizeThreshold=2m\n-XX:CMSMaxAbortablePrecleanTime=5000\n-XX:+UseCMSInitiatingOccupancyOnly\n-XX:CMSInitiatingOccupancyFraction=50\n\n运行程序，查看gc日志:在时间0.303，concurrent-preclean开始，重新扫描了5个card,在0.304时，开始abortable-preclean-start，多个线程又进行了一次迭代，扫描dirty card,在5秒后，5.324时，因为达到最大运行时间主动退出，开始remark阶段。\n\n```java\n0.303: [CMS-concurrent-mark: 0.010/0.010 secs] (CMS-concurrent-mark yielded 0 times)\n [Times: user=0.02 sys=0.00, real=0.01 secs] \n0.303: [CMS-concurrent-preclean-start]\n (cardTable: 5 cards, re-scanned 5 cards, 1 iterations)\n0.304: [CMS-concurrent-preclean: 0.000/0.000 secs] (CMS-concurrent-preclean yielded 0 times)\n [Times: user=0.00 sys=0.00, real=0.00 secs] \n0.304: [CMS-concurrent-abortable-preclean-start]\n (cardTable: 0 cards, re-scanned 0 cards, 1 iterations)\n (cardTable: 0 cards, re-scanned 0 cards, 1 iterations)\n (cardTable: 0 cards, re-scanned 0 cards, 1 iterations)\n (cardTable: 0 cards, re-scanned 0 cards, 1 iterations)\n (cardTable: 0 cards, re-scanned 0 cards, 1 iterations)\n (cardTable: 0 cards, re-scanned 0 cards, 1 iterations)\n (cardTable: 0 cards, re-scanned 0 cards, 1 iterations)\n //有省略\n CMS: abort preclean due to time  [50 iterations, 49 waits, 0 cards)] 5.324: [CMS-concurrent-abortable-preclean: 0.012/5.020 secs] (CMS-concurrent-abortable-preclean yielded 0 times)\n [Times: user=0.02 sys=0.00, real=5.02 secs] \n5.324: [GC (CMS Final Remark) [YG occupancy: 17157 K (46080 K)]5.324: [Rescan (parallel)  (Survivor:0chunks) Finished young gen rescan work in 4th thread: 0.000 sec\n```\n修改-XX:CMSScheduleRemarkEdenSizeThreshold=50m,和年轻代大小相等，再观察gc日志，不会出现concurrent-abortable-preclean阶段：\n\n```java\n2.296: [CMS-concurrent-mark: 0.010/0.010 secs] (CMS-concurrent-mark yielded 0 times)\n [Times: user=0.02 sys=0.00, real=0.01 secs] \n2.296: [CMS-concurrent-preclean-start]\n (cardTable: 1 cards, re-scanned 1 cards, 1 iterations)\n2.296: [CMS-concurrent-preclean: 0.000/0.000 secs] (CMS-concurrent-preclean yielded 0 times)\n [Times: user=0.00 sys=0.00, real=0.00 secs] \n2.296: [GC (CMS Final Remark) [YG occupancy: 17157 K (46080 K)]2.296: [Rescan (parallel)  (Survivor:0chunks) Finished young gen rescan work in 4th thread: 0.000 sec\n```\n\n## 总结\n跨代引用和card marking:\n{% asset_img summary.png image %}\n\n\npreclean: 清理card marking标记的dirty card，更新引用记录\n\nabortable-preclean: 调节final-remark阶段的运行时机\n\n参考文章：\n\nBrian Goetz的文章: https://www.ibm.com/developerworks/library/j-jtp11253/index.html\ncard mark介绍: http://psy-lob-saw.blogspot.com/2014/10/the-jvm-write-barrier-card-marking.html\n理解preclean: https://stackoverflow.com/questions/44182733/can-someone-explain-what-happens-in-the-concurrent-abortable-preclean-phase-of\njvm源码： https://github.com/JetBrains/jdk8u_hotspot\n\n[1]: https://github.com/JetBrains/jdk8u_hotspot/blob/12d02c91b0b4c63d04daff4e36a79bb6045b2c7f/src/share/vm/gc_implementation/concurrentMarkSweep/concurrentMarkSweepGeneration.cpp 'git'\n\n\n\n\n","slug":"理解CMS回收器的preclean阶段","published":1,"updated":"2020-06-26T04:07:12.582Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkqle1cw002pcynehtp5aixr","content":"<p>在《深入理解Java虚拟机：JVM高级特性与最佳实践（第二版）》里这样介绍CMS回收器的工作过程:</p>\n<blockquote>\n<p>CMS收集器是基于“标记—清除”算法实现的，它的运作过程相对于前面几种收集器来说更复杂一些，整个过程分为4个步骤，包括：   •初始标记（CMS initial mark）   •并发标记（CMS concurrent mark）   •重新标记（CMS remark）   •并发清除（CMS concurrent sweep）</p>\n</blockquote>\n<p>很多人可能只看了这本书的介绍（实际这应该只是作者的概括），就认为CMS回收器就只有这4个阶段，看一下这里的gc log:<br><a id=\"more\"></a><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0.245</span>: [GC (CMS Initial Mark) [<span class=\"number\">1</span> CMS-initial-mark: <span class=\"number\">32776</span>K(<span class=\"number\">53248</span>K)] <span class=\"number\">41701</span>K(<span class=\"number\">99328</span>K), <span class=\"number\">0.0061676</span> secs] [Times: user=<span class=\"number\">0.01</span> sys=<span class=\"number\">0.00</span>, real=<span class=\"number\">0.01</span> secs] </span><br><span class=\"line\"><span class=\"number\">0.251</span>: [CMS-concurrent-mark-start]</span><br><span class=\"line\"><span class=\"number\">0.270</span>: [CMS-concurrent-mark: <span class=\"number\">0.004</span>/<span class=\"number\">0.020</span> secs] [Times: user=<span class=\"number\">0.08</span> sys=<span class=\"number\">0.01</span>, real=<span class=\"number\">0.02</span> secs] </span><br><span class=\"line\"><span class=\"number\">0.270</span>: [CMS-concurrent-preclean-start]</span><br><span class=\"line\"><span class=\"number\">0.272</span>: [CMS-concurrent-preclean: <span class=\"number\">0.001</span>/<span class=\"number\">0.001</span> secs] [Times: user=<span class=\"number\">0.00</span> sys=<span class=\"number\">0.00</span>, real=<span class=\"number\">0.00</span> secs] </span><br><span class=\"line\"><span class=\"number\">0.272</span>: [CMS-concurrent-abortable-preclean-start]</span><br><span class=\"line\"><span class=\"number\">0.291</span>: [CMS-concurrent-abortable-preclean: <span class=\"number\">0.004</span>/<span class=\"number\">0.019</span> secs] [Times: user=<span class=\"number\">0.09</span> sys=<span class=\"number\">0.00</span>, real=<span class=\"number\">0.02</span> secs] </span><br><span class=\"line\">0.291: [GC (CMS Final Remark) [YG occupancy: 17928 K (46080 K)]0.291: [Rescan (parallel) , 0.0082702 secs]0.299: [weak refs processing, 0.0000475 secs]0.299: [class unloading, 0.0002451 secs]0.299: [scrub symbol table, 0.0003183 secs]0.300: [scrub string table, 0.0001611 secs][1 CMS-remark: 49164K(53248K)] 67093K(99328K), 0.0091462 secs] [Times: user=0.04 sys=0.00, real=0.01 secs] </span><br><span class=\"line\"><span class=\"number\">0.300</span>: [CMS-concurrent-sweep-start]</span><br><span class=\"line\"><span class=\"number\">0.300</span>: [CMS-concurrent-sweep: <span class=\"number\">0.000</span>/<span class=\"number\">0.000</span> secs] [Times: user=<span class=\"number\">0.00</span> sys=<span class=\"number\">0.00</span>, real=<span class=\"number\">0.00</span> secs] </span><br><span class=\"line\"><span class=\"number\">0.300</span>: [CMS-concurrent-reset-start]</span><br><span class=\"line\"><span class=\"number\">0.300</span>: [CMS-concurrent-reset: <span class=\"number\">0.000</span>/<span class=\"number\">0.000</span> secs] [Times: user=<span class=\"number\">0.00</span> sys=<span class=\"number\">0.00</span>, real=<span class=\"number\">0.00</span> secs]</span><br></pre></td></tr></table></figure></p>\n<p>注意日志中“增加”了concurrent-preclean，concurrent-abortable-preclean，concurrent-reset三个阶段，其中concurrent-reset主要是CMS为了下次gc做准备，而重置内部数据结构的过程，这里不做过多介绍。本文主要分享一下我对<strong>concurrent-preclean</strong> 和 <strong>concurrent-abortable-preclean</strong>两个阶段的理解。</p>\n<h2 id=\"concurrent-preclean\"><a href=\"#concurrent-preclean\" class=\"headerlink\" title=\"concurrent-preclean\"></a>concurrent-preclean</h2><h3 id=\"分代的理想状态\"><a href=\"#分代的理想状态\" class=\"headerlink\" title=\"分代的理想状态\"></a>分代的理想状态</h3><p>我们知道jvm利用<strong>分治</strong>的思想，把内存分为老年代和年轻代，在理想情况下，不同分代中的对象彼此不会有引用关系，属于老死不相往来的状态。</p>\n<img src=\"/2020/06/21/理解CMS回收器的preclean阶段/gen1.png\" title=\"image\">\n<p>在gc开始时，为了标记存活对象，gc线程需要沿着对象引用路径从gc root遍历（可达性分析），这时为了得到正确的引用关系，需要暂停应用线程，所以遍历对象的代价很高。因此，每个分代的垃圾回收器都希望<strong>各扫门前雪</strong>，只标记自己分代的存活对象，比如young gc时，当gc线程遇到引用指向老年代时就会停止遍历，因为它只负责回收年轻代内存空间，不需要去访问老年代对象。</p>\n<img src=\"/2020/06/21/理解CMS回收器的preclean阶段/gc.jpg\" title=\"image\">\n<p>但是实际上，年轻代和老年代的对象并不会100%的彼此隔离，会有一些对象引用其他分代对象，这被称为<strong>跨代引用</strong>。如果young gc线程只遍历年轻代内的对象引用，那么老年代到年轻代的跨代引用就会被忽略，被老年代存活对象跨代引用的年轻代对象会被回收，这样就破坏了应用程序的运行。下图展示了实际的对象引用情况，红色箭头代表跨代引用，在young gc时需要标记出来：</p>\n<img src=\"/2020/06/21/理解CMS回收器的preclean阶段/gen2.png\" title=\"image\">\n<h3 id=\"Card-Marking\"><a href=\"#Card-Marking\" class=\"headerlink\" title=\"Card Marking\"></a>Card Marking</h3><p>在young gc时，为了<strong>找到跨代引用</strong>，通常有这几个方法：</p>\n<ol>\n<li>当对象引用路径指向老年代时继续遍历老年代对象找到跨代引用</li>\n<li>线性地扫描老年代对象，标记跨代引用，用顺序读代替离散读</li>\n<li>从程序开始运行，就使用一个集合记录所有跨代引用的创建，在young gc时扫描这个集合里指向年轻代的跨代引用</li>\n</ol>\n<p>前两种方式都需要在young gc时去遍历老年代对象，因为老年代存活对象多，工作量太大，jvm使用的是第三种方式。</p>\n<p>首先分析<strong>跨代引用如何产生的</strong>：对于老年代到年轻代的跨代引用（a-&gt;b），产生条件有两种，一是gc线程把对象a从年轻代移动到了老年代，二是a本身是老年代对象，应用线程修改了a的引用指向了年轻代的b（<br>对于年轻代到老年代的跨代引用就只有第二种情况）。</p>\n<p>对于gc线程本身创建的跨代引用，可以直接由gc线程在创建时记录，所以问题就变成了：<strong>如何记录应用线程修改对象引用时创建的跨代引用？</strong>。</p>\n<p>在jvm中再次使用分治法，将老年代划分成多个card（和linux内存page类似），只要card内对象引用被应用线程修改，就把card标记为dirty。然后young gc时会扫描老年代中dirty card对应的内存区域，记录其中的跨代引用，这种方式被称为<strong>Card Marking</strong>。</p>\n<p>jvm通过写屏障（write barrier）来实现监控程序线程对引用的修改，并且标记对应card，写屏障工作方式和<strong>代理模式</strong>类似，具体来说是通过在引用赋值指令执行时，添加对了card table的修改指令。以最简单的<code>setFoo(Object bar)</code> 方法为例，<a href=\"http://psy-lob-saw.blogspot.com/2014/10/the-jvm-write-barrier-card-marking.html\" target=\"_blank\" rel=\"noopener\">jvm编译的汇编指令如下</a>,第一行是赋值指令，后面几行标记被修改的引用所在的card为脏页，即<code>CARD_TABLE[this address &gt;&gt; 9] = 0</code>：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">; rsi is 'this' address</span><br><span class=\"line\">; rdx is setter param, reference to bar</span><br><span class=\"line\">; JDK6:</span><br><span class=\"line\">mov    QWORD PTR [rsi+<span class=\"number\">0x20</span>],rdx  ; <span class=\"keyword\">this</span>.foo = bar</span><br><span class=\"line\">mov    r10,rsi                   ; r10 = rsi = <span class=\"keyword\">this</span></span><br><span class=\"line\">shr    r10,<span class=\"number\">0x9</span>                   ; r10 = r10 &gt;&gt; <span class=\"number\">9</span>;</span><br><span class=\"line\">mov    r11,<span class=\"number\">0x7ebdfcff7f00</span>        ; r11 is base of card table, imagine byte[] CARD_TABLE</span><br><span class=\"line\">mov    BYTE PTR [r11+r10*1],0x0  ; Mark 'this' card as dirty, CARD_TABLE[this address &gt;&gt; 9] = 0</span><br></pre></td></tr></table></figure>\n<p><strong>小结</strong>：jvm使用card marking的方式，避免了young gc时扫描整个老年代存活对象，付出的代价是在每次修改引用时添加额外的汇编指令实现写屏障，和额外的内存来保存card table。</p>\n<h3 id=\"preclean做了什么\"><a href=\"#preclean做了什么\" class=\"headerlink\" title=\"preclean做了什么\"></a>preclean做了什么</h3><p>现在回到cms回收器，在老年代gc时，同样使用到了card marking，目的不是找到跨代引用（年轻代到老年代的跨代引用是通过从gc root遍历对象标记的），而是找到前面concurrent-marking阶段被应用线程并发修改的对象引用。</p>\n<p>preclean阶段是<strong>对这些card marking产生的dirty card进行clean</strong>，cms gc线程会扫描dirty card对应的内存区域，更新之前记录的过时的引用信息，并且去掉dirty card的标记，如下图所示：</p>\n<p><img src=\"https://plumbr.io/app/uploads/2015/06/g1-08.png\" alt=\"引用自https://plumbr.io/\"></p>\n<p>在preclean执行后，dirty card被清理，被修改的引用信息也被更新。</p>\n<p><img src=\"https://plumbr.io/app/uploads/2015/06/g1-09.png\" alt=\"引用自https://plumbr.io/\"></p>\n<h2 id=\"concurrent-abortable-preclean\"><a href=\"#concurrent-abortable-preclean\" class=\"headerlink\" title=\"concurrent-abortable-preclean\"></a>concurrent-abortable-preclean</h2><p>concurrent-abortable-preclean阶段目的是减轻final remark阶段（会暂停应用线程）的负担，这个阶段同样会对dirty card的扫描/清理，和concurrent-preclean的区别在于，concurrent-abortable-preclean会重复地以迭代的方式执行，直到满足退出条件。<strong>但是concurrent-preclean已经处理过dirty card,为什么jvm还需要再执行一个类似的阶段呢？</strong></p>\n<h3 id=\"连续STW\"><a href=\"#连续STW\" class=\"headerlink\" title=\"连续STW\"></a>连续STW</h3><p>首先我们考虑下这个情况：如果final-remark阶段开始时刚好进行了young gc（比如ParNew）,应用程序刚因为young gc暂停，然后又会因为final-remark暂停，造成<strong>连续的长暂停</strong>。除此之外，因为young gc线程修改了存活对象的引用地址，会产生很多需要重新扫描的对象，增加了final-remark的工作量。<br>所以concurrent-abortable-preclean除了clean card的作用，还有<strong>调度final-remark开始时机</strong>的作用<a href=\"https://blogs.oracle.com/poonam/understanding-cms-gc-logs\" target=\"_blank\" rel=\"noopener\">参考</a>。cms回收器认为，final-remark最理想的执行时机就是年轻代占用在50%时，这时刚好处于上次young gc完成（0%）和下次young gc开始（100%）的中间节点，如图所示：</p>\n<img src=\"/2020/06/21/理解CMS回收器的preclean阶段/abpreclean.png\" title=\"image\">\n<h3 id=\"配置参数\"><a href=\"#配置参数\" class=\"headerlink\" title=\"配置参数\"></a>配置参数</h3><p>abortable-preclean的<strong>中断条件</strong>，配置参数是<code>-XX:CMSScheduleRemarkEdenPenetration=50</code>（默认值），表示当eden区内存占用到达50%时，中断abortable-preclean，开始执行final-remark，对应<a href=\"https://github.com/JetBrains/jdk8u_hotspot/blob/12d02c91b0b4c63d04daff4e36a79bb6045b2c7f/src/share/vm/gc_implementation/concurrentMarkSweep/concurrentMarkSweepGeneration.cpp\" target=\"_blank\" rel=\"noopener\">jvm源码</a>片段如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//当eden占用比例超过配置，将_abort_preclean标记赋值为true</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> ((_collectorState == AbortablePreclean) &amp;&amp; !_abort_preclean) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> used = get_eden_used();</span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> capacity = get_eden_capacity();</span><br><span class=\"line\">    assert(used &lt;= capacity, <span class=\"string\">\"Unexpected state of Eden\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (used &gt;  (capacity/<span class=\"number\">100</span> * CMSScheduleRemarkEdenPenetration)) &#123;</span><br><span class=\"line\">      _abort_preclean = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>abortable-preclean的<strong>触发条件</strong>配置， <code>-XX:CMSScheduleRemarkEdenSizeThreshold=2m</code>（默认值），表示当eden内存占用超过2mb时才会执行abortable-preclean，否则没有执行的必要。</p>\n<p>abortable-preclean的<strong>主动退出条件</strong>配置，<code>-XX:CMSMaxAbortablePrecleanTime=5000</code>和CMSMaxAbortablePrecleanLoops，主要因为如果年轻代内存占用增长缓慢，那么abortable-preclean要长时间执行，可能因为preclean赶不上应用线程创造dirty card的速度导致dirty card越来越多，此时还不如执行一个final-remark,对应jvm源码片段如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Try and schedule the remark such that young gen</span></span><br><span class=\"line\"><span class=\"comment\">// occupancy is CMSScheduleRemarkEdenPenetration %.</span></span><br><span class=\"line\"><span class=\"comment\">// 保留原始注释，看下abortable_preclean的定位</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> CMSCollector::abortable_preclean() &#123;</span><br><span class=\"line\">  <span class=\"comment\">//校验触发条件</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (get_eden_used() &gt; CMSScheduleRemarkEdenSizeThreshold) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 感受一下作者的纠结，他认为目前的主动退出条件有点蠢，FIX ME!!! 哈哈</span></span><br><span class=\"line\">    <span class=\"comment\">// One, admittedly dumb, strategy is to give up</span></span><br><span class=\"line\">    <span class=\"comment\">// after a certain number of abortable precleaning loops</span></span><br><span class=\"line\">    <span class=\"comment\">// or after a certain maximum time. We want to make</span></span><br><span class=\"line\">    <span class=\"comment\">// this smarter in the next iteration.</span></span><br><span class=\"line\">    <span class=\"comment\">// XXX FIX ME!!! YSR</span></span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> loops = <span class=\"number\">0</span>, workdone = <span class=\"number\">0</span>, cumworkdone = <span class=\"number\">0</span>, waited = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">//should_abort_preclean会检查上面说的_abort_preclean是否为true</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!(should_abort_preclean() ||</span><br><span class=\"line\">             ConcurrentMarkSweepThread::should_terminate())) &#123;</span><br><span class=\"line\">      workdone = preclean_work(CMSPrecleanRefLists2, CMSPrecleanSurvivors2);</span><br><span class=\"line\">      cumworkdone += workdone;</span><br><span class=\"line\">      loops++;</span><br><span class=\"line\">      <span class=\"comment\">// 主动停止执行</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> ((CMSMaxAbortablePrecleanLoops != <span class=\"number\">0</span>) &amp;&amp;</span><br><span class=\"line\">          loops &gt;= CMSMaxAbortablePrecleanLoops) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (PrintGCDetails) &#123;</span><br><span class=\"line\">          gclog_or_tty-&gt;print(<span class=\"string\">\" CMS: abort preclean due to loops \"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (pa.wallclock_millis() &gt; CMSMaxAbortablePrecleanTime) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (PrintGCDetails) &#123;</span><br><span class=\"line\">          gclog_or_tty-&gt;print(<span class=\"string\">\" CMS: abort preclean due to time \"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 如果工作效率不高，主动暂停一会儿</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (workdone &lt; CMSAbortablePrecleanMinWorkPerIteration) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Sleep for some time, waiting for work to accumulate</span></span><br><span class=\"line\">        stopTimer();</span><br><span class=\"line\">        cmsThread()-&gt;wait_on_cms_lock(CMSAbortablePrecleanWaitMillis);</span><br><span class=\"line\">        startTimer();</span><br><span class=\"line\">        waited++;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//打印工作情况</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (PrintCMSStatistics &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      gclog_or_tty-&gt;print(<span class=\"string\">\" [%d iterations, %d waits, %d cards)] \"</span>,</span><br><span class=\"line\">                          loops, waited, cumworkdone);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"实践验证\"><a href=\"#实践验证\" class=\"headerlink\" title=\"实践验证\"></a>实践验证</h2><p>java代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DumbObj</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DumbObj</span><span class=\"params\">(<span class=\"keyword\">int</span> sizeM,DumbObj next)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">this</span>.data = getM(sizeM);</span><br><span class=\"line\">       <span class=\"keyword\">this</span>.next = next;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">private</span> Byte[] getM(<span class=\"keyword\">int</span> m) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Byte[<span class=\"number\">1024</span> * <span class=\"number\">1024</span> * m];</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">private</span> DumbObj next;</span><br><span class=\"line\">   <span class=\"keyword\">private</span> Byte [] data;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//存活对象</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> List&lt;DumbObj&gt; liveObjs = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(<span class=\"number\">5</span>);</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">       <span class=\"comment\">//创建新对象触发gc</span></span><br><span class=\"line\">       <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">25</span>;i++)&#123;</span><br><span class=\"line\">           DumbObj dumb = <span class=\"keyword\">new</span> DumbObj(<span class=\"number\">1</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">           <span class=\"keyword\">if</span>(liveObjs.size()&lt;<span class=\"number\">5</span>)&#123;</span><br><span class=\"line\">               liveObjs.add(<span class=\"keyword\">new</span> DumbObj(<span class=\"number\">1</span>, dumb));</span><br><span class=\"line\">           &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">               dumb.setNext(liveObjs.get(i%<span class=\"number\">5</span>));</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"comment\">//等待gc线程工作</span></span><br><span class=\"line\">       TimeUnit.SECONDS.sleep(<span class=\"number\">20</span>);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>在jvm参数里添加-XX:PrintCMSStatistics=1，通过gc日志可以看到cms回收器在preclean阶段执行的操作：</p>\n<blockquote>\n<p>-Xms101m<br>-Xmn50m<br>-Xmx101m<br>-verbose:gc<br>-XX:MetaspaceSize=1m<br>-XX:+UseConcMarkSweepGC<br>-Xloggc:/tmp/gc.log<br>-XX:+PrintGCCause<br>-XX:+PrintGCTimeStamps<br>-XX:+PrintGCDetails<br>-XX:PrintCMSStatistics=1<br>-XX:CMSScheduleRemarkEdenPenetration=50<br>-XX:CMSScheduleRemarkEdenSizeThreshold=2m<br>-XX:CMSMaxAbortablePrecleanTime=5000<br>-XX:+UseCMSInitiatingOccupancyOnly<br>-XX:CMSInitiatingOccupancyFraction=50</p>\n</blockquote>\n<p>运行程序，查看gc日志:在时间0.303，concurrent-preclean开始，重新扫描了5个card,在0.304时，开始abortable-preclean-start，多个线程又进行了一次迭代，扫描dirty card,在5秒后，5.324时，因为达到最大运行时间主动退出，开始remark阶段。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0.303</span>: [CMS-concurrent-mark: <span class=\"number\">0.010</span>/<span class=\"number\">0.010</span> secs] (CMS-concurrent-mark yielded <span class=\"number\">0</span> times)</span><br><span class=\"line\"> [Times: user=<span class=\"number\">0.02</span> sys=<span class=\"number\">0.00</span>, real=<span class=\"number\">0.01</span> secs] </span><br><span class=\"line\"><span class=\"number\">0.303</span>: [CMS-concurrent-preclean-start]</span><br><span class=\"line\"> (cardTable: <span class=\"number\">5</span> cards, re-scanned <span class=\"number\">5</span> cards, <span class=\"number\">1</span> iterations)</span><br><span class=\"line\"><span class=\"number\">0.304</span>: [CMS-concurrent-preclean: <span class=\"number\">0.000</span>/<span class=\"number\">0.000</span> secs] (CMS-concurrent-preclean yielded <span class=\"number\">0</span> times)</span><br><span class=\"line\"> [Times: user=<span class=\"number\">0.00</span> sys=<span class=\"number\">0.00</span>, real=<span class=\"number\">0.00</span> secs] </span><br><span class=\"line\"><span class=\"number\">0.304</span>: [CMS-concurrent-abortable-preclean-start]</span><br><span class=\"line\"> (cardTable: <span class=\"number\">0</span> cards, re-scanned <span class=\"number\">0</span> cards, <span class=\"number\">1</span> iterations)</span><br><span class=\"line\"> (cardTable: <span class=\"number\">0</span> cards, re-scanned <span class=\"number\">0</span> cards, <span class=\"number\">1</span> iterations)</span><br><span class=\"line\"> (cardTable: <span class=\"number\">0</span> cards, re-scanned <span class=\"number\">0</span> cards, <span class=\"number\">1</span> iterations)</span><br><span class=\"line\"> (cardTable: <span class=\"number\">0</span> cards, re-scanned <span class=\"number\">0</span> cards, <span class=\"number\">1</span> iterations)</span><br><span class=\"line\"> (cardTable: <span class=\"number\">0</span> cards, re-scanned <span class=\"number\">0</span> cards, <span class=\"number\">1</span> iterations)</span><br><span class=\"line\"> (cardTable: <span class=\"number\">0</span> cards, re-scanned <span class=\"number\">0</span> cards, <span class=\"number\">1</span> iterations)</span><br><span class=\"line\"> (cardTable: <span class=\"number\">0</span> cards, re-scanned <span class=\"number\">0</span> cards, <span class=\"number\">1</span> iterations)</span><br><span class=\"line\"> <span class=\"comment\">//有省略</span></span><br><span class=\"line\"> CMS: abort preclean due to time  [<span class=\"number\">50</span> iterations, <span class=\"number\">49</span> waits, <span class=\"number\">0</span> cards)] <span class=\"number\">5.324</span>: [CMS-concurrent-abortable-preclean: <span class=\"number\">0.012</span>/<span class=\"number\">5.020</span> secs] (CMS-concurrent-abortable-preclean yielded <span class=\"number\">0</span> times)</span><br><span class=\"line\"> [Times: user=<span class=\"number\">0.02</span> sys=<span class=\"number\">0.00</span>, real=<span class=\"number\">5.02</span> secs] </span><br><span class=\"line\"><span class=\"number\">5.324</span>: [GC (CMS Final Remark) [YG occupancy: <span class=\"number\">17157</span> K (<span class=\"number\">46080</span> K)]<span class=\"number\">5.324</span>: [Rescan (parallel)  (Survivor:<span class=\"number\">0</span>chunks) Finished young gen rescan work in <span class=\"number\">4</span>th thread: <span class=\"number\">0.000</span> sec</span><br></pre></td></tr></table></figure>\n<p>修改-XX:CMSScheduleRemarkEdenSizeThreshold=50m,和年轻代大小相等，再观察gc日志，不会出现concurrent-abortable-preclean阶段：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2.296</span>: [CMS-concurrent-mark: <span class=\"number\">0.010</span>/<span class=\"number\">0.010</span> secs] (CMS-concurrent-mark yielded <span class=\"number\">0</span> times)</span><br><span class=\"line\"> [Times: user=<span class=\"number\">0.02</span> sys=<span class=\"number\">0.00</span>, real=<span class=\"number\">0.01</span> secs] </span><br><span class=\"line\"><span class=\"number\">2.296</span>: [CMS-concurrent-preclean-start]</span><br><span class=\"line\"> (cardTable: <span class=\"number\">1</span> cards, re-scanned <span class=\"number\">1</span> cards, <span class=\"number\">1</span> iterations)</span><br><span class=\"line\"><span class=\"number\">2.296</span>: [CMS-concurrent-preclean: <span class=\"number\">0.000</span>/<span class=\"number\">0.000</span> secs] (CMS-concurrent-preclean yielded <span class=\"number\">0</span> times)</span><br><span class=\"line\"> [Times: user=<span class=\"number\">0.00</span> sys=<span class=\"number\">0.00</span>, real=<span class=\"number\">0.00</span> secs] </span><br><span class=\"line\"><span class=\"number\">2.296</span>: [GC (CMS Final Remark) [YG occupancy: <span class=\"number\">17157</span> K (<span class=\"number\">46080</span> K)]<span class=\"number\">2.296</span>: [Rescan (parallel)  (Survivor:<span class=\"number\">0</span>chunks) Finished young gen rescan work in <span class=\"number\">4</span>th thread: <span class=\"number\">0.000</span> sec</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>跨代引用和card marking:<br><img src=\"/2020/06/21/理解CMS回收器的preclean阶段/summary.png\" title=\"image\"></p>\n<p>preclean: 清理card marking标记的dirty card，更新引用记录</p>\n<p>abortable-preclean: 调节final-remark阶段的运行时机</p>\n<p>参考文章：</p>\n<p>Brian Goetz的文章: <a href=\"https://www.ibm.com/developerworks/library/j-jtp11253/index.html\" target=\"_blank\" rel=\"noopener\">https://www.ibm.com/developerworks/library/j-jtp11253/index.html</a><br>card mark介绍: <a href=\"http://psy-lob-saw.blogspot.com/2014/10/the-jvm-write-barrier-card-marking.html\" target=\"_blank\" rel=\"noopener\">http://psy-lob-saw.blogspot.com/2014/10/the-jvm-write-barrier-card-marking.html</a><br>理解preclean: <a href=\"https://stackoverflow.com/questions/44182733/can-someone-explain-what-happens-in-the-concurrent-abortable-preclean-phase-of\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/questions/44182733/can-someone-explain-what-happens-in-the-concurrent-abortable-preclean-phase-of</a><br>jvm源码： <a href=\"https://github.com/JetBrains/jdk8u_hotspot\" target=\"_blank\" rel=\"noopener\">https://github.com/JetBrains/jdk8u_hotspot</a></p>\n","site":{"data":{}},"excerpt":"<p>在《深入理解Java虚拟机：JVM高级特性与最佳实践（第二版）》里这样介绍CMS回收器的工作过程:</p>\n<blockquote>\n<p>CMS收集器是基于“标记—清除”算法实现的，它的运作过程相对于前面几种收集器来说更复杂一些，整个过程分为4个步骤，包括：   •初始标记（CMS initial mark）   •并发标记（CMS concurrent mark）   •重新标记（CMS remark）   •并发清除（CMS concurrent sweep）</p>\n</blockquote>\n<p>很多人可能只看了这本书的介绍（实际这应该只是作者的概括），就认为CMS回收器就只有这4个阶段，看一下这里的gc log:<br>","more":"<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0.245</span>: [GC (CMS Initial Mark) [<span class=\"number\">1</span> CMS-initial-mark: <span class=\"number\">32776</span>K(<span class=\"number\">53248</span>K)] <span class=\"number\">41701</span>K(<span class=\"number\">99328</span>K), <span class=\"number\">0.0061676</span> secs] [Times: user=<span class=\"number\">0.01</span> sys=<span class=\"number\">0.00</span>, real=<span class=\"number\">0.01</span> secs] </span><br><span class=\"line\"><span class=\"number\">0.251</span>: [CMS-concurrent-mark-start]</span><br><span class=\"line\"><span class=\"number\">0.270</span>: [CMS-concurrent-mark: <span class=\"number\">0.004</span>/<span class=\"number\">0.020</span> secs] [Times: user=<span class=\"number\">0.08</span> sys=<span class=\"number\">0.01</span>, real=<span class=\"number\">0.02</span> secs] </span><br><span class=\"line\"><span class=\"number\">0.270</span>: [CMS-concurrent-preclean-start]</span><br><span class=\"line\"><span class=\"number\">0.272</span>: [CMS-concurrent-preclean: <span class=\"number\">0.001</span>/<span class=\"number\">0.001</span> secs] [Times: user=<span class=\"number\">0.00</span> sys=<span class=\"number\">0.00</span>, real=<span class=\"number\">0.00</span> secs] </span><br><span class=\"line\"><span class=\"number\">0.272</span>: [CMS-concurrent-abortable-preclean-start]</span><br><span class=\"line\"><span class=\"number\">0.291</span>: [CMS-concurrent-abortable-preclean: <span class=\"number\">0.004</span>/<span class=\"number\">0.019</span> secs] [Times: user=<span class=\"number\">0.09</span> sys=<span class=\"number\">0.00</span>, real=<span class=\"number\">0.02</span> secs] </span><br><span class=\"line\">0.291: [GC (CMS Final Remark) [YG occupancy: 17928 K (46080 K)]0.291: [Rescan (parallel) , 0.0082702 secs]0.299: [weak refs processing, 0.0000475 secs]0.299: [class unloading, 0.0002451 secs]0.299: [scrub symbol table, 0.0003183 secs]0.300: [scrub string table, 0.0001611 secs][1 CMS-remark: 49164K(53248K)] 67093K(99328K), 0.0091462 secs] [Times: user=0.04 sys=0.00, real=0.01 secs] </span><br><span class=\"line\"><span class=\"number\">0.300</span>: [CMS-concurrent-sweep-start]</span><br><span class=\"line\"><span class=\"number\">0.300</span>: [CMS-concurrent-sweep: <span class=\"number\">0.000</span>/<span class=\"number\">0.000</span> secs] [Times: user=<span class=\"number\">0.00</span> sys=<span class=\"number\">0.00</span>, real=<span class=\"number\">0.00</span> secs] </span><br><span class=\"line\"><span class=\"number\">0.300</span>: [CMS-concurrent-reset-start]</span><br><span class=\"line\"><span class=\"number\">0.300</span>: [CMS-concurrent-reset: <span class=\"number\">0.000</span>/<span class=\"number\">0.000</span> secs] [Times: user=<span class=\"number\">0.00</span> sys=<span class=\"number\">0.00</span>, real=<span class=\"number\">0.00</span> secs]</span><br></pre></td></tr></table></figure></p>\n<p>注意日志中“增加”了concurrent-preclean，concurrent-abortable-preclean，concurrent-reset三个阶段，其中concurrent-reset主要是CMS为了下次gc做准备，而重置内部数据结构的过程，这里不做过多介绍。本文主要分享一下我对<strong>concurrent-preclean</strong> 和 <strong>concurrent-abortable-preclean</strong>两个阶段的理解。</p>\n<h2 id=\"concurrent-preclean\"><a href=\"#concurrent-preclean\" class=\"headerlink\" title=\"concurrent-preclean\"></a>concurrent-preclean</h2><h3 id=\"分代的理想状态\"><a href=\"#分代的理想状态\" class=\"headerlink\" title=\"分代的理想状态\"></a>分代的理想状态</h3><p>我们知道jvm利用<strong>分治</strong>的思想，把内存分为老年代和年轻代，在理想情况下，不同分代中的对象彼此不会有引用关系，属于老死不相往来的状态。</p>\n<img src=\"/2020/06/21/理解CMS回收器的preclean阶段/gen1.png\" title=\"image\">\n<p>在gc开始时，为了标记存活对象，gc线程需要沿着对象引用路径从gc root遍历（可达性分析），这时为了得到正确的引用关系，需要暂停应用线程，所以遍历对象的代价很高。因此，每个分代的垃圾回收器都希望<strong>各扫门前雪</strong>，只标记自己分代的存活对象，比如young gc时，当gc线程遇到引用指向老年代时就会停止遍历，因为它只负责回收年轻代内存空间，不需要去访问老年代对象。</p>\n<img src=\"/2020/06/21/理解CMS回收器的preclean阶段/gc.jpg\" title=\"image\">\n<p>但是实际上，年轻代和老年代的对象并不会100%的彼此隔离，会有一些对象引用其他分代对象，这被称为<strong>跨代引用</strong>。如果young gc线程只遍历年轻代内的对象引用，那么老年代到年轻代的跨代引用就会被忽略，被老年代存活对象跨代引用的年轻代对象会被回收，这样就破坏了应用程序的运行。下图展示了实际的对象引用情况，红色箭头代表跨代引用，在young gc时需要标记出来：</p>\n<img src=\"/2020/06/21/理解CMS回收器的preclean阶段/gen2.png\" title=\"image\">\n<h3 id=\"Card-Marking\"><a href=\"#Card-Marking\" class=\"headerlink\" title=\"Card Marking\"></a>Card Marking</h3><p>在young gc时，为了<strong>找到跨代引用</strong>，通常有这几个方法：</p>\n<ol>\n<li>当对象引用路径指向老年代时继续遍历老年代对象找到跨代引用</li>\n<li>线性地扫描老年代对象，标记跨代引用，用顺序读代替离散读</li>\n<li>从程序开始运行，就使用一个集合记录所有跨代引用的创建，在young gc时扫描这个集合里指向年轻代的跨代引用</li>\n</ol>\n<p>前两种方式都需要在young gc时去遍历老年代对象，因为老年代存活对象多，工作量太大，jvm使用的是第三种方式。</p>\n<p>首先分析<strong>跨代引用如何产生的</strong>：对于老年代到年轻代的跨代引用（a-&gt;b），产生条件有两种，一是gc线程把对象a从年轻代移动到了老年代，二是a本身是老年代对象，应用线程修改了a的引用指向了年轻代的b（<br>对于年轻代到老年代的跨代引用就只有第二种情况）。</p>\n<p>对于gc线程本身创建的跨代引用，可以直接由gc线程在创建时记录，所以问题就变成了：<strong>如何记录应用线程修改对象引用时创建的跨代引用？</strong>。</p>\n<p>在jvm中再次使用分治法，将老年代划分成多个card（和linux内存page类似），只要card内对象引用被应用线程修改，就把card标记为dirty。然后young gc时会扫描老年代中dirty card对应的内存区域，记录其中的跨代引用，这种方式被称为<strong>Card Marking</strong>。</p>\n<p>jvm通过写屏障（write barrier）来实现监控程序线程对引用的修改，并且标记对应card，写屏障工作方式和<strong>代理模式</strong>类似，具体来说是通过在引用赋值指令执行时，添加对了card table的修改指令。以最简单的<code>setFoo(Object bar)</code> 方法为例，<a href=\"http://psy-lob-saw.blogspot.com/2014/10/the-jvm-write-barrier-card-marking.html\" target=\"_blank\" rel=\"noopener\">jvm编译的汇编指令如下</a>,第一行是赋值指令，后面几行标记被修改的引用所在的card为脏页，即<code>CARD_TABLE[this address &gt;&gt; 9] = 0</code>：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">; rsi is 'this' address</span><br><span class=\"line\">; rdx is setter param, reference to bar</span><br><span class=\"line\">; JDK6:</span><br><span class=\"line\">mov    QWORD PTR [rsi+<span class=\"number\">0x20</span>],rdx  ; <span class=\"keyword\">this</span>.foo = bar</span><br><span class=\"line\">mov    r10,rsi                   ; r10 = rsi = <span class=\"keyword\">this</span></span><br><span class=\"line\">shr    r10,<span class=\"number\">0x9</span>                   ; r10 = r10 &gt;&gt; <span class=\"number\">9</span>;</span><br><span class=\"line\">mov    r11,<span class=\"number\">0x7ebdfcff7f00</span>        ; r11 is base of card table, imagine byte[] CARD_TABLE</span><br><span class=\"line\">mov    BYTE PTR [r11+r10*1],0x0  ; Mark 'this' card as dirty, CARD_TABLE[this address &gt;&gt; 9] = 0</span><br></pre></td></tr></table></figure>\n<p><strong>小结</strong>：jvm使用card marking的方式，避免了young gc时扫描整个老年代存活对象，付出的代价是在每次修改引用时添加额外的汇编指令实现写屏障，和额外的内存来保存card table。</p>\n<h3 id=\"preclean做了什么\"><a href=\"#preclean做了什么\" class=\"headerlink\" title=\"preclean做了什么\"></a>preclean做了什么</h3><p>现在回到cms回收器，在老年代gc时，同样使用到了card marking，目的不是找到跨代引用（年轻代到老年代的跨代引用是通过从gc root遍历对象标记的），而是找到前面concurrent-marking阶段被应用线程并发修改的对象引用。</p>\n<p>preclean阶段是<strong>对这些card marking产生的dirty card进行clean</strong>，cms gc线程会扫描dirty card对应的内存区域，更新之前记录的过时的引用信息，并且去掉dirty card的标记，如下图所示：</p>\n<p><img src=\"https://plumbr.io/app/uploads/2015/06/g1-08.png\" alt=\"引用自https://plumbr.io/\"></p>\n<p>在preclean执行后，dirty card被清理，被修改的引用信息也被更新。</p>\n<p><img src=\"https://plumbr.io/app/uploads/2015/06/g1-09.png\" alt=\"引用自https://plumbr.io/\"></p>\n<h2 id=\"concurrent-abortable-preclean\"><a href=\"#concurrent-abortable-preclean\" class=\"headerlink\" title=\"concurrent-abortable-preclean\"></a>concurrent-abortable-preclean</h2><p>concurrent-abortable-preclean阶段目的是减轻final remark阶段（会暂停应用线程）的负担，这个阶段同样会对dirty card的扫描/清理，和concurrent-preclean的区别在于，concurrent-abortable-preclean会重复地以迭代的方式执行，直到满足退出条件。<strong>但是concurrent-preclean已经处理过dirty card,为什么jvm还需要再执行一个类似的阶段呢？</strong></p>\n<h3 id=\"连续STW\"><a href=\"#连续STW\" class=\"headerlink\" title=\"连续STW\"></a>连续STW</h3><p>首先我们考虑下这个情况：如果final-remark阶段开始时刚好进行了young gc（比如ParNew）,应用程序刚因为young gc暂停，然后又会因为final-remark暂停，造成<strong>连续的长暂停</strong>。除此之外，因为young gc线程修改了存活对象的引用地址，会产生很多需要重新扫描的对象，增加了final-remark的工作量。<br>所以concurrent-abortable-preclean除了clean card的作用，还有<strong>调度final-remark开始时机</strong>的作用<a href=\"https://blogs.oracle.com/poonam/understanding-cms-gc-logs\" target=\"_blank\" rel=\"noopener\">参考</a>。cms回收器认为，final-remark最理想的执行时机就是年轻代占用在50%时，这时刚好处于上次young gc完成（0%）和下次young gc开始（100%）的中间节点，如图所示：</p>\n<img src=\"/2020/06/21/理解CMS回收器的preclean阶段/abpreclean.png\" title=\"image\">\n<h3 id=\"配置参数\"><a href=\"#配置参数\" class=\"headerlink\" title=\"配置参数\"></a>配置参数</h3><p>abortable-preclean的<strong>中断条件</strong>，配置参数是<code>-XX:CMSScheduleRemarkEdenPenetration=50</code>（默认值），表示当eden区内存占用到达50%时，中断abortable-preclean，开始执行final-remark，对应<a href=\"https://github.com/JetBrains/jdk8u_hotspot/blob/12d02c91b0b4c63d04daff4e36a79bb6045b2c7f/src/share/vm/gc_implementation/concurrentMarkSweep/concurrentMarkSweepGeneration.cpp\" target=\"_blank\" rel=\"noopener\">jvm源码</a>片段如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//当eden占用比例超过配置，将_abort_preclean标记赋值为true</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> ((_collectorState == AbortablePreclean) &amp;&amp; !_abort_preclean) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> used = get_eden_used();</span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> capacity = get_eden_capacity();</span><br><span class=\"line\">    assert(used &lt;= capacity, <span class=\"string\">\"Unexpected state of Eden\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (used &gt;  (capacity/<span class=\"number\">100</span> * CMSScheduleRemarkEdenPenetration)) &#123;</span><br><span class=\"line\">      _abort_preclean = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>abortable-preclean的<strong>触发条件</strong>配置， <code>-XX:CMSScheduleRemarkEdenSizeThreshold=2m</code>（默认值），表示当eden内存占用超过2mb时才会执行abortable-preclean，否则没有执行的必要。</p>\n<p>abortable-preclean的<strong>主动退出条件</strong>配置，<code>-XX:CMSMaxAbortablePrecleanTime=5000</code>和CMSMaxAbortablePrecleanLoops，主要因为如果年轻代内存占用增长缓慢，那么abortable-preclean要长时间执行，可能因为preclean赶不上应用线程创造dirty card的速度导致dirty card越来越多，此时还不如执行一个final-remark,对应jvm源码片段如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Try and schedule the remark such that young gen</span></span><br><span class=\"line\"><span class=\"comment\">// occupancy is CMSScheduleRemarkEdenPenetration %.</span></span><br><span class=\"line\"><span class=\"comment\">// 保留原始注释，看下abortable_preclean的定位</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> CMSCollector::abortable_preclean() &#123;</span><br><span class=\"line\">  <span class=\"comment\">//校验触发条件</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (get_eden_used() &gt; CMSScheduleRemarkEdenSizeThreshold) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 感受一下作者的纠结，他认为目前的主动退出条件有点蠢，FIX ME!!! 哈哈</span></span><br><span class=\"line\">    <span class=\"comment\">// One, admittedly dumb, strategy is to give up</span></span><br><span class=\"line\">    <span class=\"comment\">// after a certain number of abortable precleaning loops</span></span><br><span class=\"line\">    <span class=\"comment\">// or after a certain maximum time. We want to make</span></span><br><span class=\"line\">    <span class=\"comment\">// this smarter in the next iteration.</span></span><br><span class=\"line\">    <span class=\"comment\">// XXX FIX ME!!! YSR</span></span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> loops = <span class=\"number\">0</span>, workdone = <span class=\"number\">0</span>, cumworkdone = <span class=\"number\">0</span>, waited = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">//should_abort_preclean会检查上面说的_abort_preclean是否为true</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!(should_abort_preclean() ||</span><br><span class=\"line\">             ConcurrentMarkSweepThread::should_terminate())) &#123;</span><br><span class=\"line\">      workdone = preclean_work(CMSPrecleanRefLists2, CMSPrecleanSurvivors2);</span><br><span class=\"line\">      cumworkdone += workdone;</span><br><span class=\"line\">      loops++;</span><br><span class=\"line\">      <span class=\"comment\">// 主动停止执行</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> ((CMSMaxAbortablePrecleanLoops != <span class=\"number\">0</span>) &amp;&amp;</span><br><span class=\"line\">          loops &gt;= CMSMaxAbortablePrecleanLoops) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (PrintGCDetails) &#123;</span><br><span class=\"line\">          gclog_or_tty-&gt;print(<span class=\"string\">\" CMS: abort preclean due to loops \"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (pa.wallclock_millis() &gt; CMSMaxAbortablePrecleanTime) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (PrintGCDetails) &#123;</span><br><span class=\"line\">          gclog_or_tty-&gt;print(<span class=\"string\">\" CMS: abort preclean due to time \"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 如果工作效率不高，主动暂停一会儿</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (workdone &lt; CMSAbortablePrecleanMinWorkPerIteration) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Sleep for some time, waiting for work to accumulate</span></span><br><span class=\"line\">        stopTimer();</span><br><span class=\"line\">        cmsThread()-&gt;wait_on_cms_lock(CMSAbortablePrecleanWaitMillis);</span><br><span class=\"line\">        startTimer();</span><br><span class=\"line\">        waited++;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//打印工作情况</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (PrintCMSStatistics &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      gclog_or_tty-&gt;print(<span class=\"string\">\" [%d iterations, %d waits, %d cards)] \"</span>,</span><br><span class=\"line\">                          loops, waited, cumworkdone);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"实践验证\"><a href=\"#实践验证\" class=\"headerlink\" title=\"实践验证\"></a>实践验证</h2><p>java代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DumbObj</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DumbObj</span><span class=\"params\">(<span class=\"keyword\">int</span> sizeM,DumbObj next)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">this</span>.data = getM(sizeM);</span><br><span class=\"line\">       <span class=\"keyword\">this</span>.next = next;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">private</span> Byte[] getM(<span class=\"keyword\">int</span> m) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Byte[<span class=\"number\">1024</span> * <span class=\"number\">1024</span> * m];</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">private</span> DumbObj next;</span><br><span class=\"line\">   <span class=\"keyword\">private</span> Byte [] data;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//存活对象</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> List&lt;DumbObj&gt; liveObjs = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(<span class=\"number\">5</span>);</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">       <span class=\"comment\">//创建新对象触发gc</span></span><br><span class=\"line\">       <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">25</span>;i++)&#123;</span><br><span class=\"line\">           DumbObj dumb = <span class=\"keyword\">new</span> DumbObj(<span class=\"number\">1</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">           <span class=\"keyword\">if</span>(liveObjs.size()&lt;<span class=\"number\">5</span>)&#123;</span><br><span class=\"line\">               liveObjs.add(<span class=\"keyword\">new</span> DumbObj(<span class=\"number\">1</span>, dumb));</span><br><span class=\"line\">           &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">               dumb.setNext(liveObjs.get(i%<span class=\"number\">5</span>));</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"comment\">//等待gc线程工作</span></span><br><span class=\"line\">       TimeUnit.SECONDS.sleep(<span class=\"number\">20</span>);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>在jvm参数里添加-XX:PrintCMSStatistics=1，通过gc日志可以看到cms回收器在preclean阶段执行的操作：</p>\n<blockquote>\n<p>-Xms101m<br>-Xmn50m<br>-Xmx101m<br>-verbose:gc<br>-XX:MetaspaceSize=1m<br>-XX:+UseConcMarkSweepGC<br>-Xloggc:/tmp/gc.log<br>-XX:+PrintGCCause<br>-XX:+PrintGCTimeStamps<br>-XX:+PrintGCDetails<br>-XX:PrintCMSStatistics=1<br>-XX:CMSScheduleRemarkEdenPenetration=50<br>-XX:CMSScheduleRemarkEdenSizeThreshold=2m<br>-XX:CMSMaxAbortablePrecleanTime=5000<br>-XX:+UseCMSInitiatingOccupancyOnly<br>-XX:CMSInitiatingOccupancyFraction=50</p>\n</blockquote>\n<p>运行程序，查看gc日志:在时间0.303，concurrent-preclean开始，重新扫描了5个card,在0.304时，开始abortable-preclean-start，多个线程又进行了一次迭代，扫描dirty card,在5秒后，5.324时，因为达到最大运行时间主动退出，开始remark阶段。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0.303</span>: [CMS-concurrent-mark: <span class=\"number\">0.010</span>/<span class=\"number\">0.010</span> secs] (CMS-concurrent-mark yielded <span class=\"number\">0</span> times)</span><br><span class=\"line\"> [Times: user=<span class=\"number\">0.02</span> sys=<span class=\"number\">0.00</span>, real=<span class=\"number\">0.01</span> secs] </span><br><span class=\"line\"><span class=\"number\">0.303</span>: [CMS-concurrent-preclean-start]</span><br><span class=\"line\"> (cardTable: <span class=\"number\">5</span> cards, re-scanned <span class=\"number\">5</span> cards, <span class=\"number\">1</span> iterations)</span><br><span class=\"line\"><span class=\"number\">0.304</span>: [CMS-concurrent-preclean: <span class=\"number\">0.000</span>/<span class=\"number\">0.000</span> secs] (CMS-concurrent-preclean yielded <span class=\"number\">0</span> times)</span><br><span class=\"line\"> [Times: user=<span class=\"number\">0.00</span> sys=<span class=\"number\">0.00</span>, real=<span class=\"number\">0.00</span> secs] </span><br><span class=\"line\"><span class=\"number\">0.304</span>: [CMS-concurrent-abortable-preclean-start]</span><br><span class=\"line\"> (cardTable: <span class=\"number\">0</span> cards, re-scanned <span class=\"number\">0</span> cards, <span class=\"number\">1</span> iterations)</span><br><span class=\"line\"> (cardTable: <span class=\"number\">0</span> cards, re-scanned <span class=\"number\">0</span> cards, <span class=\"number\">1</span> iterations)</span><br><span class=\"line\"> (cardTable: <span class=\"number\">0</span> cards, re-scanned <span class=\"number\">0</span> cards, <span class=\"number\">1</span> iterations)</span><br><span class=\"line\"> (cardTable: <span class=\"number\">0</span> cards, re-scanned <span class=\"number\">0</span> cards, <span class=\"number\">1</span> iterations)</span><br><span class=\"line\"> (cardTable: <span class=\"number\">0</span> cards, re-scanned <span class=\"number\">0</span> cards, <span class=\"number\">1</span> iterations)</span><br><span class=\"line\"> (cardTable: <span class=\"number\">0</span> cards, re-scanned <span class=\"number\">0</span> cards, <span class=\"number\">1</span> iterations)</span><br><span class=\"line\"> (cardTable: <span class=\"number\">0</span> cards, re-scanned <span class=\"number\">0</span> cards, <span class=\"number\">1</span> iterations)</span><br><span class=\"line\"> <span class=\"comment\">//有省略</span></span><br><span class=\"line\"> CMS: abort preclean due to time  [<span class=\"number\">50</span> iterations, <span class=\"number\">49</span> waits, <span class=\"number\">0</span> cards)] <span class=\"number\">5.324</span>: [CMS-concurrent-abortable-preclean: <span class=\"number\">0.012</span>/<span class=\"number\">5.020</span> secs] (CMS-concurrent-abortable-preclean yielded <span class=\"number\">0</span> times)</span><br><span class=\"line\"> [Times: user=<span class=\"number\">0.02</span> sys=<span class=\"number\">0.00</span>, real=<span class=\"number\">5.02</span> secs] </span><br><span class=\"line\"><span class=\"number\">5.324</span>: [GC (CMS Final Remark) [YG occupancy: <span class=\"number\">17157</span> K (<span class=\"number\">46080</span> K)]<span class=\"number\">5.324</span>: [Rescan (parallel)  (Survivor:<span class=\"number\">0</span>chunks) Finished young gen rescan work in <span class=\"number\">4</span>th thread: <span class=\"number\">0.000</span> sec</span><br></pre></td></tr></table></figure>\n<p>修改-XX:CMSScheduleRemarkEdenSizeThreshold=50m,和年轻代大小相等，再观察gc日志，不会出现concurrent-abortable-preclean阶段：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2.296</span>: [CMS-concurrent-mark: <span class=\"number\">0.010</span>/<span class=\"number\">0.010</span> secs] (CMS-concurrent-mark yielded <span class=\"number\">0</span> times)</span><br><span class=\"line\"> [Times: user=<span class=\"number\">0.02</span> sys=<span class=\"number\">0.00</span>, real=<span class=\"number\">0.01</span> secs] </span><br><span class=\"line\"><span class=\"number\">2.296</span>: [CMS-concurrent-preclean-start]</span><br><span class=\"line\"> (cardTable: <span class=\"number\">1</span> cards, re-scanned <span class=\"number\">1</span> cards, <span class=\"number\">1</span> iterations)</span><br><span class=\"line\"><span class=\"number\">2.296</span>: [CMS-concurrent-preclean: <span class=\"number\">0.000</span>/<span class=\"number\">0.000</span> secs] (CMS-concurrent-preclean yielded <span class=\"number\">0</span> times)</span><br><span class=\"line\"> [Times: user=<span class=\"number\">0.00</span> sys=<span class=\"number\">0.00</span>, real=<span class=\"number\">0.00</span> secs] </span><br><span class=\"line\"><span class=\"number\">2.296</span>: [GC (CMS Final Remark) [YG occupancy: <span class=\"number\">17157</span> K (<span class=\"number\">46080</span> K)]<span class=\"number\">2.296</span>: [Rescan (parallel)  (Survivor:<span class=\"number\">0</span>chunks) Finished young gen rescan work in <span class=\"number\">4</span>th thread: <span class=\"number\">0.000</span> sec</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>跨代引用和card marking:<br><img src=\"/2020/06/21/理解CMS回收器的preclean阶段/summary.png\" title=\"image\"></p>\n<p>preclean: 清理card marking标记的dirty card，更新引用记录</p>\n<p>abortable-preclean: 调节final-remark阶段的运行时机</p>\n<p>参考文章：</p>\n<p>Brian Goetz的文章: <a href=\"https://www.ibm.com/developerworks/library/j-jtp11253/index.html\" target=\"_blank\" rel=\"noopener\">https://www.ibm.com/developerworks/library/j-jtp11253/index.html</a><br>card mark介绍: <a href=\"http://psy-lob-saw.blogspot.com/2014/10/the-jvm-write-barrier-card-marking.html\" target=\"_blank\" rel=\"noopener\">http://psy-lob-saw.blogspot.com/2014/10/the-jvm-write-barrier-card-marking.html</a><br>理解preclean: <a href=\"https://stackoverflow.com/questions/44182733/can-someone-explain-what-happens-in-the-concurrent-abortable-preclean-phase-of\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/questions/44182733/can-someone-explain-what-happens-in-the-concurrent-abortable-preclean-phase-of</a><br>jvm源码： <a href=\"https://github.com/JetBrains/jdk8u_hotspot\" target=\"_blank\" rel=\"noopener\">https://github.com/JetBrains/jdk8u_hotspot</a></p>"},{"title":"如何设计一个连接池：commons-pool2源码分析","date":"2017-06-11T16:10:50.000Z","_content":"\n## 前言\n大家对连接池的概念应该都很熟悉了，[apache commons-pool](https://commons.apache.org/proper/commons-pool/)是apache基金会的一个开源对象池组件，我们常用的数据库连接池dpcp和redis的java客户端jedis都使用commons-pool来管理连接。现在我们通过阅读commons-pool的部分代码来看一看他们在编写连接池组件时采用了什么样的设计思路和技术。\n\n## 准备工作\n首先我们思考一下，连接池除应该具备哪些功能？\n\n 1. 连接池要能够管理不同类型的对象，同时作为一个服务组件不需要关心每种连接的创建细节。\n 2. 连接池中的连接当长时间空闲时可能会被服务端主动关闭，或者受网络影响断开，连接池要能够定时检查它的连接是否可用。\n 3. 支持并发操作,每个线程各种持有连接互不影响。\n\n带着这三个问题，下面我们一起看一下commons-pool的代码,\n它主要提供这个几种类型的对象池：\n<!--more-->\n![](/images/commonspool.gif)\n从左至右看，SoftReferenceObjectPool是不用指定容量的对象池，ProxiedObject是使用代理模式来创建对象池的对象，在这篇文章主要介绍GenericObjectPool的实现。\n\n## 封装对象\ncommons-pool定义了一个接口PooledObject来封装池中的对象，添加了空闲时间，使用时间等信息和对象状态流转的行为。\nPooledbject的状态有这几种：\n|    状态     |    说明  |\n| --------   | -----  | \n| IDLE     | 空闲 |\n|ALLOCATED  |   使用中\n|INVALID |不可用 即将/已经被销毁\n|ABANDONED |被遗弃\n|RETURNING |返回对象池\n|EVICTION|  在队列中 正在被检查\n|EVICTION_RETURN_TO_HEAD| 检查结束要放回队列头部\n|VALIDATION| 在队列中 正在被检查\n|VALIDATION_PREALLOCATED |验证结束要被分配\n|VALIDATION_RETURN_TO_HEAD| 检查结束要放回队列头部\n\n表格中以RETURN_TO_HEAD结尾的状态是在当前的检查操作和对象借出操作同时进行时出现的，在检查结束后为了尽量保证借出成功这个对象要放回队头。\n在我们不需要自定义对象行为的情况下可以直接使用PooledObject的默认实现DefaultPooledObject，主要代码如下：\n``` java\nprivate final long createTime = System.currentTimeMillis();\nprivate volatile long lastBorrowTime = createTime;\nprivate volatile long lastUseTime = createTime;\nprivate volatile long lastReturnTime = createTime;\nprivate volatile long borrowedCount = 0;\n@Override\n    public synchronized boolean allocate() {\n        if (state == PooledObjectState.IDLE) {\n            state = PooledObjectState.ALLOCATED;\n            lastBorrowTime = System.currentTimeMillis();\n            lastUseTime = lastBorrowTime;\n            borrowedCount++;\n            if (logAbandoned) {\n                borrowedBy = new AbandonedObjectCreatedException();\n            }\n            return true;\n        } else if (state == PooledObjectState.EVICTION) {\n            state = PooledObjectState.EVICTION_RETURN_TO_HEAD;\n            return false;\n        }\n        return false;\n    }\n```\nallocate() 定义了对象分配时的状态变化，当对象在空闲状态时才能被分配；如果对象正在做驱逐检查时,会把这个对象标记为EVICTION_RETURN_TO_HEAD.\n```java\n@Override\n//返回值：对象是否当前未被使用\npublic synchronized boolean endEvictionTest(\n            Deque<PooledObject<T>> idleQueue) {\n        if (state == PooledObjectState.EVICTION) {\n            state = PooledObjectState.IDLE;\n            return true;\n        } else if (state == PooledObjectState.EVICTION_RETURN_TO_HEAD) {\n            //如果状态是EVICTION_RETURN_TO_HEAD表示当前这个对象试图被借出，返回false.\n            state = PooledObjectState.IDLE;\n            if (!idleQueue.offerFirst(this)) {\n                // TODO - Should never happen\n            }\n        }\n        return false;\n    }\n```\n\nendEvictionTest()定义了驱逐检查之后对象状态的变化，可以看到EVICTION_RETURN_TO_HEAD状态的对象被放到空闲队列队头。\n\nallocate()和borrowedCount等使用synchronized，violatile都做了线程安全的处理。\n\n \n## 定义对象工厂\ncommons-pool为了管理多种对象使用工厂模式来创建要管理的对象，使用工厂方法后使用者可以通过重写PooledObjectFactory定义对象的实现，销毁，验证的具体实现，而commons-pool不需要关心这些细节它只管理PooledObject对象即可。\n\n工厂接口：PooledObjectFactory\n``` java\npublic interface PooledObjectFactory<T> {\n  PooledObject<T> makeObject() throws Exception;\n  void destroyObject(PooledObject<T> p) throws Exception;\n  boolean validateObject(PooledObject<T> p);\n  void activateObject(PooledObject<T> p) throws Exception;\n  void passivateObject(PooledObject<T> p) throws Exception;\n}\n```\n工厂抽象类：BasePooledObjectFactory\n``` java\npublic abstract class BasePooledObjectFactory<T> implements PooledObjectFactory<T> {\n...\n    public abstract T create() throws Exception;\n    public abstract PooledObject<T> wrap(T obj);\n    @Override\n    public PooledObject<T> makeObject() throws Exception {\n        return wrap(create());\n    }\n    @Override\n    public boolean validateObject(PooledObject<T> p) {\n        return true;\n    }\n\n...\n}\n```\nBasePooledObjectFactory添加了create,wrap两个抽象方法，create可以返回我们要放在连接池的对象，然后使用wrap封装为PooledObject即可，注意validateObject默认返回true;\n\n## 对象池定义\n对象池是我们保存对象的地方，对象的获取，归还和定时检查都通过对象池来实现。以GenericObjectPool为例，对象池使用了线程安全的集合类来保存对象，LinkedBlockingDeque用于保存空闲的对象，ConcurrentHashMap保存全部对象（包括各种状态）。\n``` java\nprivate final LinkedBlockingDeque<PooledObject<T>> idleObjects = new LinkedBlockingDeque<PooledObject<T>>();\nprivate final Map<T, PooledObject<T>> allObjects = new ConcurrentHashMap<T, PooledObject<T>>();\n```\nborrowObject()从连接池获取对象：\n连接池借出对象时，经过Abandoned和validate两种检查，在连接池满时根据配置执行对应的等待策略，当没有可用对象时会抛出异常。\n\nAbandoned检查目标是连接池所有被借出的对象，主要防止对象借出之后长时间被占用，不能退还（或者使用者忘记return）到连接池导致连接被耗尽。超时时间由AbandonedConfig定义。\n\nvalidate检查目标是当前即将被借出的对象，目的是保证提供的对象是可用的，检查方式由对象工厂的validateObject方法定义。对象工厂还有activateObject方法来验证对象，不过这个方法是强制执行的。\n\n``` java\npublic T borrowObject(long borrowMaxWaitMillis) throws Exception {\n// getNumIdle() 表示当前空空闲对象数量，getNumActive() 表示当前非空闲的对象数量，getMaxTotal()表示连接池容量\n// 那么假设最大容量10个，非空闲8个 > 7 ，空闲对象只要少于2个，就需要开始Abandoned检查\n\n        AbandonedConfig ac = this.abandonedConfig;\n        if (ac != null && ac.getRemoveAbandonedOnBorrow() &&\n                (getNumIdle() < 2) &&\n                (getNumActive() > getMaxTotal() - 3) ) {\n            removeAbandoned(ac);\n        }\n\n        PooledObject<T> p = null;\n        \n        //拷贝了变量 blockWhenExhausted\n        //因为blockWhenExhausted的修改方法是public的，这样保证在并发情况下，方法执行周期内变量也不会变化\n        boolean blockWhenExhausted = getBlockWhenExhausted();\n\n        boolean create;\n        long waitTime = 0;\n\n        while (p == null) {\n            create = false;\n            // 设置了对象池耗尽时等待\n            if (blockWhenExhausted) {\n                //从空闲队列取对象\n                p = idleObjects.pollFirst();\n                if (p == null) {\n                    //没有空闲对象 新建一个\n                    create = true;\n                    p = create();\n                }\n                if (p == null) {\n                    if (borrowMaxWaitMillis < 0) {\n                        //注意：没配置等待时间，会一直阻塞\n                        p = idleObjects.takeFirst();\n                    } else {\n                        //按照配置的时间等待\n.....\n                        p = idleObjects.pollFirst(borrowMaxWaitMillis,\n                                TimeUnit.MILLISECONDS);\n.....\n                    }\n                }\n                 //等待之后还是没有空闲对象\n                if (p == null) {\n                    throw new NoSuchElementException(\n                            \"Timeout waiting for idle object\");\n                }\n                 //等待之后获得对象 尝试分配对象\n                 //这个方法由pooledobject实现\n                if (!p.allocate()) {\n                    p = null;\n                }\n            } else {\n                //没有配置blockWhenExhausted 不等待\n                p = idleObjects.pollFirst();\n                if (p == null) {\n                    create = true;\n                    p = create();\n                }\n                if (p == null) {\n                    throw new NoSuchElementException(\"Pool exhausted\");\n                }\n                if (!p.allocate()) {\n                    p = null;\n                }\n            }\n            //对象分配成功\n            if (p != null) {\n\n                try {\n                   //激活对象\n                    factory.activateObject(p);\n                } catch (Exception e) {\n                    try {\n                        destroy(p);\n                    } catch (Exception e1) {\n                    }\n                    p = null;\n                    .....\n                }\n                //如果配置了对象检查\n                if (p != null && (getTestOnBorrow() || create && getTestOnCreate())) {\n                    boolean validate = false;\n                    Throwable validationThrowable = null;\n                    try {\n                        validate = factory.validateObject(p);\n                    } catch (Throwable t) {\n                        PoolUtils.checkRethrow(t);\n                        validationThrowable = t;\n                    }\n                    if (!validate) {\n                    //验证失败 销毁对象\n                        try {\n                            destroy(p);\n                         destroyedByBorrowValidationCount.incrementAndGet();\n                        } catch (Exception e) {\n                        }\n                        p = null;\n                        .....\n                    }\n                }\n            }\n        }\n        //更新借出时间等信息\n        updateStatsBorrow(p, waitTime);\n\n        return p.getObject();\n    }\n```\nevict()驱逐对象：\n\nevict驱逐检查：上面介绍了两种对象的检查方式，evictor不同之处在于它由后台线程独立来完成，检查对象主要是连接池中的空闲连接，超时时间等可通过EvictionConfig配置。\n``` java\npublic void evict() throws Exception {\n        //确保连接池打开\n        assertOpen();\n\n        if (idleObjects.size() > 0) {\n\n            PooledObject<T> underTest = null;\n            \n            EvictionPolicy<T> evictionPolicy = getEvictionPolicy();\n\n            synchronized (evictionLock) {\n                ...\n                // 复制变量保证函数内值不改变，同上\n                boolean testWhileIdle = getTestWhileIdle();\n                //每次驱逐对象数可配置\n                for (int i = 0, m = getNumTests(); i < m; i++) {\n                    if (evictionIterator == null || !evictionIterator.hasNext()) {\n                        //驱逐检查的顺序和空闲队列出入顺序保持一致 \n                        if (getLifo()) {\n                            //后进先出(逆序遍历)\n                            evictionIterator = idleObjects.descendingIterator();\n                        } else {\n                            //先进先出\n                            evictionIterator = idleObjects.iterator();\n                        }\n                    }\n                    if (!evictionIterator.hasNext()) {\n                        // Pool exhausted, nothing to do here\n                        return;\n                    }\n\n                    try {\n                        underTest = evictionIterator.next();\n                    } catch (NoSuchElementException nsee) {\n                        //因为idleObjects.iterator()方法并没有做同步控制，可能被检查的空闲对象再检查期间已经被借出不在队列中了，在并发条件下要考虑这种情况。。\n                        // Object was borrowed in another thread\n                        // Don't count this as an eviction test so reduce i;\n                        i--;\n                        evictionIterator = null;\n                        continue;\n                    }\n                    //再次检查，对象在队列中但是要保证状态是空闲。。。\n                    if (!underTest.startEvictionTest()) {\n                        // Object was borrowed in another thread\n                        // Don't count this as an eviction test so reduce i;\n                        i--;\n                        continue;\n                    }\n                    //EvictionPolicy定义了驱逐对象的策略，默认实现是DefaultEvictionPolicy\n                    //调用ObjectPool的setEvictionPolicyClassName方法指定自定义策略\n                    if (evictionPolicy.evict(evictionConfig, underTest,\n                            idleObjects.size())) {\n                        destroy(underTest);\n                        destroyedByEvictorCount.incrementAndGet();\n                    } else {\n                        if (testWhileIdle) {\n                            ...\n                            //执行activateObject&validateObject的检查\n                            ...\n                        }\n                        ...\n                    }\n                }\n            }\n        }\n        //无处不在的Abandoned检查，可以配置连接池是否在evictor线程中执行removeAbandoned\n        AbandonedConfig ac = this.abandonedConfig;\n        if (ac != null && ac.getRemoveAbandonedOnMaintenance()) {\n            removeAbandoned(ac);\n        }\n    }\n```\n驱逐线程的调用：\n了解驱逐对象时要做的操作之后，我们来看一下后台的驱逐者线程是怎么定义&启动的\n``` java\n//GenericObjectPool.java\n//构造方法中启动驱逐者线程\npublic GenericObjectPool(PooledObjectFactory<T> factory,\n            GenericObjectPoolConfig config) {\n        ...\n        startEvictor(getTimeBetweenEvictionRunsMillis());\n        ...\n    }\n```\n驱逐线程的定义：\n驱逐者Evictor,在BaseGenericObjectPool中定义，本质是由java.util.TimerTask定义的定时任务\n```java\n//父类BaseGenericObjectPool.java\nfinal void startEvictor(long delay) {\n        //BaseGenericObjectPool的私有成员，final Object evictionLock = new Object();做对象锁\n        synchronized (evictionLock) {\n            if (null != evictor) {\n                //已存在evictor，取消驱逐者线程，所以也可以二次调用startEvictor来停止驱逐检查\n                EvictionTimer.cancel(evictor);\n                evictor = null;\n                evictionIterator = null;\n            }\n            if (delay > 0) {\n                evictor = new Evictor();\n                EvictionTimer.schedule(evictor, delay, delay);\n            }\n        }\n    }\n```\nEvitor定义：这里有一个比较有意思的问题，驱逐者线程Evictor被多个连接池共享,但是这些连接池可能属于不同的classloader,Evictor必须要保证它的所有行为在**当前这个连接池的classloader**下执行（这是开发者给commons-pool提交的bug,[详细描述请看这里](https://issues.apache.org/jira/browse/POOL-161)）\n```java\n//内部类Evictor\nclass Evictor extends TimerTask {\n    \n        @Override\n        public void run() {\n            ClassLoader savedClassLoader =\n                    Thread.currentThread().getContextClassLoader();\n            try {\n                // 切换到当前连接池的classLoader\n                Thread.currentThread().setContextClassLoader(\n                        factoryClassLoader);\n\n                // 执行上面的evict()方法\n                try {\n                    evict();\n                } catch(Exception e) {\n                    swallowException(e);\n                } catch(OutOfMemoryError oome) {\n                    // Log problem but give evictor thread a chance to continue\n                    // in case error is recoverable\n                    oome.printStackTrace(System.err);\n                }\n                // 驱逐之后还要保证空闲连接数量不能小于配置\n                try {\n                    ensureMinIdle();\n                } catch (Exception e) {\n                    swallowException(e);\n                }\n            } finally {\n                // 切换回之前的classLoader\n                Thread.currentThread().setContextClassLoader(savedClassLoader);\n            }\n        }\n    }\n```\n驱逐策略：\n在evict()方法中最后对象是否要被驱逐是调用了evictionPolicy.evict()的方法来判断的，commons-pool提供的驱逐策略如下：\n```java\n//DefaultEvictionPolicy.java\n\npublic class DefaultEvictionPolicy<T> implements EvictionPolicy<T> {\n    @Override\n    public boolean evict(EvictionConfig config, PooledObject<T> underTest,\n            int idleCount) {\n        //getIdleTimeMillis()空闲时间\n        //config.getIdleSoftEvictTime()空闲连接大于配置的最小值时的超时时间\n        //config.getIdleEvictTime()空闲连接超时时间与数量无关\n        if ((config.getIdleSoftEvictTime() < underTest.getIdleTimeMillis() &&\n                config.getMinIdle() < idleCount) ||\n                config.getIdleEvictTime() < underTest.getIdleTimeMillis()) {\n            return true;\n        }\n        return false;\n    }\n}\n\n```\n驱逐策略是支持自定义的，这里使用的是设计模式中的策略模式，我们只要实现EvictionPolicy接口，然后调用setEvictionPolicyClassName()方法既可以更换驱逐策略（实现类要尽可能简单，只描述一种算法即可）：\n```java\n//父类BaseGenericObjectPool.java\n public final void setEvictionPolicyClassName(\n            String evictionPolicyClassName) {\n        try {\n            //使用接口+反射实现的策略模式\n            Class<?> clazz = Class.forName(evictionPolicyClassName);\n            Object policy = clazz.newInstance();\n            if (policy instanceof EvictionPolicy<?>) {\n                @SuppressWarnings(\"unchecked\") \n                EvictionPolicy<T> evicPolicy = (EvictionPolicy<T>) policy;\n                this.evictionPolicy = evicPolicy;\n            }\n        } catch (ClassNotFoundException e) {\n            ...\n        } catch (InstantiationException e) {\n            ...\n        } catch (IllegalAccessException e) {\n            ...\n        }\n    }\n\n```\n通过阅读GenericObjectPool的部分代码，可以看出来并没有在每个获取&退还对象的方法都做同步控制，线程安全主要是由LinkedBlockingDeque，ConcurrentHashMap这两个并发集合保证的，因此开发者在编写非线程安全方法时也使用了局部变量复制可能被修改的值，多次检查对象状态之类的方法保证并发条件下程序正常的执行（没全部加锁能够提升性能，不过也会有这样的麻烦）。\n总结一下连接池中对象的声明周期大概如下图：\n![](/images/commonspoolflow.png)\n蓝色线是evictor执行时对象状态的变化，红线是abandon执行的过程，绿色线是正常使用中对象的变化。\n\n\n\n## 其他功能\n附上一份objectpool的配置选项\n```java\nGenericObjectPoolConfig poolConfig = new GenericObjectPoolConfig();\n\n基本配置：\n\n        //最大连接\n        poolConfig.setMaxTotal(100);\n        //最大空闲连接\n        poolConfig.setMaxIdle(5);\n        //最小空闲连接 \n        poolConfig.setMinIdle(5);\n        //连接满时最多等待时间\n        poolConfig.setMaxWaitMillis(5000L);\n\n高级功能：\n         //使用时检查对象（默认不检查）\n        poolConfig.setTestWhileIdle(true);\n        poolConfig.setTestOnCreate(true);\n        poolConfig.setTestOnBorrow(true);\n        poolConfig.setTestOnReturn(true);\n\n        //jmx启用 之后可以实时的查看线程池对象的状态\n        poolConfig.setJmxEnabled(false);\n        poolConfig.setJmxNameBase(\"namebase\");\n        poolConfig.setJmxNamePrefix(\"nameprefix\");\n\n         //驱逐线程每次检查对象个数\n        poolConfig.setNumTestsPerEvictionRun(2);\n        //空闲连接被驱逐前能够保留的时间\n        poolConfig.setMinEvictableIdleTimeMillis(10000L);\n        //当空闲线程大于minIdle 空闲连接能够保留时间，同时指定会被上面的覆盖\n        poolConfig.setSoftMinEvictableIdleTimeMillis(10000L);\n        //驱逐线程执行间隔时间\n        poolConfig.setTimeBetweenEvictionRunsMillis(200000L);\n\n        //放弃长时间占用连接的对象\n       AbandonedConfig abandonedConfig=new AbandonedConfig();\n       abandonedConfig.setLogAbandoned(true);\n       abandonedConfig.setUseUsageTracking(false);\n       abandonedConfig.setRemoveAbandonedOnBorrow(true);\n       abandonedConfig.setRemoveAbandonedOnMaintenance(true);\n       abandonedConfig.setRemoveAbandonedTimeout(20);//second\n```\n\n\n  [1]: https://www.throwsnew.com/img/GenericObjectPool.PNG\n  [2]: https://www.throwsnew.com/img/common-pool2.png\n","source":"_posts/commons-pool.md","raw":"title: 如何设计一个连接池：commons-pool2源码分析\ndate: 2017-06-12 00:10:50\ncategories: 开源框架\ntags: \n - 连接池\n - 源码\n - commons-pool\n---\n\n## 前言\n大家对连接池的概念应该都很熟悉了，[apache commons-pool](https://commons.apache.org/proper/commons-pool/)是apache基金会的一个开源对象池组件，我们常用的数据库连接池dpcp和redis的java客户端jedis都使用commons-pool来管理连接。现在我们通过阅读commons-pool的部分代码来看一看他们在编写连接池组件时采用了什么样的设计思路和技术。\n\n## 准备工作\n首先我们思考一下，连接池除应该具备哪些功能？\n\n 1. 连接池要能够管理不同类型的对象，同时作为一个服务组件不需要关心每种连接的创建细节。\n 2. 连接池中的连接当长时间空闲时可能会被服务端主动关闭，或者受网络影响断开，连接池要能够定时检查它的连接是否可用。\n 3. 支持并发操作,每个线程各种持有连接互不影响。\n\n带着这三个问题，下面我们一起看一下commons-pool的代码,\n它主要提供这个几种类型的对象池：\n<!--more-->\n![](/images/commonspool.gif)\n从左至右看，SoftReferenceObjectPool是不用指定容量的对象池，ProxiedObject是使用代理模式来创建对象池的对象，在这篇文章主要介绍GenericObjectPool的实现。\n\n## 封装对象\ncommons-pool定义了一个接口PooledObject来封装池中的对象，添加了空闲时间，使用时间等信息和对象状态流转的行为。\nPooledbject的状态有这几种：\n|    状态     |    说明  |\n| --------   | -----  | \n| IDLE     | 空闲 |\n|ALLOCATED  |   使用中\n|INVALID |不可用 即将/已经被销毁\n|ABANDONED |被遗弃\n|RETURNING |返回对象池\n|EVICTION|  在队列中 正在被检查\n|EVICTION_RETURN_TO_HEAD| 检查结束要放回队列头部\n|VALIDATION| 在队列中 正在被检查\n|VALIDATION_PREALLOCATED |验证结束要被分配\n|VALIDATION_RETURN_TO_HEAD| 检查结束要放回队列头部\n\n表格中以RETURN_TO_HEAD结尾的状态是在当前的检查操作和对象借出操作同时进行时出现的，在检查结束后为了尽量保证借出成功这个对象要放回队头。\n在我们不需要自定义对象行为的情况下可以直接使用PooledObject的默认实现DefaultPooledObject，主要代码如下：\n``` java\nprivate final long createTime = System.currentTimeMillis();\nprivate volatile long lastBorrowTime = createTime;\nprivate volatile long lastUseTime = createTime;\nprivate volatile long lastReturnTime = createTime;\nprivate volatile long borrowedCount = 0;\n@Override\n    public synchronized boolean allocate() {\n        if (state == PooledObjectState.IDLE) {\n            state = PooledObjectState.ALLOCATED;\n            lastBorrowTime = System.currentTimeMillis();\n            lastUseTime = lastBorrowTime;\n            borrowedCount++;\n            if (logAbandoned) {\n                borrowedBy = new AbandonedObjectCreatedException();\n            }\n            return true;\n        } else if (state == PooledObjectState.EVICTION) {\n            state = PooledObjectState.EVICTION_RETURN_TO_HEAD;\n            return false;\n        }\n        return false;\n    }\n```\nallocate() 定义了对象分配时的状态变化，当对象在空闲状态时才能被分配；如果对象正在做驱逐检查时,会把这个对象标记为EVICTION_RETURN_TO_HEAD.\n```java\n@Override\n//返回值：对象是否当前未被使用\npublic synchronized boolean endEvictionTest(\n            Deque<PooledObject<T>> idleQueue) {\n        if (state == PooledObjectState.EVICTION) {\n            state = PooledObjectState.IDLE;\n            return true;\n        } else if (state == PooledObjectState.EVICTION_RETURN_TO_HEAD) {\n            //如果状态是EVICTION_RETURN_TO_HEAD表示当前这个对象试图被借出，返回false.\n            state = PooledObjectState.IDLE;\n            if (!idleQueue.offerFirst(this)) {\n                // TODO - Should never happen\n            }\n        }\n        return false;\n    }\n```\n\nendEvictionTest()定义了驱逐检查之后对象状态的变化，可以看到EVICTION_RETURN_TO_HEAD状态的对象被放到空闲队列队头。\n\nallocate()和borrowedCount等使用synchronized，violatile都做了线程安全的处理。\n\n \n## 定义对象工厂\ncommons-pool为了管理多种对象使用工厂模式来创建要管理的对象，使用工厂方法后使用者可以通过重写PooledObjectFactory定义对象的实现，销毁，验证的具体实现，而commons-pool不需要关心这些细节它只管理PooledObject对象即可。\n\n工厂接口：PooledObjectFactory\n``` java\npublic interface PooledObjectFactory<T> {\n  PooledObject<T> makeObject() throws Exception;\n  void destroyObject(PooledObject<T> p) throws Exception;\n  boolean validateObject(PooledObject<T> p);\n  void activateObject(PooledObject<T> p) throws Exception;\n  void passivateObject(PooledObject<T> p) throws Exception;\n}\n```\n工厂抽象类：BasePooledObjectFactory\n``` java\npublic abstract class BasePooledObjectFactory<T> implements PooledObjectFactory<T> {\n...\n    public abstract T create() throws Exception;\n    public abstract PooledObject<T> wrap(T obj);\n    @Override\n    public PooledObject<T> makeObject() throws Exception {\n        return wrap(create());\n    }\n    @Override\n    public boolean validateObject(PooledObject<T> p) {\n        return true;\n    }\n\n...\n}\n```\nBasePooledObjectFactory添加了create,wrap两个抽象方法，create可以返回我们要放在连接池的对象，然后使用wrap封装为PooledObject即可，注意validateObject默认返回true;\n\n## 对象池定义\n对象池是我们保存对象的地方，对象的获取，归还和定时检查都通过对象池来实现。以GenericObjectPool为例，对象池使用了线程安全的集合类来保存对象，LinkedBlockingDeque用于保存空闲的对象，ConcurrentHashMap保存全部对象（包括各种状态）。\n``` java\nprivate final LinkedBlockingDeque<PooledObject<T>> idleObjects = new LinkedBlockingDeque<PooledObject<T>>();\nprivate final Map<T, PooledObject<T>> allObjects = new ConcurrentHashMap<T, PooledObject<T>>();\n```\nborrowObject()从连接池获取对象：\n连接池借出对象时，经过Abandoned和validate两种检查，在连接池满时根据配置执行对应的等待策略，当没有可用对象时会抛出异常。\n\nAbandoned检查目标是连接池所有被借出的对象，主要防止对象借出之后长时间被占用，不能退还（或者使用者忘记return）到连接池导致连接被耗尽。超时时间由AbandonedConfig定义。\n\nvalidate检查目标是当前即将被借出的对象，目的是保证提供的对象是可用的，检查方式由对象工厂的validateObject方法定义。对象工厂还有activateObject方法来验证对象，不过这个方法是强制执行的。\n\n``` java\npublic T borrowObject(long borrowMaxWaitMillis) throws Exception {\n// getNumIdle() 表示当前空空闲对象数量，getNumActive() 表示当前非空闲的对象数量，getMaxTotal()表示连接池容量\n// 那么假设最大容量10个，非空闲8个 > 7 ，空闲对象只要少于2个，就需要开始Abandoned检查\n\n        AbandonedConfig ac = this.abandonedConfig;\n        if (ac != null && ac.getRemoveAbandonedOnBorrow() &&\n                (getNumIdle() < 2) &&\n                (getNumActive() > getMaxTotal() - 3) ) {\n            removeAbandoned(ac);\n        }\n\n        PooledObject<T> p = null;\n        \n        //拷贝了变量 blockWhenExhausted\n        //因为blockWhenExhausted的修改方法是public的，这样保证在并发情况下，方法执行周期内变量也不会变化\n        boolean blockWhenExhausted = getBlockWhenExhausted();\n\n        boolean create;\n        long waitTime = 0;\n\n        while (p == null) {\n            create = false;\n            // 设置了对象池耗尽时等待\n            if (blockWhenExhausted) {\n                //从空闲队列取对象\n                p = idleObjects.pollFirst();\n                if (p == null) {\n                    //没有空闲对象 新建一个\n                    create = true;\n                    p = create();\n                }\n                if (p == null) {\n                    if (borrowMaxWaitMillis < 0) {\n                        //注意：没配置等待时间，会一直阻塞\n                        p = idleObjects.takeFirst();\n                    } else {\n                        //按照配置的时间等待\n.....\n                        p = idleObjects.pollFirst(borrowMaxWaitMillis,\n                                TimeUnit.MILLISECONDS);\n.....\n                    }\n                }\n                 //等待之后还是没有空闲对象\n                if (p == null) {\n                    throw new NoSuchElementException(\n                            \"Timeout waiting for idle object\");\n                }\n                 //等待之后获得对象 尝试分配对象\n                 //这个方法由pooledobject实现\n                if (!p.allocate()) {\n                    p = null;\n                }\n            } else {\n                //没有配置blockWhenExhausted 不等待\n                p = idleObjects.pollFirst();\n                if (p == null) {\n                    create = true;\n                    p = create();\n                }\n                if (p == null) {\n                    throw new NoSuchElementException(\"Pool exhausted\");\n                }\n                if (!p.allocate()) {\n                    p = null;\n                }\n            }\n            //对象分配成功\n            if (p != null) {\n\n                try {\n                   //激活对象\n                    factory.activateObject(p);\n                } catch (Exception e) {\n                    try {\n                        destroy(p);\n                    } catch (Exception e1) {\n                    }\n                    p = null;\n                    .....\n                }\n                //如果配置了对象检查\n                if (p != null && (getTestOnBorrow() || create && getTestOnCreate())) {\n                    boolean validate = false;\n                    Throwable validationThrowable = null;\n                    try {\n                        validate = factory.validateObject(p);\n                    } catch (Throwable t) {\n                        PoolUtils.checkRethrow(t);\n                        validationThrowable = t;\n                    }\n                    if (!validate) {\n                    //验证失败 销毁对象\n                        try {\n                            destroy(p);\n                         destroyedByBorrowValidationCount.incrementAndGet();\n                        } catch (Exception e) {\n                        }\n                        p = null;\n                        .....\n                    }\n                }\n            }\n        }\n        //更新借出时间等信息\n        updateStatsBorrow(p, waitTime);\n\n        return p.getObject();\n    }\n```\nevict()驱逐对象：\n\nevict驱逐检查：上面介绍了两种对象的检查方式，evictor不同之处在于它由后台线程独立来完成，检查对象主要是连接池中的空闲连接，超时时间等可通过EvictionConfig配置。\n``` java\npublic void evict() throws Exception {\n        //确保连接池打开\n        assertOpen();\n\n        if (idleObjects.size() > 0) {\n\n            PooledObject<T> underTest = null;\n            \n            EvictionPolicy<T> evictionPolicy = getEvictionPolicy();\n\n            synchronized (evictionLock) {\n                ...\n                // 复制变量保证函数内值不改变，同上\n                boolean testWhileIdle = getTestWhileIdle();\n                //每次驱逐对象数可配置\n                for (int i = 0, m = getNumTests(); i < m; i++) {\n                    if (evictionIterator == null || !evictionIterator.hasNext()) {\n                        //驱逐检查的顺序和空闲队列出入顺序保持一致 \n                        if (getLifo()) {\n                            //后进先出(逆序遍历)\n                            evictionIterator = idleObjects.descendingIterator();\n                        } else {\n                            //先进先出\n                            evictionIterator = idleObjects.iterator();\n                        }\n                    }\n                    if (!evictionIterator.hasNext()) {\n                        // Pool exhausted, nothing to do here\n                        return;\n                    }\n\n                    try {\n                        underTest = evictionIterator.next();\n                    } catch (NoSuchElementException nsee) {\n                        //因为idleObjects.iterator()方法并没有做同步控制，可能被检查的空闲对象再检查期间已经被借出不在队列中了，在并发条件下要考虑这种情况。。\n                        // Object was borrowed in another thread\n                        // Don't count this as an eviction test so reduce i;\n                        i--;\n                        evictionIterator = null;\n                        continue;\n                    }\n                    //再次检查，对象在队列中但是要保证状态是空闲。。。\n                    if (!underTest.startEvictionTest()) {\n                        // Object was borrowed in another thread\n                        // Don't count this as an eviction test so reduce i;\n                        i--;\n                        continue;\n                    }\n                    //EvictionPolicy定义了驱逐对象的策略，默认实现是DefaultEvictionPolicy\n                    //调用ObjectPool的setEvictionPolicyClassName方法指定自定义策略\n                    if (evictionPolicy.evict(evictionConfig, underTest,\n                            idleObjects.size())) {\n                        destroy(underTest);\n                        destroyedByEvictorCount.incrementAndGet();\n                    } else {\n                        if (testWhileIdle) {\n                            ...\n                            //执行activateObject&validateObject的检查\n                            ...\n                        }\n                        ...\n                    }\n                }\n            }\n        }\n        //无处不在的Abandoned检查，可以配置连接池是否在evictor线程中执行removeAbandoned\n        AbandonedConfig ac = this.abandonedConfig;\n        if (ac != null && ac.getRemoveAbandonedOnMaintenance()) {\n            removeAbandoned(ac);\n        }\n    }\n```\n驱逐线程的调用：\n了解驱逐对象时要做的操作之后，我们来看一下后台的驱逐者线程是怎么定义&启动的\n``` java\n//GenericObjectPool.java\n//构造方法中启动驱逐者线程\npublic GenericObjectPool(PooledObjectFactory<T> factory,\n            GenericObjectPoolConfig config) {\n        ...\n        startEvictor(getTimeBetweenEvictionRunsMillis());\n        ...\n    }\n```\n驱逐线程的定义：\n驱逐者Evictor,在BaseGenericObjectPool中定义，本质是由java.util.TimerTask定义的定时任务\n```java\n//父类BaseGenericObjectPool.java\nfinal void startEvictor(long delay) {\n        //BaseGenericObjectPool的私有成员，final Object evictionLock = new Object();做对象锁\n        synchronized (evictionLock) {\n            if (null != evictor) {\n                //已存在evictor，取消驱逐者线程，所以也可以二次调用startEvictor来停止驱逐检查\n                EvictionTimer.cancel(evictor);\n                evictor = null;\n                evictionIterator = null;\n            }\n            if (delay > 0) {\n                evictor = new Evictor();\n                EvictionTimer.schedule(evictor, delay, delay);\n            }\n        }\n    }\n```\nEvitor定义：这里有一个比较有意思的问题，驱逐者线程Evictor被多个连接池共享,但是这些连接池可能属于不同的classloader,Evictor必须要保证它的所有行为在**当前这个连接池的classloader**下执行（这是开发者给commons-pool提交的bug,[详细描述请看这里](https://issues.apache.org/jira/browse/POOL-161)）\n```java\n//内部类Evictor\nclass Evictor extends TimerTask {\n    \n        @Override\n        public void run() {\n            ClassLoader savedClassLoader =\n                    Thread.currentThread().getContextClassLoader();\n            try {\n                // 切换到当前连接池的classLoader\n                Thread.currentThread().setContextClassLoader(\n                        factoryClassLoader);\n\n                // 执行上面的evict()方法\n                try {\n                    evict();\n                } catch(Exception e) {\n                    swallowException(e);\n                } catch(OutOfMemoryError oome) {\n                    // Log problem but give evictor thread a chance to continue\n                    // in case error is recoverable\n                    oome.printStackTrace(System.err);\n                }\n                // 驱逐之后还要保证空闲连接数量不能小于配置\n                try {\n                    ensureMinIdle();\n                } catch (Exception e) {\n                    swallowException(e);\n                }\n            } finally {\n                // 切换回之前的classLoader\n                Thread.currentThread().setContextClassLoader(savedClassLoader);\n            }\n        }\n    }\n```\n驱逐策略：\n在evict()方法中最后对象是否要被驱逐是调用了evictionPolicy.evict()的方法来判断的，commons-pool提供的驱逐策略如下：\n```java\n//DefaultEvictionPolicy.java\n\npublic class DefaultEvictionPolicy<T> implements EvictionPolicy<T> {\n    @Override\n    public boolean evict(EvictionConfig config, PooledObject<T> underTest,\n            int idleCount) {\n        //getIdleTimeMillis()空闲时间\n        //config.getIdleSoftEvictTime()空闲连接大于配置的最小值时的超时时间\n        //config.getIdleEvictTime()空闲连接超时时间与数量无关\n        if ((config.getIdleSoftEvictTime() < underTest.getIdleTimeMillis() &&\n                config.getMinIdle() < idleCount) ||\n                config.getIdleEvictTime() < underTest.getIdleTimeMillis()) {\n            return true;\n        }\n        return false;\n    }\n}\n\n```\n驱逐策略是支持自定义的，这里使用的是设计模式中的策略模式，我们只要实现EvictionPolicy接口，然后调用setEvictionPolicyClassName()方法既可以更换驱逐策略（实现类要尽可能简单，只描述一种算法即可）：\n```java\n//父类BaseGenericObjectPool.java\n public final void setEvictionPolicyClassName(\n            String evictionPolicyClassName) {\n        try {\n            //使用接口+反射实现的策略模式\n            Class<?> clazz = Class.forName(evictionPolicyClassName);\n            Object policy = clazz.newInstance();\n            if (policy instanceof EvictionPolicy<?>) {\n                @SuppressWarnings(\"unchecked\") \n                EvictionPolicy<T> evicPolicy = (EvictionPolicy<T>) policy;\n                this.evictionPolicy = evicPolicy;\n            }\n        } catch (ClassNotFoundException e) {\n            ...\n        } catch (InstantiationException e) {\n            ...\n        } catch (IllegalAccessException e) {\n            ...\n        }\n    }\n\n```\n通过阅读GenericObjectPool的部分代码，可以看出来并没有在每个获取&退还对象的方法都做同步控制，线程安全主要是由LinkedBlockingDeque，ConcurrentHashMap这两个并发集合保证的，因此开发者在编写非线程安全方法时也使用了局部变量复制可能被修改的值，多次检查对象状态之类的方法保证并发条件下程序正常的执行（没全部加锁能够提升性能，不过也会有这样的麻烦）。\n总结一下连接池中对象的声明周期大概如下图：\n![](/images/commonspoolflow.png)\n蓝色线是evictor执行时对象状态的变化，红线是abandon执行的过程，绿色线是正常使用中对象的变化。\n\n\n\n## 其他功能\n附上一份objectpool的配置选项\n```java\nGenericObjectPoolConfig poolConfig = new GenericObjectPoolConfig();\n\n基本配置：\n\n        //最大连接\n        poolConfig.setMaxTotal(100);\n        //最大空闲连接\n        poolConfig.setMaxIdle(5);\n        //最小空闲连接 \n        poolConfig.setMinIdle(5);\n        //连接满时最多等待时间\n        poolConfig.setMaxWaitMillis(5000L);\n\n高级功能：\n         //使用时检查对象（默认不检查）\n        poolConfig.setTestWhileIdle(true);\n        poolConfig.setTestOnCreate(true);\n        poolConfig.setTestOnBorrow(true);\n        poolConfig.setTestOnReturn(true);\n\n        //jmx启用 之后可以实时的查看线程池对象的状态\n        poolConfig.setJmxEnabled(false);\n        poolConfig.setJmxNameBase(\"namebase\");\n        poolConfig.setJmxNamePrefix(\"nameprefix\");\n\n         //驱逐线程每次检查对象个数\n        poolConfig.setNumTestsPerEvictionRun(2);\n        //空闲连接被驱逐前能够保留的时间\n        poolConfig.setMinEvictableIdleTimeMillis(10000L);\n        //当空闲线程大于minIdle 空闲连接能够保留时间，同时指定会被上面的覆盖\n        poolConfig.setSoftMinEvictableIdleTimeMillis(10000L);\n        //驱逐线程执行间隔时间\n        poolConfig.setTimeBetweenEvictionRunsMillis(200000L);\n\n        //放弃长时间占用连接的对象\n       AbandonedConfig abandonedConfig=new AbandonedConfig();\n       abandonedConfig.setLogAbandoned(true);\n       abandonedConfig.setUseUsageTracking(false);\n       abandonedConfig.setRemoveAbandonedOnBorrow(true);\n       abandonedConfig.setRemoveAbandonedOnMaintenance(true);\n       abandonedConfig.setRemoveAbandonedTimeout(20);//second\n```\n\n\n  [1]: https://www.throwsnew.com/img/GenericObjectPool.PNG\n  [2]: https://www.throwsnew.com/img/common-pool2.png\n","slug":"commons-pool","published":1,"updated":"2019-05-04T15:20:00.701Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkqle1ds003acyneue12t10h","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>大家对连接池的概念应该都很熟悉了，<a href=\"https://commons.apache.org/proper/commons-pool/\" target=\"_blank\" rel=\"noopener\">apache commons-pool</a>是apache基金会的一个开源对象池组件，我们常用的数据库连接池dpcp和redis的java客户端jedis都使用commons-pool来管理连接。现在我们通过阅读commons-pool的部分代码来看一看他们在编写连接池组件时采用了什么样的设计思路和技术。</p>\n<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><p>首先我们思考一下，连接池除应该具备哪些功能？</p>\n<ol>\n<li>连接池要能够管理不同类型的对象，同时作为一个服务组件不需要关心每种连接的创建细节。</li>\n<li>连接池中的连接当长时间空闲时可能会被服务端主动关闭，或者受网络影响断开，连接池要能够定时检查它的连接是否可用。</li>\n<li>支持并发操作,每个线程各种持有连接互不影响。</li>\n</ol>\n<p>带着这三个问题，下面我们一起看一下commons-pool的代码,<br>它主要提供这个几种类型的对象池：<br><a id=\"more\"></a><br><img src=\"/images/commonspool.gif\" alt=\"\"><br>从左至右看，SoftReferenceObjectPool是不用指定容量的对象池，ProxiedObject是使用代理模式来创建对象池的对象，在这篇文章主要介绍GenericObjectPool的实现。</p>\n<h2 id=\"封装对象\"><a href=\"#封装对象\" class=\"headerlink\" title=\"封装对象\"></a>封装对象</h2><p>commons-pool定义了一个接口PooledObject来封装池中的对象，添加了空闲时间，使用时间等信息和对象状态流转的行为。<br>Pooledbject的状态有这几种：<br>|    状态     |    说明  |<br>| ——–   | —–  |<br>| IDLE     | 空闲 |<br>|ALLOCATED  |   使用中<br>|INVALID |不可用 即将/已经被销毁<br>|ABANDONED |被遗弃<br>|RETURNING |返回对象池<br>|EVICTION|  在队列中 正在被检查<br>|EVICTION_RETURN_TO_HEAD| 检查结束要放回队列头部<br>|VALIDATION| 在队列中 正在被检查<br>|VALIDATION_PREALLOCATED |验证结束要被分配<br>|VALIDATION_RETURN_TO_HEAD| 检查结束要放回队列头部</p>\n<p>表格中以RETURN_TO_HEAD结尾的状态是在当前的检查操作和对象借出操作同时进行时出现的，在检查结束后为了尽量保证借出成功这个对象要放回队头。<br>在我们不需要自定义对象行为的情况下可以直接使用PooledObject的默认实现DefaultPooledObject，主要代码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> createTime = System.currentTimeMillis();</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">long</span> lastBorrowTime = createTime;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">long</span> lastUseTime = createTime;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">long</span> lastReturnTime = createTime;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">long</span> borrowedCount = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">boolean</span> <span class=\"title\">allocate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (state == PooledObjectState.IDLE) &#123;</span><br><span class=\"line\">            state = PooledObjectState.ALLOCATED;</span><br><span class=\"line\">            lastBorrowTime = System.currentTimeMillis();</span><br><span class=\"line\">            lastUseTime = lastBorrowTime;</span><br><span class=\"line\">            borrowedCount++;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (logAbandoned) &#123;</span><br><span class=\"line\">                borrowedBy = <span class=\"keyword\">new</span> AbandonedObjectCreatedException();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (state == PooledObjectState.EVICTION) &#123;</span><br><span class=\"line\">            state = PooledObjectState.EVICTION_RETURN_TO_HEAD;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>allocate() 定义了对象分配时的状态变化，当对象在空闲状态时才能被分配；如果对象正在做驱逐检查时,会把这个对象标记为EVICTION_RETURN_TO_HEAD.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"comment\">//返回值：对象是否当前未被使用</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">boolean</span> <span class=\"title\">endEvictionTest</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            Deque&lt;PooledObject&lt;T&gt;&gt; idleQueue)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (state == PooledObjectState.EVICTION) &#123;</span><br><span class=\"line\">            state = PooledObjectState.IDLE;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (state == PooledObjectState.EVICTION_RETURN_TO_HEAD) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//如果状态是EVICTION_RETURN_TO_HEAD表示当前这个对象试图被借出，返回false.</span></span><br><span class=\"line\">            state = PooledObjectState.IDLE;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!idleQueue.offerFirst(<span class=\"keyword\">this</span>)) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// TODO - Should never happen</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>endEvictionTest()定义了驱逐检查之后对象状态的变化，可以看到EVICTION_RETURN_TO_HEAD状态的对象被放到空闲队列队头。</p>\n<p>allocate()和borrowedCount等使用synchronized，violatile都做了线程安全的处理。</p>\n<h2 id=\"定义对象工厂\"><a href=\"#定义对象工厂\" class=\"headerlink\" title=\"定义对象工厂\"></a>定义对象工厂</h2><p>commons-pool为了管理多种对象使用工厂模式来创建要管理的对象，使用工厂方法后使用者可以通过重写PooledObjectFactory定义对象的实现，销毁，验证的具体实现，而commons-pool不需要关心这些细节它只管理PooledObject对象即可。</p>\n<p>工厂接口：PooledObjectFactory<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">PooledObjectFactory</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"function\">PooledObject&lt;T&gt; <span class=\"title\">makeObject</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">destroyObject</span><span class=\"params\">(PooledObject&lt;T&gt; p)</span> <span class=\"keyword\">throws</span> Exception</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">validateObject</span><span class=\"params\">(PooledObject&lt;T&gt; p)</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">activateObject</span><span class=\"params\">(PooledObject&lt;T&gt; p)</span> <span class=\"keyword\">throws</span> Exception</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">passivateObject</span><span class=\"params\">(PooledObject&lt;T&gt; p)</span> <span class=\"keyword\">throws</span> Exception</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>工厂抽象类：BasePooledObjectFactory<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BasePooledObjectFactory</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">PooledObjectFactory</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">...</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> T <span class=\"title\">create</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> PooledObject&lt;T&gt; <span class=\"title\">wrap</span><span class=\"params\">(T obj)</span></span>;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> PooledObject&lt;T&gt; <span class=\"title\">makeObject</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> wrap(create());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">validateObject</span><span class=\"params\">(PooledObject&lt;T&gt; p)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>BasePooledObjectFactory添加了create,wrap两个抽象方法，create可以返回我们要放在连接池的对象，然后使用wrap封装为PooledObject即可，注意validateObject默认返回true;</p>\n<h2 id=\"对象池定义\"><a href=\"#对象池定义\" class=\"headerlink\" title=\"对象池定义\"></a>对象池定义</h2><p>对象池是我们保存对象的地方，对象的获取，归还和定时检查都通过对象池来实现。以GenericObjectPool为例，对象池使用了线程安全的集合类来保存对象，LinkedBlockingDeque用于保存空闲的对象，ConcurrentHashMap保存全部对象（包括各种状态）。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> LinkedBlockingDeque&lt;PooledObject&lt;T&gt;&gt; idleObjects = <span class=\"keyword\">new</span> LinkedBlockingDeque&lt;PooledObject&lt;T&gt;&gt;();</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;T, PooledObject&lt;T&gt;&gt; allObjects = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;T, PooledObject&lt;T&gt;&gt;();</span><br></pre></td></tr></table></figure></p>\n<p>borrowObject()从连接池获取对象：<br>连接池借出对象时，经过Abandoned和validate两种检查，在连接池满时根据配置执行对应的等待策略，当没有可用对象时会抛出异常。</p>\n<p>Abandoned检查目标是连接池所有被借出的对象，主要防止对象借出之后长时间被占用，不能退还（或者使用者忘记return）到连接池导致连接被耗尽。超时时间由AbandonedConfig定义。</p>\n<p>validate检查目标是当前即将被借出的对象，目的是保证提供的对象是可用的，检查方式由对象工厂的validateObject方法定义。对象工厂还有activateObject方法来验证对象，不过这个方法是强制执行的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">borrowObject</span><span class=\"params\">(<span class=\"keyword\">long</span> borrowMaxWaitMillis)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">// getNumIdle() 表示当前空空闲对象数量，getNumActive() 表示当前非空闲的对象数量，getMaxTotal()表示连接池容量</span></span><br><span class=\"line\"><span class=\"comment\">// 那么假设最大容量10个，非空闲8个 &gt; 7 ，空闲对象只要少于2个，就需要开始Abandoned检查</span></span><br><span class=\"line\"></span><br><span class=\"line\">        AbandonedConfig ac = <span class=\"keyword\">this</span>.abandonedConfig;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ac != <span class=\"keyword\">null</span> &amp;&amp; ac.getRemoveAbandonedOnBorrow() &amp;&amp;</span><br><span class=\"line\">                (getNumIdle() &lt; <span class=\"number\">2</span>) &amp;&amp;</span><br><span class=\"line\">                (getNumActive() &gt; getMaxTotal() - <span class=\"number\">3</span>) ) &#123;</span><br><span class=\"line\">            removeAbandoned(ac);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        PooledObject&lt;T&gt; p = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//拷贝了变量 blockWhenExhausted</span></span><br><span class=\"line\">        <span class=\"comment\">//因为blockWhenExhausted的修改方法是public的，这样保证在并发情况下，方法执行周期内变量也不会变化</span></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> blockWhenExhausted = getBlockWhenExhausted();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> create;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> waitTime = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (p == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            create = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 设置了对象池耗尽时等待</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (blockWhenExhausted) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//从空闲队列取对象</span></span><br><span class=\"line\">                p = idleObjects.pollFirst();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//没有空闲对象 新建一个</span></span><br><span class=\"line\">                    create = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                    p = create();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (borrowMaxWaitMillis &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">//注意：没配置等待时间，会一直阻塞</span></span><br><span class=\"line\">                        p = idleObjects.takeFirst();</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"comment\">//按照配置的时间等待</span></span><br><span class=\"line\">.....</span><br><span class=\"line\">                        p = idleObjects.pollFirst(borrowMaxWaitMillis,</span><br><span class=\"line\">                                TimeUnit.MILLISECONDS);</span><br><span class=\"line\">.....</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                 <span class=\"comment\">//等待之后还是没有空闲对象</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NoSuchElementException(</span><br><span class=\"line\">                            <span class=\"string\">\"Timeout waiting for idle object\"</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                 <span class=\"comment\">//等待之后获得对象 尝试分配对象</span></span><br><span class=\"line\">                 <span class=\"comment\">//这个方法由pooledobject实现</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!p.allocate()) &#123;</span><br><span class=\"line\">                    p = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">//没有配置blockWhenExhausted 不等待</span></span><br><span class=\"line\">                p = idleObjects.pollFirst();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    create = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                    p = create();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NoSuchElementException(<span class=\"string\">\"Pool exhausted\"</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!p.allocate()) &#123;</span><br><span class=\"line\">                    p = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//对象分配成功</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                   <span class=\"comment\">//激活对象</span></span><br><span class=\"line\">                    factory.activateObject(p);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        destroy(p);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (Exception e1) &#123;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    p = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    .....</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">//如果配置了对象检查</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p != <span class=\"keyword\">null</span> &amp;&amp; (getTestOnBorrow() || create &amp;&amp; getTestOnCreate())) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">boolean</span> validate = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                    Throwable validationThrowable = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        validate = factory.validateObject(p);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">                        PoolUtils.checkRethrow(t);</span><br><span class=\"line\">                        validationThrowable = t;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (!validate) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//验证失败 销毁对象</span></span><br><span class=\"line\">                        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                            destroy(p);</span><br><span class=\"line\">                         destroyedByBorrowValidationCount.incrementAndGet();</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        p = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                        .....</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//更新借出时间等信息</span></span><br><span class=\"line\">        updateStatsBorrow(p, waitTime);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> p.getObject();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>evict()驱逐对象：</p>\n<p>evict驱逐检查：上面介绍了两种对象的检查方式，evictor不同之处在于它由后台线程独立来完成，检查对象主要是连接池中的空闲连接，超时时间等可通过EvictionConfig配置。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">evict</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//确保连接池打开</span></span><br><span class=\"line\">        assertOpen();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (idleObjects.size() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            PooledObject&lt;T&gt; underTest = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            </span><br><span class=\"line\">            EvictionPolicy&lt;T&gt; evictionPolicy = getEvictionPolicy();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (evictionLock) &#123;</span><br><span class=\"line\">                ...</span><br><span class=\"line\">                <span class=\"comment\">// 复制变量保证函数内值不改变，同上</span></span><br><span class=\"line\">                <span class=\"keyword\">boolean</span> testWhileIdle = getTestWhileIdle();</span><br><span class=\"line\">                <span class=\"comment\">//每次驱逐对象数可配置</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, m = getNumTests(); i &lt; m; i++) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (evictionIterator == <span class=\"keyword\">null</span> || !evictionIterator.hasNext()) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">//驱逐检查的顺序和空闲队列出入顺序保持一致 </span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (getLifo()) &#123;</span><br><span class=\"line\">                            <span class=\"comment\">//后进先出(逆序遍历)</span></span><br><span class=\"line\">                            evictionIterator = idleObjects.descendingIterator();</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                            <span class=\"comment\">//先进先出</span></span><br><span class=\"line\">                            evictionIterator = idleObjects.iterator();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (!evictionIterator.hasNext()) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// Pool exhausted, nothing to do here</span></span><br><span class=\"line\">                        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        underTest = evictionIterator.next();</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (NoSuchElementException nsee) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">//因为idleObjects.iterator()方法并没有做同步控制，可能被检查的空闲对象再检查期间已经被借出不在队列中了，在并发条件下要考虑这种情况。。</span></span><br><span class=\"line\">                        <span class=\"comment\">// Object was borrowed in another thread</span></span><br><span class=\"line\">                        <span class=\"comment\">// Don't count this as an eviction test so reduce i;</span></span><br><span class=\"line\">                        i--;</span><br><span class=\"line\">                        evictionIterator = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"comment\">//再次检查，对象在队列中但是要保证状态是空闲。。。</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (!underTest.startEvictionTest()) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// Object was borrowed in another thread</span></span><br><span class=\"line\">                        <span class=\"comment\">// Don't count this as an eviction test so reduce i;</span></span><br><span class=\"line\">                        i--;</span><br><span class=\"line\">                        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"comment\">//EvictionPolicy定义了驱逐对象的策略，默认实现是DefaultEvictionPolicy</span></span><br><span class=\"line\">                    <span class=\"comment\">//调用ObjectPool的setEvictionPolicyClassName方法指定自定义策略</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (evictionPolicy.evict(evictionConfig, underTest,</span><br><span class=\"line\">                            idleObjects.size())) &#123;</span><br><span class=\"line\">                        destroy(underTest);</span><br><span class=\"line\">                        destroyedByEvictorCount.incrementAndGet();</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (testWhileIdle) &#123;</span><br><span class=\"line\">                            ...</span><br><span class=\"line\">                            <span class=\"comment\">//执行activateObject&amp;validateObject的检查</span></span><br><span class=\"line\">                            ...</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        ...</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//无处不在的Abandoned检查，可以配置连接池是否在evictor线程中执行removeAbandoned</span></span><br><span class=\"line\">        AbandonedConfig ac = <span class=\"keyword\">this</span>.abandonedConfig;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ac != <span class=\"keyword\">null</span> &amp;&amp; ac.getRemoveAbandonedOnMaintenance()) &#123;</span><br><span class=\"line\">            removeAbandoned(ac);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>驱逐线程的调用：<br>了解驱逐对象时要做的操作之后，我们来看一下后台的驱逐者线程是怎么定义&amp;启动的<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//GenericObjectPool.java</span></span><br><span class=\"line\"><span class=\"comment\">//构造方法中启动驱逐者线程</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">GenericObjectPool</span><span class=\"params\">(PooledObjectFactory&lt;T&gt; factory,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            GenericObjectPoolConfig config)</span> </span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        startEvictor(getTimeBetweenEvictionRunsMillis());</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>驱逐线程的定义：<br>驱逐者Evictor,在BaseGenericObjectPool中定义，本质是由java.util.TimerTask定义的定时任务<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//父类BaseGenericObjectPool.java</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">startEvictor</span><span class=\"params\">(<span class=\"keyword\">long</span> delay)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//BaseGenericObjectPool的私有成员，final Object evictionLock = new Object();做对象锁</span></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (evictionLock) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> != evictor) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//已存在evictor，取消驱逐者线程，所以也可以二次调用startEvictor来停止驱逐检查</span></span><br><span class=\"line\">                EvictionTimer.cancel(evictor);</span><br><span class=\"line\">                evictor = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                evictionIterator = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (delay &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                evictor = <span class=\"keyword\">new</span> Evictor();</span><br><span class=\"line\">                EvictionTimer.schedule(evictor, delay, delay);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>Evitor定义：这里有一个比较有意思的问题，驱逐者线程Evictor被多个连接池共享,但是这些连接池可能属于不同的classloader,Evictor必须要保证它的所有行为在<strong>当前这个连接池的classloader</strong>下执行（这是开发者给commons-pool提交的bug,<a href=\"https://issues.apache.org/jira/browse/POOL-161\" target=\"_blank\" rel=\"noopener\">详细描述请看这里</a>）<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//内部类Evictor</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Evictor</span> <span class=\"keyword\">extends</span> <span class=\"title\">TimerTask</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            ClassLoader savedClassLoader =</span><br><span class=\"line\">                    Thread.currentThread().getContextClassLoader();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 切换到当前连接池的classLoader</span></span><br><span class=\"line\">                Thread.currentThread().setContextClassLoader(</span><br><span class=\"line\">                        factoryClassLoader);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 执行上面的evict()方法</span></span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    evict();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span>(Exception e) &#123;</span><br><span class=\"line\">                    swallowException(e);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span>(OutOfMemoryError oome) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// Log problem but give evictor thread a chance to continue</span></span><br><span class=\"line\">                    <span class=\"comment\">// in case error is recoverable</span></span><br><span class=\"line\">                    oome.printStackTrace(System.err);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 驱逐之后还要保证空闲连接数量不能小于配置</span></span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    ensureMinIdle();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                    swallowException(e);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 切换回之前的classLoader</span></span><br><span class=\"line\">                Thread.currentThread().setContextClassLoader(savedClassLoader);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>驱逐策略：<br>在evict()方法中最后对象是否要被驱逐是调用了evictionPolicy.evict()的方法来判断的，commons-pool提供的驱逐策略如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//DefaultEvictionPolicy.java</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DefaultEvictionPolicy</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">EvictionPolicy</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">evict</span><span class=\"params\">(EvictionConfig config, PooledObject&lt;T&gt; underTest,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">int</span> idleCount)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//getIdleTimeMillis()空闲时间</span></span><br><span class=\"line\">        <span class=\"comment\">//config.getIdleSoftEvictTime()空闲连接大于配置的最小值时的超时时间</span></span><br><span class=\"line\">        <span class=\"comment\">//config.getIdleEvictTime()空闲连接超时时间与数量无关</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((config.getIdleSoftEvictTime() &lt; underTest.getIdleTimeMillis() &amp;&amp;</span><br><span class=\"line\">                config.getMinIdle() &lt; idleCount) ||</span><br><span class=\"line\">                config.getIdleEvictTime() &lt; underTest.getIdleTimeMillis()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>驱逐策略是支持自定义的，这里使用的是设计模式中的策略模式，我们只要实现EvictionPolicy接口，然后调用setEvictionPolicyClassName()方法既可以更换驱逐策略（实现类要尽可能简单，只描述一种算法即可）：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//父类BaseGenericObjectPool.java</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">setEvictionPolicyClassName</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            String evictionPolicyClassName)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//使用接口+反射实现的策略模式</span></span><br><span class=\"line\">            Class&lt;?&gt; clazz = Class.forName(evictionPolicyClassName);</span><br><span class=\"line\">            Object policy = clazz.newInstance();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (policy <span class=\"keyword\">instanceof</span> EvictionPolicy&lt;?&gt;) &#123;</span><br><span class=\"line\">                <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>) </span><br><span class=\"line\">                EvictionPolicy&lt;T&gt; evicPolicy = (EvictionPolicy&lt;T&gt;) policy;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.evictionPolicy = evicPolicy;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException e) &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InstantiationException e) &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IllegalAccessException e) &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>通过阅读GenericObjectPool的部分代码，可以看出来并没有在每个获取&amp;退还对象的方法都做同步控制，线程安全主要是由LinkedBlockingDeque，ConcurrentHashMap这两个并发集合保证的，因此开发者在编写非线程安全方法时也使用了局部变量复制可能被修改的值，多次检查对象状态之类的方法保证并发条件下程序正常的执行（没全部加锁能够提升性能，不过也会有这样的麻烦）。<br>总结一下连接池中对象的声明周期大概如下图：<br><img src=\"/images/commonspoolflow.png\" alt=\"\"><br>蓝色线是evictor执行时对象状态的变化，红线是abandon执行的过程，绿色线是正常使用中对象的变化。</p>\n<h2 id=\"其他功能\"><a href=\"#其他功能\" class=\"headerlink\" title=\"其他功能\"></a>其他功能</h2><p>附上一份objectpool的配置选项<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GenericObjectPoolConfig poolConfig = <span class=\"keyword\">new</span> GenericObjectPoolConfig();</span><br><span class=\"line\"></span><br><span class=\"line\">基本配置：</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//最大连接</span></span><br><span class=\"line\">        poolConfig.setMaxTotal(<span class=\"number\">100</span>);</span><br><span class=\"line\">        <span class=\"comment\">//最大空闲连接</span></span><br><span class=\"line\">        poolConfig.setMaxIdle(<span class=\"number\">5</span>);</span><br><span class=\"line\">        <span class=\"comment\">//最小空闲连接 </span></span><br><span class=\"line\">        poolConfig.setMinIdle(<span class=\"number\">5</span>);</span><br><span class=\"line\">        <span class=\"comment\">//连接满时最多等待时间</span></span><br><span class=\"line\">        poolConfig.setMaxWaitMillis(<span class=\"number\">5000L</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">高级功能：</span><br><span class=\"line\">         <span class=\"comment\">//使用时检查对象（默认不检查）</span></span><br><span class=\"line\">        poolConfig.setTestWhileIdle(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        poolConfig.setTestOnCreate(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        poolConfig.setTestOnBorrow(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        poolConfig.setTestOnReturn(<span class=\"keyword\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//jmx启用 之后可以实时的查看线程池对象的状态</span></span><br><span class=\"line\">        poolConfig.setJmxEnabled(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">        poolConfig.setJmxNameBase(<span class=\"string\">\"namebase\"</span>);</span><br><span class=\"line\">        poolConfig.setJmxNamePrefix(<span class=\"string\">\"nameprefix\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"comment\">//驱逐线程每次检查对象个数</span></span><br><span class=\"line\">        poolConfig.setNumTestsPerEvictionRun(<span class=\"number\">2</span>);</span><br><span class=\"line\">        <span class=\"comment\">//空闲连接被驱逐前能够保留的时间</span></span><br><span class=\"line\">        poolConfig.setMinEvictableIdleTimeMillis(<span class=\"number\">10000L</span>);</span><br><span class=\"line\">        <span class=\"comment\">//当空闲线程大于minIdle 空闲连接能够保留时间，同时指定会被上面的覆盖</span></span><br><span class=\"line\">        poolConfig.setSoftMinEvictableIdleTimeMillis(<span class=\"number\">10000L</span>);</span><br><span class=\"line\">        <span class=\"comment\">//驱逐线程执行间隔时间</span></span><br><span class=\"line\">        poolConfig.setTimeBetweenEvictionRunsMillis(<span class=\"number\">200000L</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//放弃长时间占用连接的对象</span></span><br><span class=\"line\">       AbandonedConfig abandonedConfig=<span class=\"keyword\">new</span> AbandonedConfig();</span><br><span class=\"line\">       abandonedConfig.setLogAbandoned(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">       abandonedConfig.setUseUsageTracking(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">       abandonedConfig.setRemoveAbandonedOnBorrow(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">       abandonedConfig.setRemoveAbandonedOnMaintenance(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">       abandonedConfig.setRemoveAbandonedTimeout(<span class=\"number\">20</span>);<span class=\"comment\">//second</span></span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>大家对连接池的概念应该都很熟悉了，<a href=\"https://commons.apache.org/proper/commons-pool/\" target=\"_blank\" rel=\"noopener\">apache commons-pool</a>是apache基金会的一个开源对象池组件，我们常用的数据库连接池dpcp和redis的java客户端jedis都使用commons-pool来管理连接。现在我们通过阅读commons-pool的部分代码来看一看他们在编写连接池组件时采用了什么样的设计思路和技术。</p>\n<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><p>首先我们思考一下，连接池除应该具备哪些功能？</p>\n<ol>\n<li>连接池要能够管理不同类型的对象，同时作为一个服务组件不需要关心每种连接的创建细节。</li>\n<li>连接池中的连接当长时间空闲时可能会被服务端主动关闭，或者受网络影响断开，连接池要能够定时检查它的连接是否可用。</li>\n<li>支持并发操作,每个线程各种持有连接互不影响。</li>\n</ol>\n<p>带着这三个问题，下面我们一起看一下commons-pool的代码,<br>它主要提供这个几种类型的对象池：<br>","more":"<br><img src=\"/images/commonspool.gif\" alt=\"\"><br>从左至右看，SoftReferenceObjectPool是不用指定容量的对象池，ProxiedObject是使用代理模式来创建对象池的对象，在这篇文章主要介绍GenericObjectPool的实现。</p>\n<h2 id=\"封装对象\"><a href=\"#封装对象\" class=\"headerlink\" title=\"封装对象\"></a>封装对象</h2><p>commons-pool定义了一个接口PooledObject来封装池中的对象，添加了空闲时间，使用时间等信息和对象状态流转的行为。<br>Pooledbject的状态有这几种：<br>|    状态     |    说明  |<br>| ——–   | —–  |<br>| IDLE     | 空闲 |<br>|ALLOCATED  |   使用中<br>|INVALID |不可用 即将/已经被销毁<br>|ABANDONED |被遗弃<br>|RETURNING |返回对象池<br>|EVICTION|  在队列中 正在被检查<br>|EVICTION_RETURN_TO_HEAD| 检查结束要放回队列头部<br>|VALIDATION| 在队列中 正在被检查<br>|VALIDATION_PREALLOCATED |验证结束要被分配<br>|VALIDATION_RETURN_TO_HEAD| 检查结束要放回队列头部</p>\n<p>表格中以RETURN_TO_HEAD结尾的状态是在当前的检查操作和对象借出操作同时进行时出现的，在检查结束后为了尽量保证借出成功这个对象要放回队头。<br>在我们不需要自定义对象行为的情况下可以直接使用PooledObject的默认实现DefaultPooledObject，主要代码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> createTime = System.currentTimeMillis();</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">long</span> lastBorrowTime = createTime;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">long</span> lastUseTime = createTime;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">long</span> lastReturnTime = createTime;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">long</span> borrowedCount = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">boolean</span> <span class=\"title\">allocate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (state == PooledObjectState.IDLE) &#123;</span><br><span class=\"line\">            state = PooledObjectState.ALLOCATED;</span><br><span class=\"line\">            lastBorrowTime = System.currentTimeMillis();</span><br><span class=\"line\">            lastUseTime = lastBorrowTime;</span><br><span class=\"line\">            borrowedCount++;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (logAbandoned) &#123;</span><br><span class=\"line\">                borrowedBy = <span class=\"keyword\">new</span> AbandonedObjectCreatedException();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (state == PooledObjectState.EVICTION) &#123;</span><br><span class=\"line\">            state = PooledObjectState.EVICTION_RETURN_TO_HEAD;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>allocate() 定义了对象分配时的状态变化，当对象在空闲状态时才能被分配；如果对象正在做驱逐检查时,会把这个对象标记为EVICTION_RETURN_TO_HEAD.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"comment\">//返回值：对象是否当前未被使用</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">boolean</span> <span class=\"title\">endEvictionTest</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            Deque&lt;PooledObject&lt;T&gt;&gt; idleQueue)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (state == PooledObjectState.EVICTION) &#123;</span><br><span class=\"line\">            state = PooledObjectState.IDLE;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (state == PooledObjectState.EVICTION_RETURN_TO_HEAD) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//如果状态是EVICTION_RETURN_TO_HEAD表示当前这个对象试图被借出，返回false.</span></span><br><span class=\"line\">            state = PooledObjectState.IDLE;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!idleQueue.offerFirst(<span class=\"keyword\">this</span>)) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// TODO - Should never happen</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>endEvictionTest()定义了驱逐检查之后对象状态的变化，可以看到EVICTION_RETURN_TO_HEAD状态的对象被放到空闲队列队头。</p>\n<p>allocate()和borrowedCount等使用synchronized，violatile都做了线程安全的处理。</p>\n<h2 id=\"定义对象工厂\"><a href=\"#定义对象工厂\" class=\"headerlink\" title=\"定义对象工厂\"></a>定义对象工厂</h2><p>commons-pool为了管理多种对象使用工厂模式来创建要管理的对象，使用工厂方法后使用者可以通过重写PooledObjectFactory定义对象的实现，销毁，验证的具体实现，而commons-pool不需要关心这些细节它只管理PooledObject对象即可。</p>\n<p>工厂接口：PooledObjectFactory<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">PooledObjectFactory</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"function\">PooledObject&lt;T&gt; <span class=\"title\">makeObject</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">destroyObject</span><span class=\"params\">(PooledObject&lt;T&gt; p)</span> <span class=\"keyword\">throws</span> Exception</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">validateObject</span><span class=\"params\">(PooledObject&lt;T&gt; p)</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">activateObject</span><span class=\"params\">(PooledObject&lt;T&gt; p)</span> <span class=\"keyword\">throws</span> Exception</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">passivateObject</span><span class=\"params\">(PooledObject&lt;T&gt; p)</span> <span class=\"keyword\">throws</span> Exception</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>工厂抽象类：BasePooledObjectFactory<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BasePooledObjectFactory</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">PooledObjectFactory</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">...</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> T <span class=\"title\">create</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> PooledObject&lt;T&gt; <span class=\"title\">wrap</span><span class=\"params\">(T obj)</span></span>;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> PooledObject&lt;T&gt; <span class=\"title\">makeObject</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> wrap(create());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">validateObject</span><span class=\"params\">(PooledObject&lt;T&gt; p)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>BasePooledObjectFactory添加了create,wrap两个抽象方法，create可以返回我们要放在连接池的对象，然后使用wrap封装为PooledObject即可，注意validateObject默认返回true;</p>\n<h2 id=\"对象池定义\"><a href=\"#对象池定义\" class=\"headerlink\" title=\"对象池定义\"></a>对象池定义</h2><p>对象池是我们保存对象的地方，对象的获取，归还和定时检查都通过对象池来实现。以GenericObjectPool为例，对象池使用了线程安全的集合类来保存对象，LinkedBlockingDeque用于保存空闲的对象，ConcurrentHashMap保存全部对象（包括各种状态）。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> LinkedBlockingDeque&lt;PooledObject&lt;T&gt;&gt; idleObjects = <span class=\"keyword\">new</span> LinkedBlockingDeque&lt;PooledObject&lt;T&gt;&gt;();</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;T, PooledObject&lt;T&gt;&gt; allObjects = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;T, PooledObject&lt;T&gt;&gt;();</span><br></pre></td></tr></table></figure></p>\n<p>borrowObject()从连接池获取对象：<br>连接池借出对象时，经过Abandoned和validate两种检查，在连接池满时根据配置执行对应的等待策略，当没有可用对象时会抛出异常。</p>\n<p>Abandoned检查目标是连接池所有被借出的对象，主要防止对象借出之后长时间被占用，不能退还（或者使用者忘记return）到连接池导致连接被耗尽。超时时间由AbandonedConfig定义。</p>\n<p>validate检查目标是当前即将被借出的对象，目的是保证提供的对象是可用的，检查方式由对象工厂的validateObject方法定义。对象工厂还有activateObject方法来验证对象，不过这个方法是强制执行的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">borrowObject</span><span class=\"params\">(<span class=\"keyword\">long</span> borrowMaxWaitMillis)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">// getNumIdle() 表示当前空空闲对象数量，getNumActive() 表示当前非空闲的对象数量，getMaxTotal()表示连接池容量</span></span><br><span class=\"line\"><span class=\"comment\">// 那么假设最大容量10个，非空闲8个 &gt; 7 ，空闲对象只要少于2个，就需要开始Abandoned检查</span></span><br><span class=\"line\"></span><br><span class=\"line\">        AbandonedConfig ac = <span class=\"keyword\">this</span>.abandonedConfig;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ac != <span class=\"keyword\">null</span> &amp;&amp; ac.getRemoveAbandonedOnBorrow() &amp;&amp;</span><br><span class=\"line\">                (getNumIdle() &lt; <span class=\"number\">2</span>) &amp;&amp;</span><br><span class=\"line\">                (getNumActive() &gt; getMaxTotal() - <span class=\"number\">3</span>) ) &#123;</span><br><span class=\"line\">            removeAbandoned(ac);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        PooledObject&lt;T&gt; p = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//拷贝了变量 blockWhenExhausted</span></span><br><span class=\"line\">        <span class=\"comment\">//因为blockWhenExhausted的修改方法是public的，这样保证在并发情况下，方法执行周期内变量也不会变化</span></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> blockWhenExhausted = getBlockWhenExhausted();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> create;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> waitTime = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (p == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            create = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 设置了对象池耗尽时等待</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (blockWhenExhausted) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//从空闲队列取对象</span></span><br><span class=\"line\">                p = idleObjects.pollFirst();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//没有空闲对象 新建一个</span></span><br><span class=\"line\">                    create = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                    p = create();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (borrowMaxWaitMillis &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">//注意：没配置等待时间，会一直阻塞</span></span><br><span class=\"line\">                        p = idleObjects.takeFirst();</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"comment\">//按照配置的时间等待</span></span><br><span class=\"line\">.....</span><br><span class=\"line\">                        p = idleObjects.pollFirst(borrowMaxWaitMillis,</span><br><span class=\"line\">                                TimeUnit.MILLISECONDS);</span><br><span class=\"line\">.....</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                 <span class=\"comment\">//等待之后还是没有空闲对象</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NoSuchElementException(</span><br><span class=\"line\">                            <span class=\"string\">\"Timeout waiting for idle object\"</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                 <span class=\"comment\">//等待之后获得对象 尝试分配对象</span></span><br><span class=\"line\">                 <span class=\"comment\">//这个方法由pooledobject实现</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!p.allocate()) &#123;</span><br><span class=\"line\">                    p = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">//没有配置blockWhenExhausted 不等待</span></span><br><span class=\"line\">                p = idleObjects.pollFirst();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    create = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                    p = create();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NoSuchElementException(<span class=\"string\">\"Pool exhausted\"</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!p.allocate()) &#123;</span><br><span class=\"line\">                    p = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//对象分配成功</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                   <span class=\"comment\">//激活对象</span></span><br><span class=\"line\">                    factory.activateObject(p);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        destroy(p);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (Exception e1) &#123;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    p = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    .....</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">//如果配置了对象检查</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p != <span class=\"keyword\">null</span> &amp;&amp; (getTestOnBorrow() || create &amp;&amp; getTestOnCreate())) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">boolean</span> validate = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                    Throwable validationThrowable = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        validate = factory.validateObject(p);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">                        PoolUtils.checkRethrow(t);</span><br><span class=\"line\">                        validationThrowable = t;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (!validate) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//验证失败 销毁对象</span></span><br><span class=\"line\">                        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                            destroy(p);</span><br><span class=\"line\">                         destroyedByBorrowValidationCount.incrementAndGet();</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        p = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                        .....</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//更新借出时间等信息</span></span><br><span class=\"line\">        updateStatsBorrow(p, waitTime);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> p.getObject();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>evict()驱逐对象：</p>\n<p>evict驱逐检查：上面介绍了两种对象的检查方式，evictor不同之处在于它由后台线程独立来完成，检查对象主要是连接池中的空闲连接，超时时间等可通过EvictionConfig配置。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">evict</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//确保连接池打开</span></span><br><span class=\"line\">        assertOpen();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (idleObjects.size() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            PooledObject&lt;T&gt; underTest = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            </span><br><span class=\"line\">            EvictionPolicy&lt;T&gt; evictionPolicy = getEvictionPolicy();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (evictionLock) &#123;</span><br><span class=\"line\">                ...</span><br><span class=\"line\">                <span class=\"comment\">// 复制变量保证函数内值不改变，同上</span></span><br><span class=\"line\">                <span class=\"keyword\">boolean</span> testWhileIdle = getTestWhileIdle();</span><br><span class=\"line\">                <span class=\"comment\">//每次驱逐对象数可配置</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, m = getNumTests(); i &lt; m; i++) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (evictionIterator == <span class=\"keyword\">null</span> || !evictionIterator.hasNext()) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">//驱逐检查的顺序和空闲队列出入顺序保持一致 </span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (getLifo()) &#123;</span><br><span class=\"line\">                            <span class=\"comment\">//后进先出(逆序遍历)</span></span><br><span class=\"line\">                            evictionIterator = idleObjects.descendingIterator();</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                            <span class=\"comment\">//先进先出</span></span><br><span class=\"line\">                            evictionIterator = idleObjects.iterator();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (!evictionIterator.hasNext()) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// Pool exhausted, nothing to do here</span></span><br><span class=\"line\">                        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        underTest = evictionIterator.next();</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (NoSuchElementException nsee) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">//因为idleObjects.iterator()方法并没有做同步控制，可能被检查的空闲对象再检查期间已经被借出不在队列中了，在并发条件下要考虑这种情况。。</span></span><br><span class=\"line\">                        <span class=\"comment\">// Object was borrowed in another thread</span></span><br><span class=\"line\">                        <span class=\"comment\">// Don't count this as an eviction test so reduce i;</span></span><br><span class=\"line\">                        i--;</span><br><span class=\"line\">                        evictionIterator = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"comment\">//再次检查，对象在队列中但是要保证状态是空闲。。。</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (!underTest.startEvictionTest()) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// Object was borrowed in another thread</span></span><br><span class=\"line\">                        <span class=\"comment\">// Don't count this as an eviction test so reduce i;</span></span><br><span class=\"line\">                        i--;</span><br><span class=\"line\">                        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"comment\">//EvictionPolicy定义了驱逐对象的策略，默认实现是DefaultEvictionPolicy</span></span><br><span class=\"line\">                    <span class=\"comment\">//调用ObjectPool的setEvictionPolicyClassName方法指定自定义策略</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (evictionPolicy.evict(evictionConfig, underTest,</span><br><span class=\"line\">                            idleObjects.size())) &#123;</span><br><span class=\"line\">                        destroy(underTest);</span><br><span class=\"line\">                        destroyedByEvictorCount.incrementAndGet();</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (testWhileIdle) &#123;</span><br><span class=\"line\">                            ...</span><br><span class=\"line\">                            <span class=\"comment\">//执行activateObject&amp;validateObject的检查</span></span><br><span class=\"line\">                            ...</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        ...</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//无处不在的Abandoned检查，可以配置连接池是否在evictor线程中执行removeAbandoned</span></span><br><span class=\"line\">        AbandonedConfig ac = <span class=\"keyword\">this</span>.abandonedConfig;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ac != <span class=\"keyword\">null</span> &amp;&amp; ac.getRemoveAbandonedOnMaintenance()) &#123;</span><br><span class=\"line\">            removeAbandoned(ac);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>驱逐线程的调用：<br>了解驱逐对象时要做的操作之后，我们来看一下后台的驱逐者线程是怎么定义&amp;启动的<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//GenericObjectPool.java</span></span><br><span class=\"line\"><span class=\"comment\">//构造方法中启动驱逐者线程</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">GenericObjectPool</span><span class=\"params\">(PooledObjectFactory&lt;T&gt; factory,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            GenericObjectPoolConfig config)</span> </span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        startEvictor(getTimeBetweenEvictionRunsMillis());</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>驱逐线程的定义：<br>驱逐者Evictor,在BaseGenericObjectPool中定义，本质是由java.util.TimerTask定义的定时任务<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//父类BaseGenericObjectPool.java</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">startEvictor</span><span class=\"params\">(<span class=\"keyword\">long</span> delay)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//BaseGenericObjectPool的私有成员，final Object evictionLock = new Object();做对象锁</span></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (evictionLock) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> != evictor) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//已存在evictor，取消驱逐者线程，所以也可以二次调用startEvictor来停止驱逐检查</span></span><br><span class=\"line\">                EvictionTimer.cancel(evictor);</span><br><span class=\"line\">                evictor = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                evictionIterator = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (delay &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                evictor = <span class=\"keyword\">new</span> Evictor();</span><br><span class=\"line\">                EvictionTimer.schedule(evictor, delay, delay);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>Evitor定义：这里有一个比较有意思的问题，驱逐者线程Evictor被多个连接池共享,但是这些连接池可能属于不同的classloader,Evictor必须要保证它的所有行为在<strong>当前这个连接池的classloader</strong>下执行（这是开发者给commons-pool提交的bug,<a href=\"https://issues.apache.org/jira/browse/POOL-161\" target=\"_blank\" rel=\"noopener\">详细描述请看这里</a>）<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//内部类Evictor</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Evictor</span> <span class=\"keyword\">extends</span> <span class=\"title\">TimerTask</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            ClassLoader savedClassLoader =</span><br><span class=\"line\">                    Thread.currentThread().getContextClassLoader();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 切换到当前连接池的classLoader</span></span><br><span class=\"line\">                Thread.currentThread().setContextClassLoader(</span><br><span class=\"line\">                        factoryClassLoader);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 执行上面的evict()方法</span></span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    evict();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span>(Exception e) &#123;</span><br><span class=\"line\">                    swallowException(e);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span>(OutOfMemoryError oome) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// Log problem but give evictor thread a chance to continue</span></span><br><span class=\"line\">                    <span class=\"comment\">// in case error is recoverable</span></span><br><span class=\"line\">                    oome.printStackTrace(System.err);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 驱逐之后还要保证空闲连接数量不能小于配置</span></span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    ensureMinIdle();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                    swallowException(e);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 切换回之前的classLoader</span></span><br><span class=\"line\">                Thread.currentThread().setContextClassLoader(savedClassLoader);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>驱逐策略：<br>在evict()方法中最后对象是否要被驱逐是调用了evictionPolicy.evict()的方法来判断的，commons-pool提供的驱逐策略如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//DefaultEvictionPolicy.java</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DefaultEvictionPolicy</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">EvictionPolicy</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">evict</span><span class=\"params\">(EvictionConfig config, PooledObject&lt;T&gt; underTest,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">int</span> idleCount)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//getIdleTimeMillis()空闲时间</span></span><br><span class=\"line\">        <span class=\"comment\">//config.getIdleSoftEvictTime()空闲连接大于配置的最小值时的超时时间</span></span><br><span class=\"line\">        <span class=\"comment\">//config.getIdleEvictTime()空闲连接超时时间与数量无关</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((config.getIdleSoftEvictTime() &lt; underTest.getIdleTimeMillis() &amp;&amp;</span><br><span class=\"line\">                config.getMinIdle() &lt; idleCount) ||</span><br><span class=\"line\">                config.getIdleEvictTime() &lt; underTest.getIdleTimeMillis()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>驱逐策略是支持自定义的，这里使用的是设计模式中的策略模式，我们只要实现EvictionPolicy接口，然后调用setEvictionPolicyClassName()方法既可以更换驱逐策略（实现类要尽可能简单，只描述一种算法即可）：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//父类BaseGenericObjectPool.java</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">setEvictionPolicyClassName</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            String evictionPolicyClassName)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//使用接口+反射实现的策略模式</span></span><br><span class=\"line\">            Class&lt;?&gt; clazz = Class.forName(evictionPolicyClassName);</span><br><span class=\"line\">            Object policy = clazz.newInstance();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (policy <span class=\"keyword\">instanceof</span> EvictionPolicy&lt;?&gt;) &#123;</span><br><span class=\"line\">                <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>) </span><br><span class=\"line\">                EvictionPolicy&lt;T&gt; evicPolicy = (EvictionPolicy&lt;T&gt;) policy;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.evictionPolicy = evicPolicy;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException e) &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InstantiationException e) &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IllegalAccessException e) &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>通过阅读GenericObjectPool的部分代码，可以看出来并没有在每个获取&amp;退还对象的方法都做同步控制，线程安全主要是由LinkedBlockingDeque，ConcurrentHashMap这两个并发集合保证的，因此开发者在编写非线程安全方法时也使用了局部变量复制可能被修改的值，多次检查对象状态之类的方法保证并发条件下程序正常的执行（没全部加锁能够提升性能，不过也会有这样的麻烦）。<br>总结一下连接池中对象的声明周期大概如下图：<br><img src=\"/images/commonspoolflow.png\" alt=\"\"><br>蓝色线是evictor执行时对象状态的变化，红线是abandon执行的过程，绿色线是正常使用中对象的变化。</p>\n<h2 id=\"其他功能\"><a href=\"#其他功能\" class=\"headerlink\" title=\"其他功能\"></a>其他功能</h2><p>附上一份objectpool的配置选项<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GenericObjectPoolConfig poolConfig = <span class=\"keyword\">new</span> GenericObjectPoolConfig();</span><br><span class=\"line\"></span><br><span class=\"line\">基本配置：</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//最大连接</span></span><br><span class=\"line\">        poolConfig.setMaxTotal(<span class=\"number\">100</span>);</span><br><span class=\"line\">        <span class=\"comment\">//最大空闲连接</span></span><br><span class=\"line\">        poolConfig.setMaxIdle(<span class=\"number\">5</span>);</span><br><span class=\"line\">        <span class=\"comment\">//最小空闲连接 </span></span><br><span class=\"line\">        poolConfig.setMinIdle(<span class=\"number\">5</span>);</span><br><span class=\"line\">        <span class=\"comment\">//连接满时最多等待时间</span></span><br><span class=\"line\">        poolConfig.setMaxWaitMillis(<span class=\"number\">5000L</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">高级功能：</span><br><span class=\"line\">         <span class=\"comment\">//使用时检查对象（默认不检查）</span></span><br><span class=\"line\">        poolConfig.setTestWhileIdle(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        poolConfig.setTestOnCreate(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        poolConfig.setTestOnBorrow(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        poolConfig.setTestOnReturn(<span class=\"keyword\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//jmx启用 之后可以实时的查看线程池对象的状态</span></span><br><span class=\"line\">        poolConfig.setJmxEnabled(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">        poolConfig.setJmxNameBase(<span class=\"string\">\"namebase\"</span>);</span><br><span class=\"line\">        poolConfig.setJmxNamePrefix(<span class=\"string\">\"nameprefix\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"comment\">//驱逐线程每次检查对象个数</span></span><br><span class=\"line\">        poolConfig.setNumTestsPerEvictionRun(<span class=\"number\">2</span>);</span><br><span class=\"line\">        <span class=\"comment\">//空闲连接被驱逐前能够保留的时间</span></span><br><span class=\"line\">        poolConfig.setMinEvictableIdleTimeMillis(<span class=\"number\">10000L</span>);</span><br><span class=\"line\">        <span class=\"comment\">//当空闲线程大于minIdle 空闲连接能够保留时间，同时指定会被上面的覆盖</span></span><br><span class=\"line\">        poolConfig.setSoftMinEvictableIdleTimeMillis(<span class=\"number\">10000L</span>);</span><br><span class=\"line\">        <span class=\"comment\">//驱逐线程执行间隔时间</span></span><br><span class=\"line\">        poolConfig.setTimeBetweenEvictionRunsMillis(<span class=\"number\">200000L</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//放弃长时间占用连接的对象</span></span><br><span class=\"line\">       AbandonedConfig abandonedConfig=<span class=\"keyword\">new</span> AbandonedConfig();</span><br><span class=\"line\">       abandonedConfig.setLogAbandoned(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">       abandonedConfig.setUseUsageTracking(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">       abandonedConfig.setRemoveAbandonedOnBorrow(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">       abandonedConfig.setRemoveAbandonedOnMaintenance(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">       abandonedConfig.setRemoveAbandonedTimeout(<span class=\"number\">20</span>);<span class=\"comment\">//second</span></span><br></pre></td></tr></table></figure></p>"},{"title":"thrift源码（二）异步客户端","date":"2019-08-05T15:28:22.000Z","_content":"## 异步客户端简介\n异步客户端使用java nio实现，和许多NIO的例子相同，启动一个线程执行select()操作，然后把获得的SocketChannel交给统一的handler处理。\n异步客户端初始化并发起请求的调用栈如下：\n```java\n//初始化\nHelloServiceClient.main()\n= TAsyncClientManager.TAsyncClientManager()\n\n= = TAsyncClientManager.SelectThread.run()\n= = TAsyncClientManager.SelectThread.transitionMethods()\n= = = TAsyncMethodCall.transition()\n= = TAsyncClientManager.SelectThread.timeoutIdleMethods()\n= = TAsyncClientManager.SelectThread.startPendingMethods()\n= = = TAsyncMethodCall.start()\n//发起调用\n= HelloService.AsyncClient.helloVoid()\n= = TAsyncClientManager.call()\n= = = TAsyncMethodCall.prepareMethodCall()\n= = = = HelloService.AsyncClient.helloVoid_call.write_args()\n= = = TAsyncClientManager.SelectThread.getSelector().wakeup()\n= = = TAsyncMethodCall.start()\n= = = TAsyncMethodCall#registerForFirstWrite\n= = = TAsyncMethodCall#doWritingRequestSize\n= = = TAsyncMethodCall#doWritingRequestBody\n= = = TAsyncMethodCall#doReadingResponseSize\n= = = TAsyncMethodCall#doReadingResponseBody\n```\n<!--more-->\n\n## 主要组件\n### TAsyncClientManager\n管理方法调用，请求的IO状态过渡,超时管理等，持有一个Selector线程\n```java\n  //selector线程\n  private final SelectThread selectThread;\n  //保存请求的队列\n  private final ConcurrentLinkedQueue<TAsyncMethodCall> pendingCalls = new ConcurrentLinkedQueue<TAsyncMethodCall>();\n\n  public TAsyncClientManager() throws IOException {\n    this.selectThread = new SelectThread();\n    selectThread.start();\n  }\n\n```\n\n ### SelectThread\n\n SelectThread是TAsyncClientManager的内部类，继承了Thread,使用了java提供的nio包的selector\n\n```java\nprivate class SelectThread extends Thread {\n    // Selector waits at most SELECT_TIME milliseconds before waking\n    private static final long SELECT_TIME = 5;\n    \n    private final Selector selector;\n    // 线程共享的变量\n    private volatile boolean running;\n    // 用来管理超时\n    private final Set<TAsyncMethodCall> timeoutWatchSet = new HashSet<TAsyncMethodCall>();\n    //核心方法，调用select监听IO事件，然后依次执行处理方法\n    public void run() {\n      while (running) {\n        try {\n          try {\n            selector.select(SELECT_TIME);\n          } catch (IOException e) {\n            LOGGER.error(\"Caught IOException in TAsyncClientManager!\", e);\n          }\n          //触发TAsyncMethodCall状态机的状态变化，状态机会按照状态执行操作\n          transitionMethods();\n          //遍历timeoutWatchSet中的请求，让超时调用返回异常\n          timeoutIdleMethods();\n          //从pendingCalls队列中取出全部的新请求并处理\n          startPendingMethods();\n        } catch (Throwable throwable) {\n          LOGGER.error(\"Ignoring uncaught exception in SelectThread\", throwable);\n        }\n      }\n    }\n```\n#### startPendingMethods() \n从pendingCalls队列中取出全部的新请求并处理：\n```java\n// Start any new calls\n    private void startPendingMethods() {\n      TAsyncMethodCall methodCall;\n      while ((methodCall = pendingCalls.poll()) != null) {\n        \n        try {\n          methodCall.start(selector);\n\n          // If timeout specified and first transition went smoothly, add to timeout watch set\n          TAsyncClient client = methodCall.getClient();\n          if (client.hasTimeout() && !client.hasError()) {\n            //放入超时检查set\n            timeoutWatchSet.add(methodCall);\n          }\n        } catch (Throwable e) {\n          LOGGER.warn(\"Caught throwable in TAsyncClientManager!\", e);\n          methodCall.onError(e);\n        }\n      }\n    }\n```\n#### timeoutIdleMethods() \n遍历timeoutWatchSet，检查超时的调用：\n```java\nprivate final Set<TAsyncMethodCall> timeoutWatchSet = new HashSet<TAsyncMethodCall>();\n// Timeout any existing method calls                                                \nprivate void timeoutIdleMethods() {                                                     \n  Iterator<TAsyncMethodCall> iterator = timeoutWatchSet.iterator();                     \n  while (iterator.hasNext()) {                                                          \n    TAsyncMethodCall methodCall = iterator.next();                                      \n    long clientTimeout = methodCall.getClient().getTimeout();                           \n    long timeElapsed = System.currentTimeMillis() - methodCall.getLastTransitionTime(); \n                                                                                        \n    if (timeElapsed > clientTimeout) {                                                  \n      iterator.remove();                                                                \n      methodCall.onError(new TimeoutException(\"Operation \" +                            \n          methodCall.getClass() + \" timed out after \" + timeElapsed +                   \n          \" milliseconds.\"));                                                           \n    }                                                                                   \n  }                                                                                     \n}                                                                                       \n```\n\n\n\n### TAsyncMethodCall\n抽象类，代表远程方法的异步调用，thrift生成的helloString_call的父类，持有callback调用，负责建立socket连接，写入TNonblockingTransport、构造ByteBuffer等，**对IO操作的切换通过状态机来完成**,重点关注transition()方法。\n```java\npublic abstract class TAsyncMethodCall<T extends TAsyncMethodCall> {\n\n  private static final int INITIAL_MEMORY_BUFFER_SIZE = 128;\n  //内部的状态机，一共7个状态\n  public static enum State {\n    CONNECTING,\n    WRITING_REQUEST_SIZE,\n    WRITING_REQUEST_BODY,\n    READING_RESPONSE_SIZE,\n    READING_RESPONSE_BODY,\n    RESPONSE_READ,\n    ERROR;\n  }\n  //Transport socket连接的封装\n  protected final TNonblockingTransport transport;\n  //负责序列化\n  private final TProtocolFactory protocolFactory;\n  //rpc client\n  protected final TAsyncClient client;\n  //回调方法\n  private final AsyncMethodCallback<T> callback;\n  //isOneway==true则不用回调\n  private final boolean isOneway;\n  //方法调用到达这个状态的时间，用来判断超时\n  private long lastTransitionTime;\n  //保存数据包的内容size\n  private ByteBuffer sizeBuffer;\n  private final byte[] sizeBufferArray = new byte[4];\n  //保存数据包内容\n  private ByteBuffer frameBuffer;\n \n  protected TAsyncMethodCall(TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport, AsyncMethodCallback<T> callback, boolean isOneway) {\n    this.transport = transport;\n    this.callback = callback;\n    this.protocolFactory = protocolFactory;\n    this.client = client;\n    this.isOneway = isOneway;\n    this.lastTransitionTime = System.currentTimeMillis();\n  }\n  //Transition方法，根据状态机状态执行对应的操作。\n  //这个方法是线程安全的，因为只在SelectThread内部执行\n  protected void transition(SelectionKey key) {\n    // Ensure key is valid\n    if (!key.isValid()) {\n      key.cancel();\n      Exception e = new TTransportException(\"Selection key not valid!\");\n      onError(e);\n      return;\n    }\n\n    // Transition function\n    try {\n      switch (state) {\n        case CONNECTING:\n          doConnecting(key);\n          break;\n        case WRITING_REQUEST_SIZE:\n          doWritingRequestSize();\n          break;\n        case WRITING_REQUEST_BODY:\n          doWritingRequestBody(key);\n          break;\n        case READING_RESPONSE_SIZE:\n          doReadingResponseSize();\n          break;\n        case READING_RESPONSE_BODY:\n          doReadingResponseBody(key);\n          break;\n        default: // RESPONSE_READ, ERROR, or bug\n          throw new IllegalStateException(\"Method call in state \" + state\n              + \" but selector called transition method. Seems like a bug...\");\n      }\n      lastTransitionTime = System.currentTimeMillis();\n    } catch (Throwable e) {\n      key.cancel();\n      key.attach(null);\n      onError(e);\n    }\n  }\n```\n#### start()\n在TAsyncMethodCall的start()方法中**有一个优化处理**：一般当socket连接未建立时，会向selector注册连接事件的监听。但是**因为非阻塞socket的CONNECT操作可以立刻完成(不会一直阻塞，当连接不能立即完成时，connect返回EINPROGRESS，之后select会再判断描述符是否可写)**，所以添加了对startConnect()返回值的检查，如果return true那么就去注册读事件。\n```java\nvoid start(Selector sel) throws IOException {\n    SelectionKey key;\n    if (transport.isOpen()) {\n      state = State.WRITING_REQUEST_SIZE;\n      key = transport.registerSelector(sel, SelectionKey.OP_WRITE);\n    } else {\n      state = State.CONNECTING;\n      key = transport.registerSelector(sel, SelectionKey.OP_CONNECT);\n\n      // non-blocking connect can complete immediately,\n      // in which case we should not expect the OP_CONNECT\n      if (transport.startConnect()) {\n        registerForFirstWrite(key);\n      }\n    }\n\n    key.attach(this);\n  }\n```\n\n## 初始化的时序图\n{% asset_img client-init.png image %}\n\n如图所示，首先HelloServiceClient创建TAsyncClientManger实例，然后SelectThread对象初始化，创建守护线程并启动。\n线程启动之后，执行SelectThread.run()方法的循环，selector开始监听I/O事件。\nselect()执行后，依次执行\ntransitionMethods();\ntimeoutIdleMethods();\nstartPendingMethods();\n这些方法分别会调用TAsyncMethodCall的transition(),onError(),start()方法。\n最右侧是TAsyncMethodCall中State状态机的状态图。当过渡到RESPONSE_READ状态后，本次调用的I/O操作完成。\n\n\n## 执行异步调用的时序图\n下面是异步客户端初始化并发起异步调用的代码，为了不让程序立即退出最后增加了sleep()方法。\n```java\nTAsyncClientManager clientManager = new TAsyncClientManager();\nTNonblockingTransport transport = new TNonblockingSocket(\"localhost\", 7911);\nTProtocolFactory protocol = new TBinaryProtocol.Factory();\nHelloService.AsyncClient asyncClient = new HelloService.AsyncClient(protocol, clientManager, transport);\nasyncClient.setTimeout(1500L);\nSystem.out.println(\"client async calls\");\nHelloStringCallback callback = new HelloStringCallback();\nasyncClient.helloString(\"baba\", callback);\n//等待触发回调\nThread.sleep(10000L);\n```\n处理异步调用结果的回调类HelloStringCallback代码如下：\n```java\npublic class HelloStringCallback implements AsyncMethodCallback<helloString_call> {\n\n    private String response = null;\n\n    HelloStringCallback() {\n        super();\n        System.out.println(\"init Thread ID=\" + Thread.currentThread().getId());\n    }\n\n    @Override\n    public void onComplete(helloString_call response) {\n        try {\n            System.out.println(\"onComplete Thread ID=\" + Thread.currentThread().getId());\n            //调用helloString_call的getResult方法\n            System.out.println(\"msg:\" + response.getResult());\n        } catch (TException e) {\n            e.printStackTrace();\n        }\n    }\n\n    @Override\n    public void onError(Throwable throwable) {\n        System.out.println(\"onError:\");\n        throwable.printStackTrace();\n    }\n}\n\n```\n下面的时序图展示了客户端调用异步方法时，thrift内部组件的工作流程。\n\n\n**步骤1～3** 首先使用thrift为HelloService生成的AsyncClient对象，**checkReady()** 检查当前是否正在执行HelloService的方法，**一个时刻同一个Service只能执行一个方法**，然后创建thrift生成的helloString_call对象(TAsyncMethodCall的子类)，最后调用TAsyncClientManager.call(TAsyncMethodCall method)。\n\n**步骤3.1~3.1.4** TAsyncClientManager创建一个临时TProtocol对象，调用helloString_call的write_args方法，得到这次调用的方法名，参数等信息的序列化内容填充到frameBuffer中，然后根据序列化内容的长度初始化对应大小的sizeBuffer。\n\n**步骤3.2~3.3.2** SelectThread重新执行select(),并调用TAsyncMethodCall.start()方法，将这次调用的socket连接注册到selector上，图中灰色框是SelectThread线程的内部循环，橙色框是对套接字transport是否建立连接的判断(**实际上SelectThread和TAsyncClientManager不在一个线程内工作**，这里只是描述大概的执行顺序，SelectThread的内部细节在上面的初始化时序图中)\n\n**步骤3.4~3.4.6.2** SelectThread调用TAsyncMethodCall.transition()方法，TAsyncMethodCall根据状态机的状态执行操作，这里展示一次调用的正常顺序(没有包含异常的情况)。\n\n3.4.1~3.4.5是建立连接，发送请求包size,请求包内容，接收响应包size，响应包内容 **(注意除了size相关的方法，都需要SelectionKey做参数，因为这次操作需要修改selector上注册的事件)**。\n\n3.4.6 当响应接收完成，执行cleanUpAndFireCallback()方法，先是调用HelloService.AsyncClient的onComplete()方法，让它能去处理下一个HelloService的异步调用，然后调用我们定义的回调函数HelloStringCallback.onComplete(helloString_call response)方法(这也是在SelectThread内完成的)。\n\n{% asset_img thrift-client-call.png image %}\n\n**在调用中selector上注册事件的变化**\n\n向selector注册事件的顺序全部由TAsyncMethodCall来完成，左侧是注册的事件，右侧会注册这个事件的函数：\n当通信完成注册0清空事件\n|事件| 状态机 | 函数 |\n| --- |---|--- |\n|OP_CONNECT |State.CONNECTING  |  start() |\n|OP_WRITE|State.WRITING_REQUEST_SIZE或State.CONNECTING|start()或doConnecting()|\n|OP_READ|State.READING_RESPONSE_SIZE|doWritingRequestBody()|\n|0|State.RESPONSE_READ|cleanUpAndFireCallback()|\n#### 对比同步客户端\n**同步客户端的使用方式**\n\n对于同一个Service,同一时间只能执行一个Service中的方法。需要开发者确保Client不会被多个线程调用，因为同步客户端的**Client对象不是线程安全的。一般都会创建Client的对象池，每次调用从对象池中获得一个Client**。\n每次发起调用seqid都会+1，然后在调用完成后检查收到的seqid和发起时一致。\n\n**异步客户端内的使用方式**\n\n**必须使用非阻塞服务端**,在我的测试中，使用同步的服务端&异步客户端会遇到readMessageBegin()操作阻塞的问题。\n在执行`int size = readI32();`时，同步服务端获得size是**整个请求包的size**,并不是TMessage第一个构造参数name的size,所以readStringBody会读取整个请求包，之后的readByte()和readI32()已经没有数据可读，就会阻塞（**到底为什么呢**）。\n```java\npublic TMessage readMessageBegin() throws TException {\n        int size = readI32();\n        if (size < 0) {\n            int version = size & VERSION_MASK;\n            if (version != VERSION_1) {\n                throw new TProtocolException(TProtocolException.BAD_VERSION, \"Bad version in readMessageBegin\");\n            }\n            return new TMessage(readString(), (byte) (size & 0x000000ff), readI32());\n        } else {\n        //使用同步服务端时，执行这部分阻塞\n            if (strictRead_) {\n                throw new TProtocolException(TProtocolException.BAD_VERSION, \"Missing version in readMessageBegin, old client?\");\n            }\n            return new TMessage(readStringBody(size), readByte(), readI32());\n        }\n    }\n```\n\nAsyncClient也不是线程安全的，甚至**即使同一个线程在一个循环中多次调用一个方法**也会出现异常，比如：\n```\n                for(int i=3;i>0;i--) {\n                    HelloStringCallback callback = new HelloStringCallback();\n                    asyncClient.helloString(\"baba\", callback);\n                }\n                //等待触发回调\n                Thread.sleep(1000L);\n```\n会触发异常：\njava.nio.channels.ConnectionPendingException//连接正在进行\njava.nio.channels.ClosedChannelException//连接已关闭\n\n在上面的例子中，因为没有等上次调用返回就发起了新的调用，每次调用使用的socket连接相同，因此对socket连接的操作产生了冲突，实际上**checkReady()并没有起到作用**，在这个版本的源码中TAsyncClient.**currentMethod字段一直是null**。所以使用异步客户端时**发起一次调用就需要创建一个AsyncClient**，使用新的socket，一般是使用Client的对象池。\n没卵用的checkReady():\n```java\nprotected void checkReady() {\n    // Ensure we are not currently executing a method\n    if (currentMethod != null) {\n      throw new IllegalStateException(\"Client is currently executing another method: \" + currentMethod.getClass().getName());\n    }\n\n    // Ensure we're not in an error state\n    if (error != null) {\n      throw new IllegalStateException(\"Client has an error!\", error);\n    }\n```\n**seqid在异步调用中没有变化**，一直是0：\n```java\n        prot.writeMessageBegin(new TMessage(\"helloString\", TMessageType.CALL, 0));\n```\n在同步客户端中，seqid会自增：\n```java\n        oprot_.writeMessageBegin(new TMessage(\"helloString\", TMessageType.CALL, ++seqid_));\n```\n\n**在接收调用结果时和同步客户端一样:**\n在helloString_call(extends TAsyncMethodCall)中可以看到getResult方法使用了同步客户端(创新了一个同步客户端实例，new Client(prot))的recv_helloString方法。\n```java\npublic String getResult() throws TException {\n                if (getState() != State.RESPONSE_READ) {\n                    throw new IllegalStateException(\"Method call not finished!\");\n                }\n                TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());\n                TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);\n                return (new Client(prot)).recv_helloString();\n            }\n```\n","source":"_posts/thrift源码（二）异步客户端.md","raw":"---\ntitle: thrift源码（二）异步客户端\ndate: 2019-08-05 23:28:22\ncategories: thrift源码\ntags: [thrift,rpc框架]\n---\n## 异步客户端简介\n异步客户端使用java nio实现，和许多NIO的例子相同，启动一个线程执行select()操作，然后把获得的SocketChannel交给统一的handler处理。\n异步客户端初始化并发起请求的调用栈如下：\n```java\n//初始化\nHelloServiceClient.main()\n= TAsyncClientManager.TAsyncClientManager()\n\n= = TAsyncClientManager.SelectThread.run()\n= = TAsyncClientManager.SelectThread.transitionMethods()\n= = = TAsyncMethodCall.transition()\n= = TAsyncClientManager.SelectThread.timeoutIdleMethods()\n= = TAsyncClientManager.SelectThread.startPendingMethods()\n= = = TAsyncMethodCall.start()\n//发起调用\n= HelloService.AsyncClient.helloVoid()\n= = TAsyncClientManager.call()\n= = = TAsyncMethodCall.prepareMethodCall()\n= = = = HelloService.AsyncClient.helloVoid_call.write_args()\n= = = TAsyncClientManager.SelectThread.getSelector().wakeup()\n= = = TAsyncMethodCall.start()\n= = = TAsyncMethodCall#registerForFirstWrite\n= = = TAsyncMethodCall#doWritingRequestSize\n= = = TAsyncMethodCall#doWritingRequestBody\n= = = TAsyncMethodCall#doReadingResponseSize\n= = = TAsyncMethodCall#doReadingResponseBody\n```\n<!--more-->\n\n## 主要组件\n### TAsyncClientManager\n管理方法调用，请求的IO状态过渡,超时管理等，持有一个Selector线程\n```java\n  //selector线程\n  private final SelectThread selectThread;\n  //保存请求的队列\n  private final ConcurrentLinkedQueue<TAsyncMethodCall> pendingCalls = new ConcurrentLinkedQueue<TAsyncMethodCall>();\n\n  public TAsyncClientManager() throws IOException {\n    this.selectThread = new SelectThread();\n    selectThread.start();\n  }\n\n```\n\n ### SelectThread\n\n SelectThread是TAsyncClientManager的内部类，继承了Thread,使用了java提供的nio包的selector\n\n```java\nprivate class SelectThread extends Thread {\n    // Selector waits at most SELECT_TIME milliseconds before waking\n    private static final long SELECT_TIME = 5;\n    \n    private final Selector selector;\n    // 线程共享的变量\n    private volatile boolean running;\n    // 用来管理超时\n    private final Set<TAsyncMethodCall> timeoutWatchSet = new HashSet<TAsyncMethodCall>();\n    //核心方法，调用select监听IO事件，然后依次执行处理方法\n    public void run() {\n      while (running) {\n        try {\n          try {\n            selector.select(SELECT_TIME);\n          } catch (IOException e) {\n            LOGGER.error(\"Caught IOException in TAsyncClientManager!\", e);\n          }\n          //触发TAsyncMethodCall状态机的状态变化，状态机会按照状态执行操作\n          transitionMethods();\n          //遍历timeoutWatchSet中的请求，让超时调用返回异常\n          timeoutIdleMethods();\n          //从pendingCalls队列中取出全部的新请求并处理\n          startPendingMethods();\n        } catch (Throwable throwable) {\n          LOGGER.error(\"Ignoring uncaught exception in SelectThread\", throwable);\n        }\n      }\n    }\n```\n#### startPendingMethods() \n从pendingCalls队列中取出全部的新请求并处理：\n```java\n// Start any new calls\n    private void startPendingMethods() {\n      TAsyncMethodCall methodCall;\n      while ((methodCall = pendingCalls.poll()) != null) {\n        \n        try {\n          methodCall.start(selector);\n\n          // If timeout specified and first transition went smoothly, add to timeout watch set\n          TAsyncClient client = methodCall.getClient();\n          if (client.hasTimeout() && !client.hasError()) {\n            //放入超时检查set\n            timeoutWatchSet.add(methodCall);\n          }\n        } catch (Throwable e) {\n          LOGGER.warn(\"Caught throwable in TAsyncClientManager!\", e);\n          methodCall.onError(e);\n        }\n      }\n    }\n```\n#### timeoutIdleMethods() \n遍历timeoutWatchSet，检查超时的调用：\n```java\nprivate final Set<TAsyncMethodCall> timeoutWatchSet = new HashSet<TAsyncMethodCall>();\n// Timeout any existing method calls                                                \nprivate void timeoutIdleMethods() {                                                     \n  Iterator<TAsyncMethodCall> iterator = timeoutWatchSet.iterator();                     \n  while (iterator.hasNext()) {                                                          \n    TAsyncMethodCall methodCall = iterator.next();                                      \n    long clientTimeout = methodCall.getClient().getTimeout();                           \n    long timeElapsed = System.currentTimeMillis() - methodCall.getLastTransitionTime(); \n                                                                                        \n    if (timeElapsed > clientTimeout) {                                                  \n      iterator.remove();                                                                \n      methodCall.onError(new TimeoutException(\"Operation \" +                            \n          methodCall.getClass() + \" timed out after \" + timeElapsed +                   \n          \" milliseconds.\"));                                                           \n    }                                                                                   \n  }                                                                                     \n}                                                                                       \n```\n\n\n\n### TAsyncMethodCall\n抽象类，代表远程方法的异步调用，thrift生成的helloString_call的父类，持有callback调用，负责建立socket连接，写入TNonblockingTransport、构造ByteBuffer等，**对IO操作的切换通过状态机来完成**,重点关注transition()方法。\n```java\npublic abstract class TAsyncMethodCall<T extends TAsyncMethodCall> {\n\n  private static final int INITIAL_MEMORY_BUFFER_SIZE = 128;\n  //内部的状态机，一共7个状态\n  public static enum State {\n    CONNECTING,\n    WRITING_REQUEST_SIZE,\n    WRITING_REQUEST_BODY,\n    READING_RESPONSE_SIZE,\n    READING_RESPONSE_BODY,\n    RESPONSE_READ,\n    ERROR;\n  }\n  //Transport socket连接的封装\n  protected final TNonblockingTransport transport;\n  //负责序列化\n  private final TProtocolFactory protocolFactory;\n  //rpc client\n  protected final TAsyncClient client;\n  //回调方法\n  private final AsyncMethodCallback<T> callback;\n  //isOneway==true则不用回调\n  private final boolean isOneway;\n  //方法调用到达这个状态的时间，用来判断超时\n  private long lastTransitionTime;\n  //保存数据包的内容size\n  private ByteBuffer sizeBuffer;\n  private final byte[] sizeBufferArray = new byte[4];\n  //保存数据包内容\n  private ByteBuffer frameBuffer;\n \n  protected TAsyncMethodCall(TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport, AsyncMethodCallback<T> callback, boolean isOneway) {\n    this.transport = transport;\n    this.callback = callback;\n    this.protocolFactory = protocolFactory;\n    this.client = client;\n    this.isOneway = isOneway;\n    this.lastTransitionTime = System.currentTimeMillis();\n  }\n  //Transition方法，根据状态机状态执行对应的操作。\n  //这个方法是线程安全的，因为只在SelectThread内部执行\n  protected void transition(SelectionKey key) {\n    // Ensure key is valid\n    if (!key.isValid()) {\n      key.cancel();\n      Exception e = new TTransportException(\"Selection key not valid!\");\n      onError(e);\n      return;\n    }\n\n    // Transition function\n    try {\n      switch (state) {\n        case CONNECTING:\n          doConnecting(key);\n          break;\n        case WRITING_REQUEST_SIZE:\n          doWritingRequestSize();\n          break;\n        case WRITING_REQUEST_BODY:\n          doWritingRequestBody(key);\n          break;\n        case READING_RESPONSE_SIZE:\n          doReadingResponseSize();\n          break;\n        case READING_RESPONSE_BODY:\n          doReadingResponseBody(key);\n          break;\n        default: // RESPONSE_READ, ERROR, or bug\n          throw new IllegalStateException(\"Method call in state \" + state\n              + \" but selector called transition method. Seems like a bug...\");\n      }\n      lastTransitionTime = System.currentTimeMillis();\n    } catch (Throwable e) {\n      key.cancel();\n      key.attach(null);\n      onError(e);\n    }\n  }\n```\n#### start()\n在TAsyncMethodCall的start()方法中**有一个优化处理**：一般当socket连接未建立时，会向selector注册连接事件的监听。但是**因为非阻塞socket的CONNECT操作可以立刻完成(不会一直阻塞，当连接不能立即完成时，connect返回EINPROGRESS，之后select会再判断描述符是否可写)**，所以添加了对startConnect()返回值的检查，如果return true那么就去注册读事件。\n```java\nvoid start(Selector sel) throws IOException {\n    SelectionKey key;\n    if (transport.isOpen()) {\n      state = State.WRITING_REQUEST_SIZE;\n      key = transport.registerSelector(sel, SelectionKey.OP_WRITE);\n    } else {\n      state = State.CONNECTING;\n      key = transport.registerSelector(sel, SelectionKey.OP_CONNECT);\n\n      // non-blocking connect can complete immediately,\n      // in which case we should not expect the OP_CONNECT\n      if (transport.startConnect()) {\n        registerForFirstWrite(key);\n      }\n    }\n\n    key.attach(this);\n  }\n```\n\n## 初始化的时序图\n{% asset_img client-init.png image %}\n\n如图所示，首先HelloServiceClient创建TAsyncClientManger实例，然后SelectThread对象初始化，创建守护线程并启动。\n线程启动之后，执行SelectThread.run()方法的循环，selector开始监听I/O事件。\nselect()执行后，依次执行\ntransitionMethods();\ntimeoutIdleMethods();\nstartPendingMethods();\n这些方法分别会调用TAsyncMethodCall的transition(),onError(),start()方法。\n最右侧是TAsyncMethodCall中State状态机的状态图。当过渡到RESPONSE_READ状态后，本次调用的I/O操作完成。\n\n\n## 执行异步调用的时序图\n下面是异步客户端初始化并发起异步调用的代码，为了不让程序立即退出最后增加了sleep()方法。\n```java\nTAsyncClientManager clientManager = new TAsyncClientManager();\nTNonblockingTransport transport = new TNonblockingSocket(\"localhost\", 7911);\nTProtocolFactory protocol = new TBinaryProtocol.Factory();\nHelloService.AsyncClient asyncClient = new HelloService.AsyncClient(protocol, clientManager, transport);\nasyncClient.setTimeout(1500L);\nSystem.out.println(\"client async calls\");\nHelloStringCallback callback = new HelloStringCallback();\nasyncClient.helloString(\"baba\", callback);\n//等待触发回调\nThread.sleep(10000L);\n```\n处理异步调用结果的回调类HelloStringCallback代码如下：\n```java\npublic class HelloStringCallback implements AsyncMethodCallback<helloString_call> {\n\n    private String response = null;\n\n    HelloStringCallback() {\n        super();\n        System.out.println(\"init Thread ID=\" + Thread.currentThread().getId());\n    }\n\n    @Override\n    public void onComplete(helloString_call response) {\n        try {\n            System.out.println(\"onComplete Thread ID=\" + Thread.currentThread().getId());\n            //调用helloString_call的getResult方法\n            System.out.println(\"msg:\" + response.getResult());\n        } catch (TException e) {\n            e.printStackTrace();\n        }\n    }\n\n    @Override\n    public void onError(Throwable throwable) {\n        System.out.println(\"onError:\");\n        throwable.printStackTrace();\n    }\n}\n\n```\n下面的时序图展示了客户端调用异步方法时，thrift内部组件的工作流程。\n\n\n**步骤1～3** 首先使用thrift为HelloService生成的AsyncClient对象，**checkReady()** 检查当前是否正在执行HelloService的方法，**一个时刻同一个Service只能执行一个方法**，然后创建thrift生成的helloString_call对象(TAsyncMethodCall的子类)，最后调用TAsyncClientManager.call(TAsyncMethodCall method)。\n\n**步骤3.1~3.1.4** TAsyncClientManager创建一个临时TProtocol对象，调用helloString_call的write_args方法，得到这次调用的方法名，参数等信息的序列化内容填充到frameBuffer中，然后根据序列化内容的长度初始化对应大小的sizeBuffer。\n\n**步骤3.2~3.3.2** SelectThread重新执行select(),并调用TAsyncMethodCall.start()方法，将这次调用的socket连接注册到selector上，图中灰色框是SelectThread线程的内部循环，橙色框是对套接字transport是否建立连接的判断(**实际上SelectThread和TAsyncClientManager不在一个线程内工作**，这里只是描述大概的执行顺序，SelectThread的内部细节在上面的初始化时序图中)\n\n**步骤3.4~3.4.6.2** SelectThread调用TAsyncMethodCall.transition()方法，TAsyncMethodCall根据状态机的状态执行操作，这里展示一次调用的正常顺序(没有包含异常的情况)。\n\n3.4.1~3.4.5是建立连接，发送请求包size,请求包内容，接收响应包size，响应包内容 **(注意除了size相关的方法，都需要SelectionKey做参数，因为这次操作需要修改selector上注册的事件)**。\n\n3.4.6 当响应接收完成，执行cleanUpAndFireCallback()方法，先是调用HelloService.AsyncClient的onComplete()方法，让它能去处理下一个HelloService的异步调用，然后调用我们定义的回调函数HelloStringCallback.onComplete(helloString_call response)方法(这也是在SelectThread内完成的)。\n\n{% asset_img thrift-client-call.png image %}\n\n**在调用中selector上注册事件的变化**\n\n向selector注册事件的顺序全部由TAsyncMethodCall来完成，左侧是注册的事件，右侧会注册这个事件的函数：\n当通信完成注册0清空事件\n|事件| 状态机 | 函数 |\n| --- |---|--- |\n|OP_CONNECT |State.CONNECTING  |  start() |\n|OP_WRITE|State.WRITING_REQUEST_SIZE或State.CONNECTING|start()或doConnecting()|\n|OP_READ|State.READING_RESPONSE_SIZE|doWritingRequestBody()|\n|0|State.RESPONSE_READ|cleanUpAndFireCallback()|\n#### 对比同步客户端\n**同步客户端的使用方式**\n\n对于同一个Service,同一时间只能执行一个Service中的方法。需要开发者确保Client不会被多个线程调用，因为同步客户端的**Client对象不是线程安全的。一般都会创建Client的对象池，每次调用从对象池中获得一个Client**。\n每次发起调用seqid都会+1，然后在调用完成后检查收到的seqid和发起时一致。\n\n**异步客户端内的使用方式**\n\n**必须使用非阻塞服务端**,在我的测试中，使用同步的服务端&异步客户端会遇到readMessageBegin()操作阻塞的问题。\n在执行`int size = readI32();`时，同步服务端获得size是**整个请求包的size**,并不是TMessage第一个构造参数name的size,所以readStringBody会读取整个请求包，之后的readByte()和readI32()已经没有数据可读，就会阻塞（**到底为什么呢**）。\n```java\npublic TMessage readMessageBegin() throws TException {\n        int size = readI32();\n        if (size < 0) {\n            int version = size & VERSION_MASK;\n            if (version != VERSION_1) {\n                throw new TProtocolException(TProtocolException.BAD_VERSION, \"Bad version in readMessageBegin\");\n            }\n            return new TMessage(readString(), (byte) (size & 0x000000ff), readI32());\n        } else {\n        //使用同步服务端时，执行这部分阻塞\n            if (strictRead_) {\n                throw new TProtocolException(TProtocolException.BAD_VERSION, \"Missing version in readMessageBegin, old client?\");\n            }\n            return new TMessage(readStringBody(size), readByte(), readI32());\n        }\n    }\n```\n\nAsyncClient也不是线程安全的，甚至**即使同一个线程在一个循环中多次调用一个方法**也会出现异常，比如：\n```\n                for(int i=3;i>0;i--) {\n                    HelloStringCallback callback = new HelloStringCallback();\n                    asyncClient.helloString(\"baba\", callback);\n                }\n                //等待触发回调\n                Thread.sleep(1000L);\n```\n会触发异常：\njava.nio.channels.ConnectionPendingException//连接正在进行\njava.nio.channels.ClosedChannelException//连接已关闭\n\n在上面的例子中，因为没有等上次调用返回就发起了新的调用，每次调用使用的socket连接相同，因此对socket连接的操作产生了冲突，实际上**checkReady()并没有起到作用**，在这个版本的源码中TAsyncClient.**currentMethod字段一直是null**。所以使用异步客户端时**发起一次调用就需要创建一个AsyncClient**，使用新的socket，一般是使用Client的对象池。\n没卵用的checkReady():\n```java\nprotected void checkReady() {\n    // Ensure we are not currently executing a method\n    if (currentMethod != null) {\n      throw new IllegalStateException(\"Client is currently executing another method: \" + currentMethod.getClass().getName());\n    }\n\n    // Ensure we're not in an error state\n    if (error != null) {\n      throw new IllegalStateException(\"Client has an error!\", error);\n    }\n```\n**seqid在异步调用中没有变化**，一直是0：\n```java\n        prot.writeMessageBegin(new TMessage(\"helloString\", TMessageType.CALL, 0));\n```\n在同步客户端中，seqid会自增：\n```java\n        oprot_.writeMessageBegin(new TMessage(\"helloString\", TMessageType.CALL, ++seqid_));\n```\n\n**在接收调用结果时和同步客户端一样:**\n在helloString_call(extends TAsyncMethodCall)中可以看到getResult方法使用了同步客户端(创新了一个同步客户端实例，new Client(prot))的recv_helloString方法。\n```java\npublic String getResult() throws TException {\n                if (getState() != State.RESPONSE_READ) {\n                    throw new IllegalStateException(\"Method call not finished!\");\n                }\n                TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());\n                TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);\n                return (new Client(prot)).recv_helloString();\n            }\n```\n","slug":"thrift源码（二）异步客户端","published":1,"updated":"2019-10-24T16:51:20.204Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkqle1dt003bcyneke11cfve","content":"<h2 id=\"异步客户端简介\"><a href=\"#异步客户端简介\" class=\"headerlink\" title=\"异步客户端简介\"></a>异步客户端简介</h2><p>异步客户端使用java nio实现，和许多NIO的例子相同，启动一个线程执行select()操作，然后把获得的SocketChannel交给统一的handler处理。<br>异步客户端初始化并发起请求的调用栈如下：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//初始化</span></span><br><span class=\"line\">HelloServiceClient.main()</span><br><span class=\"line\">= TAsyncClientManager.TAsyncClientManager()</span><br><span class=\"line\"></span><br><span class=\"line\">= = TAsyncClientManager.SelectThread.run()</span><br><span class=\"line\">= = TAsyncClientManager.SelectThread.transitionMethods()</span><br><span class=\"line\">= = = TAsyncMethodCall.transition()</span><br><span class=\"line\">= = TAsyncClientManager.SelectThread.timeoutIdleMethods()</span><br><span class=\"line\">= = TAsyncClientManager.SelectThread.startPendingMethods()</span><br><span class=\"line\">= = = TAsyncMethodCall.start()</span><br><span class=\"line\"><span class=\"comment\">//发起调用</span></span><br><span class=\"line\">= HelloService.AsyncClient.helloVoid()</span><br><span class=\"line\">= = TAsyncClientManager.call()</span><br><span class=\"line\">= = = TAsyncMethodCall.prepareMethodCall()</span><br><span class=\"line\">= = = = HelloService.AsyncClient.helloVoid_call.write_args()</span><br><span class=\"line\">= = = TAsyncClientManager.SelectThread.getSelector().wakeup()</span><br><span class=\"line\">= = = TAsyncMethodCall.start()</span><br><span class=\"line\">= = = TAsyncMethodCall#registerForFirstWrite</span><br><span class=\"line\">= = = TAsyncMethodCall#doWritingRequestSize</span><br><span class=\"line\">= = = TAsyncMethodCall#doWritingRequestBody</span><br><span class=\"line\">= = = TAsyncMethodCall#doReadingResponseSize</span><br><span class=\"line\">= = = TAsyncMethodCall#doReadingResponseBody</span><br></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<h2 id=\"主要组件\"><a href=\"#主要组件\" class=\"headerlink\" title=\"主要组件\"></a>主要组件</h2><h3 id=\"TAsyncClientManager\"><a href=\"#TAsyncClientManager\" class=\"headerlink\" title=\"TAsyncClientManager\"></a>TAsyncClientManager</h3><p>管理方法调用，请求的IO状态过渡,超时管理等，持有一个Selector线程<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//selector线程</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> SelectThread selectThread;</span><br><span class=\"line\"><span class=\"comment\">//保存请求的队列</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ConcurrentLinkedQueue&lt;TAsyncMethodCall&gt; pendingCalls = <span class=\"keyword\">new</span> ConcurrentLinkedQueue&lt;TAsyncMethodCall&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TAsyncClientManager</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.selectThread = <span class=\"keyword\">new</span> SelectThread();</span><br><span class=\"line\">  selectThread.start();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"SelectThread\"><a href=\"#SelectThread\" class=\"headerlink\" title=\"SelectThread\"></a>SelectThread</h3><p> SelectThread是TAsyncClientManager的内部类，继承了Thread,使用了java提供的nio包的selector</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SelectThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Selector waits at most SELECT_TIME milliseconds before waking</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> SELECT_TIME = <span class=\"number\">5</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Selector selector;</span><br><span class=\"line\">    <span class=\"comment\">// 线程共享的变量</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">boolean</span> running;</span><br><span class=\"line\">    <span class=\"comment\">// 用来管理超时</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Set&lt;TAsyncMethodCall&gt; timeoutWatchSet = <span class=\"keyword\">new</span> HashSet&lt;TAsyncMethodCall&gt;();</span><br><span class=\"line\">    <span class=\"comment\">//核心方法，调用select监听IO事件，然后依次执行处理方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">while</span> (running) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            selector.select(SELECT_TIME);</span><br><span class=\"line\">          &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            LOGGER.error(<span class=\"string\">\"Caught IOException in TAsyncClientManager!\"</span>, e);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"comment\">//触发TAsyncMethodCall状态机的状态变化，状态机会按照状态执行操作</span></span><br><span class=\"line\">          transitionMethods();</span><br><span class=\"line\">          <span class=\"comment\">//遍历timeoutWatchSet中的请求，让超时调用返回异常</span></span><br><span class=\"line\">          timeoutIdleMethods();</span><br><span class=\"line\">          <span class=\"comment\">//从pendingCalls队列中取出全部的新请求并处理</span></span><br><span class=\"line\">          startPendingMethods();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable throwable) &#123;</span><br><span class=\"line\">          LOGGER.error(<span class=\"string\">\"Ignoring uncaught exception in SelectThread\"</span>, throwable);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"startPendingMethods\"><a href=\"#startPendingMethods\" class=\"headerlink\" title=\"startPendingMethods()\"></a>startPendingMethods()</h4><p>从pendingCalls队列中取出全部的新请求并处理：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Start any new calls</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">startPendingMethods</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      TAsyncMethodCall methodCall;</span><br><span class=\"line\">      <span class=\"keyword\">while</span> ((methodCall = pendingCalls.poll()) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          methodCall.start(selector);</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"comment\">// If timeout specified and first transition went smoothly, add to timeout watch set</span></span><br><span class=\"line\">          TAsyncClient client = methodCall.getClient();</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (client.hasTimeout() &amp;&amp; !client.hasError()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//放入超时检查set</span></span><br><span class=\"line\">            timeoutWatchSet.add(methodCall);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">          LOGGER.warn(<span class=\"string\">\"Caught throwable in TAsyncClientManager!\"</span>, e);</span><br><span class=\"line\">          methodCall.onError(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"timeoutIdleMethods\"><a href=\"#timeoutIdleMethods\" class=\"headerlink\" title=\"timeoutIdleMethods()\"></a>timeoutIdleMethods()</h4><p>遍历timeoutWatchSet，检查超时的调用：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Set&lt;TAsyncMethodCall&gt; timeoutWatchSet = <span class=\"keyword\">new</span> HashSet&lt;TAsyncMethodCall&gt;();</span><br><span class=\"line\"><span class=\"comment\">// Timeout any existing method calls                                                </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">timeoutIdleMethods</span><span class=\"params\">()</span> </span>&#123;                                                     </span><br><span class=\"line\">  Iterator&lt;TAsyncMethodCall&gt; iterator = timeoutWatchSet.iterator();                     </span><br><span class=\"line\">  <span class=\"keyword\">while</span> (iterator.hasNext()) &#123;                                                          </span><br><span class=\"line\">    TAsyncMethodCall methodCall = iterator.next();                                      </span><br><span class=\"line\">    <span class=\"keyword\">long</span> clientTimeout = methodCall.getClient().getTimeout();                           </span><br><span class=\"line\">    <span class=\"keyword\">long</span> timeElapsed = System.currentTimeMillis() - methodCall.getLastTransitionTime(); </span><br><span class=\"line\">                                                                                        </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (timeElapsed &gt; clientTimeout) &#123;                                                  </span><br><span class=\"line\">      iterator.remove();                                                                </span><br><span class=\"line\">      methodCall.onError(<span class=\"keyword\">new</span> TimeoutException(<span class=\"string\">\"Operation \"</span> +                            </span><br><span class=\"line\">          methodCall.getClass() + <span class=\"string\">\" timed out after \"</span> + timeElapsed +                   </span><br><span class=\"line\">          <span class=\"string\">\" milliseconds.\"</span>));                                                           </span><br><span class=\"line\">    &#125;                                                                                   </span><br><span class=\"line\">  &#125;                                                                                     </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"TAsyncMethodCall\"><a href=\"#TAsyncMethodCall\" class=\"headerlink\" title=\"TAsyncMethodCall\"></a>TAsyncMethodCall</h3><p>抽象类，代表远程方法的异步调用，thrift生成的helloString_call的父类，持有callback调用，负责建立socket连接，写入TNonblockingTransport、构造ByteBuffer等，<strong>对IO操作的切换通过状态机来完成</strong>,重点关注transition()方法。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TAsyncMethodCall</span>&lt;<span class=\"title\">T</span> <span class=\"keyword\">extends</span> <span class=\"title\">TAsyncMethodCall</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> INITIAL_MEMORY_BUFFER_SIZE = <span class=\"number\">128</span>;</span><br><span class=\"line\">  <span class=\"comment\">//内部的状态机，一共7个状态</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">enum</span> State &#123;</span><br><span class=\"line\">    CONNECTING,</span><br><span class=\"line\">    WRITING_REQUEST_SIZE,</span><br><span class=\"line\">    WRITING_REQUEST_BODY,</span><br><span class=\"line\">    READING_RESPONSE_SIZE,</span><br><span class=\"line\">    READING_RESPONSE_BODY,</span><br><span class=\"line\">    RESPONSE_READ,</span><br><span class=\"line\">    ERROR;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//Transport socket连接的封装</span></span><br><span class=\"line\">  <span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> TNonblockingTransport transport;</span><br><span class=\"line\">  <span class=\"comment\">//负责序列化</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> TProtocolFactory protocolFactory;</span><br><span class=\"line\">  <span class=\"comment\">//rpc client</span></span><br><span class=\"line\">  <span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> TAsyncClient client;</span><br><span class=\"line\">  <span class=\"comment\">//回调方法</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AsyncMethodCallback&lt;T&gt; callback;</span><br><span class=\"line\">  <span class=\"comment\">//isOneway==true则不用回调</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> isOneway;</span><br><span class=\"line\">  <span class=\"comment\">//方法调用到达这个状态的时间，用来判断超时</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> lastTransitionTime;</span><br><span class=\"line\">  <span class=\"comment\">//保存数据包的内容size</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> ByteBuffer sizeBuffer;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">byte</span>[] sizeBufferArray = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">4</span>];</span><br><span class=\"line\">  <span class=\"comment\">//保存数据包内容</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> ByteBuffer frameBuffer;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"title\">TAsyncMethodCall</span><span class=\"params\">(TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport, AsyncMethodCallback&lt;T&gt; callback, <span class=\"keyword\">boolean</span> isOneway)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.transport = transport;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.callback = callback;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.protocolFactory = protocolFactory;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.client = client;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.isOneway = isOneway;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.lastTransitionTime = System.currentTimeMillis();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//Transition方法，根据状态机状态执行对应的操作。</span></span><br><span class=\"line\">  <span class=\"comment\">//这个方法是线程安全的，因为只在SelectThread内部执行</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">transition</span><span class=\"params\">(SelectionKey key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Ensure key is valid</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!key.isValid()) &#123;</span><br><span class=\"line\">      key.cancel();</span><br><span class=\"line\">      Exception e = <span class=\"keyword\">new</span> TTransportException(<span class=\"string\">\"Selection key not valid!\"</span>);</span><br><span class=\"line\">      onError(e);</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Transition function</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">switch</span> (state) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> CONNECTING:</span><br><span class=\"line\">          doConnecting(key);</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> WRITING_REQUEST_SIZE:</span><br><span class=\"line\">          doWritingRequestSize();</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> WRITING_REQUEST_BODY:</span><br><span class=\"line\">          doWritingRequestBody(key);</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> READING_RESPONSE_SIZE:</span><br><span class=\"line\">          doReadingResponseSize();</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> READING_RESPONSE_BODY:</span><br><span class=\"line\">          doReadingResponseBody(key);</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">default</span>: <span class=\"comment\">// RESPONSE_READ, ERROR, or bug</span></span><br><span class=\"line\">          <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Method call in state \"</span> + state</span><br><span class=\"line\">              + <span class=\"string\">\" but selector called transition method. Seems like a bug...\"</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      lastTransitionTime = System.currentTimeMillis();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">      key.cancel();</span><br><span class=\"line\">      key.attach(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">      onError(e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"start\"><a href=\"#start\" class=\"headerlink\" title=\"start()\"></a>start()</h4><p>在TAsyncMethodCall的start()方法中<strong>有一个优化处理</strong>：一般当socket连接未建立时，会向selector注册连接事件的监听。但是<strong>因为非阻塞socket的CONNECT操作可以立刻完成(不会一直阻塞，当连接不能立即完成时，connect返回EINPROGRESS，之后select会再判断描述符是否可写)</strong>，所以添加了对startConnect()返回值的检查，如果return true那么就去注册读事件。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">(Selector sel)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    SelectionKey key;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (transport.isOpen()) &#123;</span><br><span class=\"line\">      state = State.WRITING_REQUEST_SIZE;</span><br><span class=\"line\">      key = transport.registerSelector(sel, SelectionKey.OP_WRITE);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      state = State.CONNECTING;</span><br><span class=\"line\">      key = transport.registerSelector(sel, SelectionKey.OP_CONNECT);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// non-blocking connect can complete immediately,</span></span><br><span class=\"line\">      <span class=\"comment\">// in which case we should not expect the OP_CONNECT</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (transport.startConnect()) &#123;</span><br><span class=\"line\">        registerForFirstWrite(key);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    key.attach(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"初始化的时序图\"><a href=\"#初始化的时序图\" class=\"headerlink\" title=\"初始化的时序图\"></a>初始化的时序图</h2><img src=\"/2019/08/05/thrift源码（二）异步客户端/client-init.png\" title=\"image\">\n<p>如图所示，首先HelloServiceClient创建TAsyncClientManger实例，然后SelectThread对象初始化，创建守护线程并启动。<br>线程启动之后，执行SelectThread.run()方法的循环，selector开始监听I/O事件。<br>select()执行后，依次执行<br>transitionMethods();<br>timeoutIdleMethods();<br>startPendingMethods();<br>这些方法分别会调用TAsyncMethodCall的transition(),onError(),start()方法。<br>最右侧是TAsyncMethodCall中State状态机的状态图。当过渡到RESPONSE_READ状态后，本次调用的I/O操作完成。</p>\n<h2 id=\"执行异步调用的时序图\"><a href=\"#执行异步调用的时序图\" class=\"headerlink\" title=\"执行异步调用的时序图\"></a>执行异步调用的时序图</h2><p>下面是异步客户端初始化并发起异步调用的代码，为了不让程序立即退出最后增加了sleep()方法。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TAsyncClientManager clientManager = <span class=\"keyword\">new</span> TAsyncClientManager();</span><br><span class=\"line\">TNonblockingTransport transport = <span class=\"keyword\">new</span> TNonblockingSocket(<span class=\"string\">\"localhost\"</span>, <span class=\"number\">7911</span>);</span><br><span class=\"line\">TProtocolFactory protocol = <span class=\"keyword\">new</span> TBinaryProtocol.Factory();</span><br><span class=\"line\">HelloService.AsyncClient asyncClient = <span class=\"keyword\">new</span> HelloService.AsyncClient(protocol, clientManager, transport);</span><br><span class=\"line\">asyncClient.setTimeout(<span class=\"number\">1500L</span>);</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"client async calls\"</span>);</span><br><span class=\"line\">HelloStringCallback callback = <span class=\"keyword\">new</span> HelloStringCallback();</span><br><span class=\"line\">asyncClient.helloString(<span class=\"string\">\"baba\"</span>, callback);</span><br><span class=\"line\"><span class=\"comment\">//等待触发回调</span></span><br><span class=\"line\">Thread.sleep(<span class=\"number\">10000L</span>);</span><br></pre></td></tr></table></figure></p>\n<p>处理异步调用结果的回调类HelloStringCallback代码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloStringCallback</span> <span class=\"keyword\">implements</span> <span class=\"title\">AsyncMethodCallback</span>&lt;<span class=\"title\">helloString_call</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String response = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    HelloStringCallback() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"init Thread ID=\"</span> + Thread.currentThread().getId());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onComplete</span><span class=\"params\">(helloString_call response)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"onComplete Thread ID=\"</span> + Thread.currentThread().getId());</span><br><span class=\"line\">            <span class=\"comment\">//调用helloString_call的getResult方法</span></span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"msg:\"</span> + response.getResult());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (TException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">(Throwable throwable)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"onError:\"</span>);</span><br><span class=\"line\">        throwable.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>下面的时序图展示了客户端调用异步方法时，thrift内部组件的工作流程。</p>\n<p><strong>步骤1～3</strong> 首先使用thrift为HelloService生成的AsyncClient对象，<strong>checkReady()</strong> 检查当前是否正在执行HelloService的方法，<strong>一个时刻同一个Service只能执行一个方法</strong>，然后创建thrift生成的helloString_call对象(TAsyncMethodCall的子类)，最后调用TAsyncClientManager.call(TAsyncMethodCall method)。</p>\n<p><strong>步骤3.1~3.1.4</strong> TAsyncClientManager创建一个临时TProtocol对象，调用helloString_call的write_args方法，得到这次调用的方法名，参数等信息的序列化内容填充到frameBuffer中，然后根据序列化内容的长度初始化对应大小的sizeBuffer。</p>\n<p><strong>步骤3.2~3.3.2</strong> SelectThread重新执行select(),并调用TAsyncMethodCall.start()方法，将这次调用的socket连接注册到selector上，图中灰色框是SelectThread线程的内部循环，橙色框是对套接字transport是否建立连接的判断(<strong>实际上SelectThread和TAsyncClientManager不在一个线程内工作</strong>，这里只是描述大概的执行顺序，SelectThread的内部细节在上面的初始化时序图中)</p>\n<p><strong>步骤3.4~3.4.6.2</strong> SelectThread调用TAsyncMethodCall.transition()方法，TAsyncMethodCall根据状态机的状态执行操作，这里展示一次调用的正常顺序(没有包含异常的情况)。</p>\n<p>3.4.1~3.4.5是建立连接，发送请求包size,请求包内容，接收响应包size，响应包内容 <strong>(注意除了size相关的方法，都需要SelectionKey做参数，因为这次操作需要修改selector上注册的事件)</strong>。</p>\n<p>3.4.6 当响应接收完成，执行cleanUpAndFireCallback()方法，先是调用HelloService.AsyncClient的onComplete()方法，让它能去处理下一个HelloService的异步调用，然后调用我们定义的回调函数HelloStringCallback.onComplete(helloString_call response)方法(这也是在SelectThread内完成的)。</p>\n<img src=\"/2019/08/05/thrift源码（二）异步客户端/thrift-client-call.png\" title=\"image\">\n<p><strong>在调用中selector上注册事件的变化</strong></p>\n<p>向selector注册事件的顺序全部由TAsyncMethodCall来完成，左侧是注册的事件，右侧会注册这个事件的函数：<br>当通信完成注册0清空事件<br>|事件| 状态机 | 函数 |<br>| — |—|— |<br>|OP_CONNECT |State.CONNECTING  |  start() |<br>|OP_WRITE|State.WRITING_REQUEST_SIZE或State.CONNECTING|start()或doConnecting()|<br>|OP_READ|State.READING_RESPONSE_SIZE|doWritingRequestBody()|<br>|0|State.RESPONSE_READ|cleanUpAndFireCallback()|</p>\n<h4 id=\"对比同步客户端\"><a href=\"#对比同步客户端\" class=\"headerlink\" title=\"对比同步客户端\"></a>对比同步客户端</h4><p><strong>同步客户端的使用方式</strong></p>\n<p>对于同一个Service,同一时间只能执行一个Service中的方法。需要开发者确保Client不会被多个线程调用，因为同步客户端的<strong>Client对象不是线程安全的。一般都会创建Client的对象池，每次调用从对象池中获得一个Client</strong>。<br>每次发起调用seqid都会+1，然后在调用完成后检查收到的seqid和发起时一致。</p>\n<p><strong>异步客户端内的使用方式</strong></p>\n<p><strong>必须使用非阻塞服务端</strong>,在我的测试中，使用同步的服务端&amp;异步客户端会遇到readMessageBegin()操作阻塞的问题。<br>在执行<code>int size = readI32();</code>时，同步服务端获得size是<strong>整个请求包的size</strong>,并不是TMessage第一个构造参数name的size,所以readStringBody会读取整个请求包，之后的readByte()和readI32()已经没有数据可读，就会阻塞（<strong>到底为什么呢</strong>）。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> TMessage <span class=\"title\">readMessageBegin</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> TException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> size = readI32();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (size &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> version = size &amp; VERSION_MASK;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (version != VERSION_1) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> TProtocolException(TProtocolException.BAD_VERSION, <span class=\"string\">\"Bad version in readMessageBegin\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> TMessage(readString(), (<span class=\"keyword\">byte</span>) (size &amp; <span class=\"number\">0x000000ff</span>), readI32());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//使用同步服务端时，执行这部分阻塞</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (strictRead_) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> TProtocolException(TProtocolException.BAD_VERSION, <span class=\"string\">\"Missing version in readMessageBegin, old client?\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> TMessage(readStringBody(size), readByte(), readI32());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>AsyncClient也不是线程安全的，甚至<strong>即使同一个线程在一个循环中多次调用一个方法</strong>也会出现异常，比如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for(int i=3;i&gt;0;i--) &#123;</span><br><span class=\"line\">    HelloStringCallback callback = new HelloStringCallback();</span><br><span class=\"line\">    asyncClient.helloString(&quot;baba&quot;, callback);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//等待触发回调</span><br><span class=\"line\">Thread.sleep(1000L);</span><br></pre></td></tr></table></figure></p>\n<p>会触发异常：<br>java.nio.channels.ConnectionPendingException//连接正在进行<br>java.nio.channels.ClosedChannelException//连接已关闭</p>\n<p>在上面的例子中，因为没有等上次调用返回就发起了新的调用，每次调用使用的socket连接相同，因此对socket连接的操作产生了冲突，实际上<strong>checkReady()并没有起到作用</strong>，在这个版本的源码中TAsyncClient.<strong>currentMethod字段一直是null</strong>。所以使用异步客户端时<strong>发起一次调用就需要创建一个AsyncClient</strong>，使用新的socket，一般是使用Client的对象池。<br>没卵用的checkReady():<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">checkReady</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Ensure we are not currently executing a method</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (currentMethod != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Client is currently executing another method: \"</span> + currentMethod.getClass().getName());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Ensure we're not in an error state</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (error != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Client has an error!\"</span>, error);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>seqid在异步调用中没有变化</strong>，一直是0：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">prot.writeMessageBegin(<span class=\"keyword\">new</span> TMessage(<span class=\"string\">\"helloString\"</span>, TMessageType.CALL, <span class=\"number\">0</span>));</span><br></pre></td></tr></table></figure></p>\n<p>在同步客户端中，seqid会自增：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">oprot_.writeMessageBegin(<span class=\"keyword\">new</span> TMessage(<span class=\"string\">\"helloString\"</span>, TMessageType.CALL, ++seqid_));</span><br></pre></td></tr></table></figure></p>\n<p><strong>在接收调用结果时和同步客户端一样:</strong><br>在helloString_call(extends TAsyncMethodCall)中可以看到getResult方法使用了同步客户端(创新了一个同步客户端实例，new Client(prot))的recv_helloString方法。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getResult</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> TException </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (getState() != State.RESPONSE_READ) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Method call not finished!\"</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                TMemoryInputTransport memoryTransport = <span class=\"keyword\">new</span> TMemoryInputTransport(getFrameBuffer().array());</span><br><span class=\"line\">                TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> (<span class=\"keyword\">new</span> Client(prot)).recv_helloString();</span><br><span class=\"line\">            &#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"异步客户端简介\"><a href=\"#异步客户端简介\" class=\"headerlink\" title=\"异步客户端简介\"></a>异步客户端简介</h2><p>异步客户端使用java nio实现，和许多NIO的例子相同，启动一个线程执行select()操作，然后把获得的SocketChannel交给统一的handler处理。<br>异步客户端初始化并发起请求的调用栈如下：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//初始化</span></span><br><span class=\"line\">HelloServiceClient.main()</span><br><span class=\"line\">= TAsyncClientManager.TAsyncClientManager()</span><br><span class=\"line\"></span><br><span class=\"line\">= = TAsyncClientManager.SelectThread.run()</span><br><span class=\"line\">= = TAsyncClientManager.SelectThread.transitionMethods()</span><br><span class=\"line\">= = = TAsyncMethodCall.transition()</span><br><span class=\"line\">= = TAsyncClientManager.SelectThread.timeoutIdleMethods()</span><br><span class=\"line\">= = TAsyncClientManager.SelectThread.startPendingMethods()</span><br><span class=\"line\">= = = TAsyncMethodCall.start()</span><br><span class=\"line\"><span class=\"comment\">//发起调用</span></span><br><span class=\"line\">= HelloService.AsyncClient.helloVoid()</span><br><span class=\"line\">= = TAsyncClientManager.call()</span><br><span class=\"line\">= = = TAsyncMethodCall.prepareMethodCall()</span><br><span class=\"line\">= = = = HelloService.AsyncClient.helloVoid_call.write_args()</span><br><span class=\"line\">= = = TAsyncClientManager.SelectThread.getSelector().wakeup()</span><br><span class=\"line\">= = = TAsyncMethodCall.start()</span><br><span class=\"line\">= = = TAsyncMethodCall#registerForFirstWrite</span><br><span class=\"line\">= = = TAsyncMethodCall#doWritingRequestSize</span><br><span class=\"line\">= = = TAsyncMethodCall#doWritingRequestBody</span><br><span class=\"line\">= = = TAsyncMethodCall#doReadingResponseSize</span><br><span class=\"line\">= = = TAsyncMethodCall#doReadingResponseBody</span><br></pre></td></tr></table></figure></p>","more":"<h2 id=\"主要组件\"><a href=\"#主要组件\" class=\"headerlink\" title=\"主要组件\"></a>主要组件</h2><h3 id=\"TAsyncClientManager\"><a href=\"#TAsyncClientManager\" class=\"headerlink\" title=\"TAsyncClientManager\"></a>TAsyncClientManager</h3><p>管理方法调用，请求的IO状态过渡,超时管理等，持有一个Selector线程<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//selector线程</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> SelectThread selectThread;</span><br><span class=\"line\"><span class=\"comment\">//保存请求的队列</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ConcurrentLinkedQueue&lt;TAsyncMethodCall&gt; pendingCalls = <span class=\"keyword\">new</span> ConcurrentLinkedQueue&lt;TAsyncMethodCall&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TAsyncClientManager</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.selectThread = <span class=\"keyword\">new</span> SelectThread();</span><br><span class=\"line\">  selectThread.start();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"SelectThread\"><a href=\"#SelectThread\" class=\"headerlink\" title=\"SelectThread\"></a>SelectThread</h3><p> SelectThread是TAsyncClientManager的内部类，继承了Thread,使用了java提供的nio包的selector</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SelectThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Selector waits at most SELECT_TIME milliseconds before waking</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> SELECT_TIME = <span class=\"number\">5</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Selector selector;</span><br><span class=\"line\">    <span class=\"comment\">// 线程共享的变量</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">boolean</span> running;</span><br><span class=\"line\">    <span class=\"comment\">// 用来管理超时</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Set&lt;TAsyncMethodCall&gt; timeoutWatchSet = <span class=\"keyword\">new</span> HashSet&lt;TAsyncMethodCall&gt;();</span><br><span class=\"line\">    <span class=\"comment\">//核心方法，调用select监听IO事件，然后依次执行处理方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">while</span> (running) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            selector.select(SELECT_TIME);</span><br><span class=\"line\">          &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            LOGGER.error(<span class=\"string\">\"Caught IOException in TAsyncClientManager!\"</span>, e);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"comment\">//触发TAsyncMethodCall状态机的状态变化，状态机会按照状态执行操作</span></span><br><span class=\"line\">          transitionMethods();</span><br><span class=\"line\">          <span class=\"comment\">//遍历timeoutWatchSet中的请求，让超时调用返回异常</span></span><br><span class=\"line\">          timeoutIdleMethods();</span><br><span class=\"line\">          <span class=\"comment\">//从pendingCalls队列中取出全部的新请求并处理</span></span><br><span class=\"line\">          startPendingMethods();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable throwable) &#123;</span><br><span class=\"line\">          LOGGER.error(<span class=\"string\">\"Ignoring uncaught exception in SelectThread\"</span>, throwable);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"startPendingMethods\"><a href=\"#startPendingMethods\" class=\"headerlink\" title=\"startPendingMethods()\"></a>startPendingMethods()</h4><p>从pendingCalls队列中取出全部的新请求并处理：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Start any new calls</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">startPendingMethods</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      TAsyncMethodCall methodCall;</span><br><span class=\"line\">      <span class=\"keyword\">while</span> ((methodCall = pendingCalls.poll()) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          methodCall.start(selector);</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"comment\">// If timeout specified and first transition went smoothly, add to timeout watch set</span></span><br><span class=\"line\">          TAsyncClient client = methodCall.getClient();</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (client.hasTimeout() &amp;&amp; !client.hasError()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//放入超时检查set</span></span><br><span class=\"line\">            timeoutWatchSet.add(methodCall);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">          LOGGER.warn(<span class=\"string\">\"Caught throwable in TAsyncClientManager!\"</span>, e);</span><br><span class=\"line\">          methodCall.onError(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"timeoutIdleMethods\"><a href=\"#timeoutIdleMethods\" class=\"headerlink\" title=\"timeoutIdleMethods()\"></a>timeoutIdleMethods()</h4><p>遍历timeoutWatchSet，检查超时的调用：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Set&lt;TAsyncMethodCall&gt; timeoutWatchSet = <span class=\"keyword\">new</span> HashSet&lt;TAsyncMethodCall&gt;();</span><br><span class=\"line\"><span class=\"comment\">// Timeout any existing method calls                                                </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">timeoutIdleMethods</span><span class=\"params\">()</span> </span>&#123;                                                     </span><br><span class=\"line\">  Iterator&lt;TAsyncMethodCall&gt; iterator = timeoutWatchSet.iterator();                     </span><br><span class=\"line\">  <span class=\"keyword\">while</span> (iterator.hasNext()) &#123;                                                          </span><br><span class=\"line\">    TAsyncMethodCall methodCall = iterator.next();                                      </span><br><span class=\"line\">    <span class=\"keyword\">long</span> clientTimeout = methodCall.getClient().getTimeout();                           </span><br><span class=\"line\">    <span class=\"keyword\">long</span> timeElapsed = System.currentTimeMillis() - methodCall.getLastTransitionTime(); </span><br><span class=\"line\">                                                                                        </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (timeElapsed &gt; clientTimeout) &#123;                                                  </span><br><span class=\"line\">      iterator.remove();                                                                </span><br><span class=\"line\">      methodCall.onError(<span class=\"keyword\">new</span> TimeoutException(<span class=\"string\">\"Operation \"</span> +                            </span><br><span class=\"line\">          methodCall.getClass() + <span class=\"string\">\" timed out after \"</span> + timeElapsed +                   </span><br><span class=\"line\">          <span class=\"string\">\" milliseconds.\"</span>));                                                           </span><br><span class=\"line\">    &#125;                                                                                   </span><br><span class=\"line\">  &#125;                                                                                     </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"TAsyncMethodCall\"><a href=\"#TAsyncMethodCall\" class=\"headerlink\" title=\"TAsyncMethodCall\"></a>TAsyncMethodCall</h3><p>抽象类，代表远程方法的异步调用，thrift生成的helloString_call的父类，持有callback调用，负责建立socket连接，写入TNonblockingTransport、构造ByteBuffer等，<strong>对IO操作的切换通过状态机来完成</strong>,重点关注transition()方法。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TAsyncMethodCall</span>&lt;<span class=\"title\">T</span> <span class=\"keyword\">extends</span> <span class=\"title\">TAsyncMethodCall</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> INITIAL_MEMORY_BUFFER_SIZE = <span class=\"number\">128</span>;</span><br><span class=\"line\">  <span class=\"comment\">//内部的状态机，一共7个状态</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">enum</span> State &#123;</span><br><span class=\"line\">    CONNECTING,</span><br><span class=\"line\">    WRITING_REQUEST_SIZE,</span><br><span class=\"line\">    WRITING_REQUEST_BODY,</span><br><span class=\"line\">    READING_RESPONSE_SIZE,</span><br><span class=\"line\">    READING_RESPONSE_BODY,</span><br><span class=\"line\">    RESPONSE_READ,</span><br><span class=\"line\">    ERROR;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//Transport socket连接的封装</span></span><br><span class=\"line\">  <span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> TNonblockingTransport transport;</span><br><span class=\"line\">  <span class=\"comment\">//负责序列化</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> TProtocolFactory protocolFactory;</span><br><span class=\"line\">  <span class=\"comment\">//rpc client</span></span><br><span class=\"line\">  <span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> TAsyncClient client;</span><br><span class=\"line\">  <span class=\"comment\">//回调方法</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AsyncMethodCallback&lt;T&gt; callback;</span><br><span class=\"line\">  <span class=\"comment\">//isOneway==true则不用回调</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> isOneway;</span><br><span class=\"line\">  <span class=\"comment\">//方法调用到达这个状态的时间，用来判断超时</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> lastTransitionTime;</span><br><span class=\"line\">  <span class=\"comment\">//保存数据包的内容size</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> ByteBuffer sizeBuffer;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">byte</span>[] sizeBufferArray = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">4</span>];</span><br><span class=\"line\">  <span class=\"comment\">//保存数据包内容</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> ByteBuffer frameBuffer;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"title\">TAsyncMethodCall</span><span class=\"params\">(TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport, AsyncMethodCallback&lt;T&gt; callback, <span class=\"keyword\">boolean</span> isOneway)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.transport = transport;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.callback = callback;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.protocolFactory = protocolFactory;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.client = client;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.isOneway = isOneway;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.lastTransitionTime = System.currentTimeMillis();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//Transition方法，根据状态机状态执行对应的操作。</span></span><br><span class=\"line\">  <span class=\"comment\">//这个方法是线程安全的，因为只在SelectThread内部执行</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">transition</span><span class=\"params\">(SelectionKey key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Ensure key is valid</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!key.isValid()) &#123;</span><br><span class=\"line\">      key.cancel();</span><br><span class=\"line\">      Exception e = <span class=\"keyword\">new</span> TTransportException(<span class=\"string\">\"Selection key not valid!\"</span>);</span><br><span class=\"line\">      onError(e);</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Transition function</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">switch</span> (state) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> CONNECTING:</span><br><span class=\"line\">          doConnecting(key);</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> WRITING_REQUEST_SIZE:</span><br><span class=\"line\">          doWritingRequestSize();</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> WRITING_REQUEST_BODY:</span><br><span class=\"line\">          doWritingRequestBody(key);</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> READING_RESPONSE_SIZE:</span><br><span class=\"line\">          doReadingResponseSize();</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> READING_RESPONSE_BODY:</span><br><span class=\"line\">          doReadingResponseBody(key);</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">default</span>: <span class=\"comment\">// RESPONSE_READ, ERROR, or bug</span></span><br><span class=\"line\">          <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Method call in state \"</span> + state</span><br><span class=\"line\">              + <span class=\"string\">\" but selector called transition method. Seems like a bug...\"</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      lastTransitionTime = System.currentTimeMillis();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">      key.cancel();</span><br><span class=\"line\">      key.attach(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">      onError(e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"start\"><a href=\"#start\" class=\"headerlink\" title=\"start()\"></a>start()</h4><p>在TAsyncMethodCall的start()方法中<strong>有一个优化处理</strong>：一般当socket连接未建立时，会向selector注册连接事件的监听。但是<strong>因为非阻塞socket的CONNECT操作可以立刻完成(不会一直阻塞，当连接不能立即完成时，connect返回EINPROGRESS，之后select会再判断描述符是否可写)</strong>，所以添加了对startConnect()返回值的检查，如果return true那么就去注册读事件。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">(Selector sel)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    SelectionKey key;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (transport.isOpen()) &#123;</span><br><span class=\"line\">      state = State.WRITING_REQUEST_SIZE;</span><br><span class=\"line\">      key = transport.registerSelector(sel, SelectionKey.OP_WRITE);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      state = State.CONNECTING;</span><br><span class=\"line\">      key = transport.registerSelector(sel, SelectionKey.OP_CONNECT);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// non-blocking connect can complete immediately,</span></span><br><span class=\"line\">      <span class=\"comment\">// in which case we should not expect the OP_CONNECT</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (transport.startConnect()) &#123;</span><br><span class=\"line\">        registerForFirstWrite(key);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    key.attach(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"初始化的时序图\"><a href=\"#初始化的时序图\" class=\"headerlink\" title=\"初始化的时序图\"></a>初始化的时序图</h2><img src=\"/2019/08/05/thrift源码（二）异步客户端/client-init.png\" title=\"image\">\n<p>如图所示，首先HelloServiceClient创建TAsyncClientManger实例，然后SelectThread对象初始化，创建守护线程并启动。<br>线程启动之后，执行SelectThread.run()方法的循环，selector开始监听I/O事件。<br>select()执行后，依次执行<br>transitionMethods();<br>timeoutIdleMethods();<br>startPendingMethods();<br>这些方法分别会调用TAsyncMethodCall的transition(),onError(),start()方法。<br>最右侧是TAsyncMethodCall中State状态机的状态图。当过渡到RESPONSE_READ状态后，本次调用的I/O操作完成。</p>\n<h2 id=\"执行异步调用的时序图\"><a href=\"#执行异步调用的时序图\" class=\"headerlink\" title=\"执行异步调用的时序图\"></a>执行异步调用的时序图</h2><p>下面是异步客户端初始化并发起异步调用的代码，为了不让程序立即退出最后增加了sleep()方法。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TAsyncClientManager clientManager = <span class=\"keyword\">new</span> TAsyncClientManager();</span><br><span class=\"line\">TNonblockingTransport transport = <span class=\"keyword\">new</span> TNonblockingSocket(<span class=\"string\">\"localhost\"</span>, <span class=\"number\">7911</span>);</span><br><span class=\"line\">TProtocolFactory protocol = <span class=\"keyword\">new</span> TBinaryProtocol.Factory();</span><br><span class=\"line\">HelloService.AsyncClient asyncClient = <span class=\"keyword\">new</span> HelloService.AsyncClient(protocol, clientManager, transport);</span><br><span class=\"line\">asyncClient.setTimeout(<span class=\"number\">1500L</span>);</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"client async calls\"</span>);</span><br><span class=\"line\">HelloStringCallback callback = <span class=\"keyword\">new</span> HelloStringCallback();</span><br><span class=\"line\">asyncClient.helloString(<span class=\"string\">\"baba\"</span>, callback);</span><br><span class=\"line\"><span class=\"comment\">//等待触发回调</span></span><br><span class=\"line\">Thread.sleep(<span class=\"number\">10000L</span>);</span><br></pre></td></tr></table></figure></p>\n<p>处理异步调用结果的回调类HelloStringCallback代码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloStringCallback</span> <span class=\"keyword\">implements</span> <span class=\"title\">AsyncMethodCallback</span>&lt;<span class=\"title\">helloString_call</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String response = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    HelloStringCallback() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"init Thread ID=\"</span> + Thread.currentThread().getId());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onComplete</span><span class=\"params\">(helloString_call response)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"onComplete Thread ID=\"</span> + Thread.currentThread().getId());</span><br><span class=\"line\">            <span class=\"comment\">//调用helloString_call的getResult方法</span></span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"msg:\"</span> + response.getResult());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (TException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">(Throwable throwable)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"onError:\"</span>);</span><br><span class=\"line\">        throwable.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>下面的时序图展示了客户端调用异步方法时，thrift内部组件的工作流程。</p>\n<p><strong>步骤1～3</strong> 首先使用thrift为HelloService生成的AsyncClient对象，<strong>checkReady()</strong> 检查当前是否正在执行HelloService的方法，<strong>一个时刻同一个Service只能执行一个方法</strong>，然后创建thrift生成的helloString_call对象(TAsyncMethodCall的子类)，最后调用TAsyncClientManager.call(TAsyncMethodCall method)。</p>\n<p><strong>步骤3.1~3.1.4</strong> TAsyncClientManager创建一个临时TProtocol对象，调用helloString_call的write_args方法，得到这次调用的方法名，参数等信息的序列化内容填充到frameBuffer中，然后根据序列化内容的长度初始化对应大小的sizeBuffer。</p>\n<p><strong>步骤3.2~3.3.2</strong> SelectThread重新执行select(),并调用TAsyncMethodCall.start()方法，将这次调用的socket连接注册到selector上，图中灰色框是SelectThread线程的内部循环，橙色框是对套接字transport是否建立连接的判断(<strong>实际上SelectThread和TAsyncClientManager不在一个线程内工作</strong>，这里只是描述大概的执行顺序，SelectThread的内部细节在上面的初始化时序图中)</p>\n<p><strong>步骤3.4~3.4.6.2</strong> SelectThread调用TAsyncMethodCall.transition()方法，TAsyncMethodCall根据状态机的状态执行操作，这里展示一次调用的正常顺序(没有包含异常的情况)。</p>\n<p>3.4.1~3.4.5是建立连接，发送请求包size,请求包内容，接收响应包size，响应包内容 <strong>(注意除了size相关的方法，都需要SelectionKey做参数，因为这次操作需要修改selector上注册的事件)</strong>。</p>\n<p>3.4.6 当响应接收完成，执行cleanUpAndFireCallback()方法，先是调用HelloService.AsyncClient的onComplete()方法，让它能去处理下一个HelloService的异步调用，然后调用我们定义的回调函数HelloStringCallback.onComplete(helloString_call response)方法(这也是在SelectThread内完成的)。</p>\n<img src=\"/2019/08/05/thrift源码（二）异步客户端/thrift-client-call.png\" title=\"image\">\n<p><strong>在调用中selector上注册事件的变化</strong></p>\n<p>向selector注册事件的顺序全部由TAsyncMethodCall来完成，左侧是注册的事件，右侧会注册这个事件的函数：<br>当通信完成注册0清空事件<br>|事件| 状态机 | 函数 |<br>| — |—|— |<br>|OP_CONNECT |State.CONNECTING  |  start() |<br>|OP_WRITE|State.WRITING_REQUEST_SIZE或State.CONNECTING|start()或doConnecting()|<br>|OP_READ|State.READING_RESPONSE_SIZE|doWritingRequestBody()|<br>|0|State.RESPONSE_READ|cleanUpAndFireCallback()|</p>\n<h4 id=\"对比同步客户端\"><a href=\"#对比同步客户端\" class=\"headerlink\" title=\"对比同步客户端\"></a>对比同步客户端</h4><p><strong>同步客户端的使用方式</strong></p>\n<p>对于同一个Service,同一时间只能执行一个Service中的方法。需要开发者确保Client不会被多个线程调用，因为同步客户端的<strong>Client对象不是线程安全的。一般都会创建Client的对象池，每次调用从对象池中获得一个Client</strong>。<br>每次发起调用seqid都会+1，然后在调用完成后检查收到的seqid和发起时一致。</p>\n<p><strong>异步客户端内的使用方式</strong></p>\n<p><strong>必须使用非阻塞服务端</strong>,在我的测试中，使用同步的服务端&amp;异步客户端会遇到readMessageBegin()操作阻塞的问题。<br>在执行<code>int size = readI32();</code>时，同步服务端获得size是<strong>整个请求包的size</strong>,并不是TMessage第一个构造参数name的size,所以readStringBody会读取整个请求包，之后的readByte()和readI32()已经没有数据可读，就会阻塞（<strong>到底为什么呢</strong>）。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> TMessage <span class=\"title\">readMessageBegin</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> TException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> size = readI32();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (size &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> version = size &amp; VERSION_MASK;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (version != VERSION_1) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> TProtocolException(TProtocolException.BAD_VERSION, <span class=\"string\">\"Bad version in readMessageBegin\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> TMessage(readString(), (<span class=\"keyword\">byte</span>) (size &amp; <span class=\"number\">0x000000ff</span>), readI32());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//使用同步服务端时，执行这部分阻塞</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (strictRead_) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> TProtocolException(TProtocolException.BAD_VERSION, <span class=\"string\">\"Missing version in readMessageBegin, old client?\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> TMessage(readStringBody(size), readByte(), readI32());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>AsyncClient也不是线程安全的，甚至<strong>即使同一个线程在一个循环中多次调用一个方法</strong>也会出现异常，比如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for(int i=3;i&gt;0;i--) &#123;</span><br><span class=\"line\">    HelloStringCallback callback = new HelloStringCallback();</span><br><span class=\"line\">    asyncClient.helloString(&quot;baba&quot;, callback);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//等待触发回调</span><br><span class=\"line\">Thread.sleep(1000L);</span><br></pre></td></tr></table></figure></p>\n<p>会触发异常：<br>java.nio.channels.ConnectionPendingException//连接正在进行<br>java.nio.channels.ClosedChannelException//连接已关闭</p>\n<p>在上面的例子中，因为没有等上次调用返回就发起了新的调用，每次调用使用的socket连接相同，因此对socket连接的操作产生了冲突，实际上<strong>checkReady()并没有起到作用</strong>，在这个版本的源码中TAsyncClient.<strong>currentMethod字段一直是null</strong>。所以使用异步客户端时<strong>发起一次调用就需要创建一个AsyncClient</strong>，使用新的socket，一般是使用Client的对象池。<br>没卵用的checkReady():<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">checkReady</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Ensure we are not currently executing a method</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (currentMethod != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Client is currently executing another method: \"</span> + currentMethod.getClass().getName());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Ensure we're not in an error state</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (error != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Client has an error!\"</span>, error);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>seqid在异步调用中没有变化</strong>，一直是0：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">prot.writeMessageBegin(<span class=\"keyword\">new</span> TMessage(<span class=\"string\">\"helloString\"</span>, TMessageType.CALL, <span class=\"number\">0</span>));</span><br></pre></td></tr></table></figure></p>\n<p>在同步客户端中，seqid会自增：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">oprot_.writeMessageBegin(<span class=\"keyword\">new</span> TMessage(<span class=\"string\">\"helloString\"</span>, TMessageType.CALL, ++seqid_));</span><br></pre></td></tr></table></figure></p>\n<p><strong>在接收调用结果时和同步客户端一样:</strong><br>在helloString_call(extends TAsyncMethodCall)中可以看到getResult方法使用了同步客户端(创新了一个同步客户端实例，new Client(prot))的recv_helloString方法。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getResult</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> TException </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (getState() != State.RESPONSE_READ) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Method call not finished!\"</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                TMemoryInputTransport memoryTransport = <span class=\"keyword\">new</span> TMemoryInputTransport(getFrameBuffer().array());</span><br><span class=\"line\">                TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> (<span class=\"keyword\">new</span> Client(prot)).recv_helloString();</span><br><span class=\"line\">            &#125;</span><br></pre></td></tr></table></figure></p>"},{"title":"用机器学习判断ins内容是否能上热门","date":"2020-05-21T15:21:46.000Z","_content":"\n## 背景\n\n假设现在要使用爬虫从ins抓取内容,在ins的网页版上每个#tag标签下都有'热门'和'最新'两部分tab页,因为热门内容的质量更好,所以希望能抓取更多热门内容,但是网页版每个#tag只显示最近的9条热门内容,不过'最新'tab下可以一直向前翻页,所以如果能从'最新'下的内容中过滤出热门内容就可以满足内容抓取质量的要求,需要找到一个能将内容分类为热门和非热门的算法.\n\n<!--more-->\n\n\n<div align=center> {% asset_img ins.png image %} </div>\n\n\n\n那么现在我来介绍一下如何使用机器学习来实现这个算法,本文主要介绍从零开始使用机器学习并解决问题的过程.不会介绍理论知识(刚好我也不懂),速战速决就完事儿了.\n\n{% asset_img gan.jpg image %}\n\n### 开始之前要了解\n\n- **python**:一种蛇\n- **instagram**: 著名被墙网站之一\n- **pandas**:数据处理类库\n- **matplotlib&seaborn**: 画图类库\n- **机器学习**: 一种对计算机算法的研究方式，算法会根据经验自动优化效果\n- **分类问题**: 把一组数据分成两类或者多类,要划分类型已提前定义\n- **sklearn**: 封装了多种机器学习算法的类库,开箱即用\n\n## 数据处理\n\nins内容有很多字段信息,首先选择出可能影响内容上热门的字段,包含点赞/曝光/评论/发布时间/抓取时间/标题包含的tag数和当前页面tag下的内容总数等,这些内容用json格式保存,示例如下:\n\n```python\n{\n    \"id\":\"CAA-r0SjtF3\",\n    \"sourceTag\":\"dharmaproductions\",\n    \"publishTime\":1589130910000,\n    \"addTime\":1589134125000,\n    \"likes\":4,\n    \"comments\":1,\n    \"views\":18,\n    \"tagNumber\":15,\n    \"description\":\"\",\n    \"totalMedia\":57149,\n    \"hot\":1\n}\n```\n\n### 数据探索\n\n这一步是为了进一步了解原始数据,检查数据真实性和字段的分布\n\n1. 用seaborn画直方图,查看热门/非热门内容的比例:\n\n```python\n    self.df = pd.read_json('debug/train_video.jl', lines=True)\n    sns.countplot(self.df['hot'], label=\"Count\")\n```\n\n<div align=center> {% asset_img hot.png image %} </div>\n\n图中热门内容占比还是比较高的,有一点脱离真实情况,实际对于ins上被活跃使用的tag,本身内容数量就很多又更新频繁,所以只有很少一部分内容能上热门.\n\n2. 用seaborn画热力图,这一步是为了查看字段之间的关系:\n```\n    self.df = pd.read_json('debug/train_video.jl', lines=True)\n    corr = self.df.corr()\n    plt.figure(figsize=(14, 14))\n    sns.heatmap(corr, annot=True)\n```\ncorr()函数会计算数据集df中各字段的相关关系,图中的颜色越浅代表越相关,可以看到like/view之前相关性比较高,如果两个字段之间相关性接近1,可以考虑去掉其中一个字段.\n\n<div align=left> {% asset_img heatmap.png image %} </div>\n\n3. 用matplotlib画频率分布直方图\n\n```python\n    def draw_histo(self):\n        plt.figure(1, figsize=(20, 20))\n        i = 810\n        for field in self.df.keys():\n            i += 1\n            # 去掉区间上数量小于10的记录\n            items = self.df.groupby(field).filter(lambda x: len(x) > 10)[field]\n            self.histogram(items=items, index=i, field=field)\n        plt.savefig('histogram.png')\n        \n        def histogram(self, items=None, index=None, field=None, y_label='Probability'):\n        \"\"\"\n        画频率直方图（带正态分布曲线）\n        :param index: 图片位置\n        :param field: 字段名\n        :param y_label:\n        :return:\n        \"\"\"\n        title = field + ' distribution'\n        if items is None:\n            items = self.df[field]\n        try:\n            plt.subplot(index)\n            mean = items.mean()\n            std = items.std()\n            x = np.arange(items.min(), items.max())\n            y = self.normfun(x=x, mu=mean, sigma=std)\n            plt.plot(x, y)\n            plt.hist(items, bins='auto', density=True, rwidth=0.9, stacked=True)\n            plt.title(title)\n            plt.xlabel(field)\n            plt.ylabel(y_label)\n            plt.tight_layout()\n        except Exception as e:\n            print(field)\n            print(e)\n\n    @staticmethod\n    def normfun(x, mu, sigma):\n        \"\"\"\n        正态分布的概率密度函数。可以理解成 x 是 mu（均值）和 sigma（标准差）的函数\n        :param x:\n        :param mu:\n        :param sigma:\n        :return:\n        \"\"\"\n        pdf = np.exp(-((x - mu) ** 2) / (2 * sigma ** 2)) / (sigma * np.sqrt(2 * np.pi))\n        return pdf    \n```\n<div align=center> {% asset_img histogram.png image %} </div>\n\n画直方图的目的是查看字段的分布类型,图中蓝色的线是正态分布函数曲线,明细like/view/comment的分布不符合正态分布,更像是长尾分布(大多数值分布在头部)\n\n\n### 数据清洗&特征选择\n因为原始数据中并没有缺失值或异常值得情况,所以忽略数据清洗的步骤,直接进行特征选择.\n首先我们不需要具体的时间戳,把发布时间publistTime和抓取时间addTime的间隔计算出来,单位是天和小时(ins热门tab中通常是最近发布的内容)\n\n```python\n    df['days'] = (pd.to_datetime(df['addTime'], unit='ms') - pd.to_datetime(df['publishTime'], unit='ms')).dt.days\n    # 不满一天的用1天替换\n    df['days'] = df['days'].replace(0, 1)\n    df['hours'] = ((pd.to_datetime(df['addTime'], unit='ms') - pd.to_datetime(df['publishTime'], unit='ms'))\n                   .dt.total_seconds() / 3600).astype(int)\n    df['hours'] = df['hours'].replace(0, 1)\n```\n\n然后因为一般内容发布越早曝光也越高,所以添加like_per_hour/view_per_hour两个特征,减弱时间影响\n\n```python\n    df['like_per_hour'] = (df['likes'] / df['hours']).astype(int)\n    df['view_per_hour'] = (df['views'] / df['hours']).astype(int)\n```\n\n最后选择的特征如下:\n\n```python\n    features = ['views', 'likes', 'comments', 'tagNumber', 'totalMedia', 'days', 'like_per_hour', 'view_per_hour']\n```\n\n## 评分标准\n\n在选择分类算法前,先来了解一下评估分类算法的常用标准\n\n### 准确率,精确率,召回率\n\n假设你开发了一款检测新冠病毒的试剂盒,那么每次检测结果有一下四种(阳性表示被检测人携带病毒):\n\nTP(True Prosivite): 真阳性,说明正确检测出病毒\n\nFP(False Prosivite): 假阳性\n\nTN(True Negative): 真阴性\n\nFN(False Negative): 假阴性,携带病毒却没有检测出来\n\n对于病毒检测来说FN的危害显然要比FP更大,而根据这几种情况的样本数量就可以计算出准确率,精确率和召回率:\n\n准确率(accuracy): ${TP+TN}\\over{TP+FP+TN+FN}$,代表全部样本的正确率\n\n精确率(precision): ${TP}\\over{TP+FP}$,代表检测为阳性时的正确率\n\n召回率(recall): ${TP}\\over{TP+FN}$,代表所有病毒携带者被检测为阳性的覆盖率,也叫查全率\n\n\n![举个例子:][1]\n\n有三个样本,检测结果为y_predict,而实际值为y_true,1代表阳性,sklearn的score函数默认返回的是阳性分类的分数\n\n```python\nfrom sklearn.metrics import accuracy_score,precision_score,recall_score\n\nif __name__ == '__main__':\n    y_predict = [1,0,1]\n    y_true = [0,0,1]\n    print(f'accuracy:{accuracy_score(y_true,y_predict)}')\n    print(f'precision:{precision_score(y_true,y_predict)}')\n    print(f'recall:{recall_score(y_true,y_predict)}')\n```\n\n输出结果为:\naccuracy:0.6666666666666666\nprecision:0.5\nrecall:1.0\n\n对于判断ins是否属于热门内容的算法,可以允许ta把非热门内容分到热门但是要尽量不遗漏热门内容，即FN越小越好，FP 可以大一些，所以我们要求**召回率越高越好,精确率次之**\n\n### 宏平均和微平均\n\n对于求准确率还有宏平均和微平均两种方式,宏平均是对直接每个分类的准确率求平均值,而微平均要先对所有分类的预测结果求和再计算平均值,举个例子:\n\n```\n    Class A: 1 TP and 1 FP\n    Class B: 10 TP and 90 FP\n    Class C: 1 TP and 1 FP\n    Class D: 1 TP and 1 FP\n```\n对于上面的分类结果:\n\n准确率 $pA=pC=pD=0.5$, $pB=0.1$\n\n$宏平均准确率(macro-avg)=$${0.5+0.1+0.5+0.5}\\over{4}$$=0.4$\n\n$微平均准确率(micro-avg)=$${1+10+1+1}\\over{2+100+2+2}$$=0.123$\n\n\n这个例子体现了宏平均把所有分类的**权重都视为1**的问题，在进行C分类时只有0.1的准确率，并且分类C的样本数占整体的90%以上，却没有影响宏平均的结果，所以一般把宏平均改进为加权的宏平均(权重是分类样本占总数的比例):\n$macro-weight-avg=$$0.0189\\times0.5+0.943\\times0.1+0.0189\\times0.5+0.0189\\times0.5=0.123$\n\nsklearn中求宏平均/微平均的精确率,猜下结果是多少?\n```python\ny_predict = [1,0,1]\ny_true = [0,0,1]\nmacro=precision_score(y_true, y_predict,average=\"macro\")\nmicro=precision_score(y_true, y_predict,average=\"micro\")\n```\n\n## 算法选择\n### sklearn常用分类算法\n\n**决策树**: 使用树形结构,把特征作为决策树上的节点,叶节点就是分类结果,构造决策树时追求最纯净的分类结果(越纯净则分类的不确定性越低)\n\n**朴素贝叶斯**: 在你不知道事件全貌的情况下,先根据一点人生经验得到一个主观判断,然后根据后续观察结果进行修正.根据概率大小判断最后的分类,常用于文本分类\n\n**SVM**: 几何解法,先把所有样本用多维空间的向量表示,然后求一个平面将不同分类的样本分隔开\n\n**KNN**: K-Nearest Neighbor,几何解法,因为\"近朱者赤,近墨者黑\",所以对于节点A,相邻最近的K个节点是什么类型,A大概就是什么类型\n\n**集成算法**: 本着\"人多力量大\"的原则,使用多个分类器一起工作,按分类器的协作方式分为两种,bagging:分类器一起投票,看哪个分类票多;boosting:再学习,通过多次迭代强化整体的分类效果\n\n### 效果对比\n准备了训练数据24w条,测试数据2.7w条,训练数据来自上百个tag,非热门内容占比较少,测试来自两个tag,非热门数据占比更接近整体比例.\n```python\nimport pandas as pd\nfrom sklearn import naive_bayes\nfrom sklearn.ensemble import AdaBoostClassifier, RandomForestClassifier\nfrom sklearn.metrics import classification_report\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.utils import shuffle\n\nclf_list = {\n    'cart': DecisionTreeClassifier(max_depth=5),\n    # 'svm': svm.SVC(),  # 太慢了，放弃\n    # 'nb_gauss': naive_bayes.GaussianNB(), # 太差了，放弃\n    'nb_multi': naive_bayes.MultinomialNB(),\n    'k_neighbors': KNeighborsClassifier(),\n    'adaptive_boost': AdaBoostClassifier(),\n    'random_forest': RandomForestClassifier(max_depth=2)\n}\n\ndef train():\n    train_data = pd.read_json('debug/train_video.jl', lines=True)\n    train_data = shuffle(train_data)\n\n    # 特征选择\n    features = ['views', 'likes', 'comments', 'tagNumber', 'totalMedia', 'days', 'like_per_hour', 'view_per_hour']\n    train_features = train_data[features]\n    train_labels = train_data['hot']\n\n    # 测试数据\n    test_data = pd.read_json('debug/test_video.jl', lines=True)\n    test_data = shuffle(test_data)\n    test_features = test_data[features]\n    test_labels = test_data['hot']\n\n    for k, clf in clf_list.items():\n        print(f'-----{k} result-------')\n        # 决策树训练\n        clf.fit(train_features, train_labels)\n        target_names = ['normal', 'hot']\n        test_predict = clf.predict(test_features)\n        sample_weight = test_labels.replace(1, 100).replace(0, 1)\n        # 打印测试报告\n        print(classification_report(test_labels, test_predict, target_names=target_names, sample_weight=sample_weight))\n```\n在测试报告中,f1是precision/recall的综合平均分,support是分类的样本权重(默认按样本数量计算权重).因为ins内容热门数量比较少,所以我用sample_weight参数把hot分类的权重调整为normal分类的100倍,macro/weighted avg就是上面说的宏平均和加权宏平均.\n观察测试报告可以发现,CART决策树的对热门内容的召回率最高,达到92%,朴素贝叶斯次之\n```\n-----cart result-------\n              precision    recall  f1-score   support\n\n      normal       0.44      0.90      0.59   24222.0\n         hot       0.99      0.92      0.95  344800.0\n\n    accuracy                           0.92  369022.0\n   macro avg       0.72      0.91      0.77  369022.0\nweighted avg       0.96      0.92      0.93  369022.0\n\n-----nb_multi result-------\n              precision    recall  f1-score   support\n\n      normal       0.17      0.63      0.27   24222.0\n         hot       0.97      0.79      0.87  344800.0\n\n    accuracy                           0.78  369022.0\n   macro avg       0.57      0.71      0.57  369022.0\nweighted avg       0.92      0.78      0.83  369022.0\n\n-----k_neighbors result-------\n              precision    recall  f1-score   support\n\n      normal       0.11      0.69      0.20   24222.0\n         hot       0.97      0.63      0.76  344800.0\n\n    accuracy                           0.63  369022.0\n   macro avg       0.54      0.66      0.48  369022.0\nweighted avg       0.91      0.63      0.72  369022.0\n\n-----adaptive_boost result-------\n              precision    recall  f1-score   support\n\n      normal       0.08      0.99      0.15   24222.0\n         hot       1.00      0.20      0.34  344800.0\n\n    accuracy                           0.25  369022.0\n   macro avg       0.54      0.60      0.24  369022.0\nweighted avg       0.94      0.25      0.32  369022.0\n\n-----random_forest result-------\n              precision    recall  f1-score   support\n\n      normal       0.10      0.96      0.18   24222.0\n         hot       0.99      0.37      0.54  344800.0\n\n    accuracy                           0.41  369022.0\n   macro avg       0.54      0.67      0.36  369022.0\nweighted avg       0.93      0.41      0.52  369022.0\n\n```\n为了进一步验证，将测试集分为14个大小2000的子集，然后分别记录每次的测试结果，画出折线图，选择的标准是热门内容的召回率&精确率和整体的准确率，在14次测试中CART算法都表现最好。\n重复测试的代码如下：\n```python\ndef train():\n    train_data = pd.read_json('debug/train_video.jl', lines=True)\n    train_data = shuffle(train_data)\n\n    # 特征选择\n    features = ['views', 'likes', 'comments', 'tagNumber', 'totalMedia', 'days', 'like_per_hour', 'view_per_hour']\n    train_features = train_data[features]\n    train_labels = train_data['hot']\n\n    # 测试数据\n    test_data = pd.read_json('debug/test_video.jl', lines=True)\n    test_data = shuffle(test_data)\n\n    # 切分为每组大小为2000的集合\n    test_size = 2000\n    test_list = [test_data[i:i + test_size] for i in range(0, test_data.shape[0], test_size)]\n    reports = {}\n    for k, clf in clf_list.items():\n        print(f'-----{k} result-------')\n        # 决策树训练\n        clf.fit(train_features, train_labels)\n        target_names = ['normal', 'hot']\n        for test_set in test_list:\n            test_features = test_set[features]\n            test_labels = test_set['hot']\n            test_predict = clf.predict(test_features)\n            sample_weight = test_labels.replace(1, 100).replace(0, 1)\n            report = classification_report(test_labels, test_predict, target_names=target_names,\n                                           sample_weight=sample_weight, output_dict=True)\n            reports.setdefault(f'{k}_hot_recall', []).append(report['hot']['recall'])\n            reports.setdefault(f'{k}_hot_precision', []).append(report['hot']['precision'])\n            reports.setdefault(f'{k}_accuracy', []).append(report['accuracy'])\n\n    df = pd.DataFrame(reports)\n    metrics = ['hot_recall', 'hot_precision', '_accuracy']\n    fig, axes = plt.subplots(nrows=3, figsize=(16, 20))\n    for i, m in enumerate(metrics):\n        m_df = df.filter(regex=m)\n        m_df.plot(ax=axes[i], title=m, xticks=range(1, len(test_list) + 1))\n    fig.savefig(f\"debug/report.png\")\n```\n测试结果:\n<div align=center> {% asset_img report.png image %} </div>\n\n### 未解决的问题\n\n这里我们缺失了机器学习最关键的一步,那就是调参(手动狗头),总感觉使用默认参数的模型没有灵魂.因为按直觉来说随机森林和AdaBoost应该优于决策树才对,结果准确率和召回率相差都很大\n另外测试结果容易受测试集影响,当我使用只有39个样本，其中只有一个非热门内容的测试集时，决策树的召回率反而最低，所以选择测试集时要注意样本数量和真实性.\n```\n-----cart result-------\n              precision    recall  f1-score   support\n\n      normal       0.00      1.00      0.00       1.0\n         hot       1.00      0.79      0.88    3800.0\n\n    accuracy                           0.79    3801.0\n   macro avg       0.50      0.89      0.44    3801.0\nweighted avg       1.00      0.79      0.88    3801.0\n\n-----nb_multi result-------\n              precision    recall  f1-score   support\n\n      normal       0.01      1.00      0.02       1.0\n         hot       1.00      0.97      0.99    3800.0\n\n    accuracy                           0.97    3801.0\n   macro avg       0.50      0.99      0.50    3801.0\nweighted avg       1.00      0.97      0.99    3801.0\n\n```\n\n\n### 保存分类器\n\n把表现最好的CART分类器模型保存到代码文件中，然后当需要对ins内容进行分类就可以直接用模型进行判断了.保存模型时我使用的是cPickle(\n除了cPickle还可以使用joblib,python3.6直接import _pickle即可，而joblib还需要安装)\n保存非常简单,调用dump()即可\n```\nimport _pickle as cPickle\n    # 保存\n    with open('ins_hot_model.clf','wb') as f:\n        cPickle.dump(clf,f)\n```\n使用时需要从文件中加载分类器:\n```\ndef use_model():\n    # 未分类的ins文档信息\n    doc = {\"likes\": 107, \"comments\": 2, \"views\": 435.0, \"tagNumber\": 25, \"totalMedia\": 22000, \"days\": 1343,\n           \"like_per_hour\": 0, \"view_per_hour\": 0}\n    # 读取分类器       \n    clf = cPickle.load(open('ins_hot.clf', \"rb\"))\n    # 把文档转换为DataFrame\n    source = pd.DataFrame([doc], columns=list(doc.keys()))\n    features = ['views', 'likes', 'comments', 'tagNumber', 'totalMedia', 'days', 'like_per_hour', 'view_per_hour']\n    df = source[features]\n    # 为文档分类\n    print(clf.predict(df))\n```\n\n## 总结\n使用机器学习进行数据分析时,需要经过数据采集,清洗,特征选择,模型训练几个过程.借助sklearn库可以让我们在不了解算法原理的情况下也能轻松地使用机器学习进行数据分析,而对于在生产环境中用机器学习解决实际问题,还是需要丰富的经验和大量的优化验证才可以,看来要成为高薪的算法工程师也不是那么容易.\n所以,亲爱的朋友,你想成为算法大佬吗?你想学习数据分析吗?现在扫码即可8折购买参加极客时间的数据分析课程哦😯\n\n<div align=center> {% asset_img jike_ad.jpeg image %} </div>\n\n\n\n\n  [1]: https://throwsnew.com/images/example.jpg\n  [2]: https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=2143959536,453965174&fm=26&gp=0.jpg","source":"_posts/用机器学习判断ins内容是否能上热门.md","raw":"---\ntitle: 用机器学习判断ins内容是否能上热门\ndate: 2020-05-21 23:21:46\ntags: [算法]\n---\n\n## 背景\n\n假设现在要使用爬虫从ins抓取内容,在ins的网页版上每个#tag标签下都有'热门'和'最新'两部分tab页,因为热门内容的质量更好,所以希望能抓取更多热门内容,但是网页版每个#tag只显示最近的9条热门内容,不过'最新'tab下可以一直向前翻页,所以如果能从'最新'下的内容中过滤出热门内容就可以满足内容抓取质量的要求,需要找到一个能将内容分类为热门和非热门的算法.\n\n<!--more-->\n\n\n<div align=center> {% asset_img ins.png image %} </div>\n\n\n\n那么现在我来介绍一下如何使用机器学习来实现这个算法,本文主要介绍从零开始使用机器学习并解决问题的过程.不会介绍理论知识(刚好我也不懂),速战速决就完事儿了.\n\n{% asset_img gan.jpg image %}\n\n### 开始之前要了解\n\n- **python**:一种蛇\n- **instagram**: 著名被墙网站之一\n- **pandas**:数据处理类库\n- **matplotlib&seaborn**: 画图类库\n- **机器学习**: 一种对计算机算法的研究方式，算法会根据经验自动优化效果\n- **分类问题**: 把一组数据分成两类或者多类,要划分类型已提前定义\n- **sklearn**: 封装了多种机器学习算法的类库,开箱即用\n\n## 数据处理\n\nins内容有很多字段信息,首先选择出可能影响内容上热门的字段,包含点赞/曝光/评论/发布时间/抓取时间/标题包含的tag数和当前页面tag下的内容总数等,这些内容用json格式保存,示例如下:\n\n```python\n{\n    \"id\":\"CAA-r0SjtF3\",\n    \"sourceTag\":\"dharmaproductions\",\n    \"publishTime\":1589130910000,\n    \"addTime\":1589134125000,\n    \"likes\":4,\n    \"comments\":1,\n    \"views\":18,\n    \"tagNumber\":15,\n    \"description\":\"\",\n    \"totalMedia\":57149,\n    \"hot\":1\n}\n```\n\n### 数据探索\n\n这一步是为了进一步了解原始数据,检查数据真实性和字段的分布\n\n1. 用seaborn画直方图,查看热门/非热门内容的比例:\n\n```python\n    self.df = pd.read_json('debug/train_video.jl', lines=True)\n    sns.countplot(self.df['hot'], label=\"Count\")\n```\n\n<div align=center> {% asset_img hot.png image %} </div>\n\n图中热门内容占比还是比较高的,有一点脱离真实情况,实际对于ins上被活跃使用的tag,本身内容数量就很多又更新频繁,所以只有很少一部分内容能上热门.\n\n2. 用seaborn画热力图,这一步是为了查看字段之间的关系:\n```\n    self.df = pd.read_json('debug/train_video.jl', lines=True)\n    corr = self.df.corr()\n    plt.figure(figsize=(14, 14))\n    sns.heatmap(corr, annot=True)\n```\ncorr()函数会计算数据集df中各字段的相关关系,图中的颜色越浅代表越相关,可以看到like/view之前相关性比较高,如果两个字段之间相关性接近1,可以考虑去掉其中一个字段.\n\n<div align=left> {% asset_img heatmap.png image %} </div>\n\n3. 用matplotlib画频率分布直方图\n\n```python\n    def draw_histo(self):\n        plt.figure(1, figsize=(20, 20))\n        i = 810\n        for field in self.df.keys():\n            i += 1\n            # 去掉区间上数量小于10的记录\n            items = self.df.groupby(field).filter(lambda x: len(x) > 10)[field]\n            self.histogram(items=items, index=i, field=field)\n        plt.savefig('histogram.png')\n        \n        def histogram(self, items=None, index=None, field=None, y_label='Probability'):\n        \"\"\"\n        画频率直方图（带正态分布曲线）\n        :param index: 图片位置\n        :param field: 字段名\n        :param y_label:\n        :return:\n        \"\"\"\n        title = field + ' distribution'\n        if items is None:\n            items = self.df[field]\n        try:\n            plt.subplot(index)\n            mean = items.mean()\n            std = items.std()\n            x = np.arange(items.min(), items.max())\n            y = self.normfun(x=x, mu=mean, sigma=std)\n            plt.plot(x, y)\n            plt.hist(items, bins='auto', density=True, rwidth=0.9, stacked=True)\n            plt.title(title)\n            plt.xlabel(field)\n            plt.ylabel(y_label)\n            plt.tight_layout()\n        except Exception as e:\n            print(field)\n            print(e)\n\n    @staticmethod\n    def normfun(x, mu, sigma):\n        \"\"\"\n        正态分布的概率密度函数。可以理解成 x 是 mu（均值）和 sigma（标准差）的函数\n        :param x:\n        :param mu:\n        :param sigma:\n        :return:\n        \"\"\"\n        pdf = np.exp(-((x - mu) ** 2) / (2 * sigma ** 2)) / (sigma * np.sqrt(2 * np.pi))\n        return pdf    \n```\n<div align=center> {% asset_img histogram.png image %} </div>\n\n画直方图的目的是查看字段的分布类型,图中蓝色的线是正态分布函数曲线,明细like/view/comment的分布不符合正态分布,更像是长尾分布(大多数值分布在头部)\n\n\n### 数据清洗&特征选择\n因为原始数据中并没有缺失值或异常值得情况,所以忽略数据清洗的步骤,直接进行特征选择.\n首先我们不需要具体的时间戳,把发布时间publistTime和抓取时间addTime的间隔计算出来,单位是天和小时(ins热门tab中通常是最近发布的内容)\n\n```python\n    df['days'] = (pd.to_datetime(df['addTime'], unit='ms') - pd.to_datetime(df['publishTime'], unit='ms')).dt.days\n    # 不满一天的用1天替换\n    df['days'] = df['days'].replace(0, 1)\n    df['hours'] = ((pd.to_datetime(df['addTime'], unit='ms') - pd.to_datetime(df['publishTime'], unit='ms'))\n                   .dt.total_seconds() / 3600).astype(int)\n    df['hours'] = df['hours'].replace(0, 1)\n```\n\n然后因为一般内容发布越早曝光也越高,所以添加like_per_hour/view_per_hour两个特征,减弱时间影响\n\n```python\n    df['like_per_hour'] = (df['likes'] / df['hours']).astype(int)\n    df['view_per_hour'] = (df['views'] / df['hours']).astype(int)\n```\n\n最后选择的特征如下:\n\n```python\n    features = ['views', 'likes', 'comments', 'tagNumber', 'totalMedia', 'days', 'like_per_hour', 'view_per_hour']\n```\n\n## 评分标准\n\n在选择分类算法前,先来了解一下评估分类算法的常用标准\n\n### 准确率,精确率,召回率\n\n假设你开发了一款检测新冠病毒的试剂盒,那么每次检测结果有一下四种(阳性表示被检测人携带病毒):\n\nTP(True Prosivite): 真阳性,说明正确检测出病毒\n\nFP(False Prosivite): 假阳性\n\nTN(True Negative): 真阴性\n\nFN(False Negative): 假阴性,携带病毒却没有检测出来\n\n对于病毒检测来说FN的危害显然要比FP更大,而根据这几种情况的样本数量就可以计算出准确率,精确率和召回率:\n\n准确率(accuracy): ${TP+TN}\\over{TP+FP+TN+FN}$,代表全部样本的正确率\n\n精确率(precision): ${TP}\\over{TP+FP}$,代表检测为阳性时的正确率\n\n召回率(recall): ${TP}\\over{TP+FN}$,代表所有病毒携带者被检测为阳性的覆盖率,也叫查全率\n\n\n![举个例子:][1]\n\n有三个样本,检测结果为y_predict,而实际值为y_true,1代表阳性,sklearn的score函数默认返回的是阳性分类的分数\n\n```python\nfrom sklearn.metrics import accuracy_score,precision_score,recall_score\n\nif __name__ == '__main__':\n    y_predict = [1,0,1]\n    y_true = [0,0,1]\n    print(f'accuracy:{accuracy_score(y_true,y_predict)}')\n    print(f'precision:{precision_score(y_true,y_predict)}')\n    print(f'recall:{recall_score(y_true,y_predict)}')\n```\n\n输出结果为:\naccuracy:0.6666666666666666\nprecision:0.5\nrecall:1.0\n\n对于判断ins是否属于热门内容的算法,可以允许ta把非热门内容分到热门但是要尽量不遗漏热门内容，即FN越小越好，FP 可以大一些，所以我们要求**召回率越高越好,精确率次之**\n\n### 宏平均和微平均\n\n对于求准确率还有宏平均和微平均两种方式,宏平均是对直接每个分类的准确率求平均值,而微平均要先对所有分类的预测结果求和再计算平均值,举个例子:\n\n```\n    Class A: 1 TP and 1 FP\n    Class B: 10 TP and 90 FP\n    Class C: 1 TP and 1 FP\n    Class D: 1 TP and 1 FP\n```\n对于上面的分类结果:\n\n准确率 $pA=pC=pD=0.5$, $pB=0.1$\n\n$宏平均准确率(macro-avg)=$${0.5+0.1+0.5+0.5}\\over{4}$$=0.4$\n\n$微平均准确率(micro-avg)=$${1+10+1+1}\\over{2+100+2+2}$$=0.123$\n\n\n这个例子体现了宏平均把所有分类的**权重都视为1**的问题，在进行C分类时只有0.1的准确率，并且分类C的样本数占整体的90%以上，却没有影响宏平均的结果，所以一般把宏平均改进为加权的宏平均(权重是分类样本占总数的比例):\n$macro-weight-avg=$$0.0189\\times0.5+0.943\\times0.1+0.0189\\times0.5+0.0189\\times0.5=0.123$\n\nsklearn中求宏平均/微平均的精确率,猜下结果是多少?\n```python\ny_predict = [1,0,1]\ny_true = [0,0,1]\nmacro=precision_score(y_true, y_predict,average=\"macro\")\nmicro=precision_score(y_true, y_predict,average=\"micro\")\n```\n\n## 算法选择\n### sklearn常用分类算法\n\n**决策树**: 使用树形结构,把特征作为决策树上的节点,叶节点就是分类结果,构造决策树时追求最纯净的分类结果(越纯净则分类的不确定性越低)\n\n**朴素贝叶斯**: 在你不知道事件全貌的情况下,先根据一点人生经验得到一个主观判断,然后根据后续观察结果进行修正.根据概率大小判断最后的分类,常用于文本分类\n\n**SVM**: 几何解法,先把所有样本用多维空间的向量表示,然后求一个平面将不同分类的样本分隔开\n\n**KNN**: K-Nearest Neighbor,几何解法,因为\"近朱者赤,近墨者黑\",所以对于节点A,相邻最近的K个节点是什么类型,A大概就是什么类型\n\n**集成算法**: 本着\"人多力量大\"的原则,使用多个分类器一起工作,按分类器的协作方式分为两种,bagging:分类器一起投票,看哪个分类票多;boosting:再学习,通过多次迭代强化整体的分类效果\n\n### 效果对比\n准备了训练数据24w条,测试数据2.7w条,训练数据来自上百个tag,非热门内容占比较少,测试来自两个tag,非热门数据占比更接近整体比例.\n```python\nimport pandas as pd\nfrom sklearn import naive_bayes\nfrom sklearn.ensemble import AdaBoostClassifier, RandomForestClassifier\nfrom sklearn.metrics import classification_report\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.utils import shuffle\n\nclf_list = {\n    'cart': DecisionTreeClassifier(max_depth=5),\n    # 'svm': svm.SVC(),  # 太慢了，放弃\n    # 'nb_gauss': naive_bayes.GaussianNB(), # 太差了，放弃\n    'nb_multi': naive_bayes.MultinomialNB(),\n    'k_neighbors': KNeighborsClassifier(),\n    'adaptive_boost': AdaBoostClassifier(),\n    'random_forest': RandomForestClassifier(max_depth=2)\n}\n\ndef train():\n    train_data = pd.read_json('debug/train_video.jl', lines=True)\n    train_data = shuffle(train_data)\n\n    # 特征选择\n    features = ['views', 'likes', 'comments', 'tagNumber', 'totalMedia', 'days', 'like_per_hour', 'view_per_hour']\n    train_features = train_data[features]\n    train_labels = train_data['hot']\n\n    # 测试数据\n    test_data = pd.read_json('debug/test_video.jl', lines=True)\n    test_data = shuffle(test_data)\n    test_features = test_data[features]\n    test_labels = test_data['hot']\n\n    for k, clf in clf_list.items():\n        print(f'-----{k} result-------')\n        # 决策树训练\n        clf.fit(train_features, train_labels)\n        target_names = ['normal', 'hot']\n        test_predict = clf.predict(test_features)\n        sample_weight = test_labels.replace(1, 100).replace(0, 1)\n        # 打印测试报告\n        print(classification_report(test_labels, test_predict, target_names=target_names, sample_weight=sample_weight))\n```\n在测试报告中,f1是precision/recall的综合平均分,support是分类的样本权重(默认按样本数量计算权重).因为ins内容热门数量比较少,所以我用sample_weight参数把hot分类的权重调整为normal分类的100倍,macro/weighted avg就是上面说的宏平均和加权宏平均.\n观察测试报告可以发现,CART决策树的对热门内容的召回率最高,达到92%,朴素贝叶斯次之\n```\n-----cart result-------\n              precision    recall  f1-score   support\n\n      normal       0.44      0.90      0.59   24222.0\n         hot       0.99      0.92      0.95  344800.0\n\n    accuracy                           0.92  369022.0\n   macro avg       0.72      0.91      0.77  369022.0\nweighted avg       0.96      0.92      0.93  369022.0\n\n-----nb_multi result-------\n              precision    recall  f1-score   support\n\n      normal       0.17      0.63      0.27   24222.0\n         hot       0.97      0.79      0.87  344800.0\n\n    accuracy                           0.78  369022.0\n   macro avg       0.57      0.71      0.57  369022.0\nweighted avg       0.92      0.78      0.83  369022.0\n\n-----k_neighbors result-------\n              precision    recall  f1-score   support\n\n      normal       0.11      0.69      0.20   24222.0\n         hot       0.97      0.63      0.76  344800.0\n\n    accuracy                           0.63  369022.0\n   macro avg       0.54      0.66      0.48  369022.0\nweighted avg       0.91      0.63      0.72  369022.0\n\n-----adaptive_boost result-------\n              precision    recall  f1-score   support\n\n      normal       0.08      0.99      0.15   24222.0\n         hot       1.00      0.20      0.34  344800.0\n\n    accuracy                           0.25  369022.0\n   macro avg       0.54      0.60      0.24  369022.0\nweighted avg       0.94      0.25      0.32  369022.0\n\n-----random_forest result-------\n              precision    recall  f1-score   support\n\n      normal       0.10      0.96      0.18   24222.0\n         hot       0.99      0.37      0.54  344800.0\n\n    accuracy                           0.41  369022.0\n   macro avg       0.54      0.67      0.36  369022.0\nweighted avg       0.93      0.41      0.52  369022.0\n\n```\n为了进一步验证，将测试集分为14个大小2000的子集，然后分别记录每次的测试结果，画出折线图，选择的标准是热门内容的召回率&精确率和整体的准确率，在14次测试中CART算法都表现最好。\n重复测试的代码如下：\n```python\ndef train():\n    train_data = pd.read_json('debug/train_video.jl', lines=True)\n    train_data = shuffle(train_data)\n\n    # 特征选择\n    features = ['views', 'likes', 'comments', 'tagNumber', 'totalMedia', 'days', 'like_per_hour', 'view_per_hour']\n    train_features = train_data[features]\n    train_labels = train_data['hot']\n\n    # 测试数据\n    test_data = pd.read_json('debug/test_video.jl', lines=True)\n    test_data = shuffle(test_data)\n\n    # 切分为每组大小为2000的集合\n    test_size = 2000\n    test_list = [test_data[i:i + test_size] for i in range(0, test_data.shape[0], test_size)]\n    reports = {}\n    for k, clf in clf_list.items():\n        print(f'-----{k} result-------')\n        # 决策树训练\n        clf.fit(train_features, train_labels)\n        target_names = ['normal', 'hot']\n        for test_set in test_list:\n            test_features = test_set[features]\n            test_labels = test_set['hot']\n            test_predict = clf.predict(test_features)\n            sample_weight = test_labels.replace(1, 100).replace(0, 1)\n            report = classification_report(test_labels, test_predict, target_names=target_names,\n                                           sample_weight=sample_weight, output_dict=True)\n            reports.setdefault(f'{k}_hot_recall', []).append(report['hot']['recall'])\n            reports.setdefault(f'{k}_hot_precision', []).append(report['hot']['precision'])\n            reports.setdefault(f'{k}_accuracy', []).append(report['accuracy'])\n\n    df = pd.DataFrame(reports)\n    metrics = ['hot_recall', 'hot_precision', '_accuracy']\n    fig, axes = plt.subplots(nrows=3, figsize=(16, 20))\n    for i, m in enumerate(metrics):\n        m_df = df.filter(regex=m)\n        m_df.plot(ax=axes[i], title=m, xticks=range(1, len(test_list) + 1))\n    fig.savefig(f\"debug/report.png\")\n```\n测试结果:\n<div align=center> {% asset_img report.png image %} </div>\n\n### 未解决的问题\n\n这里我们缺失了机器学习最关键的一步,那就是调参(手动狗头),总感觉使用默认参数的模型没有灵魂.因为按直觉来说随机森林和AdaBoost应该优于决策树才对,结果准确率和召回率相差都很大\n另外测试结果容易受测试集影响,当我使用只有39个样本，其中只有一个非热门内容的测试集时，决策树的召回率反而最低，所以选择测试集时要注意样本数量和真实性.\n```\n-----cart result-------\n              precision    recall  f1-score   support\n\n      normal       0.00      1.00      0.00       1.0\n         hot       1.00      0.79      0.88    3800.0\n\n    accuracy                           0.79    3801.0\n   macro avg       0.50      0.89      0.44    3801.0\nweighted avg       1.00      0.79      0.88    3801.0\n\n-----nb_multi result-------\n              precision    recall  f1-score   support\n\n      normal       0.01      1.00      0.02       1.0\n         hot       1.00      0.97      0.99    3800.0\n\n    accuracy                           0.97    3801.0\n   macro avg       0.50      0.99      0.50    3801.0\nweighted avg       1.00      0.97      0.99    3801.0\n\n```\n\n\n### 保存分类器\n\n把表现最好的CART分类器模型保存到代码文件中，然后当需要对ins内容进行分类就可以直接用模型进行判断了.保存模型时我使用的是cPickle(\n除了cPickle还可以使用joblib,python3.6直接import _pickle即可，而joblib还需要安装)\n保存非常简单,调用dump()即可\n```\nimport _pickle as cPickle\n    # 保存\n    with open('ins_hot_model.clf','wb') as f:\n        cPickle.dump(clf,f)\n```\n使用时需要从文件中加载分类器:\n```\ndef use_model():\n    # 未分类的ins文档信息\n    doc = {\"likes\": 107, \"comments\": 2, \"views\": 435.0, \"tagNumber\": 25, \"totalMedia\": 22000, \"days\": 1343,\n           \"like_per_hour\": 0, \"view_per_hour\": 0}\n    # 读取分类器       \n    clf = cPickle.load(open('ins_hot.clf', \"rb\"))\n    # 把文档转换为DataFrame\n    source = pd.DataFrame([doc], columns=list(doc.keys()))\n    features = ['views', 'likes', 'comments', 'tagNumber', 'totalMedia', 'days', 'like_per_hour', 'view_per_hour']\n    df = source[features]\n    # 为文档分类\n    print(clf.predict(df))\n```\n\n## 总结\n使用机器学习进行数据分析时,需要经过数据采集,清洗,特征选择,模型训练几个过程.借助sklearn库可以让我们在不了解算法原理的情况下也能轻松地使用机器学习进行数据分析,而对于在生产环境中用机器学习解决实际问题,还是需要丰富的经验和大量的优化验证才可以,看来要成为高薪的算法工程师也不是那么容易.\n所以,亲爱的朋友,你想成为算法大佬吗?你想学习数据分析吗?现在扫码即可8折购买参加极客时间的数据分析课程哦😯\n\n<div align=center> {% asset_img jike_ad.jpeg image %} </div>\n\n\n\n\n  [1]: https://throwsnew.com/images/example.jpg\n  [2]: https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=2143959536,453965174&fm=26&gp=0.jpg","slug":"用机器学习判断ins内容是否能上热门","published":1,"updated":"2020-05-22T16:50:23.200Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkqle1dv003ecynenaq99b7r","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>假设现在要使用爬虫从ins抓取内容,在ins的网页版上每个#tag标签下都有’热门’和’最新’两部分tab页,因为热门内容的质量更好,所以希望能抓取更多热门内容,但是网页版每个#tag只显示最近的9条热门内容,不过’最新’tab下可以一直向前翻页,所以如果能从’最新’下的内容中过滤出热门内容就可以满足内容抓取质量的要求,需要找到一个能将内容分类为热门和非热门的算法.</p>\n<a id=\"more\"></a>\n<div align=\"center\"> <img src=\"/2020/05/21/用机器学习判断ins内容是否能上热门/ins.png\" title=\"image\"> </div>\n\n\n\n<p>那么现在我来介绍一下如何使用机器学习来实现这个算法,本文主要介绍从零开始使用机器学习并解决问题的过程.不会介绍理论知识(刚好我也不懂),速战速决就完事儿了.</p>\n<img src=\"/2020/05/21/用机器学习判断ins内容是否能上热门/gan.jpg\" title=\"image\">\n<h3 id=\"开始之前要了解\"><a href=\"#开始之前要了解\" class=\"headerlink\" title=\"开始之前要了解\"></a>开始之前要了解</h3><ul>\n<li><strong>python</strong>:一种蛇</li>\n<li><strong>instagram</strong>: 著名被墙网站之一</li>\n<li><strong>pandas</strong>:数据处理类库</li>\n<li><strong>matplotlib&amp;seaborn</strong>: 画图类库</li>\n<li><strong>机器学习</strong>: 一种对计算机算法的研究方式，算法会根据经验自动优化效果</li>\n<li><strong>分类问题</strong>: 把一组数据分成两类或者多类,要划分类型已提前定义</li>\n<li><strong>sklearn</strong>: 封装了多种机器学习算法的类库,开箱即用</li>\n</ul>\n<h2 id=\"数据处理\"><a href=\"#数据处理\" class=\"headerlink\" title=\"数据处理\"></a>数据处理</h2><p>ins内容有很多字段信息,首先选择出可能影响内容上热门的字段,包含点赞/曝光/评论/发布时间/抓取时间/标题包含的tag数和当前页面tag下的内容总数等,这些内容用json格式保存,示例如下:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">\"id\"</span>:<span class=\"string\">\"CAA-r0SjtF3\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"sourceTag\"</span>:<span class=\"string\">\"dharmaproductions\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"publishTime\"</span>:<span class=\"number\">1589130910000</span>,</span><br><span class=\"line\">    <span class=\"string\">\"addTime\"</span>:<span class=\"number\">1589134125000</span>,</span><br><span class=\"line\">    <span class=\"string\">\"likes\"</span>:<span class=\"number\">4</span>,</span><br><span class=\"line\">    <span class=\"string\">\"comments\"</span>:<span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"string\">\"views\"</span>:<span class=\"number\">18</span>,</span><br><span class=\"line\">    <span class=\"string\">\"tagNumber\"</span>:<span class=\"number\">15</span>,</span><br><span class=\"line\">    <span class=\"string\">\"description\"</span>:<span class=\"string\">\"\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"totalMedia\"</span>:<span class=\"number\">57149</span>,</span><br><span class=\"line\">    <span class=\"string\">\"hot\"</span>:<span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"数据探索\"><a href=\"#数据探索\" class=\"headerlink\" title=\"数据探索\"></a>数据探索</h3><p>这一步是为了进一步了解原始数据,检查数据真实性和字段的分布</p>\n<ol>\n<li>用seaborn画直方图,查看热门/非热门内容的比例:</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.df = pd.read_json(<span class=\"string\">'debug/train_video.jl'</span>, lines=<span class=\"keyword\">True</span>)</span><br><span class=\"line\">sns.countplot(self.df[<span class=\"string\">'hot'</span>], label=<span class=\"string\">\"Count\"</span>)</span><br></pre></td></tr></table></figure>\n<div align=\"center\"> <img src=\"/2020/05/21/用机器学习判断ins内容是否能上热门/hot.png\" title=\"image\"> </div>\n\n<p>图中热门内容占比还是比较高的,有一点脱离真实情况,实际对于ins上被活跃使用的tag,本身内容数量就很多又更新频繁,所以只有很少一部分内容能上热门.</p>\n<ol start=\"2\">\n<li>用seaborn画热力图,这一步是为了查看字段之间的关系:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.df = pd.read_json(&apos;debug/train_video.jl&apos;, lines=True)</span><br><span class=\"line\">corr = self.df.corr()</span><br><span class=\"line\">plt.figure(figsize=(14, 14))</span><br><span class=\"line\">sns.heatmap(corr, annot=True)</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>corr()函数会计算数据集df中各字段的相关关系,图中的颜色越浅代表越相关,可以看到like/view之前相关性比较高,如果两个字段之间相关性接近1,可以考虑去掉其中一个字段.</p>\n<div align=\"left\"> <img src=\"/2020/05/21/用机器学习判断ins内容是否能上热门/heatmap.png\" title=\"image\"> </div>\n\n<ol start=\"3\">\n<li>用matplotlib画频率分布直方图</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">draw_histo</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">    plt.figure(<span class=\"number\">1</span>, figsize=(<span class=\"number\">20</span>, <span class=\"number\">20</span>))</span><br><span class=\"line\">    i = <span class=\"number\">810</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> field <span class=\"keyword\">in</span> self.df.keys():</span><br><span class=\"line\">        i += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"comment\"># 去掉区间上数量小于10的记录</span></span><br><span class=\"line\">        items = self.df.groupby(field).filter(<span class=\"keyword\">lambda</span> x: len(x) &gt; <span class=\"number\">10</span>)[field]</span><br><span class=\"line\">        self.histogram(items=items, index=i, field=field)</span><br><span class=\"line\">    plt.savefig(<span class=\"string\">'histogram.png'</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">histogram</span><span class=\"params\">(self, items=None, index=None, field=None, y_label=<span class=\"string\">'Probability'</span>)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">    画频率直方图（带正态分布曲线）</span></span><br><span class=\"line\"><span class=\"string\">    :param index: 图片位置</span></span><br><span class=\"line\"><span class=\"string\">    :param field: 字段名</span></span><br><span class=\"line\"><span class=\"string\">    :param y_label:</span></span><br><span class=\"line\"><span class=\"string\">    :return:</span></span><br><span class=\"line\"><span class=\"string\">    \"\"\"</span></span><br><span class=\"line\">    title = field + <span class=\"string\">' distribution'</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> items <span class=\"keyword\">is</span> <span class=\"keyword\">None</span>:</span><br><span class=\"line\">        items = self.df[field]</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        plt.subplot(index)</span><br><span class=\"line\">        mean = items.mean()</span><br><span class=\"line\">        std = items.std()</span><br><span class=\"line\">        x = np.arange(items.min(), items.max())</span><br><span class=\"line\">        y = self.normfun(x=x, mu=mean, sigma=std)</span><br><span class=\"line\">        plt.plot(x, y)</span><br><span class=\"line\">        plt.hist(items, bins=<span class=\"string\">'auto'</span>, density=<span class=\"keyword\">True</span>, rwidth=<span class=\"number\">0.9</span>, stacked=<span class=\"keyword\">True</span>)</span><br><span class=\"line\">        plt.title(title)</span><br><span class=\"line\">        plt.xlabel(field)</span><br><span class=\"line\">        plt.ylabel(y_label)</span><br><span class=\"line\">        plt.tight_layout()</span><br><span class=\"line\">    <span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">        print(field)</span><br><span class=\"line\">        print(e)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@staticmethod</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">normfun</span><span class=\"params\">(x, mu, sigma)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">    正态分布的概率密度函数。可以理解成 x 是 mu（均值）和 sigma（标准差）的函数</span></span><br><span class=\"line\"><span class=\"string\">    :param x:</span></span><br><span class=\"line\"><span class=\"string\">    :param mu:</span></span><br><span class=\"line\"><span class=\"string\">    :param sigma:</span></span><br><span class=\"line\"><span class=\"string\">    :return:</span></span><br><span class=\"line\"><span class=\"string\">    \"\"\"</span></span><br><span class=\"line\">    pdf = np.exp(-((x - mu) ** <span class=\"number\">2</span>) / (<span class=\"number\">2</span> * sigma ** <span class=\"number\">2</span>)) / (sigma * np.sqrt(<span class=\"number\">2</span> * np.pi))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pdf</span><br></pre></td></tr></table></figure>\n<div align=\"center\"> <img src=\"/2020/05/21/用机器学习判断ins内容是否能上热门/histogram.png\" title=\"image\"> </div>\n\n<p>画直方图的目的是查看字段的分布类型,图中蓝色的线是正态分布函数曲线,明细like/view/comment的分布不符合正态分布,更像是长尾分布(大多数值分布在头部)</p>\n<h3 id=\"数据清洗-amp-特征选择\"><a href=\"#数据清洗-amp-特征选择\" class=\"headerlink\" title=\"数据清洗&amp;特征选择\"></a>数据清洗&amp;特征选择</h3><p>因为原始数据中并没有缺失值或异常值得情况,所以忽略数据清洗的步骤,直接进行特征选择.<br>首先我们不需要具体的时间戳,把发布时间publistTime和抓取时间addTime的间隔计算出来,单位是天和小时(ins热门tab中通常是最近发布的内容)</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">df[<span class=\"string\">'days'</span>] = (pd.to_datetime(df[<span class=\"string\">'addTime'</span>], unit=<span class=\"string\">'ms'</span>) - pd.to_datetime(df[<span class=\"string\">'publishTime'</span>], unit=<span class=\"string\">'ms'</span>)).dt.days</span><br><span class=\"line\"><span class=\"comment\"># 不满一天的用1天替换</span></span><br><span class=\"line\">df[<span class=\"string\">'days'</span>] = df[<span class=\"string\">'days'</span>].replace(<span class=\"number\">0</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">df[<span class=\"string\">'hours'</span>] = ((pd.to_datetime(df[<span class=\"string\">'addTime'</span>], unit=<span class=\"string\">'ms'</span>) - pd.to_datetime(df[<span class=\"string\">'publishTime'</span>], unit=<span class=\"string\">'ms'</span>))</span><br><span class=\"line\">               .dt.total_seconds() / <span class=\"number\">3600</span>).astype(int)</span><br><span class=\"line\">df[<span class=\"string\">'hours'</span>] = df[<span class=\"string\">'hours'</span>].replace(<span class=\"number\">0</span>, <span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n<p>然后因为一般内容发布越早曝光也越高,所以添加like_per_hour/view_per_hour两个特征,减弱时间影响</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">df[<span class=\"string\">'like_per_hour'</span>] = (df[<span class=\"string\">'likes'</span>] / df[<span class=\"string\">'hours'</span>]).astype(int)</span><br><span class=\"line\">df[<span class=\"string\">'view_per_hour'</span>] = (df[<span class=\"string\">'views'</span>] / df[<span class=\"string\">'hours'</span>]).astype(int)</span><br></pre></td></tr></table></figure>\n<p>最后选择的特征如下:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">features = [<span class=\"string\">'views'</span>, <span class=\"string\">'likes'</span>, <span class=\"string\">'comments'</span>, <span class=\"string\">'tagNumber'</span>, <span class=\"string\">'totalMedia'</span>, <span class=\"string\">'days'</span>, <span class=\"string\">'like_per_hour'</span>, <span class=\"string\">'view_per_hour'</span>]</span><br></pre></td></tr></table></figure>\n<h2 id=\"评分标准\"><a href=\"#评分标准\" class=\"headerlink\" title=\"评分标准\"></a>评分标准</h2><p>在选择分类算法前,先来了解一下评估分类算法的常用标准</p>\n<h3 id=\"准确率-精确率-召回率\"><a href=\"#准确率-精确率-召回率\" class=\"headerlink\" title=\"准确率,精确率,召回率\"></a>准确率,精确率,召回率</h3><p>假设你开发了一款检测新冠病毒的试剂盒,那么每次检测结果有一下四种(阳性表示被检测人携带病毒):</p>\n<p>TP(True Prosivite): 真阳性,说明正确检测出病毒</p>\n<p>FP(False Prosivite): 假阳性</p>\n<p>TN(True Negative): 真阴性</p>\n<p>FN(False Negative): 假阴性,携带病毒却没有检测出来</p>\n<p>对于病毒检测来说FN的危害显然要比FP更大,而根据这几种情况的样本数量就可以计算出准确率,精确率和召回率:</p>\n<p>准确率(accuracy): ${TP+TN}\\over{TP+FP+TN+FN}$,代表全部样本的正确率</p>\n<p>精确率(precision): ${TP}\\over{TP+FP}$,代表检测为阳性时的正确率</p>\n<p>召回率(recall): ${TP}\\over{TP+FN}$,代表所有病毒携带者被检测为阳性的覆盖率,也叫查全率</p>\n<p><img src=\"https://throwsnew.com/images/example.jpg\" alt=\"举个例子:\"></p>\n<p>有三个样本,检测结果为y_predict,而实际值为y_true,1代表阳性,sklearn的score函数默认返回的是阳性分类的分数</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> sklearn.metrics <span class=\"keyword\">import</span> accuracy_score,precision_score,recall_score</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    y_predict = [<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>]</span><br><span class=\"line\">    y_true = [<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>]</span><br><span class=\"line\">    print(<span class=\"string\">f'accuracy:<span class=\"subst\">&#123;accuracy_score(y_true,y_predict)&#125;</span>'</span>)</span><br><span class=\"line\">    print(<span class=\"string\">f'precision:<span class=\"subst\">&#123;precision_score(y_true,y_predict)&#125;</span>'</span>)</span><br><span class=\"line\">    print(<span class=\"string\">f'recall:<span class=\"subst\">&#123;recall_score(y_true,y_predict)&#125;</span>'</span>)</span><br></pre></td></tr></table></figure>\n<p>输出结果为:<br>accuracy:0.6666666666666666<br>precision:0.5<br>recall:1.0</p>\n<p>对于判断ins是否属于热门内容的算法,可以允许ta把非热门内容分到热门但是要尽量不遗漏热门内容，即FN越小越好，FP 可以大一些，所以我们要求<strong>召回率越高越好,精确率次之</strong></p>\n<h3 id=\"宏平均和微平均\"><a href=\"#宏平均和微平均\" class=\"headerlink\" title=\"宏平均和微平均\"></a>宏平均和微平均</h3><p>对于求准确率还有宏平均和微平均两种方式,宏平均是对直接每个分类的准确率求平均值,而微平均要先对所有分类的预测结果求和再计算平均值,举个例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class A: 1 TP and 1 FP</span><br><span class=\"line\">Class B: 10 TP and 90 FP</span><br><span class=\"line\">Class C: 1 TP and 1 FP</span><br><span class=\"line\">Class D: 1 TP and 1 FP</span><br></pre></td></tr></table></figure>\n<p>对于上面的分类结果:</p>\n<p>准确率 $pA=pC=pD=0.5$, $pB=0.1$</p>\n<p>$宏平均准确率(macro-avg)=$${0.5+0.1+0.5+0.5}\\over{4}$$=0.4$</p>\n<p>$微平均准确率(micro-avg)=$${1+10+1+1}\\over{2+100+2+2}$$=0.123$</p>\n<p>这个例子体现了宏平均把所有分类的<strong>权重都视为1</strong>的问题，在进行C分类时只有0.1的准确率，并且分类C的样本数占整体的90%以上，却没有影响宏平均的结果，所以一般把宏平均改进为加权的宏平均(权重是分类样本占总数的比例):<br>$macro-weight-avg=$$0.0189\\times0.5+0.943\\times0.1+0.0189\\times0.5+0.0189\\times0.5=0.123$</p>\n<p>sklearn中求宏平均/微平均的精确率,猜下结果是多少?<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">y_predict = [<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>]</span><br><span class=\"line\">y_true = [<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>]</span><br><span class=\"line\">macro=precision_score(y_true, y_predict,average=<span class=\"string\">\"macro\"</span>)</span><br><span class=\"line\">micro=precision_score(y_true, y_predict,average=<span class=\"string\">\"micro\"</span>)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"算法选择\"><a href=\"#算法选择\" class=\"headerlink\" title=\"算法选择\"></a>算法选择</h2><h3 id=\"sklearn常用分类算法\"><a href=\"#sklearn常用分类算法\" class=\"headerlink\" title=\"sklearn常用分类算法\"></a>sklearn常用分类算法</h3><p><strong>决策树</strong>: 使用树形结构,把特征作为决策树上的节点,叶节点就是分类结果,构造决策树时追求最纯净的分类结果(越纯净则分类的不确定性越低)</p>\n<p><strong>朴素贝叶斯</strong>: 在你不知道事件全貌的情况下,先根据一点人生经验得到一个主观判断,然后根据后续观察结果进行修正.根据概率大小判断最后的分类,常用于文本分类</p>\n<p><strong>SVM</strong>: 几何解法,先把所有样本用多维空间的向量表示,然后求一个平面将不同分类的样本分隔开</p>\n<p><strong>KNN</strong>: K-Nearest Neighbor,几何解法,因为”近朱者赤,近墨者黑”,所以对于节点A,相邻最近的K个节点是什么类型,A大概就是什么类型</p>\n<p><strong>集成算法</strong>: 本着”人多力量大”的原则,使用多个分类器一起工作,按分类器的协作方式分为两种,bagging:分类器一起投票,看哪个分类票多;boosting:再学习,通过多次迭代强化整体的分类效果</p>\n<h3 id=\"效果对比\"><a href=\"#效果对比\" class=\"headerlink\" title=\"效果对比\"></a>效果对比</h3><p>准备了训练数据24w条,测试数据2.7w条,训练数据来自上百个tag,非热门内容占比较少,测试来自两个tag,非热门数据占比更接近整体比例.<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn <span class=\"keyword\">import</span> naive_bayes</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn.ensemble <span class=\"keyword\">import</span> AdaBoostClassifier, RandomForestClassifier</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn.metrics <span class=\"keyword\">import</span> classification_report</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn.neighbors <span class=\"keyword\">import</span> KNeighborsClassifier</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn.tree <span class=\"keyword\">import</span> DecisionTreeClassifier</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn.utils <span class=\"keyword\">import</span> shuffle</span><br><span class=\"line\"></span><br><span class=\"line\">clf_list = &#123;</span><br><span class=\"line\">    <span class=\"string\">'cart'</span>: DecisionTreeClassifier(max_depth=<span class=\"number\">5</span>),</span><br><span class=\"line\">    <span class=\"comment\"># 'svm': svm.SVC(),  # 太慢了，放弃</span></span><br><span class=\"line\">    <span class=\"comment\"># 'nb_gauss': naive_bayes.GaussianNB(), # 太差了，放弃</span></span><br><span class=\"line\">    <span class=\"string\">'nb_multi'</span>: naive_bayes.MultinomialNB(),</span><br><span class=\"line\">    <span class=\"string\">'k_neighbors'</span>: KNeighborsClassifier(),</span><br><span class=\"line\">    <span class=\"string\">'adaptive_boost'</span>: AdaBoostClassifier(),</span><br><span class=\"line\">    <span class=\"string\">'random_forest'</span>: RandomForestClassifier(max_depth=<span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">train</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    train_data = pd.read_json(<span class=\"string\">'debug/train_video.jl'</span>, lines=<span class=\"keyword\">True</span>)</span><br><span class=\"line\">    train_data = shuffle(train_data)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 特征选择</span></span><br><span class=\"line\">    features = [<span class=\"string\">'views'</span>, <span class=\"string\">'likes'</span>, <span class=\"string\">'comments'</span>, <span class=\"string\">'tagNumber'</span>, <span class=\"string\">'totalMedia'</span>, <span class=\"string\">'days'</span>, <span class=\"string\">'like_per_hour'</span>, <span class=\"string\">'view_per_hour'</span>]</span><br><span class=\"line\">    train_features = train_data[features]</span><br><span class=\"line\">    train_labels = train_data[<span class=\"string\">'hot'</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 测试数据</span></span><br><span class=\"line\">    test_data = pd.read_json(<span class=\"string\">'debug/test_video.jl'</span>, lines=<span class=\"keyword\">True</span>)</span><br><span class=\"line\">    test_data = shuffle(test_data)</span><br><span class=\"line\">    test_features = test_data[features]</span><br><span class=\"line\">    test_labels = test_data[<span class=\"string\">'hot'</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> k, clf <span class=\"keyword\">in</span> clf_list.items():</span><br><span class=\"line\">        print(<span class=\"string\">f'-----<span class=\"subst\">&#123;k&#125;</span> result-------'</span>)</span><br><span class=\"line\">        <span class=\"comment\"># 决策树训练</span></span><br><span class=\"line\">        clf.fit(train_features, train_labels)</span><br><span class=\"line\">        target_names = [<span class=\"string\">'normal'</span>, <span class=\"string\">'hot'</span>]</span><br><span class=\"line\">        test_predict = clf.predict(test_features)</span><br><span class=\"line\">        sample_weight = test_labels.replace(<span class=\"number\">1</span>, <span class=\"number\">100</span>).replace(<span class=\"number\">0</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"comment\"># 打印测试报告</span></span><br><span class=\"line\">        print(classification_report(test_labels, test_predict, target_names=target_names, sample_weight=sample_weight))</span><br></pre></td></tr></table></figure></p>\n<p>在测试报告中,f1是precision/recall的综合平均分,support是分类的样本权重(默认按样本数量计算权重).因为ins内容热门数量比较少,所以我用sample_weight参数把hot分类的权重调整为normal分类的100倍,macro/weighted avg就是上面说的宏平均和加权宏平均.<br>观察测试报告可以发现,CART决策树的对热门内容的召回率最高,达到92%,朴素贝叶斯次之<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-----cart result-------</span><br><span class=\"line\">              precision    recall  f1-score   support</span><br><span class=\"line\"></span><br><span class=\"line\">      normal       0.44      0.90      0.59   24222.0</span><br><span class=\"line\">         hot       0.99      0.92      0.95  344800.0</span><br><span class=\"line\"></span><br><span class=\"line\">    accuracy                           0.92  369022.0</span><br><span class=\"line\">   macro avg       0.72      0.91      0.77  369022.0</span><br><span class=\"line\">weighted avg       0.96      0.92      0.93  369022.0</span><br><span class=\"line\"></span><br><span class=\"line\">-----nb_multi result-------</span><br><span class=\"line\">              precision    recall  f1-score   support</span><br><span class=\"line\"></span><br><span class=\"line\">      normal       0.17      0.63      0.27   24222.0</span><br><span class=\"line\">         hot       0.97      0.79      0.87  344800.0</span><br><span class=\"line\"></span><br><span class=\"line\">    accuracy                           0.78  369022.0</span><br><span class=\"line\">   macro avg       0.57      0.71      0.57  369022.0</span><br><span class=\"line\">weighted avg       0.92      0.78      0.83  369022.0</span><br><span class=\"line\"></span><br><span class=\"line\">-----k_neighbors result-------</span><br><span class=\"line\">              precision    recall  f1-score   support</span><br><span class=\"line\"></span><br><span class=\"line\">      normal       0.11      0.69      0.20   24222.0</span><br><span class=\"line\">         hot       0.97      0.63      0.76  344800.0</span><br><span class=\"line\"></span><br><span class=\"line\">    accuracy                           0.63  369022.0</span><br><span class=\"line\">   macro avg       0.54      0.66      0.48  369022.0</span><br><span class=\"line\">weighted avg       0.91      0.63      0.72  369022.0</span><br><span class=\"line\"></span><br><span class=\"line\">-----adaptive_boost result-------</span><br><span class=\"line\">              precision    recall  f1-score   support</span><br><span class=\"line\"></span><br><span class=\"line\">      normal       0.08      0.99      0.15   24222.0</span><br><span class=\"line\">         hot       1.00      0.20      0.34  344800.0</span><br><span class=\"line\"></span><br><span class=\"line\">    accuracy                           0.25  369022.0</span><br><span class=\"line\">   macro avg       0.54      0.60      0.24  369022.0</span><br><span class=\"line\">weighted avg       0.94      0.25      0.32  369022.0</span><br><span class=\"line\"></span><br><span class=\"line\">-----random_forest result-------</span><br><span class=\"line\">              precision    recall  f1-score   support</span><br><span class=\"line\"></span><br><span class=\"line\">      normal       0.10      0.96      0.18   24222.0</span><br><span class=\"line\">         hot       0.99      0.37      0.54  344800.0</span><br><span class=\"line\"></span><br><span class=\"line\">    accuracy                           0.41  369022.0</span><br><span class=\"line\">   macro avg       0.54      0.67      0.36  369022.0</span><br><span class=\"line\">weighted avg       0.93      0.41      0.52  369022.0</span><br></pre></td></tr></table></figure></p>\n<p>为了进一步验证，将测试集分为14个大小2000的子集，然后分别记录每次的测试结果，画出折线图，选择的标准是热门内容的召回率&amp;精确率和整体的准确率，在14次测试中CART算法都表现最好。<br>重复测试的代码如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">train</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    train_data = pd.read_json(<span class=\"string\">'debug/train_video.jl'</span>, lines=<span class=\"keyword\">True</span>)</span><br><span class=\"line\">    train_data = shuffle(train_data)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 特征选择</span></span><br><span class=\"line\">    features = [<span class=\"string\">'views'</span>, <span class=\"string\">'likes'</span>, <span class=\"string\">'comments'</span>, <span class=\"string\">'tagNumber'</span>, <span class=\"string\">'totalMedia'</span>, <span class=\"string\">'days'</span>, <span class=\"string\">'like_per_hour'</span>, <span class=\"string\">'view_per_hour'</span>]</span><br><span class=\"line\">    train_features = train_data[features]</span><br><span class=\"line\">    train_labels = train_data[<span class=\"string\">'hot'</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 测试数据</span></span><br><span class=\"line\">    test_data = pd.read_json(<span class=\"string\">'debug/test_video.jl'</span>, lines=<span class=\"keyword\">True</span>)</span><br><span class=\"line\">    test_data = shuffle(test_data)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 切分为每组大小为2000的集合</span></span><br><span class=\"line\">    test_size = <span class=\"number\">2000</span></span><br><span class=\"line\">    test_list = [test_data[i:i + test_size] <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, test_data.shape[<span class=\"number\">0</span>], test_size)]</span><br><span class=\"line\">    reports = &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> k, clf <span class=\"keyword\">in</span> clf_list.items():</span><br><span class=\"line\">        print(<span class=\"string\">f'-----<span class=\"subst\">&#123;k&#125;</span> result-------'</span>)</span><br><span class=\"line\">        <span class=\"comment\"># 决策树训练</span></span><br><span class=\"line\">        clf.fit(train_features, train_labels)</span><br><span class=\"line\">        target_names = [<span class=\"string\">'normal'</span>, <span class=\"string\">'hot'</span>]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> test_set <span class=\"keyword\">in</span> test_list:</span><br><span class=\"line\">            test_features = test_set[features]</span><br><span class=\"line\">            test_labels = test_set[<span class=\"string\">'hot'</span>]</span><br><span class=\"line\">            test_predict = clf.predict(test_features)</span><br><span class=\"line\">            sample_weight = test_labels.replace(<span class=\"number\">1</span>, <span class=\"number\">100</span>).replace(<span class=\"number\">0</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">            report = classification_report(test_labels, test_predict, target_names=target_names,</span><br><span class=\"line\">                                           sample_weight=sample_weight, output_dict=<span class=\"keyword\">True</span>)</span><br><span class=\"line\">            reports.setdefault(<span class=\"string\">f'<span class=\"subst\">&#123;k&#125;</span>_hot_recall'</span>, []).append(report[<span class=\"string\">'hot'</span>][<span class=\"string\">'recall'</span>])</span><br><span class=\"line\">            reports.setdefault(<span class=\"string\">f'<span class=\"subst\">&#123;k&#125;</span>_hot_precision'</span>, []).append(report[<span class=\"string\">'hot'</span>][<span class=\"string\">'precision'</span>])</span><br><span class=\"line\">            reports.setdefault(<span class=\"string\">f'<span class=\"subst\">&#123;k&#125;</span>_accuracy'</span>, []).append(report[<span class=\"string\">'accuracy'</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">    df = pd.DataFrame(reports)</span><br><span class=\"line\">    metrics = [<span class=\"string\">'hot_recall'</span>, <span class=\"string\">'hot_precision'</span>, <span class=\"string\">'_accuracy'</span>]</span><br><span class=\"line\">    fig, axes = plt.subplots(nrows=<span class=\"number\">3</span>, figsize=(<span class=\"number\">16</span>, <span class=\"number\">20</span>))</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, m <span class=\"keyword\">in</span> enumerate(metrics):</span><br><span class=\"line\">        m_df = df.filter(regex=m)</span><br><span class=\"line\">        m_df.plot(ax=axes[i], title=m, xticks=range(<span class=\"number\">1</span>, len(test_list) + <span class=\"number\">1</span>))</span><br><span class=\"line\">    fig.savefig(<span class=\"string\">f\"debug/report.png\"</span>)</span><br></pre></td></tr></table></figure></p>\n<p>测试结果:</p>\n<div align=\"center\"> <img src=\"/2020/05/21/用机器学习判断ins内容是否能上热门/report.png\" title=\"image\"> </div>\n\n<h3 id=\"未解决的问题\"><a href=\"#未解决的问题\" class=\"headerlink\" title=\"未解决的问题\"></a>未解决的问题</h3><p>这里我们缺失了机器学习最关键的一步,那就是调参(手动狗头),总感觉使用默认参数的模型没有灵魂.因为按直觉来说随机森林和AdaBoost应该优于决策树才对,结果准确率和召回率相差都很大<br>另外测试结果容易受测试集影响,当我使用只有39个样本，其中只有一个非热门内容的测试集时，决策树的召回率反而最低，所以选择测试集时要注意样本数量和真实性.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-----cart result-------</span><br><span class=\"line\">              precision    recall  f1-score   support</span><br><span class=\"line\"></span><br><span class=\"line\">      normal       0.00      1.00      0.00       1.0</span><br><span class=\"line\">         hot       1.00      0.79      0.88    3800.0</span><br><span class=\"line\"></span><br><span class=\"line\">    accuracy                           0.79    3801.0</span><br><span class=\"line\">   macro avg       0.50      0.89      0.44    3801.0</span><br><span class=\"line\">weighted avg       1.00      0.79      0.88    3801.0</span><br><span class=\"line\"></span><br><span class=\"line\">-----nb_multi result-------</span><br><span class=\"line\">              precision    recall  f1-score   support</span><br><span class=\"line\"></span><br><span class=\"line\">      normal       0.01      1.00      0.02       1.0</span><br><span class=\"line\">         hot       1.00      0.97      0.99    3800.0</span><br><span class=\"line\"></span><br><span class=\"line\">    accuracy                           0.97    3801.0</span><br><span class=\"line\">   macro avg       0.50      0.99      0.50    3801.0</span><br><span class=\"line\">weighted avg       1.00      0.97      0.99    3801.0</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"保存分类器\"><a href=\"#保存分类器\" class=\"headerlink\" title=\"保存分类器\"></a>保存分类器</h3><p>把表现最好的CART分类器模型保存到代码文件中，然后当需要对ins内容进行分类就可以直接用模型进行判断了.保存模型时我使用的是cPickle(<br>除了cPickle还可以使用joblib,python3.6直接import _pickle即可，而joblib还需要安装)<br>保存非常简单,调用dump()即可<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import _pickle as cPickle</span><br><span class=\"line\">    # 保存</span><br><span class=\"line\">    with open(&apos;ins_hot_model.clf&apos;,&apos;wb&apos;) as f:</span><br><span class=\"line\">        cPickle.dump(clf,f)</span><br></pre></td></tr></table></figure></p>\n<p>使用时需要从文件中加载分类器:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def use_model():</span><br><span class=\"line\">    # 未分类的ins文档信息</span><br><span class=\"line\">    doc = &#123;&quot;likes&quot;: 107, &quot;comments&quot;: 2, &quot;views&quot;: 435.0, &quot;tagNumber&quot;: 25, &quot;totalMedia&quot;: 22000, &quot;days&quot;: 1343,</span><br><span class=\"line\">           &quot;like_per_hour&quot;: 0, &quot;view_per_hour&quot;: 0&#125;</span><br><span class=\"line\">    # 读取分类器       </span><br><span class=\"line\">    clf = cPickle.load(open(&apos;ins_hot.clf&apos;, &quot;rb&quot;))</span><br><span class=\"line\">    # 把文档转换为DataFrame</span><br><span class=\"line\">    source = pd.DataFrame([doc], columns=list(doc.keys()))</span><br><span class=\"line\">    features = [&apos;views&apos;, &apos;likes&apos;, &apos;comments&apos;, &apos;tagNumber&apos;, &apos;totalMedia&apos;, &apos;days&apos;, &apos;like_per_hour&apos;, &apos;view_per_hour&apos;]</span><br><span class=\"line\">    df = source[features]</span><br><span class=\"line\">    # 为文档分类</span><br><span class=\"line\">    print(clf.predict(df))</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>使用机器学习进行数据分析时,需要经过数据采集,清洗,特征选择,模型训练几个过程.借助sklearn库可以让我们在不了解算法原理的情况下也能轻松地使用机器学习进行数据分析,而对于在生产环境中用机器学习解决实际问题,还是需要丰富的经验和大量的优化验证才可以,看来要成为高薪的算法工程师也不是那么容易.<br>所以,亲爱的朋友,你想成为算法大佬吗?你想学习数据分析吗?现在扫码即可8折购买参加极客时间的数据分析课程哦😯</p>\n<div align=\"center\"> <img src=\"/2020/05/21/用机器学习判断ins内容是否能上热门/jike_ad.jpeg\" title=\"image\"> </div>\n\n\n\n\n","site":{"data":{}},"excerpt":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>假设现在要使用爬虫从ins抓取内容,在ins的网页版上每个#tag标签下都有’热门’和’最新’两部分tab页,因为热门内容的质量更好,所以希望能抓取更多热门内容,但是网页版每个#tag只显示最近的9条热门内容,不过’最新’tab下可以一直向前翻页,所以如果能从’最新’下的内容中过滤出热门内容就可以满足内容抓取质量的要求,需要找到一个能将内容分类为热门和非热门的算法.</p>","more":"<div align=\"center\"> <img src=\"/2020/05/21/用机器学习判断ins内容是否能上热门/ins.png\" title=\"image\"> </div>\n\n\n\n<p>那么现在我来介绍一下如何使用机器学习来实现这个算法,本文主要介绍从零开始使用机器学习并解决问题的过程.不会介绍理论知识(刚好我也不懂),速战速决就完事儿了.</p>\n<img src=\"/2020/05/21/用机器学习判断ins内容是否能上热门/gan.jpg\" title=\"image\">\n<h3 id=\"开始之前要了解\"><a href=\"#开始之前要了解\" class=\"headerlink\" title=\"开始之前要了解\"></a>开始之前要了解</h3><ul>\n<li><strong>python</strong>:一种蛇</li>\n<li><strong>instagram</strong>: 著名被墙网站之一</li>\n<li><strong>pandas</strong>:数据处理类库</li>\n<li><strong>matplotlib&amp;seaborn</strong>: 画图类库</li>\n<li><strong>机器学习</strong>: 一种对计算机算法的研究方式，算法会根据经验自动优化效果</li>\n<li><strong>分类问题</strong>: 把一组数据分成两类或者多类,要划分类型已提前定义</li>\n<li><strong>sklearn</strong>: 封装了多种机器学习算法的类库,开箱即用</li>\n</ul>\n<h2 id=\"数据处理\"><a href=\"#数据处理\" class=\"headerlink\" title=\"数据处理\"></a>数据处理</h2><p>ins内容有很多字段信息,首先选择出可能影响内容上热门的字段,包含点赞/曝光/评论/发布时间/抓取时间/标题包含的tag数和当前页面tag下的内容总数等,这些内容用json格式保存,示例如下:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">\"id\"</span>:<span class=\"string\">\"CAA-r0SjtF3\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"sourceTag\"</span>:<span class=\"string\">\"dharmaproductions\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"publishTime\"</span>:<span class=\"number\">1589130910000</span>,</span><br><span class=\"line\">    <span class=\"string\">\"addTime\"</span>:<span class=\"number\">1589134125000</span>,</span><br><span class=\"line\">    <span class=\"string\">\"likes\"</span>:<span class=\"number\">4</span>,</span><br><span class=\"line\">    <span class=\"string\">\"comments\"</span>:<span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"string\">\"views\"</span>:<span class=\"number\">18</span>,</span><br><span class=\"line\">    <span class=\"string\">\"tagNumber\"</span>:<span class=\"number\">15</span>,</span><br><span class=\"line\">    <span class=\"string\">\"description\"</span>:<span class=\"string\">\"\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"totalMedia\"</span>:<span class=\"number\">57149</span>,</span><br><span class=\"line\">    <span class=\"string\">\"hot\"</span>:<span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"数据探索\"><a href=\"#数据探索\" class=\"headerlink\" title=\"数据探索\"></a>数据探索</h3><p>这一步是为了进一步了解原始数据,检查数据真实性和字段的分布</p>\n<ol>\n<li>用seaborn画直方图,查看热门/非热门内容的比例:</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.df = pd.read_json(<span class=\"string\">'debug/train_video.jl'</span>, lines=<span class=\"keyword\">True</span>)</span><br><span class=\"line\">sns.countplot(self.df[<span class=\"string\">'hot'</span>], label=<span class=\"string\">\"Count\"</span>)</span><br></pre></td></tr></table></figure>\n<div align=\"center\"> <img src=\"/2020/05/21/用机器学习判断ins内容是否能上热门/hot.png\" title=\"image\"> </div>\n\n<p>图中热门内容占比还是比较高的,有一点脱离真实情况,实际对于ins上被活跃使用的tag,本身内容数量就很多又更新频繁,所以只有很少一部分内容能上热门.</p>\n<ol start=\"2\">\n<li>用seaborn画热力图,这一步是为了查看字段之间的关系:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.df = pd.read_json(&apos;debug/train_video.jl&apos;, lines=True)</span><br><span class=\"line\">corr = self.df.corr()</span><br><span class=\"line\">plt.figure(figsize=(14, 14))</span><br><span class=\"line\">sns.heatmap(corr, annot=True)</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>corr()函数会计算数据集df中各字段的相关关系,图中的颜色越浅代表越相关,可以看到like/view之前相关性比较高,如果两个字段之间相关性接近1,可以考虑去掉其中一个字段.</p>\n<div align=\"left\"> <img src=\"/2020/05/21/用机器学习判断ins内容是否能上热门/heatmap.png\" title=\"image\"> </div>\n\n<ol start=\"3\">\n<li>用matplotlib画频率分布直方图</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">draw_histo</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">    plt.figure(<span class=\"number\">1</span>, figsize=(<span class=\"number\">20</span>, <span class=\"number\">20</span>))</span><br><span class=\"line\">    i = <span class=\"number\">810</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> field <span class=\"keyword\">in</span> self.df.keys():</span><br><span class=\"line\">        i += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"comment\"># 去掉区间上数量小于10的记录</span></span><br><span class=\"line\">        items = self.df.groupby(field).filter(<span class=\"keyword\">lambda</span> x: len(x) &gt; <span class=\"number\">10</span>)[field]</span><br><span class=\"line\">        self.histogram(items=items, index=i, field=field)</span><br><span class=\"line\">    plt.savefig(<span class=\"string\">'histogram.png'</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">histogram</span><span class=\"params\">(self, items=None, index=None, field=None, y_label=<span class=\"string\">'Probability'</span>)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">    画频率直方图（带正态分布曲线）</span></span><br><span class=\"line\"><span class=\"string\">    :param index: 图片位置</span></span><br><span class=\"line\"><span class=\"string\">    :param field: 字段名</span></span><br><span class=\"line\"><span class=\"string\">    :param y_label:</span></span><br><span class=\"line\"><span class=\"string\">    :return:</span></span><br><span class=\"line\"><span class=\"string\">    \"\"\"</span></span><br><span class=\"line\">    title = field + <span class=\"string\">' distribution'</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> items <span class=\"keyword\">is</span> <span class=\"keyword\">None</span>:</span><br><span class=\"line\">        items = self.df[field]</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        plt.subplot(index)</span><br><span class=\"line\">        mean = items.mean()</span><br><span class=\"line\">        std = items.std()</span><br><span class=\"line\">        x = np.arange(items.min(), items.max())</span><br><span class=\"line\">        y = self.normfun(x=x, mu=mean, sigma=std)</span><br><span class=\"line\">        plt.plot(x, y)</span><br><span class=\"line\">        plt.hist(items, bins=<span class=\"string\">'auto'</span>, density=<span class=\"keyword\">True</span>, rwidth=<span class=\"number\">0.9</span>, stacked=<span class=\"keyword\">True</span>)</span><br><span class=\"line\">        plt.title(title)</span><br><span class=\"line\">        plt.xlabel(field)</span><br><span class=\"line\">        plt.ylabel(y_label)</span><br><span class=\"line\">        plt.tight_layout()</span><br><span class=\"line\">    <span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">        print(field)</span><br><span class=\"line\">        print(e)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@staticmethod</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">normfun</span><span class=\"params\">(x, mu, sigma)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">    正态分布的概率密度函数。可以理解成 x 是 mu（均值）和 sigma（标准差）的函数</span></span><br><span class=\"line\"><span class=\"string\">    :param x:</span></span><br><span class=\"line\"><span class=\"string\">    :param mu:</span></span><br><span class=\"line\"><span class=\"string\">    :param sigma:</span></span><br><span class=\"line\"><span class=\"string\">    :return:</span></span><br><span class=\"line\"><span class=\"string\">    \"\"\"</span></span><br><span class=\"line\">    pdf = np.exp(-((x - mu) ** <span class=\"number\">2</span>) / (<span class=\"number\">2</span> * sigma ** <span class=\"number\">2</span>)) / (sigma * np.sqrt(<span class=\"number\">2</span> * np.pi))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pdf</span><br></pre></td></tr></table></figure>\n<div align=\"center\"> <img src=\"/2020/05/21/用机器学习判断ins内容是否能上热门/histogram.png\" title=\"image\"> </div>\n\n<p>画直方图的目的是查看字段的分布类型,图中蓝色的线是正态分布函数曲线,明细like/view/comment的分布不符合正态分布,更像是长尾分布(大多数值分布在头部)</p>\n<h3 id=\"数据清洗-amp-特征选择\"><a href=\"#数据清洗-amp-特征选择\" class=\"headerlink\" title=\"数据清洗&amp;特征选择\"></a>数据清洗&amp;特征选择</h3><p>因为原始数据中并没有缺失值或异常值得情况,所以忽略数据清洗的步骤,直接进行特征选择.<br>首先我们不需要具体的时间戳,把发布时间publistTime和抓取时间addTime的间隔计算出来,单位是天和小时(ins热门tab中通常是最近发布的内容)</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">df[<span class=\"string\">'days'</span>] = (pd.to_datetime(df[<span class=\"string\">'addTime'</span>], unit=<span class=\"string\">'ms'</span>) - pd.to_datetime(df[<span class=\"string\">'publishTime'</span>], unit=<span class=\"string\">'ms'</span>)).dt.days</span><br><span class=\"line\"><span class=\"comment\"># 不满一天的用1天替换</span></span><br><span class=\"line\">df[<span class=\"string\">'days'</span>] = df[<span class=\"string\">'days'</span>].replace(<span class=\"number\">0</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">df[<span class=\"string\">'hours'</span>] = ((pd.to_datetime(df[<span class=\"string\">'addTime'</span>], unit=<span class=\"string\">'ms'</span>) - pd.to_datetime(df[<span class=\"string\">'publishTime'</span>], unit=<span class=\"string\">'ms'</span>))</span><br><span class=\"line\">               .dt.total_seconds() / <span class=\"number\">3600</span>).astype(int)</span><br><span class=\"line\">df[<span class=\"string\">'hours'</span>] = df[<span class=\"string\">'hours'</span>].replace(<span class=\"number\">0</span>, <span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n<p>然后因为一般内容发布越早曝光也越高,所以添加like_per_hour/view_per_hour两个特征,减弱时间影响</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">df[<span class=\"string\">'like_per_hour'</span>] = (df[<span class=\"string\">'likes'</span>] / df[<span class=\"string\">'hours'</span>]).astype(int)</span><br><span class=\"line\">df[<span class=\"string\">'view_per_hour'</span>] = (df[<span class=\"string\">'views'</span>] / df[<span class=\"string\">'hours'</span>]).astype(int)</span><br></pre></td></tr></table></figure>\n<p>最后选择的特征如下:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">features = [<span class=\"string\">'views'</span>, <span class=\"string\">'likes'</span>, <span class=\"string\">'comments'</span>, <span class=\"string\">'tagNumber'</span>, <span class=\"string\">'totalMedia'</span>, <span class=\"string\">'days'</span>, <span class=\"string\">'like_per_hour'</span>, <span class=\"string\">'view_per_hour'</span>]</span><br></pre></td></tr></table></figure>\n<h2 id=\"评分标准\"><a href=\"#评分标准\" class=\"headerlink\" title=\"评分标准\"></a>评分标准</h2><p>在选择分类算法前,先来了解一下评估分类算法的常用标准</p>\n<h3 id=\"准确率-精确率-召回率\"><a href=\"#准确率-精确率-召回率\" class=\"headerlink\" title=\"准确率,精确率,召回率\"></a>准确率,精确率,召回率</h3><p>假设你开发了一款检测新冠病毒的试剂盒,那么每次检测结果有一下四种(阳性表示被检测人携带病毒):</p>\n<p>TP(True Prosivite): 真阳性,说明正确检测出病毒</p>\n<p>FP(False Prosivite): 假阳性</p>\n<p>TN(True Negative): 真阴性</p>\n<p>FN(False Negative): 假阴性,携带病毒却没有检测出来</p>\n<p>对于病毒检测来说FN的危害显然要比FP更大,而根据这几种情况的样本数量就可以计算出准确率,精确率和召回率:</p>\n<p>准确率(accuracy): ${TP+TN}\\over{TP+FP+TN+FN}$,代表全部样本的正确率</p>\n<p>精确率(precision): ${TP}\\over{TP+FP}$,代表检测为阳性时的正确率</p>\n<p>召回率(recall): ${TP}\\over{TP+FN}$,代表所有病毒携带者被检测为阳性的覆盖率,也叫查全率</p>\n<p><img src=\"https://throwsnew.com/images/example.jpg\" alt=\"举个例子:\"></p>\n<p>有三个样本,检测结果为y_predict,而实际值为y_true,1代表阳性,sklearn的score函数默认返回的是阳性分类的分数</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> sklearn.metrics <span class=\"keyword\">import</span> accuracy_score,precision_score,recall_score</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    y_predict = [<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>]</span><br><span class=\"line\">    y_true = [<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>]</span><br><span class=\"line\">    print(<span class=\"string\">f'accuracy:<span class=\"subst\">&#123;accuracy_score(y_true,y_predict)&#125;</span>'</span>)</span><br><span class=\"line\">    print(<span class=\"string\">f'precision:<span class=\"subst\">&#123;precision_score(y_true,y_predict)&#125;</span>'</span>)</span><br><span class=\"line\">    print(<span class=\"string\">f'recall:<span class=\"subst\">&#123;recall_score(y_true,y_predict)&#125;</span>'</span>)</span><br></pre></td></tr></table></figure>\n<p>输出结果为:<br>accuracy:0.6666666666666666<br>precision:0.5<br>recall:1.0</p>\n<p>对于判断ins是否属于热门内容的算法,可以允许ta把非热门内容分到热门但是要尽量不遗漏热门内容，即FN越小越好，FP 可以大一些，所以我们要求<strong>召回率越高越好,精确率次之</strong></p>\n<h3 id=\"宏平均和微平均\"><a href=\"#宏平均和微平均\" class=\"headerlink\" title=\"宏平均和微平均\"></a>宏平均和微平均</h3><p>对于求准确率还有宏平均和微平均两种方式,宏平均是对直接每个分类的准确率求平均值,而微平均要先对所有分类的预测结果求和再计算平均值,举个例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class A: 1 TP and 1 FP</span><br><span class=\"line\">Class B: 10 TP and 90 FP</span><br><span class=\"line\">Class C: 1 TP and 1 FP</span><br><span class=\"line\">Class D: 1 TP and 1 FP</span><br></pre></td></tr></table></figure>\n<p>对于上面的分类结果:</p>\n<p>准确率 $pA=pC=pD=0.5$, $pB=0.1$</p>\n<p>$宏平均准确率(macro-avg)=$${0.5+0.1+0.5+0.5}\\over{4}$$=0.4$</p>\n<p>$微平均准确率(micro-avg)=$${1+10+1+1}\\over{2+100+2+2}$$=0.123$</p>\n<p>这个例子体现了宏平均把所有分类的<strong>权重都视为1</strong>的问题，在进行C分类时只有0.1的准确率，并且分类C的样本数占整体的90%以上，却没有影响宏平均的结果，所以一般把宏平均改进为加权的宏平均(权重是分类样本占总数的比例):<br>$macro-weight-avg=$$0.0189\\times0.5+0.943\\times0.1+0.0189\\times0.5+0.0189\\times0.5=0.123$</p>\n<p>sklearn中求宏平均/微平均的精确率,猜下结果是多少?<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">y_predict = [<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>]</span><br><span class=\"line\">y_true = [<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>]</span><br><span class=\"line\">macro=precision_score(y_true, y_predict,average=<span class=\"string\">\"macro\"</span>)</span><br><span class=\"line\">micro=precision_score(y_true, y_predict,average=<span class=\"string\">\"micro\"</span>)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"算法选择\"><a href=\"#算法选择\" class=\"headerlink\" title=\"算法选择\"></a>算法选择</h2><h3 id=\"sklearn常用分类算法\"><a href=\"#sklearn常用分类算法\" class=\"headerlink\" title=\"sklearn常用分类算法\"></a>sklearn常用分类算法</h3><p><strong>决策树</strong>: 使用树形结构,把特征作为决策树上的节点,叶节点就是分类结果,构造决策树时追求最纯净的分类结果(越纯净则分类的不确定性越低)</p>\n<p><strong>朴素贝叶斯</strong>: 在你不知道事件全貌的情况下,先根据一点人生经验得到一个主观判断,然后根据后续观察结果进行修正.根据概率大小判断最后的分类,常用于文本分类</p>\n<p><strong>SVM</strong>: 几何解法,先把所有样本用多维空间的向量表示,然后求一个平面将不同分类的样本分隔开</p>\n<p><strong>KNN</strong>: K-Nearest Neighbor,几何解法,因为”近朱者赤,近墨者黑”,所以对于节点A,相邻最近的K个节点是什么类型,A大概就是什么类型</p>\n<p><strong>集成算法</strong>: 本着”人多力量大”的原则,使用多个分类器一起工作,按分类器的协作方式分为两种,bagging:分类器一起投票,看哪个分类票多;boosting:再学习,通过多次迭代强化整体的分类效果</p>\n<h3 id=\"效果对比\"><a href=\"#效果对比\" class=\"headerlink\" title=\"效果对比\"></a>效果对比</h3><p>准备了训练数据24w条,测试数据2.7w条,训练数据来自上百个tag,非热门内容占比较少,测试来自两个tag,非热门数据占比更接近整体比例.<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn <span class=\"keyword\">import</span> naive_bayes</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn.ensemble <span class=\"keyword\">import</span> AdaBoostClassifier, RandomForestClassifier</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn.metrics <span class=\"keyword\">import</span> classification_report</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn.neighbors <span class=\"keyword\">import</span> KNeighborsClassifier</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn.tree <span class=\"keyword\">import</span> DecisionTreeClassifier</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn.utils <span class=\"keyword\">import</span> shuffle</span><br><span class=\"line\"></span><br><span class=\"line\">clf_list = &#123;</span><br><span class=\"line\">    <span class=\"string\">'cart'</span>: DecisionTreeClassifier(max_depth=<span class=\"number\">5</span>),</span><br><span class=\"line\">    <span class=\"comment\"># 'svm': svm.SVC(),  # 太慢了，放弃</span></span><br><span class=\"line\">    <span class=\"comment\"># 'nb_gauss': naive_bayes.GaussianNB(), # 太差了，放弃</span></span><br><span class=\"line\">    <span class=\"string\">'nb_multi'</span>: naive_bayes.MultinomialNB(),</span><br><span class=\"line\">    <span class=\"string\">'k_neighbors'</span>: KNeighborsClassifier(),</span><br><span class=\"line\">    <span class=\"string\">'adaptive_boost'</span>: AdaBoostClassifier(),</span><br><span class=\"line\">    <span class=\"string\">'random_forest'</span>: RandomForestClassifier(max_depth=<span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">train</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    train_data = pd.read_json(<span class=\"string\">'debug/train_video.jl'</span>, lines=<span class=\"keyword\">True</span>)</span><br><span class=\"line\">    train_data = shuffle(train_data)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 特征选择</span></span><br><span class=\"line\">    features = [<span class=\"string\">'views'</span>, <span class=\"string\">'likes'</span>, <span class=\"string\">'comments'</span>, <span class=\"string\">'tagNumber'</span>, <span class=\"string\">'totalMedia'</span>, <span class=\"string\">'days'</span>, <span class=\"string\">'like_per_hour'</span>, <span class=\"string\">'view_per_hour'</span>]</span><br><span class=\"line\">    train_features = train_data[features]</span><br><span class=\"line\">    train_labels = train_data[<span class=\"string\">'hot'</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 测试数据</span></span><br><span class=\"line\">    test_data = pd.read_json(<span class=\"string\">'debug/test_video.jl'</span>, lines=<span class=\"keyword\">True</span>)</span><br><span class=\"line\">    test_data = shuffle(test_data)</span><br><span class=\"line\">    test_features = test_data[features]</span><br><span class=\"line\">    test_labels = test_data[<span class=\"string\">'hot'</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> k, clf <span class=\"keyword\">in</span> clf_list.items():</span><br><span class=\"line\">        print(<span class=\"string\">f'-----<span class=\"subst\">&#123;k&#125;</span> result-------'</span>)</span><br><span class=\"line\">        <span class=\"comment\"># 决策树训练</span></span><br><span class=\"line\">        clf.fit(train_features, train_labels)</span><br><span class=\"line\">        target_names = [<span class=\"string\">'normal'</span>, <span class=\"string\">'hot'</span>]</span><br><span class=\"line\">        test_predict = clf.predict(test_features)</span><br><span class=\"line\">        sample_weight = test_labels.replace(<span class=\"number\">1</span>, <span class=\"number\">100</span>).replace(<span class=\"number\">0</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"comment\"># 打印测试报告</span></span><br><span class=\"line\">        print(classification_report(test_labels, test_predict, target_names=target_names, sample_weight=sample_weight))</span><br></pre></td></tr></table></figure></p>\n<p>在测试报告中,f1是precision/recall的综合平均分,support是分类的样本权重(默认按样本数量计算权重).因为ins内容热门数量比较少,所以我用sample_weight参数把hot分类的权重调整为normal分类的100倍,macro/weighted avg就是上面说的宏平均和加权宏平均.<br>观察测试报告可以发现,CART决策树的对热门内容的召回率最高,达到92%,朴素贝叶斯次之<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-----cart result-------</span><br><span class=\"line\">              precision    recall  f1-score   support</span><br><span class=\"line\"></span><br><span class=\"line\">      normal       0.44      0.90      0.59   24222.0</span><br><span class=\"line\">         hot       0.99      0.92      0.95  344800.0</span><br><span class=\"line\"></span><br><span class=\"line\">    accuracy                           0.92  369022.0</span><br><span class=\"line\">   macro avg       0.72      0.91      0.77  369022.0</span><br><span class=\"line\">weighted avg       0.96      0.92      0.93  369022.0</span><br><span class=\"line\"></span><br><span class=\"line\">-----nb_multi result-------</span><br><span class=\"line\">              precision    recall  f1-score   support</span><br><span class=\"line\"></span><br><span class=\"line\">      normal       0.17      0.63      0.27   24222.0</span><br><span class=\"line\">         hot       0.97      0.79      0.87  344800.0</span><br><span class=\"line\"></span><br><span class=\"line\">    accuracy                           0.78  369022.0</span><br><span class=\"line\">   macro avg       0.57      0.71      0.57  369022.0</span><br><span class=\"line\">weighted avg       0.92      0.78      0.83  369022.0</span><br><span class=\"line\"></span><br><span class=\"line\">-----k_neighbors result-------</span><br><span class=\"line\">              precision    recall  f1-score   support</span><br><span class=\"line\"></span><br><span class=\"line\">      normal       0.11      0.69      0.20   24222.0</span><br><span class=\"line\">         hot       0.97      0.63      0.76  344800.0</span><br><span class=\"line\"></span><br><span class=\"line\">    accuracy                           0.63  369022.0</span><br><span class=\"line\">   macro avg       0.54      0.66      0.48  369022.0</span><br><span class=\"line\">weighted avg       0.91      0.63      0.72  369022.0</span><br><span class=\"line\"></span><br><span class=\"line\">-----adaptive_boost result-------</span><br><span class=\"line\">              precision    recall  f1-score   support</span><br><span class=\"line\"></span><br><span class=\"line\">      normal       0.08      0.99      0.15   24222.0</span><br><span class=\"line\">         hot       1.00      0.20      0.34  344800.0</span><br><span class=\"line\"></span><br><span class=\"line\">    accuracy                           0.25  369022.0</span><br><span class=\"line\">   macro avg       0.54      0.60      0.24  369022.0</span><br><span class=\"line\">weighted avg       0.94      0.25      0.32  369022.0</span><br><span class=\"line\"></span><br><span class=\"line\">-----random_forest result-------</span><br><span class=\"line\">              precision    recall  f1-score   support</span><br><span class=\"line\"></span><br><span class=\"line\">      normal       0.10      0.96      0.18   24222.0</span><br><span class=\"line\">         hot       0.99      0.37      0.54  344800.0</span><br><span class=\"line\"></span><br><span class=\"line\">    accuracy                           0.41  369022.0</span><br><span class=\"line\">   macro avg       0.54      0.67      0.36  369022.0</span><br><span class=\"line\">weighted avg       0.93      0.41      0.52  369022.0</span><br></pre></td></tr></table></figure></p>\n<p>为了进一步验证，将测试集分为14个大小2000的子集，然后分别记录每次的测试结果，画出折线图，选择的标准是热门内容的召回率&amp;精确率和整体的准确率，在14次测试中CART算法都表现最好。<br>重复测试的代码如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">train</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    train_data = pd.read_json(<span class=\"string\">'debug/train_video.jl'</span>, lines=<span class=\"keyword\">True</span>)</span><br><span class=\"line\">    train_data = shuffle(train_data)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 特征选择</span></span><br><span class=\"line\">    features = [<span class=\"string\">'views'</span>, <span class=\"string\">'likes'</span>, <span class=\"string\">'comments'</span>, <span class=\"string\">'tagNumber'</span>, <span class=\"string\">'totalMedia'</span>, <span class=\"string\">'days'</span>, <span class=\"string\">'like_per_hour'</span>, <span class=\"string\">'view_per_hour'</span>]</span><br><span class=\"line\">    train_features = train_data[features]</span><br><span class=\"line\">    train_labels = train_data[<span class=\"string\">'hot'</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 测试数据</span></span><br><span class=\"line\">    test_data = pd.read_json(<span class=\"string\">'debug/test_video.jl'</span>, lines=<span class=\"keyword\">True</span>)</span><br><span class=\"line\">    test_data = shuffle(test_data)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 切分为每组大小为2000的集合</span></span><br><span class=\"line\">    test_size = <span class=\"number\">2000</span></span><br><span class=\"line\">    test_list = [test_data[i:i + test_size] <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, test_data.shape[<span class=\"number\">0</span>], test_size)]</span><br><span class=\"line\">    reports = &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> k, clf <span class=\"keyword\">in</span> clf_list.items():</span><br><span class=\"line\">        print(<span class=\"string\">f'-----<span class=\"subst\">&#123;k&#125;</span> result-------'</span>)</span><br><span class=\"line\">        <span class=\"comment\"># 决策树训练</span></span><br><span class=\"line\">        clf.fit(train_features, train_labels)</span><br><span class=\"line\">        target_names = [<span class=\"string\">'normal'</span>, <span class=\"string\">'hot'</span>]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> test_set <span class=\"keyword\">in</span> test_list:</span><br><span class=\"line\">            test_features = test_set[features]</span><br><span class=\"line\">            test_labels = test_set[<span class=\"string\">'hot'</span>]</span><br><span class=\"line\">            test_predict = clf.predict(test_features)</span><br><span class=\"line\">            sample_weight = test_labels.replace(<span class=\"number\">1</span>, <span class=\"number\">100</span>).replace(<span class=\"number\">0</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">            report = classification_report(test_labels, test_predict, target_names=target_names,</span><br><span class=\"line\">                                           sample_weight=sample_weight, output_dict=<span class=\"keyword\">True</span>)</span><br><span class=\"line\">            reports.setdefault(<span class=\"string\">f'<span class=\"subst\">&#123;k&#125;</span>_hot_recall'</span>, []).append(report[<span class=\"string\">'hot'</span>][<span class=\"string\">'recall'</span>])</span><br><span class=\"line\">            reports.setdefault(<span class=\"string\">f'<span class=\"subst\">&#123;k&#125;</span>_hot_precision'</span>, []).append(report[<span class=\"string\">'hot'</span>][<span class=\"string\">'precision'</span>])</span><br><span class=\"line\">            reports.setdefault(<span class=\"string\">f'<span class=\"subst\">&#123;k&#125;</span>_accuracy'</span>, []).append(report[<span class=\"string\">'accuracy'</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">    df = pd.DataFrame(reports)</span><br><span class=\"line\">    metrics = [<span class=\"string\">'hot_recall'</span>, <span class=\"string\">'hot_precision'</span>, <span class=\"string\">'_accuracy'</span>]</span><br><span class=\"line\">    fig, axes = plt.subplots(nrows=<span class=\"number\">3</span>, figsize=(<span class=\"number\">16</span>, <span class=\"number\">20</span>))</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, m <span class=\"keyword\">in</span> enumerate(metrics):</span><br><span class=\"line\">        m_df = df.filter(regex=m)</span><br><span class=\"line\">        m_df.plot(ax=axes[i], title=m, xticks=range(<span class=\"number\">1</span>, len(test_list) + <span class=\"number\">1</span>))</span><br><span class=\"line\">    fig.savefig(<span class=\"string\">f\"debug/report.png\"</span>)</span><br></pre></td></tr></table></figure></p>\n<p>测试结果:</p>\n<div align=\"center\"> <img src=\"/2020/05/21/用机器学习判断ins内容是否能上热门/report.png\" title=\"image\"> </div>\n\n<h3 id=\"未解决的问题\"><a href=\"#未解决的问题\" class=\"headerlink\" title=\"未解决的问题\"></a>未解决的问题</h3><p>这里我们缺失了机器学习最关键的一步,那就是调参(手动狗头),总感觉使用默认参数的模型没有灵魂.因为按直觉来说随机森林和AdaBoost应该优于决策树才对,结果准确率和召回率相差都很大<br>另外测试结果容易受测试集影响,当我使用只有39个样本，其中只有一个非热门内容的测试集时，决策树的召回率反而最低，所以选择测试集时要注意样本数量和真实性.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-----cart result-------</span><br><span class=\"line\">              precision    recall  f1-score   support</span><br><span class=\"line\"></span><br><span class=\"line\">      normal       0.00      1.00      0.00       1.0</span><br><span class=\"line\">         hot       1.00      0.79      0.88    3800.0</span><br><span class=\"line\"></span><br><span class=\"line\">    accuracy                           0.79    3801.0</span><br><span class=\"line\">   macro avg       0.50      0.89      0.44    3801.0</span><br><span class=\"line\">weighted avg       1.00      0.79      0.88    3801.0</span><br><span class=\"line\"></span><br><span class=\"line\">-----nb_multi result-------</span><br><span class=\"line\">              precision    recall  f1-score   support</span><br><span class=\"line\"></span><br><span class=\"line\">      normal       0.01      1.00      0.02       1.0</span><br><span class=\"line\">         hot       1.00      0.97      0.99    3800.0</span><br><span class=\"line\"></span><br><span class=\"line\">    accuracy                           0.97    3801.0</span><br><span class=\"line\">   macro avg       0.50      0.99      0.50    3801.0</span><br><span class=\"line\">weighted avg       1.00      0.97      0.99    3801.0</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"保存分类器\"><a href=\"#保存分类器\" class=\"headerlink\" title=\"保存分类器\"></a>保存分类器</h3><p>把表现最好的CART分类器模型保存到代码文件中，然后当需要对ins内容进行分类就可以直接用模型进行判断了.保存模型时我使用的是cPickle(<br>除了cPickle还可以使用joblib,python3.6直接import _pickle即可，而joblib还需要安装)<br>保存非常简单,调用dump()即可<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import _pickle as cPickle</span><br><span class=\"line\">    # 保存</span><br><span class=\"line\">    with open(&apos;ins_hot_model.clf&apos;,&apos;wb&apos;) as f:</span><br><span class=\"line\">        cPickle.dump(clf,f)</span><br></pre></td></tr></table></figure></p>\n<p>使用时需要从文件中加载分类器:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def use_model():</span><br><span class=\"line\">    # 未分类的ins文档信息</span><br><span class=\"line\">    doc = &#123;&quot;likes&quot;: 107, &quot;comments&quot;: 2, &quot;views&quot;: 435.0, &quot;tagNumber&quot;: 25, &quot;totalMedia&quot;: 22000, &quot;days&quot;: 1343,</span><br><span class=\"line\">           &quot;like_per_hour&quot;: 0, &quot;view_per_hour&quot;: 0&#125;</span><br><span class=\"line\">    # 读取分类器       </span><br><span class=\"line\">    clf = cPickle.load(open(&apos;ins_hot.clf&apos;, &quot;rb&quot;))</span><br><span class=\"line\">    # 把文档转换为DataFrame</span><br><span class=\"line\">    source = pd.DataFrame([doc], columns=list(doc.keys()))</span><br><span class=\"line\">    features = [&apos;views&apos;, &apos;likes&apos;, &apos;comments&apos;, &apos;tagNumber&apos;, &apos;totalMedia&apos;, &apos;days&apos;, &apos;like_per_hour&apos;, &apos;view_per_hour&apos;]</span><br><span class=\"line\">    df = source[features]</span><br><span class=\"line\">    # 为文档分类</span><br><span class=\"line\">    print(clf.predict(df))</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>使用机器学习进行数据分析时,需要经过数据采集,清洗,特征选择,模型训练几个过程.借助sklearn库可以让我们在不了解算法原理的情况下也能轻松地使用机器学习进行数据分析,而对于在生产环境中用机器学习解决实际问题,还是需要丰富的经验和大量的优化验证才可以,看来要成为高薪的算法工程师也不是那么容易.<br>所以,亲爱的朋友,你想成为算法大佬吗?你想学习数据分析吗?现在扫码即可8折购买参加极客时间的数据分析课程哦😯</p>\n<div align=\"center\"> <img src=\"/2020/05/21/用机器学习判断ins内容是否能上热门/jike_ad.jpeg\" title=\"image\"> </div>"}],"PostAsset":[{"_id":"source/_posts/量化交易入门/run.png","slug":"run.png","post":"ckkqle17c000ycynertk5wfwo","modified":1,"renderable":0},{"_id":"source/_posts/thrift源码（四）非阻塞服务端/reactor-single.png","slug":"reactor-single.png","post":"ckkqle1cr002dcyneu1joz8ig","modified":1,"renderable":0},{"_id":"source/_posts/量化交易入门/run1.png","slug":"run1.png","post":"ckkqle17c000ycynertk5wfwo","modified":1,"renderable":0},{"_id":"source/_posts/thrift源码（五）非阻塞服务端其他实现/reactor-multi.png","slug":"reactor-multi.png","post":"ckkqle1cs002fcynecr3b0s3q","modified":1,"renderable":0},{"_id":"source/_posts/理解CMS回收器的preclean阶段/summary.png","slug":"summary.png","post":"ckkqle1cw002pcynehtp5aixr","modified":1,"renderable":0},{"_id":"source/_posts/用机器学习判断ins内容是否能上热门/report.png","slug":"report.png","post":"ckkqle1dv003ecynenaq99b7r","modified":1,"renderable":0},{"_id":"source/_posts/量化交易入门/real.png","slug":"real.png","post":"ckkqle17c000ycynertk5wfwo","modified":1,"renderable":0},{"_id":"source/_posts/thrift源码-客户端/overview.png","post":"ckkqle175000kcyneuic1xwha","slug":"overview.png","modified":1,"renderable":1},{"_id":"source/_posts/restlet-示例/message.png","post":"ckkqle171000dcynedrsk6ucn","slug":"message.png","modified":1,"renderable":1},{"_id":"source/_posts/restlet-示例/resource.png","post":"ckkqle171000dcynedrsk6ucn","slug":"resource.png","modified":1,"renderable":1},{"_id":"source/_posts/restlet-示例/restlet.png","post":"ckkqle171000dcynedrsk6ucn","slug":"restlet.png","modified":1,"renderable":1},{"_id":"source/_posts/restlet-示例/service.png","post":"ckkqle171000dcynedrsk6ucn","slug":"service.png","modified":1,"renderable":1},{"_id":"source/_posts/为什么别人能把java-gc讲清楚/1.png","post":"ckkqle179000ucyned1txgs9z","slug":"1.png","modified":1,"renderable":1},{"_id":"source/_posts/为什么别人能把java-gc讲清楚/2.png","post":"ckkqle179000ucyned1txgs9z","slug":"2.png","modified":1,"renderable":1},{"_id":"source/_posts/为什么别人能把java-gc讲清楚/3.png","post":"ckkqle179000ucyned1txgs9z","slug":"3.png","modified":1,"renderable":1},{"_id":"source/_posts/为什么别人能把java-gc讲清楚/4.png","post":"ckkqle179000ucyned1txgs9z","slug":"4.png","modified":1,"renderable":1},{"_id":"source/_posts/为什么别人能把java-gc讲清楚/5.png","post":"ckkqle179000ucyned1txgs9z","slug":"5.png","modified":1,"renderable":1},{"_id":"source/_posts/为什么别人能把java-gc讲清楚/6.png","post":"ckkqle179000ucyned1txgs9z","slug":"6.png","modified":1,"renderable":1},{"_id":"source/_posts/量化交易入门/debug.png","slug":"debug.png","post":"ckkqle17c000ycynertk5wfwo","modified":1,"renderable":0},{"_id":"source/_posts/量化交易入门/found.jpeg","post":"ckkqle17c000ycynertk5wfwo","slug":"found.jpeg","modified":1,"renderable":1},{"_id":"source/_posts/量化交易入门/james.jpg","post":"ckkqle17c000ycynertk5wfwo","slug":"james.jpg","modified":1,"renderable":1},{"_id":"source/_posts/thrift源码（五）非阻塞服务端其他实现/reactor-pool.png","post":"ckkqle1cs002fcynecr3b0s3q","slug":"reactor-pool.png","modified":1,"renderable":1},{"_id":"source/_posts/2020年理财总结/nio.jpeg","post":"ckkqle1cj0025cynejyt9hs66","slug":"nio.jpeg","modified":1,"renderable":1},{"_id":"source/_posts/2020年理财总结/vix0.jpeg","post":"ckkqle1cj0025cynejyt9hs66","slug":"vix0.jpeg","modified":1,"renderable":1},{"_id":"source/_posts/2020年理财总结/vix1.jpeg","post":"ckkqle1cj0025cynejyt9hs66","slug":"vix1.jpeg","modified":1,"renderable":1},{"_id":"source/_posts/thrift源码（四）非阻塞服务端/FrameBuffer.png","post":"ckkqle1cr002dcyneu1joz8ig","slug":"FrameBuffer.png","modified":1,"renderable":1},{"_id":"source/_posts/thrift源码（四）非阻塞服务端/FrameBufferState.png","slug":"FrameBufferState.png","post":"ckkqle1cr002dcyneu1joz8ig","modified":1,"renderable":0},{"_id":"source/_posts/thrift源码（四）非阻塞服务端/SelectThread.png","post":"ckkqle1cr002dcyneu1joz8ig","slug":"SelectThread.png","modified":1,"renderable":1},{"_id":"source/_posts/thrift源码（四）非阻塞服务端/serverflow.png","slug":"serverflow.png","post":"ckkqle1cr002dcyneu1joz8ig","modified":1,"renderable":0},{"_id":"source/_posts/理解CMS回收器的preclean阶段/abpreclean.png","post":"ckkqle1cw002pcynehtp5aixr","slug":"abpreclean.png","modified":1,"renderable":1},{"_id":"source/_posts/理解CMS回收器的preclean阶段/gc.jpg","post":"ckkqle1cw002pcynehtp5aixr","slug":"gc.jpg","modified":1,"renderable":1},{"_id":"source/_posts/理解CMS回收器的preclean阶段/gen1.png","post":"ckkqle1cw002pcynehtp5aixr","slug":"gen1.png","modified":1,"renderable":1},{"_id":"source/_posts/理解CMS回收器的preclean阶段/gen2.png","post":"ckkqle1cw002pcynehtp5aixr","slug":"gen2.png","modified":1,"renderable":1},{"_id":"source/_posts/thrift源码（二）异步客户端/client-init.png","slug":"client-init.png","post":"ckkqle1dt003bcyneke11cfve","modified":1,"renderable":0},{"_id":"source/_posts/thrift源码（二）异步客户端/thrift-client-call.png","slug":"thrift-client-call.png","post":"ckkqle1dt003bcyneke11cfve","modified":1,"renderable":0},{"_id":"source/_posts/用机器学习判断ins内容是否能上热门/gan.jpg","post":"ckkqle1dv003ecynenaq99b7r","slug":"gan.jpg","modified":1,"renderable":1},{"_id":"source/_posts/用机器学习判断ins内容是否能上热门/heatmap.png","post":"ckkqle1dv003ecynenaq99b7r","slug":"heatmap.png","modified":1,"renderable":1},{"_id":"source/_posts/用机器学习判断ins内容是否能上热门/histogram.png","post":"ckkqle1dv003ecynenaq99b7r","slug":"histogram.png","modified":1,"renderable":1},{"_id":"source/_posts/用机器学习判断ins内容是否能上热门/hot.png","post":"ckkqle1dv003ecynenaq99b7r","slug":"hot.png","modified":1,"renderable":1},{"_id":"source/_posts/用机器学习判断ins内容是否能上热门/ins.png","slug":"ins.png","post":"ckkqle1dv003ecynenaq99b7r","modified":1,"renderable":0},{"_id":"source/_posts/用机器学习判断ins内容是否能上热门/jike_ad.jpeg","post":"ckkqle1dv003ecynenaq99b7r","slug":"jike_ad.jpeg","modified":1,"renderable":1}],"PostCategory":[{"post_id":"ckkqle16p0003cyne9z43op3g","category_id":"ckkqle16v0006cynezhoxw33s","_id":"ckkqle174000fcynel119jvfx"},{"post_id":"ckkqle16t0005cyneudvrr3qy","category_id":"ckkqle170000bcyne5reho9c5","_id":"ckkqle176000mcynebqyroq1o"},{"post_id":"ckkqle16w0008cynek4195akh","category_id":"ckkqle174000gcynesd88zntv","_id":"ckkqle178000scynegebh684i"},{"post_id":"ckkqle175000kcyneuic1xwha","category_id":"ckkqle177000qcynenolz7qcb","_id":"ckkqle17d0012cynelvui08m2"},{"post_id":"ckkqle177000ocyney6im1bug","category_id":"ckkqle177000qcynenolz7qcb","_id":"ckkqle17l0015cyne1noykbbt"},{"post_id":"ckkqle179000vcynes787cn95","category_id":"ckkqle17d0011cyneb4p6tzkw","_id":"ckkqle17l0018cyne0i56zdml"},{"post_id":"ckkqle1co002acyne62152l71","category_id":"ckkqle170000bcyne5reho9c5","_id":"ckkqle1ct002gcyneywzw9imu"},{"post_id":"ckkqle1cr002dcyneu1joz8ig","category_id":"ckkqle177000qcynenolz7qcb","_id":"ckkqle1cv002mcynec8upkola"},{"post_id":"ckkqle1cs002fcynecr3b0s3q","category_id":"ckkqle177000qcynenolz7qcb","_id":"ckkqle1cw002qcynezsrwox2p"},{"post_id":"ckkqle1ct002jcynec1hkbd76","category_id":"ckkqle17d0011cyneb4p6tzkw","_id":"ckkqle1cx002scynex7x8mmhv"},{"post_id":"ckkqle1cp002ccynelxvvpg7g","category_id":"ckkqle1cs002ecyne4c484ph6","_id":"ckkqle1cy002vcynec9o5crvm"},{"post_id":"ckkqle1cv002lcyneg7x68vue","category_id":"ckkqle17d0011cyneb4p6tzkw","_id":"ckkqle1cy002xcyneuip2unsz"},{"post_id":"ckkqle1dt003bcyneke11cfve","category_id":"ckkqle177000qcynenolz7qcb","_id":"ckkqle1dw003hcynea1byzdfl"},{"post_id":"ckkqle1ds003acyneue12t10h","category_id":"ckkqle1du003ccyneckv2bojl","_id":"ckkqle1ed003jcyne7n3yl68r"}],"PostTag":[{"post_id":"ckkqle16p0003cyne9z43op3g","tag_id":"ckkqle16w0007cynelb8bwowr","_id":"ckkqle175000jcyne6o59k78a"},{"post_id":"ckkqle16p0003cyne9z43op3g","tag_id":"ckkqle170000ccyneqpmxhk25","_id":"ckkqle176000lcyneuswh627y"},{"post_id":"ckkqle16t0005cyneudvrr3qy","tag_id":"ckkqle174000hcynef683gz4s","_id":"ckkqle177000pcyneklsj6fve"},{"post_id":"ckkqle179000ucyned1txgs9z","tag_id":"ckkqle16w0007cynelb8bwowr","_id":"ckkqle17b000xcyne1nrr1ir5"},{"post_id":"ckkqle16w0008cynek4195akh","tag_id":"ckkqle176000ncyneheb5mdxc","_id":"ckkqle17d0010cynejea04h4b"},{"post_id":"ckkqle16w0008cynek4195akh","tag_id":"ckkqle178000tcyne2wdlfg6w","_id":"ckkqle17h0013cyneuphgm42b"},{"post_id":"ckkqle16x0009cynepl2gsd9q","tag_id":"ckkqle17c000zcynewdqq06w2","_id":"ckkqle17l0016cyneghwxe3so"},{"post_id":"ckkqle16z000acynexf5w9zph","tag_id":"ckkqle16w0007cynelb8bwowr","_id":"ckkqle17m001acyneudzwq744"},{"post_id":"ckkqle16z000acynexf5w9zph","tag_id":"ckkqle17h0014cynex5fwco3u","_id":"ckkqle17m001bcynef2agk2d0"},{"post_id":"ckkqle16z000acynexf5w9zph","tag_id":"ckkqle17l0017cyne8cyfshh4","_id":"ckkqle17m001dcynekvgvwzu3"},{"post_id":"ckkqle173000ecyneyo8hlqnz","tag_id":"ckkqle17l0019cyne869uk4oj","_id":"ckkqle17m001ecyne43yxo338"},{"post_id":"ckkqle174000icynemedir66r","tag_id":"ckkqle17m001ccynejr51zxt1","_id":"ckkqle17n001hcyne6xt8g8iq"},{"post_id":"ckkqle174000icynemedir66r","tag_id":"ckkqle17m001fcynedeg20qo6","_id":"ckkqle17n001icynee1lgb1ab"},{"post_id":"ckkqle175000kcyneuic1xwha","tag_id":"ckkqle17m001gcynebrm8h4ez","_id":"ckkqle17n001lcynejx4rfh6s"},{"post_id":"ckkqle175000kcyneuic1xwha","tag_id":"ckkqle17n001jcyneb55pdwjj","_id":"ckkqle17n001mcyne3jq7h4ek"},{"post_id":"ckkqle177000ocyney6im1bug","tag_id":"ckkqle17m001gcynebrm8h4ez","_id":"ckkqle17o001pcyneq3625mci"},{"post_id":"ckkqle177000ocyney6im1bug","tag_id":"ckkqle17n001jcyneb55pdwjj","_id":"ckkqle17o001qcyne0od1muah"},{"post_id":"ckkqle178000rcynehjp9hmej","tag_id":"ckkqle17o001ocyne2v7rwoi4","_id":"ckkqle17p001ucynera0qmn3g"},{"post_id":"ckkqle178000rcynehjp9hmej","tag_id":"ckkqle17o001rcyne7owdnqs6","_id":"ckkqle17p001vcyneu1j5f5sc"},{"post_id":"ckkqle178000rcynehjp9hmej","tag_id":"ckkqle17o001scyneklg3ejar","_id":"ckkqle17p001xcynelqwh088i"},{"post_id":"ckkqle179000vcynes787cn95","tag_id":"ckkqle17o001tcyne86f2su0b","_id":"ckkqle17p0020cyneemp4su5z"},{"post_id":"ckkqle179000vcynes787cn95","tag_id":"ckkqle17p001wcyne82u7atvr","_id":"ckkqle17p0021cyneulwirmjq"},{"post_id":"ckkqle179000vcynes787cn95","tag_id":"ckkqle17p001ycyne6d07z5dm","_id":"ckkqle17p0022cynelyuck209"},{"post_id":"ckkqle17c000ycynertk5wfwo","tag_id":"ckkqle17p001zcyne8psgg25g","_id":"ckkqle17q0023cyne6fdgo69f"},{"post_id":"ckkqle1cj0025cynejyt9hs66","tag_id":"ckkqle17p001zcyne8psgg25g","_id":"ckkqle1cn0028cyneew0xki0p"},{"post_id":"ckkqle1cr002dcyneu1joz8ig","tag_id":"ckkqle17m001gcynebrm8h4ez","_id":"ckkqle1ct002icynegeg9gzx9"},{"post_id":"ckkqle1cr002dcyneu1joz8ig","tag_id":"ckkqle17n001jcyneb55pdwjj","_id":"ckkqle1cu002kcyne5ln242q4"},{"post_id":"ckkqle1cl0027cynedp3tuz6x","tag_id":"ckkqle1cp002bcyne7ajwapdv","_id":"ckkqle1cw002ocyne0juwq781"},{"post_id":"ckkqle1cs002fcynecr3b0s3q","tag_id":"ckkqle17m001gcynebrm8h4ez","_id":"ckkqle1cx002rcyner61k3sj6"},{"post_id":"ckkqle1cs002fcynecr3b0s3q","tag_id":"ckkqle17n001jcyneb55pdwjj","_id":"ckkqle1cy002ucyne6tynxuf3"},{"post_id":"ckkqle1ct002jcynec1hkbd76","tag_id":"ckkqle17o001tcyne86f2su0b","_id":"ckkqle1cy002wcyne45yc97j7"},{"post_id":"ckkqle1ct002jcynec1hkbd76","tag_id":"ckkqle17p001ycyne6d07z5dm","_id":"ckkqle1cy002ycynet43b612m"},{"post_id":"ckkqle1ct002jcynec1hkbd76","tag_id":"ckkqle17p001wcyne82u7atvr","_id":"ckkqle1cy0030cyne4v1enksm"},{"post_id":"ckkqle1cv002lcyneg7x68vue","tag_id":"ckkqle17o001tcyne86f2su0b","_id":"ckkqle1cz0031cynejmsedhv5"},{"post_id":"ckkqle1cv002lcyneg7x68vue","tag_id":"ckkqle17p001wcyne82u7atvr","_id":"ckkqle1cz0033cyne10nnrcc9"},{"post_id":"ckkqle1cv002lcyneg7x68vue","tag_id":"ckkqle17p001ycyne6d07z5dm","_id":"ckkqle1cz0034cynek304bgis"},{"post_id":"ckkqle1co002acyne62152l71","tag_id":"ckkqle1ct002hcynem17eyatx","_id":"ckkqle1cz0035cynev88uowb2"},{"post_id":"ckkqle1co002acyne62152l71","tag_id":"ckkqle1cv002ncynepwkrgk00","_id":"ckkqle1cz0036cynekludgyil"},{"post_id":"ckkqle1co002acyne62152l71","tag_id":"ckkqle1cx002tcynehdx2gcsz","_id":"ckkqle1d00037cyne8ilc6xno"},{"post_id":"ckkqle1cp002ccynelxvvpg7g","tag_id":"ckkqle1cy002zcynewbig9s5g","_id":"ckkqle1d00038cynendewmbnu"},{"post_id":"ckkqle1cp002ccynelxvvpg7g","tag_id":"ckkqle1cz0032cyner7c6mmmj","_id":"ckkqle1d00039cynefapfrlzd"},{"post_id":"ckkqle1dt003bcyneke11cfve","tag_id":"ckkqle17m001gcynebrm8h4ez","_id":"ckkqle1dw003fcyne4rvjd73d"},{"post_id":"ckkqle1dt003bcyneke11cfve","tag_id":"ckkqle17n001jcyneb55pdwjj","_id":"ckkqle1dw003gcyne2v8bvkca"},{"post_id":"ckkqle1ds003acyneue12t10h","tag_id":"ckkqle1dv003dcyner2ayzf73","_id":"ckkqle1ei003lcyneg9ym73um"},{"post_id":"ckkqle1ds003acyneue12t10h","tag_id":"ckkqle17p001ycyne6d07z5dm","_id":"ckkqle1en003mcyne4f2txe3c"},{"post_id":"ckkqle1ds003acyneue12t10h","tag_id":"ckkqle1dx003icyne3g1cjktr","_id":"ckkqle1en003ncyneyobkaico"},{"post_id":"ckkqle1dv003ecynenaq99b7r","tag_id":"ckkqle1ed003kcyne137ri8go","_id":"ckkqle1en003ocynesur00vft"}],"Tag":[{"name":"java基础","_id":"ckkqle16w0007cynelb8bwowr"},{"name":"并发","_id":"ckkqle170000ccyneqpmxhk25"},{"name":"mesos","_id":"ckkqle174000hcynef683gz4s"},{"name":"mysql","_id":"ckkqle176000ncyneheb5mdxc"},{"name":"数据库","_id":"ckkqle178000tcyne2wdlfg6w"},{"name":"Spring","_id":"ckkqle17c000zcynewdqq06w2"},{"name":"注解","_id":"ckkqle17h0014cynex5fwco3u"},{"name":"annotation","_id":"ckkqle17l0017cyne8cyfshh4"},{"name":"邮件","_id":"ckkqle17l0019cyne869uk4oj"},{"name":"shell","_id":"ckkqle17m001ccynejr51zxt1"},{"name":"Linux","_id":"ckkqle17m001fcynedeg20qo6"},{"name":"thrift","_id":"ckkqle17m001gcynebrm8h4ez"},{"name":"rpc框架","_id":"ckkqle17n001jcyneb55pdwjj"},{"name":"kafaka","_id":"ckkqle17o001ocyne2v7rwoi4"},{"name":"zookeeper","_id":"ckkqle17o001rcyne7owdnqs6"},{"name":"集群","_id":"ckkqle17o001scyneklg3ejar"},{"name":"redis","_id":"ckkqle17o001tcyne86f2su0b"},{"name":"nosql","_id":"ckkqle17p001wcyne82u7atvr"},{"name":"源码","_id":"ckkqle17p001ycyne6d07z5dm"},{"name":"理财","_id":"ckkqle17p001zcyne8psgg25g"},{"name":"中间件","_id":"ckkqle1cp002bcyne7ajwapdv"},{"name":"jenkins","_id":"ckkqle1ct002hcynem17eyatx"},{"name":"docker","_id":"ckkqle1cv002ncynepwkrgk00"},{"name":"kubernetes","_id":"ckkqle1cx002tcynehdx2gcsz"},{"name":"mongodb","_id":"ckkqle1cy002zcynewbig9s5g"},{"name":"springboot","_id":"ckkqle1cz0032cyner7c6mmmj"},{"name":"连接池","_id":"ckkqle1dv003dcyner2ayzf73"},{"name":"commons-pool","_id":"ckkqle1dx003icyne3g1cjktr"},{"name":"算法","_id":"ckkqle1ed003kcyne137ri8go"}]}}