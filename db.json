{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/favicon.ico","path":"favicon.ico","modified":0,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next-bak.png","path":"images/favicon-16x16-next-bak.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next-bak.png","path":"images/favicon-32x32-next-bak.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/logoNew.gif","path":"images/logoNew.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/qrcode.jpg","path":"images/qrcode.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/bg.png","path":"images/bg.png","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"28a2b1c2b82e6eb1cc516271d052784447c9d0e7","modified":1543654213547},{"_id":"source/CNAME","hash":"f308cb64e2c48b5087084897cde96c8d09d008fe","modified":1495279855850},{"_id":"source/baidu_verify_pzRlBW6eu6.html","hash":"272583530ec2e714bf3b66721bb33351ba02bc87","modified":1495376283511},{"_id":"source/google43dee7d23dee4e5e.html","hash":"e1c96efbc3f46db33ce06b4cb8612f2645550a4a","modified":1495199541000},{"_id":"source/favicon.ico","hash":"6a3af5eaeff6a96c373b17afcf3caef6f5030437","modified":1543247248149},{"_id":"themes/next/.DS_Store","hash":"a0487c39d253e99eadd88ac0b8731bc957b58501","modified":1543413224303},{"_id":"themes/next/.all-contributorsrc","hash":"e32dc4075e304af04b98d0726d489081bea722c0","modified":1541695892156},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1541695892156},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1541695892156},{"_id":"themes/next/.eslintrc.json","hash":"cc5f297f0322672fe3f684f823bc4659e4a54c41","modified":1541695892157},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1541695892157},{"_id":"themes/next/.gitignore","hash":"a18c2e83bb20991b899b58e6aeadcb87dd8aa16e","modified":1541695892161},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1541695892161},{"_id":"themes/next/.travis.yml","hash":"3d1dc928c4a97933e64379cfde749dedf62f252c","modified":1541695892161},{"_id":"themes/next/LICENSE.md","hash":"fc7227c508af3351120181cbf2f9b99dc41f063e","modified":1541695892161},{"_id":"themes/next/README.md","hash":"ee7119baf976616a84d3c9c10fcab567995dc98e","modified":1541695892161},{"_id":"themes/next/bower.json","hash":"087eb7b81c0aa77a2b07c2ecf411ceb5ee00386d","modified":1541695892162},{"_id":"themes/next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1541695892162},{"_id":"themes/next/_config.yml","hash":"2c9f80ba2f997b81ea805613e14557f4fe75b591","modified":1543654001932},{"_id":"themes/next/gulpfile.coffee","hash":"48d2f9fa88a4210308fc41cc7d3f6d53989f71b7","modified":1541695892165},{"_id":"themes/next/package.json","hash":"cf079447c126a9ad760f1457441f31803ef0470b","modified":1541695892195},{"_id":"source/_posts/.DS_Store","hash":"ebe4e99189d61e4be40e6e47c7173734debae77e","modified":1542819663509},{"_id":"source/_posts/ConcurrentLinkedQueue的几个细节问题.md","hash":"ade34b1e7ab32ff8ce7884c8609a355c35387e29","modified":1542817180622},{"_id":"source/_posts/Mesos安装.md","hash":"f1e8f565793bf17c84ec392e5bcd79b1818dec93","modified":1542817384006},{"_id":"source/_posts/MySQL事务隔离性测试.md","hash":"f564e23d0e44ef07977a71ec57584ebe8c94424d","modified":1542818064066},{"_id":"source/_posts/commons-pool.md","hash":"efa25473a35c6de0b6eee36535fdd1369974f76c","modified":1542817077182},{"_id":"source/_posts/ioc-one.md","hash":"2d93f5e615d53fd3ec9a4c763bdc65ee985653f0","modified":1542817633905},{"_id":"source/_posts/java-annotation.md","hash":"56c5d02f89725637c183e80f0f7da1121cbebeeb","modified":1542817337310},{"_id":"source/_posts/jenkins on kubernetes实践.md","hash":"1d8aa5201c1480343920f0098714ca48ff37fdbe","modified":1542817369717},{"_id":"source/_posts/sendmail.md","hash":"3e56ad5f964aa9b1a27bc6db382e895bb0c02567","modified":1542817444824},{"_id":"source/_posts/shell-in-action-1.md","hash":"dbcee840fc3006cd50d1c63d14e8ff1cb6d344eb","modified":1542817455250},{"_id":"source/_posts/zookeeper,kafka集群安装.md","hash":"ca27b6eea4f66a096fb9fe3699a07b1f43c0d953","modified":1542817470257},{"_id":"source/_posts/为什么Redis使用ziplist能节省内存.md","hash":"87a857c120a4992ede8518bdde05212f68b534df","modified":1542818080367},{"_id":"source/_posts/图解redis sentinel.md","hash":"04317cd3113f639c3df0e270ca96f22d85c554a0","modified":1542818086273},{"_id":"source/_posts/图解redis主从.md","hash":"a8497b088db49f49d18be14e76d7372b2c534541","modified":1542818091689},{"_id":"source/about/index.md","hash":"23f29fde0d7af97e92222ea1996c6067656615b1","modified":1439392505633},{"_id":"source/archives/index.md","hash":"ccdbf097fe4213908d3d79defb700a5259c8505d","modified":1439394724564},{"_id":"source/categories/index.md","hash":"34c838833907f61ac0996d1902f88c9168789eec","modified":1542815973620},{"_id":"source/subject/index.md","hash":"ed1bb8e3213f9f2be0e25382f4deafb23a0881b0","modified":1446222412056},{"_id":"source/tags/.DS_Store","hash":"7b25729ebf047f9e7e2472e957300ec1eadcee81","modified":1542815836561},{"_id":"source/tags/index.md","hash":"eb66ba07ce16ea80ce7725e8cc3209ce1b8ac7f0","modified":1542815480346},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"b63696d41f022525e40d7e7870c3785b6bc7536b","modified":1541695892157},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"a5335a99377069ae76fd993d488bc3eaf48f3a05","modified":1541695892157},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"00c25366764e6b9ccb40b877c60dc13b2916bbf7","modified":1541695892158},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"7abbb4c8a29b2c14e576a00f53dbc0b4f5669c13","modified":1541695892159},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1541695892160},{"_id":"themes/next/.github/stale.yml","hash":"fd0856f6745db8bd0228079ccb92a662830cc4fb","modified":1541695892161},{"_id":"themes/next/.git/HEAD","hash":"b6c2091da7683b424070a8dd6d7e377dec7c8ea0","modified":1541695892152},{"_id":"themes/next/.git/config","hash":"2e1904e20cc0ebc04662c38115a391883e219598","modified":1541695857150},{"_id":"themes/next/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1541695854802},{"_id":"themes/next/.git/index","hash":"4fb577800d9cbde7bb8e21e85a0ba6c26b997cc8","modified":1541695892234},{"_id":"themes/next/.git/packed-refs","hash":"9b61919a4fdd44b73ba3f98798152a36b1efe5ae","modified":1541695892150},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"141e989844d0b5ae2e09fb162a280715afb39b0d","modified":1541695892162},{"_id":"themes/next/docs/AUTHORS.md","hash":"7b24be2891167bdedb9284a682c2344ec63e50b5","modified":1541695892162},{"_id":"themes/next/docs/DATA-FILES.md","hash":"8e1962dd3e1b700169b3ae5bba43992f100651ce","modified":1541695892163},{"_id":"themes/next/docs/INSTALLATION.md","hash":"2bbdd6c1751b2b42ce9b9335da420c6026a483e9","modified":1541695892163},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"120750c03ec30ccaa470b113bbe39f3d423c67f0","modified":1541695892163},{"_id":"themes/next/docs/LICENSE","hash":"fe607fe22fc9308f6434b892a7f2d2c5514b8f0d","modified":1541695892163},{"_id":"themes/next/docs/MATH.md","hash":"e6023505dcccaef0b856102543585a13fc6af0b1","modified":1541695892163},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"ad57c168d12ba01cf144a1ea0627b2ffd1847d3e","modified":1541695892163},{"_id":"themes/next/languages/de.yml","hash":"fb478c5040a4e58a4c1ad5fb52a91e5983d65a3a","modified":1541695892166},{"_id":"themes/next/languages/default.yml.bak","hash":"c540c3a0d7db2d4239293c8783881962640b6c34","modified":1542816711197},{"_id":"themes/next/languages/en.yml","hash":"c540c3a0d7db2d4239293c8783881962640b6c34","modified":1542816711197},{"_id":"themes/next/languages/fr.yml","hash":"0162a85ae4175e66882a9ead1249fedb89200467","modified":1541695892166},{"_id":"themes/next/languages/id.yml","hash":"e7fb582e117a0785036dcdbb853a6551263d6aa6","modified":1541695892166},{"_id":"themes/next/languages/it.yml","hash":"62ef41d0a9a3816939cb4d93a524e6930ab9c517","modified":1541695892166},{"_id":"themes/next/languages/ja.yml","hash":"e331b15b1fda0f2285d25853f834682ab8dc3c39","modified":1541695892166},{"_id":"themes/next/languages/ko.yml","hash":"fae155018ae0efdf68669b2c7dd3f959c2e45cc9","modified":1541695892167},{"_id":"themes/next/languages/nl.yml","hash":"bb9ce8adfa5ee94bc6b5fac6ad24ba4605d180d3","modified":1541695892167},{"_id":"themes/next/languages/pt-BR.yml","hash":"bfc80c8a363fa2e8dde38ea2bc85cd19e15ab653","modified":1541695892167},{"_id":"themes/next/languages/pt.yml","hash":"3cb51937d13ff12fcce747f972ccb664840a9ef3","modified":1541695892167},{"_id":"themes/next/languages/ru.yml","hash":"db0644e738d2306ac38567aa183ca3e859a3980f","modified":1541695892167},{"_id":"themes/next/languages/tr.yml","hash":"c5f0c20743b1dd52ccb256050b1397d023e6bcd9","modified":1541695892168},{"_id":"themes/next/languages/vi.yml","hash":"8da921dd8335dd676efce31bf75fdd4af7ce6448","modified":1541695892168},{"_id":"themes/next/languages/zh-CN.yml","hash":"5ae87a3c6a92b85c75a0247be854f2f23e0483e6","modified":1542817974545},{"_id":"themes/next/languages/zh-HK.yml","hash":"7903b96912c605e630fb695534012501b2fad805","modified":1541695892168},{"_id":"themes/next/languages/zh-TW.yml","hash":"6e6d2cd8f4244cb1b349b94904cb4770935acefd","modified":1541695892169},{"_id":"themes/next/layout/_layout.swig","hash":"85de0662a1b136277a72f8d8b4b1425a006f377e","modified":1541695892170},{"_id":"themes/next/layout/archive.swig","hash":"2b6450c6b6d2bcbcd123ad9f59922a5e323d77a5","modified":1541695892193},{"_id":"themes/next/layout/category.swig","hash":"5d955284a42f802a48560b4452c80906a5d1da02","modified":1541695892194},{"_id":"themes/next/layout/index.swig","hash":"c2a3896c64e96790edc10426ef586b6186a87f46","modified":1541695892194},{"_id":"themes/next/layout/page.swig","hash":"862b361852fb6d7a95bfb6077922410a33cd3126","modified":1541695892194},{"_id":"themes/next/layout/post.swig","hash":"318249db246a57e9422875a2457c6acfce974ba5","modified":1541695892194},{"_id":"themes/next/layout/schedule.swig","hash":"3268dd3d90d8b0e142cfa1a2ebb23355baeda148","modified":1541695892194},{"_id":"themes/next/layout/tag.swig","hash":"ba402ce8fd55e80b240e019e8d8c48949b194373","modified":1541695892194},{"_id":"themes/next/scripts/helpers.js","hash":"a70bfad3efda76738dab12e28e8b75e3989ee3da","modified":1541695892195},{"_id":"themes/next/scripts/merge-configs.js","hash":"33afe97284d34542015d358a720823feeebef120","modified":1541695892195},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1541695892195},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1541695892233},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1541695892233},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1541695892233},{"_id":"themes/next/source/.DS_Store","hash":"16b447f5d35397c472d69e2527562c04f54438cb","modified":1543413224304},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1541695892162},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1541695892219},{"_id":"themes/next/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1541695854805},{"_id":"themes/next/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1541695854803},{"_id":"themes/next/.git/hooks/fsmonitor-watchman.sample","hash":"f7c0aa40cb0d620ff0bca3efe3521ec79e5d7156","modified":1541695854806},{"_id":"themes/next/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1541695854807},{"_id":"themes/next/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1541695854807},{"_id":"themes/next/.git/hooks/pre-commit.sample","hash":"33729ad4ce51acda35094e581e4088f3167a0af8","modified":1541695854804},{"_id":"themes/next/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1541695854808},{"_id":"themes/next/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1541695854804},{"_id":"themes/next/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1541695854806},{"_id":"themes/next/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1541695854807},{"_id":"themes/next/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1541695854808},{"_id":"themes/next/.git/info/exclude","hash":"bb5a85730dcf100facee799c05cc4f6affec0745","modified":1541695854801},{"_id":"themes/next/.git/logs/HEAD","hash":"22b1d8d6219b20b656b18464b0affa60fdc2ca33","modified":1541695892152},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"d6d20f60f77a76c77f8e65d0c9adbd79d0274557","modified":1541695892163},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"6c5d69e94961c793da156217ecf1179e868d7ba1","modified":1541695892164},{"_id":"themes/next/docs/ru/README.md","hash":"c54e256ed11a84ee38f755d6f35a3e6e29a91dbc","modified":1541695892164},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"b1dd18d9b890b21718883ea1832e7e02a773104a","modified":1541695892164},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"6855402e2ef59aae307e8bd2a990647d3a605eb8","modified":1541695892164},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"a45a791b49954331390d548ac34169d573ea5922","modified":1541695892164},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"bd2c955d9b7b1b45bd74a4536717d547e03fcde3","modified":1541695892164},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"f3eec572a7d83542e2710a7404082014aaa1a5e7","modified":1541695892165},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"b19a6e0ae96eb7c756fb5b1ba03934c7f9cbb3c3","modified":1541695892165},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"24cf2618d164440b047bb9396263de83bee5b993","modified":1541695892165},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"8ac2f5d2a023211d8d8ea626cbf6b8dea67ac201","modified":1541695892165},{"_id":"themes/next/docs/zh-CN/README.md","hash":"aa6808f4f587c1a97205fa9427ba96a366bcb288","modified":1541695892165},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"5da70d7fa0c988a66a469b9795d33d471a4a4433","modified":1541695892165},{"_id":"themes/next/layout/_custom/head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1541695892169},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1541695892169},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1541695892169},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1541695892171},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"0790ddbc349508d7ece45a9a4391d0a1cd7263cc","modified":1541695892171},{"_id":"themes/next/layout/_macro/post-related.swig","hash":"08fe30ce8909b920540231e36c97e28cfbce62b6","modified":1541695892172},{"_id":"themes/next/layout/_macro/post.swig","hash":"5767eccaf3951151e01c61189016932e9516c8b9","modified":1541695892172},{"_id":"themes/next/layout/_macro/reward.swig","hash":"bd5778d509c51f4b1d8da3a2bc35462929f08c75","modified":1541695892172},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"1f3121ef66a4698fd78f34bf2594ef79a407c92c","modified":1541695892172},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"a9e1346b83cf99e06bed59a53fc069279751e52a","modified":1541695892172},{"_id":"themes/next/layout/_partials/breadcrumb.swig","hash":"6994d891e064f10607bce23f6e2997db7994010e","modified":1541695892173},{"_id":"themes/next/layout/_partials/comments.swig","hash":"eafff2d623af8991844f34819a60e37ac11ef245","modified":1541695892173},{"_id":"themes/next/layout/_partials/footer.swig","hash":"d15a983de60d4c0bdd23cd31cd49de876ed2310c","modified":1541695892173},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1aaf32bed57b976c4c1913fd801be34d4838cc72","modified":1541695892174},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"dbe321bcf3cf45917cc11a3e3f50d8572bac2c70","modified":1541695892175},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"0a0129e926c27fffc6e7ef87fe370016bc7a4564","modified":1541695892180},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"6fc63d5da49cb6157b8792f39c7305b55a0d1593","modified":1541695892180},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"ac3ad2c0eccdf16edaa48816d111aaf51200a54b","modified":1541695892180},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"f380a10c792411eff82204305b097a288ed0b423","modified":1541695892182},{"_id":"themes/next/layout/_third-party/bookmark.swig","hash":"60001c8e08b21bf3a7afaf029839e1455340e95d","modified":1541695892186},{"_id":"themes/next/layout/_third-party/copy-code.swig","hash":"a8ab2035654dd06d94faf11a35750529e922d719","modified":1541695892189},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"f532ce257fca6108e84b8f35329c53f272c2ce84","modified":1541695892190},{"_id":"themes/next/layout/_third-party/github-banner.swig","hash":"cabd9640dc3027a0b3ac06f5ebce777e50754065","modified":1541695892191},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"927f19160ae14e7030df306fc7114ba777476282","modified":1541695892191},{"_id":"themes/next/layout/_third-party/pangu.swig","hash":"6b75c5fd76ae7cf0a7b04024510bd5221607eab3","modified":1541695892191},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1541695892192},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1541695892192},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"b0ca46e0d1ff4c08cb0a3a8c1994f20d0260cef9","modified":1541695892192},{"_id":"themes/next/scripts/tags/button.js","hash":"4b12c376bea894d23cca0f9fcb3d6518b6db279d","modified":1541695892196},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"f13430d9d1c9773b390787c2f046bb1f12a79878","modified":1541695892196},{"_id":"themes/next/scripts/tags/exturl.js","hash":"1412ce2ef59fa4137b697a507fd759ff067a2398","modified":1541695892196},{"_id":"themes/next/scripts/tags/full-image.js","hash":"e282bf5a7c70b3d354001e8f66d3bef1a4fbb79e","modified":1541695892196},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"981e01aaf45a1f0f23ce0796d03134f9e437aaca","modified":1541695892196},{"_id":"themes/next/scripts/tags/include-raw.js","hash":"5db59d56f4f4082382bf1c16722e6c383892b0c5","modified":1541695892196},{"_id":"themes/next/scripts/tags/label.js","hash":"f0ecd3b5773b19a6bd93a819dfe0c49ee418e4de","modified":1541695892197},{"_id":"themes/next/scripts/tags/note.js","hash":"adb945ba93ac487d46b969ca4e59d3681b8f8d1c","modified":1541695892197},{"_id":"themes/next/scripts/tags/tabs.js","hash":"e37761253d68a29593fe9ed2fe403f49b6e971de","modified":1541695892197},{"_id":"themes/next/source/css/.DS_Store","hash":"365dc1ee6afc933cee3bfa4611d037b609f43c3d","modified":1543413229311},{"_id":"themes/next/source/css/main.styl","hash":"c26ca6e7b5bd910b9046d6722c8e00be672890e0","modified":1541695892219},{"_id":"themes/next/source/images/.DS_Store","hash":"d0e4b40bd67f91a1e059b11bf43f87dbf2b77d19","modified":1543502696672},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1541695892219},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1541695892219},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1541695892219},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1541695892220},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1541695892220},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1541695892220},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1541695892220},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1541695892220},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1541695892220},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1541695892221},{"_id":"themes/next/source/images/favicon-16x16-next-bak.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1541695892221},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"3ec104ac311b4da9f2fcaabfb839ea6fdcf0b514","modified":1543247039524},{"_id":"themes/next/source/images/favicon-32x32-next-bak.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1541695892221},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"6a3af5eaeff6a96c373b17afcf3caef6f5030437","modified":1543247248149},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1541695892221},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1541695892221},{"_id":"themes/next/source/images/logoNew.gif","hash":"02a742e5cdc5c50031ef0a6b664fd312f5cd0c9d","modified":1543247167082},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1541695892221},{"_id":"themes/next/source/images/qrcode.jpg","hash":"4eec0b5dd07a5a6f89c343c5e0ae5318a97c63a3","modified":1543247827284},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1541695892222},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1541695892222},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1541695892222},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1541695892181},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1541695892182},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1541695892213},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1541695892213},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1541695892214},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1541695892218},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1541695892219},{"_id":"themes/next/layout/_macro/menu/menu-badge.swig","hash":"65c5e585982dae7ae1542cada71858b4ea1f73d6","modified":1541695892170},{"_id":"themes/next/layout/_macro/menu/menu-item.swig","hash":"d1b73c926109145e52605929b75914cc8b60fb89","modified":1541695892171},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1541695892173},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"a7e376b087ae77f2e2a61ba6af81cde5af693174","modified":1541695892173},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"00bf33b3c557b8f7e9faf49b226ea6ff7df5cda0","modified":1541695892174},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"fd780171713aada5eb4f4ffed8e714617c8ae6be","modified":1541695892174},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"2082f5077551123e695e8afec471c9c44b436acb","modified":1541695892174},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"3db735d0cd2d449edf2674310ac1e7c0043cb357","modified":1541695892174},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"88b4b6051592d26bff59788acb76346ce4e398c2","modified":1541695892174},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"a33b29ccbdc2248aedff23b04e0627f435824406","modified":1541695892175},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1541695892177},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1541695892178},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1541695892179},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1541695892179},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1541695892179},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1541695892179},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"cc865af4a3cb6d25a0be171b7fc919ade306bb50","modified":1541695892181},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"ea03fe9c98ddcfcc0ecfdbe5a2b622f9cde3b3a1","modified":1541695892181},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"ea03fe9c98ddcfcc0ecfdbe5a2b622f9cde3b3a1","modified":1541695892182},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1541695892182},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1541695892182},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1541695892182},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"07307f1f0e0e9858f2c7143cbdfcb2a9a92149ab","modified":1541695892183},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1541695892183},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1541695892183},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"fae69a0e1a1d42f7bb44e594a29857d94594698b","modified":1541695892183},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"beb53371c035b62e1a2c7bb76c63afbb595fe6e5","modified":1541695892183},{"_id":"themes/next/layout/_third-party/analytics/growingio.swig","hash":"5dbeb640707a9c91357e373b9063a48c8e78f439","modified":1541695892184},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"438c6f5e6665d72f4ea7ee206011d669246f6102","modified":1541695892184},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"c28f3f4aa31d7f996d26a97df6cd7ffa9bfd2cec","modified":1541695892184},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1541695892185},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1541695892185},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1541695892186},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1541695892187},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"03ef008bc95e8e83232e5464a6c63d6157d33a5e","modified":1541695892187},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"fe8177e4698df764e470354b6acde8292a3515e0","modified":1541695892188},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"03e83f1311faafb7dddc2899042ed1cacd5c995e","modified":1541695892188},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"2c74a96dd314e804d801f8773ac1b2e0a970fce3","modified":1541695892188},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"34421679cae6581697cd3ab7c3729eb220e3e3f5","modified":1541695892189},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"a6fc00ec7f5642aabd66aa1cf51c6acc5b10e012","modified":1541695892191},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"97dbc2035bcb5aa7eafb80a4202dc827cce34983","modified":1541695892191},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"9b9ff4cc6d5474ab03f09835a2be80e0dba9fe89","modified":1541695892191},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1541695892193},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"b15e10abe85b4270860a56c970b559baa258b2a8","modified":1541695892193},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1541695892193},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1541695892193},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1541695892213},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1541695892213},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"2640a54fa63bdd4c547eab7ce2fc1192cf0ccec8","modified":1541695892213},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"59961fb806a39c367fd19ad37268eee112be6729","modified":1541695892214},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"e1f6f59ad6e562dfe640ee4ed5d1ac9b6aba4114","modified":1541695892218},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1541695892218},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"c167eeb6b736f7b021fba98c38c2c21032ee1255","modified":1541695892218},{"_id":"themes/next/source/css/_variables/base.styl","hash":"2247e277e49ee17fd8ff26d3f3a2a3a61bb3870c","modified":1543413925318},{"_id":"themes/next/source/images/bg.png","hash":"8771e8dce8aa6e86874e0188fbf4ec28f56badca","modified":1543415640140},{"_id":"themes/next/source/js/src/affix.js","hash":"a2aab233d99297435a5274bf512c3c753fe08e80","modified":1541695892222},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"1f7f10c579e7703d0f6acb8b73f3d78a07d0c623","modified":1541695892222},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"1c41508b83cb0c4512e64b4d63afa1be954ce8ef","modified":1541695892222},{"_id":"themes/next/source/js/src/exturl.js","hash":"54825acc8de4793feac415be227b965428f4e97d","modified":1541695892223},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1541695892223},{"_id":"themes/next/source/js/src/motion.js","hash":"b45d2c0d48f2c8e6a0621b8063845f76b89476cc","modified":1541695892223},{"_id":"themes/next/source/js/src/post-details.js","hash":"0dde5e6d4547587662a3256317a9d5d1db507692","modified":1541695892223},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"d07b3776708d4ae79ed2037c4c7391d5c9b06b19","modified":1541695892224},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fa3c92968bcdbcb8d95a1729f7659d9753cbd077","modified":1541695892224},{"_id":"themes/next/source/js/src/utils.js","hash":"66f2ac658d6110f70a86f784d0c5d891a97c14bd","modified":1541695892224},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1541695892224},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1541695892225},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1541695892225},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1541695892225},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1541695892225},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1541695892232},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1541695892232},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1541695892232},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1541695892230},{"_id":"themes/next/.git/objects/pack/pack-0159052e2c7c58c403f0d79dfca04e23ebaaadb0.idx","hash":"10d8a8ea29967ebfe5f0f3a061b761e82acc2ce9","modified":1541695892142},{"_id":"themes/next/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1541695892151},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"6958a97fde63e03983ec2394a4f8e408860fb42b","modified":1541695892192},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1541695892192},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"b4a2f1d031fe44452cf55ded8211cf018235073a","modified":1541695892197},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1541695892197},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1541695892197},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1541695892198},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1541695892198},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1541695892200},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1541695892205},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"aebbd86500d819c4532ab290c62b6f432bc2f878","modified":1541695892211},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"b75256fe3768b1a37b6ff6dd7f9f0ff135a42067","modified":1541695892212},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1541695892212},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"efc40a32487e0ac7b94b1ca81bdbdcc4ec8f2924","modified":1541695892212},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1541695892212},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1541695892212},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"02d138ed65060e98f20bc5b1dd59a791222b7156","modified":1541695892213},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"665b1813a1d6fbc3c5549a76e4f26cd62a804dde","modified":1541695892214},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"0bef9f0dc134215bc4d0984ba3a16a1a0b6f87ec","modified":1541695892214},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"b498068ffbc55ada76f3a8a9ba07fa5122513215","modified":1543413870838},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1541695892214},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"f43c821ea272f80703862260b140932fe4aa0e1f","modified":1541695892215},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"2212511ae14258d93bec57993c0385e5ffbb382b","modified":1541695892215},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1541695892215},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"5e12572b18846250e016a872a738026478ceef37","modified":1541695892215},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1541695892216},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1541695892216},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"35f093fe4c1861661ac1542d6e8ea5a9bbfeb659","modified":1541695892216},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1541695892216},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"d5e8ea6336bc2e237d501ed0d5bbcbbfe296c832","modified":1541695892216},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1541695892217},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"876b5d99061025cf485a3cac440624ded5734319","modified":1541695892217},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"05a5abf02e84ba8f639b6f9533418359f0ae4ecb","modified":1541695892217},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1541695892217},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"41f9cdafa00e256561c50ae0b97ab7fcd7c1d6a2","modified":1541695892217},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"ffa870c3fa37a48b01dc6f967e66f5df508d02bf","modified":1541695892218},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"5779cc8086b1cfde9bc4f1afdd85223bdc45f0a0","modified":1541695892218},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"89267bd16ecbedd1958af7f0fb3f4f654d24fffa","modified":1541695892223},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1541695892226},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1541695892226},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1541695892226},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1541695892230},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1541695892230},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1541695892229},{"_id":"themes/next/.git/logs/refs/remotes/origin/HEAD","hash":"4fe7e69897d109f6c7af84788d0ff68a786d0995","modified":1541695892151},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"39dee82d481dd9d44e33658960ec63e47cd0a715","modified":1541695892198},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"7cc3f36222494c9a1325c5347d7eb9ae53755a32","modified":1543413520948},{"_id":"themes/next/source/css/_common/components/header/github-banner.styl","hash":"ee37e6c465b9b2a7e39175fccfcbed14f2db039b","modified":1541695892198},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1541695892198},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1541695892198},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1541695892198},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1541695892199},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1541695892199},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1541695892199},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"a6dc3c7eb81ef5117c28fa2245fff1adc02d0292","modified":1541695892199},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1541695892199},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"7dd9a0378ccff3e4a2003f486b1a34e74c20dac6","modified":1541695892200},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1541695892200},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"fb451dc4cc0355b57849c27d3eb110c73562f794","modified":1541695892200},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1541695892200},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"f2911a048e5c20ca2a059bd1087d98ac1c51681c","modified":1541695892200},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1541695892201},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1541695892201},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1541695892201},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1541695892201},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"ca89b167d368eac50a4f808fa53ba67e69cbef94","modified":1541695892201},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1541695892201},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"417f05ff12a2aaca6ceeac8b7e7eb26e9440c4c3","modified":1541695892201},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1541695892202},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"549a8a0b5301d32acd86a97f17340cdfcd46fb63","modified":1541695892202},{"_id":"themes/next/source/css/_common/components/post/post-reading_progress.styl","hash":"f4e9f870baa56eae423a123062f00e24cc780be1","modified":1541695892202},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1541695892202},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1541695892202},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"578bb2d5f24cad39205bbafb4c39c7e9962b9fa9","modified":1541695892203},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"fcbbf06b546c366d70b7d2ba5880b0be3ca1e8ea","modified":1541695892202},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1541695892203},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"6089cbf4c907fe198b6501e40dc937480d0be175","modified":1541695892203},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"35c0350096921dd8e2222ec41b6c17a4ea6b44f2","modified":1541695892203},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"e18b90c97aaff027e795f5a0cb10476a71bf1c3a","modified":1541695892203},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1541695892204},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1541695892204},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1541695892204},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1541695892204},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"4427ed3250483ed5b7baad74fa93474bd1eda729","modified":1541695892204},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1541695892204},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"43bc58daa8d35d5d515dc787ceb21dd77633fe49","modified":1541695892204},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1541695892205},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1541695892205},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"6ec8ea7b11a146777b6b8da0f71f0cc1dbd129df","modified":1541695892205},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1541695892205},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1541695892206},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1541695892206},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1541695892206},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1541695892206},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"5e340ee2407a4e39cd708794cfcc718a5f398d7b","modified":1541695892206},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"10e9bb3392826a5a8f4cabfc14c6d81645f33fe6","modified":1541695892206},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1541695892207},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1541695892207},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1541695892207},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1541695892207},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1541695892207},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"76937db9702053d772f6758d9cea4088c2a6e2a3","modified":1541695892208},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1c18c91ab3c60169ebe654c80c968fd8458786a3","modified":1541695892209},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1541695892215},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1541695892216},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1541695892216},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1541695892229},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1541695892232},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1541695892228},{"_id":"themes/next/.git/objects/pack/pack-0159052e2c7c58c403f0d79dfca04e23ebaaadb0.pack","hash":"6d574178274d4cc216722dda05bafe9279a8545f","modified":1541695892140}],"Category":[{"name":"jdk源码","_id":"cjp57u3ws00062xpbjt6dapxg"},{"name":"容器技术","_id":"cjp57u3x0000c2xpb3fpil7pk"},{"name":"mysql进阶","_id":"cjp57u3x2000h2xpb3zj6cksp"},{"name":"redis进阶","_id":"cjp57u3x5000q2xpb8cnv7tjq"},{"name":"开源框架","_id":"cjp57u42f00262xpbrce0y0th"}],"Data":[],"Page":[{"_content":"pzRlBW6eu6","source":"baidu_verify_pzRlBW6eu6.html","raw":"pzRlBW6eu6","date":"2018-11-09T14:36:34.386Z","updated":"2017-05-21T14:18:03.511Z","path":"baidu_verify_pzRlBW6eu6.html","title":"","comments":1,"layout":"page","_id":"cjp57u3v600002xpbh54l4971","content":"pzRlBW6eu6","site":{"data":{}},"excerpt":"","more":"pzRlBW6eu6"},{"_content":"google-site-verification: google43dee7d23dee4e5e.html","source":"google43dee7d23dee4e5e.html","raw":"google-site-verification: google43dee7d23dee4e5e.html","date":"2018-11-09T14:36:34.387Z","updated":"2017-05-19T13:12:21.000Z","path":"google43dee7d23dee4e5e.html","title":"","comments":1,"layout":"page","_id":"cjp57u3v700012xpbbhs3oo80","content":"google-site-verification: google43dee7d23dee4e5e.html","site":{"data":{}},"excerpt":"","more":"google-site-verification: google43dee7d23dee4e5e.html"},{"title":"about","date":"2015-08-12T15:15:05.000Z","_content":"","source":"about/index.md","raw":"title: about\ndate: 2015-08-12 23:15:05\n---\n","updated":"2015-08-12T15:15:05.633Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjp57u3wo00032xpb2w52wqyr","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"archives","date":"2015-08-12T15:52:04.000Z","_content":"","source":"archives/index.md","raw":"title: archives\ndate: 2015-08-12 23:52:04\n---\n","updated":"2015-08-12T15:52:04.564Z","path":"archives/index.html","comments":1,"layout":"page","_id":"cjp57u3wr00052xpbuqzh40i0","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"categories","date":"2018-11-21T15:56:56.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2018-11-21 23:56:56\ntype: \"categories\"\ncomments: false\n---\n","updated":"2018-11-21T15:59:33.620Z","path":"categories/index.html","layout":"page","_id":"cjp57u3ww00092xpb03oj4zuv","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"subject","date":"2015-10-30T16:26:52.000Z","_content":"","source":"subject/index.md","raw":"title: subject\ndate: 2015-10-31 00:26:52\n---\n","updated":"2015-10-30T16:26:52.056Z","path":"subject/index.html","comments":1,"layout":"page","_id":"cjp57u41j001l2xpb6mz25g09","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2018-11-21T15:49:28.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2018-11-21 23:49:28\ntype: \"tags\"\ncomments: false\n---\n","updated":"2018-11-21T15:51:20.346Z","path":"tags/index.html","layout":"page","_id":"cjp57u41l001n2xpbnhuas4tu","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"ConcurrentLinkedQueue的几个细节问题","date":"2018-02-22T15:05:46.000Z","_content":"所有的注释和源码都引用自jdk1.7版本的ConcurrentLinkedQueue\n\n### ABA问题\n源码注释中对这个问题的说明\n> Note that like most non-blocking algorithms in this package,this implementation relies on the fact that in garbage collected systems, there is no possibility of ABA problems due to recycled nodes, so there is no need to use \"counted pointers\" or related techniques seen in versions used in non-GC'ed settings.\n\n(ConcurrentLinkedQueue的实现依赖GC操作，因为GC会收节点所以不会出现ABA问题，因此不需要使用非GC(non-GC'ed)中使用的“计数指针”或相关技术）\n\nGC能避免ABA问题，主要是因为GC能保证引用值相同时他们指向的内容一定是一样的，具体说明看这里[这个文章讲的不错][1]\n<!--more-->\n\n### Node的初始化\n\n为了保证可见性，Node的两个属性都是volatile的\n```java\nprivate static class Node<E> {\n        volatile E item;\n        volatile Node<E> next;\n```\n但是初始化是没有直接对volatile变量赋值，初始化Node使用的是unsafe的putObject方法\n```java\nNode(E item) {\n        /**\n        * Constructs a new node.  Uses relaxed write because item can\n         * only be seen after publication via casNext.\n         */\n            UNSAFE.putObject(this, itemOffset, item);\n        }\n```\n源码中对此的说明\n> When constructing a Node (before enqueuing it) we avoid paying for a volatile write to item by using Unsafe.putObject instead of a normal write.  This allows the cost of enqueue to be \"one-and-a-half\" CASes.（避免写volatile操作的开销，使得入队操作的cost相当与1.5个CAS操作）\n\nUNSAFE的putObject相当于对普通变量的写操作（作者称之为relaxed write），因为item是volatile的所以直接对他赋值会触发volatile写（引发缓存一致性操作），使用putObject方法就是为了避免了这一操作。参考[对putObject()方法的说明][2]\n\n我理解的是初始化的Node在执行构造函数后还需要执行casNext()方法才能被其他线程看到，因此使用\"relaxed write\"是安全的。既然node入队操作由初始化和casNext组成（参考offer()源码）,而执行casNext()之后保证了node的可见性，那么减少初始化操作的性能消耗就可以优化入队操作。\ncasNext方法：\n```java\nclass Node{\n    boolean casNext(Node<E> cmp, Node<E> val) {\n            return UNSAFE.compareAndSwapObject(this, nextOffset, cmp, val);\n        }\n}\n```\n### 引申\n对UNSAFE的一点介绍,UNSAFE的赋值操作：\n\n1. **putXXX(long address, XXX value)**: Will place the specified value of type XXX directly at the specified address.(指定地址保存变量)\n2. **putXXXVolatile(Object target, long offset, XXX value)**\nWill place value at target's address at the specified offset and not hit any thread local caches(不会被加载到线程本地缓存，只保存在主存，保证可见性)\n3. **putOrderedXXX(Object target, long offset, XXX value)**: Will place value at target's address at the specified offet and might not hit all thread local caches.(不保证可见性)\n\n### offer()方法\n\njdk1.7中更改了offer的写法，变得更简洁\n```java\npublic boolean offer(E e) {\n        checkNotNull(e);\n        final Node<E> newNode = new Node<E>(e);\n\n        for (Node<E> t = tail, p = t;;) {\n            Node<E> q = p.next;\n            if (q == null) {\n                // p is last node\n                //Node的入队操作\n                if (p.casNext(null, newNode)) {\n                    // Successful CAS is the linearization point\n                    // for e to become an element of this queue,\n                    // and for newNode to become \"live\".\n                    if (p != t) // hop two nodes at a time\n                        casTail(t, newNode);  // Failure is OK.\n                    return true;\n                }\n                // Lost CAS race to another thread; re-read next\n            }\n            else if (p == q)\n                // We have fallen off list.  If tail is unchanged, it\n                // will also be off-list, in which case we need to\n                // jump to head, from which all live nodes are always\n                // reachable.  Else the new tail is a better bet.\n                p = (t != (t = tail)) ? t : head;\n            else\n                // Check for tail updates after two hops.\n                p = (p != t && t != (t = tail)) ? t : q;\n        }\n    }\n```\n对于第24行，(t!=(t=tail))的执行顺序是这样的\n1. t_old=t\n2. t=tail\n3. t_old!=t\n在执行比较之前tail被赋值给t(new)\n\n### 弱一致迭代器导致的GC问题\n\n在LinkedBlockingQueue也有类似描述\n>That would cause two problems:\n      - allow a rogue Iterator to cause unbounded memory retention\n      - cause cross-generational linking of old Nodes to new Nodes if a Node was tenured while live, which generational GCs have a\n hard time dealing with, causing repeated major collections.\nHowever, only non-deleted Nodes need to be reachable from dequeued Nodes, and reachability does not necessarily have to be of the kind understood by the GC.  We use the trick of linking a Node that has just been dequeued to itself.  Such a self-link implicitly means to advance to head.\n\n### 常见的使用错误\n\n#### 谨慎使用addAll()方法\n\n批量操作不保证原子性，执行addlAll方法是并发的迭代操作可能看不到全部添加到队列的元素。\nAdditionally, the bulk operations addAll, removeAll, retainAll, containsAll, equals, and toArray are not guaranteed to be performed atomically. For example, an iterator operating concurrently with an addAll operation might view only some of the added elements.\n\n#### 谨慎使用size()方法\nint size()方法返回的值不一定是准确的，currentlinkedqueue只能通过从头遍历来统计数量，在此期间发生的添加和删除操作不会反应到size()的返回结果中。\n\n#### head和tail的位置\nhead和tail都支持延迟更新（延迟等于或超过两个节点才更新），这样可以减少cas操作，所以head/tail不保证一定指向头结点和尾节点，甚至不保证head和tail之间的相互顺序。\n>Both head and tail are permitted to lag.  In fact, failing to update them every time one could is a significant optimization(fewer CASes). As with LinkedTransferQueue (see the internal documentation for that class), we use a slack threshold of two;\n      that is, we update head/tail when the current pointer appears to be two or more steps away from the first/last node.\n     Since head and tail are updated concurrently and independently, it is possible for tail to lag behind head (why not)?\n     \n     \n  [1]: http://www.cnblogs.com/devos/p/4396773.html\n  [2]: https://stackoverflow.com/questions/46280313/relaxed-write-what-does-it-mean","source":"_posts/ConcurrentLinkedQueue的几个细节问题.md","raw":"title: ConcurrentLinkedQueue的几个细节问题\ndate: 2018-02-22 23:05:46\ncategories: jdk源码\ntags: [java基础,并发]\n\n---\n所有的注释和源码都引用自jdk1.7版本的ConcurrentLinkedQueue\n\n### ABA问题\n源码注释中对这个问题的说明\n> Note that like most non-blocking algorithms in this package,this implementation relies on the fact that in garbage collected systems, there is no possibility of ABA problems due to recycled nodes, so there is no need to use \"counted pointers\" or related techniques seen in versions used in non-GC'ed settings.\n\n(ConcurrentLinkedQueue的实现依赖GC操作，因为GC会收节点所以不会出现ABA问题，因此不需要使用非GC(non-GC'ed)中使用的“计数指针”或相关技术）\n\nGC能避免ABA问题，主要是因为GC能保证引用值相同时他们指向的内容一定是一样的，具体说明看这里[这个文章讲的不错][1]\n<!--more-->\n\n### Node的初始化\n\n为了保证可见性，Node的两个属性都是volatile的\n```java\nprivate static class Node<E> {\n        volatile E item;\n        volatile Node<E> next;\n```\n但是初始化是没有直接对volatile变量赋值，初始化Node使用的是unsafe的putObject方法\n```java\nNode(E item) {\n        /**\n        * Constructs a new node.  Uses relaxed write because item can\n         * only be seen after publication via casNext.\n         */\n            UNSAFE.putObject(this, itemOffset, item);\n        }\n```\n源码中对此的说明\n> When constructing a Node (before enqueuing it) we avoid paying for a volatile write to item by using Unsafe.putObject instead of a normal write.  This allows the cost of enqueue to be \"one-and-a-half\" CASes.（避免写volatile操作的开销，使得入队操作的cost相当与1.5个CAS操作）\n\nUNSAFE的putObject相当于对普通变量的写操作（作者称之为relaxed write），因为item是volatile的所以直接对他赋值会触发volatile写（引发缓存一致性操作），使用putObject方法就是为了避免了这一操作。参考[对putObject()方法的说明][2]\n\n我理解的是初始化的Node在执行构造函数后还需要执行casNext()方法才能被其他线程看到，因此使用\"relaxed write\"是安全的。既然node入队操作由初始化和casNext组成（参考offer()源码）,而执行casNext()之后保证了node的可见性，那么减少初始化操作的性能消耗就可以优化入队操作。\ncasNext方法：\n```java\nclass Node{\n    boolean casNext(Node<E> cmp, Node<E> val) {\n            return UNSAFE.compareAndSwapObject(this, nextOffset, cmp, val);\n        }\n}\n```\n### 引申\n对UNSAFE的一点介绍,UNSAFE的赋值操作：\n\n1. **putXXX(long address, XXX value)**: Will place the specified value of type XXX directly at the specified address.(指定地址保存变量)\n2. **putXXXVolatile(Object target, long offset, XXX value)**\nWill place value at target's address at the specified offset and not hit any thread local caches(不会被加载到线程本地缓存，只保存在主存，保证可见性)\n3. **putOrderedXXX(Object target, long offset, XXX value)**: Will place value at target's address at the specified offet and might not hit all thread local caches.(不保证可见性)\n\n### offer()方法\n\njdk1.7中更改了offer的写法，变得更简洁\n```java\npublic boolean offer(E e) {\n        checkNotNull(e);\n        final Node<E> newNode = new Node<E>(e);\n\n        for (Node<E> t = tail, p = t;;) {\n            Node<E> q = p.next;\n            if (q == null) {\n                // p is last node\n                //Node的入队操作\n                if (p.casNext(null, newNode)) {\n                    // Successful CAS is the linearization point\n                    // for e to become an element of this queue,\n                    // and for newNode to become \"live\".\n                    if (p != t) // hop two nodes at a time\n                        casTail(t, newNode);  // Failure is OK.\n                    return true;\n                }\n                // Lost CAS race to another thread; re-read next\n            }\n            else if (p == q)\n                // We have fallen off list.  If tail is unchanged, it\n                // will also be off-list, in which case we need to\n                // jump to head, from which all live nodes are always\n                // reachable.  Else the new tail is a better bet.\n                p = (t != (t = tail)) ? t : head;\n            else\n                // Check for tail updates after two hops.\n                p = (p != t && t != (t = tail)) ? t : q;\n        }\n    }\n```\n对于第24行，(t!=(t=tail))的执行顺序是这样的\n1. t_old=t\n2. t=tail\n3. t_old!=t\n在执行比较之前tail被赋值给t(new)\n\n### 弱一致迭代器导致的GC问题\n\n在LinkedBlockingQueue也有类似描述\n>That would cause two problems:\n      - allow a rogue Iterator to cause unbounded memory retention\n      - cause cross-generational linking of old Nodes to new Nodes if a Node was tenured while live, which generational GCs have a\n hard time dealing with, causing repeated major collections.\nHowever, only non-deleted Nodes need to be reachable from dequeued Nodes, and reachability does not necessarily have to be of the kind understood by the GC.  We use the trick of linking a Node that has just been dequeued to itself.  Such a self-link implicitly means to advance to head.\n\n### 常见的使用错误\n\n#### 谨慎使用addAll()方法\n\n批量操作不保证原子性，执行addlAll方法是并发的迭代操作可能看不到全部添加到队列的元素。\nAdditionally, the bulk operations addAll, removeAll, retainAll, containsAll, equals, and toArray are not guaranteed to be performed atomically. For example, an iterator operating concurrently with an addAll operation might view only some of the added elements.\n\n#### 谨慎使用size()方法\nint size()方法返回的值不一定是准确的，currentlinkedqueue只能通过从头遍历来统计数量，在此期间发生的添加和删除操作不会反应到size()的返回结果中。\n\n#### head和tail的位置\nhead和tail都支持延迟更新（延迟等于或超过两个节点才更新），这样可以减少cas操作，所以head/tail不保证一定指向头结点和尾节点，甚至不保证head和tail之间的相互顺序。\n>Both head and tail are permitted to lag.  In fact, failing to update them every time one could is a significant optimization(fewer CASes). As with LinkedTransferQueue (see the internal documentation for that class), we use a slack threshold of two;\n      that is, we update head/tail when the current pointer appears to be two or more steps away from the first/last node.\n     Since head and tail are updated concurrently and independently, it is possible for tail to lag behind head (why not)?\n     \n     \n  [1]: http://www.cnblogs.com/devos/p/4396773.html\n  [2]: https://stackoverflow.com/questions/46280313/relaxed-write-what-does-it-mean","slug":"ConcurrentLinkedQueue的几个细节问题","published":1,"updated":"2018-11-21T16:19:40.622Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp57u3wl00022xpbgd96hojz","content":"<p>所有的注释和源码都引用自jdk1.7版本的ConcurrentLinkedQueue</p>\n<h3 id=\"ABA问题\"><a href=\"#ABA问题\" class=\"headerlink\" title=\"ABA问题\"></a>ABA问题</h3><p>源码注释中对这个问题的说明</p>\n<blockquote>\n<p>Note that like most non-blocking algorithms in this package,this implementation relies on the fact that in garbage collected systems, there is no possibility of ABA problems due to recycled nodes, so there is no need to use “counted pointers” or related techniques seen in versions used in non-GC’ed settings.</p>\n</blockquote>\n<p>(ConcurrentLinkedQueue的实现依赖GC操作，因为GC会收节点所以不会出现ABA问题，因此不需要使用非GC(non-GC’ed)中使用的“计数指针”或相关技术）</p>\n<p>GC能避免ABA问题，主要是因为GC能保证引用值相同时他们指向的内容一定是一样的，具体说明看这里<a href=\"http://www.cnblogs.com/devos/p/4396773.html\" target=\"_blank\" rel=\"noopener\">这个文章讲的不错</a><br><a id=\"more\"></a></p>\n<h3 id=\"Node的初始化\"><a href=\"#Node的初始化\" class=\"headerlink\" title=\"Node的初始化\"></a>Node的初始化</h3><p>为了保证可见性，Node的两个属性都是volatile的<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">volatile</span> E item;</span><br><span class=\"line\">        <span class=\"keyword\">volatile</span> Node&lt;E&gt; next;</span><br></pre></td></tr></table></figure></p>\n<p>但是初始化是没有直接对volatile变量赋值，初始化Node使用的是unsafe的putObject方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Node(E item) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">        * Constructs a new node.  Uses relaxed write because item can</span></span><br><span class=\"line\"><span class=\"comment\">         * only be seen after publication via casNext.</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">            UNSAFE.putObject(<span class=\"keyword\">this</span>, itemOffset, item);</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure></p>\n<p>源码中对此的说明</p>\n<blockquote>\n<p>When constructing a Node (before enqueuing it) we avoid paying for a volatile write to item by using Unsafe.putObject instead of a normal write.  This allows the cost of enqueue to be “one-and-a-half” CASes.（避免写volatile操作的开销，使得入队操作的cost相当与1.5个CAS操作）</p>\n</blockquote>\n<p>UNSAFE的putObject相当于对普通变量的写操作（作者称之为relaxed write），因为item是volatile的所以直接对他赋值会触发volatile写（引发缓存一致性操作），使用putObject方法就是为了避免了这一操作。参考<a href=\"https://stackoverflow.com/questions/46280313/relaxed-write-what-does-it-mean\" target=\"_blank\" rel=\"noopener\">对putObject()方法的说明</a></p>\n<p>我理解的是初始化的Node在执行构造函数后还需要执行casNext()方法才能被其他线程看到，因此使用”relaxed write”是安全的。既然node入队操作由初始化和casNext组成（参考offer()源码）,而执行casNext()之后保证了node的可见性，那么减少初始化操作的性能消耗就可以优化入队操作。<br>casNext方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">casNext</span><span class=\"params\">(Node&lt;E&gt; cmp, Node&lt;E&gt; val)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> UNSAFE.compareAndSwapObject(<span class=\"keyword\">this</span>, nextOffset, cmp, val);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"引申\"><a href=\"#引申\" class=\"headerlink\" title=\"引申\"></a>引申</h3><p>对UNSAFE的一点介绍,UNSAFE的赋值操作：</p>\n<ol>\n<li><strong>putXXX(long address, XXX value)</strong>: Will place the specified value of type XXX directly at the specified address.(指定地址保存变量)</li>\n<li><strong>putXXXVolatile(Object target, long offset, XXX value)</strong><br>Will place value at target’s address at the specified offset and not hit any thread local caches(不会被加载到线程本地缓存，只保存在主存，保证可见性)</li>\n<li><strong>putOrderedXXX(Object target, long offset, XXX value)</strong>: Will place value at target’s address at the specified offet and might not hit all thread local caches.(不保证可见性)</li>\n</ol>\n<h3 id=\"offer-方法\"><a href=\"#offer-方法\" class=\"headerlink\" title=\"offer()方法\"></a>offer()方法</h3><p>jdk1.7中更改了offer的写法，变得更简洁<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">offer</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">        checkNotNull(e);</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Node&lt;E&gt; newNode = <span class=\"keyword\">new</span> Node&lt;E&gt;(e);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Node&lt;E&gt; t = tail, p = t;;) &#123;</span><br><span class=\"line\">            Node&lt;E&gt; q = p.next;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (q == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// p is last node</span></span><br><span class=\"line\">                <span class=\"comment\">//Node的入队操作</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p.casNext(<span class=\"keyword\">null</span>, newNode)) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// Successful CAS is the linearization point</span></span><br><span class=\"line\">                    <span class=\"comment\">// for e to become an element of this queue,</span></span><br><span class=\"line\">                    <span class=\"comment\">// and for newNode to become \"live\".</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (p != t) <span class=\"comment\">// hop two nodes at a time</span></span><br><span class=\"line\">                        casTail(t, newNode);  <span class=\"comment\">// Failure is OK.</span></span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// Lost CAS race to another thread; re-read next</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p == q)</span><br><span class=\"line\">                <span class=\"comment\">// We have fallen off list.  If tail is unchanged, it</span></span><br><span class=\"line\">                <span class=\"comment\">// will also be off-list, in which case we need to</span></span><br><span class=\"line\">                <span class=\"comment\">// jump to head, from which all live nodes are always</span></span><br><span class=\"line\">                <span class=\"comment\">// reachable.  Else the new tail is a better bet.</span></span><br><span class=\"line\">                p = (t != (t = tail)) ? t : head;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                <span class=\"comment\">// Check for tail updates after two hops.</span></span><br><span class=\"line\">                p = (p != t &amp;&amp; t != (t = tail)) ? t : q;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>对于第24行，(t!=(t=tail))的执行顺序是这样的</p>\n<ol>\n<li>t_old=t</li>\n<li>t=tail</li>\n<li>t_old!=t<br>在执行比较之前tail被赋值给t(new)</li>\n</ol>\n<h3 id=\"弱一致迭代器导致的GC问题\"><a href=\"#弱一致迭代器导致的GC问题\" class=\"headerlink\" title=\"弱一致迭代器导致的GC问题\"></a>弱一致迭代器导致的GC问题</h3><p>在LinkedBlockingQueue也有类似描述</p>\n<blockquote>\n<p>That would cause two problems:</p>\n<pre><code>- allow a rogue Iterator to cause unbounded memory retention\n- cause cross-generational linking of old Nodes to new Nodes if a Node was tenured while live, which generational GCs have a\n</code></pre><p> hard time dealing with, causing repeated major collections.<br>However, only non-deleted Nodes need to be reachable from dequeued Nodes, and reachability does not necessarily have to be of the kind understood by the GC.  We use the trick of linking a Node that has just been dequeued to itself.  Such a self-link implicitly means to advance to head.</p>\n</blockquote>\n<h3 id=\"常见的使用错误\"><a href=\"#常见的使用错误\" class=\"headerlink\" title=\"常见的使用错误\"></a>常见的使用错误</h3><h4 id=\"谨慎使用addAll-方法\"><a href=\"#谨慎使用addAll-方法\" class=\"headerlink\" title=\"谨慎使用addAll()方法\"></a>谨慎使用addAll()方法</h4><p>批量操作不保证原子性，执行addlAll方法是并发的迭代操作可能看不到全部添加到队列的元素。<br>Additionally, the bulk operations addAll, removeAll, retainAll, containsAll, equals, and toArray are not guaranteed to be performed atomically. For example, an iterator operating concurrently with an addAll operation might view only some of the added elements.</p>\n<h4 id=\"谨慎使用size-方法\"><a href=\"#谨慎使用size-方法\" class=\"headerlink\" title=\"谨慎使用size()方法\"></a>谨慎使用size()方法</h4><p>int size()方法返回的值不一定是准确的，currentlinkedqueue只能通过从头遍历来统计数量，在此期间发生的添加和删除操作不会反应到size()的返回结果中。</p>\n<h4 id=\"head和tail的位置\"><a href=\"#head和tail的位置\" class=\"headerlink\" title=\"head和tail的位置\"></a>head和tail的位置</h4><p>head和tail都支持延迟更新（延迟等于或超过两个节点才更新），这样可以减少cas操作，所以head/tail不保证一定指向头结点和尾节点，甚至不保证head和tail之间的相互顺序。</p>\n<blockquote>\n<p>Both head and tail are permitted to lag.  In fact, failing to update them every time one could is a significant optimization(fewer CASes). As with LinkedTransferQueue (see the internal documentation for that class), we use a slack threshold of two;<br>      that is, we update head/tail when the current pointer appears to be two or more steps away from the first/last node.<br>     Since head and tail are updated concurrently and independently, it is possible for tail to lag behind head (why not)?</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>所有的注释和源码都引用自jdk1.7版本的ConcurrentLinkedQueue</p>\n<h3 id=\"ABA问题\"><a href=\"#ABA问题\" class=\"headerlink\" title=\"ABA问题\"></a>ABA问题</h3><p>源码注释中对这个问题的说明</p>\n<blockquote>\n<p>Note that like most non-blocking algorithms in this package,this implementation relies on the fact that in garbage collected systems, there is no possibility of ABA problems due to recycled nodes, so there is no need to use “counted pointers” or related techniques seen in versions used in non-GC’ed settings.</p>\n</blockquote>\n<p>(ConcurrentLinkedQueue的实现依赖GC操作，因为GC会收节点所以不会出现ABA问题，因此不需要使用非GC(non-GC’ed)中使用的“计数指针”或相关技术）</p>\n<p>GC能避免ABA问题，主要是因为GC能保证引用值相同时他们指向的内容一定是一样的，具体说明看这里<a href=\"http://www.cnblogs.com/devos/p/4396773.html\" target=\"_blank\" rel=\"noopener\">这个文章讲的不错</a><br>","more":"</p>\n<h3 id=\"Node的初始化\"><a href=\"#Node的初始化\" class=\"headerlink\" title=\"Node的初始化\"></a>Node的初始化</h3><p>为了保证可见性，Node的两个属性都是volatile的<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">volatile</span> E item;</span><br><span class=\"line\">        <span class=\"keyword\">volatile</span> Node&lt;E&gt; next;</span><br></pre></td></tr></table></figure></p>\n<p>但是初始化是没有直接对volatile变量赋值，初始化Node使用的是unsafe的putObject方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Node(E item) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">        * Constructs a new node.  Uses relaxed write because item can</span></span><br><span class=\"line\"><span class=\"comment\">         * only be seen after publication via casNext.</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">            UNSAFE.putObject(<span class=\"keyword\">this</span>, itemOffset, item);</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure></p>\n<p>源码中对此的说明</p>\n<blockquote>\n<p>When constructing a Node (before enqueuing it) we avoid paying for a volatile write to item by using Unsafe.putObject instead of a normal write.  This allows the cost of enqueue to be “one-and-a-half” CASes.（避免写volatile操作的开销，使得入队操作的cost相当与1.5个CAS操作）</p>\n</blockquote>\n<p>UNSAFE的putObject相当于对普通变量的写操作（作者称之为relaxed write），因为item是volatile的所以直接对他赋值会触发volatile写（引发缓存一致性操作），使用putObject方法就是为了避免了这一操作。参考<a href=\"https://stackoverflow.com/questions/46280313/relaxed-write-what-does-it-mean\" target=\"_blank\" rel=\"noopener\">对putObject()方法的说明</a></p>\n<p>我理解的是初始化的Node在执行构造函数后还需要执行casNext()方法才能被其他线程看到，因此使用”relaxed write”是安全的。既然node入队操作由初始化和casNext组成（参考offer()源码）,而执行casNext()之后保证了node的可见性，那么减少初始化操作的性能消耗就可以优化入队操作。<br>casNext方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">casNext</span><span class=\"params\">(Node&lt;E&gt; cmp, Node&lt;E&gt; val)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> UNSAFE.compareAndSwapObject(<span class=\"keyword\">this</span>, nextOffset, cmp, val);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"引申\"><a href=\"#引申\" class=\"headerlink\" title=\"引申\"></a>引申</h3><p>对UNSAFE的一点介绍,UNSAFE的赋值操作：</p>\n<ol>\n<li><strong>putXXX(long address, XXX value)</strong>: Will place the specified value of type XXX directly at the specified address.(指定地址保存变量)</li>\n<li><strong>putXXXVolatile(Object target, long offset, XXX value)</strong><br>Will place value at target’s address at the specified offset and not hit any thread local caches(不会被加载到线程本地缓存，只保存在主存，保证可见性)</li>\n<li><strong>putOrderedXXX(Object target, long offset, XXX value)</strong>: Will place value at target’s address at the specified offet and might not hit all thread local caches.(不保证可见性)</li>\n</ol>\n<h3 id=\"offer-方法\"><a href=\"#offer-方法\" class=\"headerlink\" title=\"offer()方法\"></a>offer()方法</h3><p>jdk1.7中更改了offer的写法，变得更简洁<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">offer</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">        checkNotNull(e);</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Node&lt;E&gt; newNode = <span class=\"keyword\">new</span> Node&lt;E&gt;(e);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Node&lt;E&gt; t = tail, p = t;;) &#123;</span><br><span class=\"line\">            Node&lt;E&gt; q = p.next;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (q == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// p is last node</span></span><br><span class=\"line\">                <span class=\"comment\">//Node的入队操作</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p.casNext(<span class=\"keyword\">null</span>, newNode)) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// Successful CAS is the linearization point</span></span><br><span class=\"line\">                    <span class=\"comment\">// for e to become an element of this queue,</span></span><br><span class=\"line\">                    <span class=\"comment\">// and for newNode to become \"live\".</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (p != t) <span class=\"comment\">// hop two nodes at a time</span></span><br><span class=\"line\">                        casTail(t, newNode);  <span class=\"comment\">// Failure is OK.</span></span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// Lost CAS race to another thread; re-read next</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p == q)</span><br><span class=\"line\">                <span class=\"comment\">// We have fallen off list.  If tail is unchanged, it</span></span><br><span class=\"line\">                <span class=\"comment\">// will also be off-list, in which case we need to</span></span><br><span class=\"line\">                <span class=\"comment\">// jump to head, from which all live nodes are always</span></span><br><span class=\"line\">                <span class=\"comment\">// reachable.  Else the new tail is a better bet.</span></span><br><span class=\"line\">                p = (t != (t = tail)) ? t : head;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                <span class=\"comment\">// Check for tail updates after two hops.</span></span><br><span class=\"line\">                p = (p != t &amp;&amp; t != (t = tail)) ? t : q;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>对于第24行，(t!=(t=tail))的执行顺序是这样的</p>\n<ol>\n<li>t_old=t</li>\n<li>t=tail</li>\n<li>t_old!=t<br>在执行比较之前tail被赋值给t(new)</li>\n</ol>\n<h3 id=\"弱一致迭代器导致的GC问题\"><a href=\"#弱一致迭代器导致的GC问题\" class=\"headerlink\" title=\"弱一致迭代器导致的GC问题\"></a>弱一致迭代器导致的GC问题</h3><p>在LinkedBlockingQueue也有类似描述</p>\n<blockquote>\n<p>That would cause two problems:</p>\n<pre><code>- allow a rogue Iterator to cause unbounded memory retention\n- cause cross-generational linking of old Nodes to new Nodes if a Node was tenured while live, which generational GCs have a\n</code></pre><p> hard time dealing with, causing repeated major collections.<br>However, only non-deleted Nodes need to be reachable from dequeued Nodes, and reachability does not necessarily have to be of the kind understood by the GC.  We use the trick of linking a Node that has just been dequeued to itself.  Such a self-link implicitly means to advance to head.</p>\n</blockquote>\n<h3 id=\"常见的使用错误\"><a href=\"#常见的使用错误\" class=\"headerlink\" title=\"常见的使用错误\"></a>常见的使用错误</h3><h4 id=\"谨慎使用addAll-方法\"><a href=\"#谨慎使用addAll-方法\" class=\"headerlink\" title=\"谨慎使用addAll()方法\"></a>谨慎使用addAll()方法</h4><p>批量操作不保证原子性，执行addlAll方法是并发的迭代操作可能看不到全部添加到队列的元素。<br>Additionally, the bulk operations addAll, removeAll, retainAll, containsAll, equals, and toArray are not guaranteed to be performed atomically. For example, an iterator operating concurrently with an addAll operation might view only some of the added elements.</p>\n<h4 id=\"谨慎使用size-方法\"><a href=\"#谨慎使用size-方法\" class=\"headerlink\" title=\"谨慎使用size()方法\"></a>谨慎使用size()方法</h4><p>int size()方法返回的值不一定是准确的，currentlinkedqueue只能通过从头遍历来统计数量，在此期间发生的添加和删除操作不会反应到size()的返回结果中。</p>\n<h4 id=\"head和tail的位置\"><a href=\"#head和tail的位置\" class=\"headerlink\" title=\"head和tail的位置\"></a>head和tail的位置</h4><p>head和tail都支持延迟更新（延迟等于或超过两个节点才更新），这样可以减少cas操作，所以head/tail不保证一定指向头结点和尾节点，甚至不保证head和tail之间的相互顺序。</p>\n<blockquote>\n<p>Both head and tail are permitted to lag.  In fact, failing to update them every time one could is a significant optimization(fewer CASes). As with LinkedTransferQueue (see the internal documentation for that class), we use a slack threshold of two;<br>      that is, we update head/tail when the current pointer appears to be two or more steps away from the first/last node.<br>     Since head and tail are updated concurrently and independently, it is possible for tail to lag behind head (why not)?</p>\n</blockquote>"},{"title":"Mesos安装","date":"2017-12-26T12:05:46.000Z","_content":"\n系统环境：CentOS 6.6 java7\n\nmesos安装\n\n按官网教程下载&编译\nhttp://mesos.apache.org/documentation/latest/building/\n\n借助mussh同时操作多个机器（需要先建立互信）\n\n示例：`./mussh -H iplist -c 'hostname -i'`;\n-H 指定ip\n-c 指定执行的命令\niplist 一行一个ip\ncat iplist \n10.9.19.xx\n10.9.19.xx\n10.9.19.xx\n<!--more-->\n\n问题\n1.执行configure时\nconfigure: error: cannot find libcurl\n-------------------------------------------------------------------\nlibcurl is required for mesos to build.\n-------------------------------------------------------------------\n `yum install libcurl-devel `\n2.libsubversion-1 is required for mesos to build.\n\n` yum install -y subversion-devel`\n这两个都是之前命令中安装的东西但是到了这里又需要重新安装，应该是yum安装失败的问题\n编译过程太慢了\n\n3.执行make时出现错误\n>Building mesos-1.4.0.jar ...\nException in thread \"main\" java.lang.UnsupportedClassVersionError: org/apache/maven/cli/MavenCli : Unsupported major.minor version 51.0\n\n这个主要是因为你的java环境低于1.7造成的，可以尝试升级jdk版本，\n但是**我在升级之后明明java  -version提示的1.7，编译还是失败**，后来查看Makefile文件发现，文件中已经写死了jdk路径，比如这种：\n`CONFIGURE_ARGS =  'JAVA_HOME=/opt/soft/jdk/jdk1.6.0_45`\n最后通过修改(注意有好几个Makefile文件)\n`vim build/src/Makefile`\n`1,$s/jdk1.6.0_45/jdk1.7.0_79/g`（执行替换）\n\n配置有两种\n一个是 在通过命令行启动时添加选项 eg:--option_name=value\n一个是 通过设置环境变量 eg:MESOS_XXX(XXX就是OPTION_NAME）\n\nmesos master配置\n必填项\n--work_dir=/var/lib/mesos/master\n这两个在单master时是不需要的\n--zk=\n--quorum==\n\n我们使用环境变量来配置\necho 'export MESOS_work_dir=/var/lib/mesos'>>/etc/profile\nsource /etc/profile\n进入build目录\n执行`./bin/mesos-master.sh --ip=127.0.0.1 >/dev/null &`\n启动master\n\nmesos agent配置\n必填项\n--master=\nhost:port \nzk://host1:port1,host2:port2,.../path zk://username:password@host1:port1,host2:port2,.../path file:///path/to/file (where file contains one of the above)\n--work_dir=VALUE \n\n`./mussh -H iplist3 -c 'echo \"export MESOS_master=10.252.81.25:5050\">>/etc/profile'`\n`./mussh -H iplist3 -c 'echo \"export MESOS_work_dir=/var/lib/mesos/agent\">>/etc/profile'\n`\n`./mussh -H iplist3 -c 'source /etc/profile'`（mussh执行source无效，还是要逐个刷新）\n`./bin/mesos-agent.sh`启动agent\n\nagent启动报错，无法在master注册\nXX exited event for master XX\n这时要检查master的hostname是不是配置的ip地址，如果不一致使用hostname \"name\"命令设置为对应ip\n\n在master访问http://127.0.0.1:5050/#/agents\n就能看到启动的agents\n![启动成功][1]\n\n\n  [1]: http://7xl4v5.com1.z0.glb.clouddn.com/%E7%81%AB%E7%8B%90%E6%88%AA%E5%9B%BE_2017-11-20T03-34-36.517Z.png","source":"_posts/Mesos安装.md","raw":"title: Mesos安装\ndate: 2017-12-26 20:05:46\ncategories: 容器技术\ntags: [mesos]\n\n---\n\n系统环境：CentOS 6.6 java7\n\nmesos安装\n\n按官网教程下载&编译\nhttp://mesos.apache.org/documentation/latest/building/\n\n借助mussh同时操作多个机器（需要先建立互信）\n\n示例：`./mussh -H iplist -c 'hostname -i'`;\n-H 指定ip\n-c 指定执行的命令\niplist 一行一个ip\ncat iplist \n10.9.19.xx\n10.9.19.xx\n10.9.19.xx\n<!--more-->\n\n问题\n1.执行configure时\nconfigure: error: cannot find libcurl\n-------------------------------------------------------------------\nlibcurl is required for mesos to build.\n-------------------------------------------------------------------\n `yum install libcurl-devel `\n2.libsubversion-1 is required for mesos to build.\n\n` yum install -y subversion-devel`\n这两个都是之前命令中安装的东西但是到了这里又需要重新安装，应该是yum安装失败的问题\n编译过程太慢了\n\n3.执行make时出现错误\n>Building mesos-1.4.0.jar ...\nException in thread \"main\" java.lang.UnsupportedClassVersionError: org/apache/maven/cli/MavenCli : Unsupported major.minor version 51.0\n\n这个主要是因为你的java环境低于1.7造成的，可以尝试升级jdk版本，\n但是**我在升级之后明明java  -version提示的1.7，编译还是失败**，后来查看Makefile文件发现，文件中已经写死了jdk路径，比如这种：\n`CONFIGURE_ARGS =  'JAVA_HOME=/opt/soft/jdk/jdk1.6.0_45`\n最后通过修改(注意有好几个Makefile文件)\n`vim build/src/Makefile`\n`1,$s/jdk1.6.0_45/jdk1.7.0_79/g`（执行替换）\n\n配置有两种\n一个是 在通过命令行启动时添加选项 eg:--option_name=value\n一个是 通过设置环境变量 eg:MESOS_XXX(XXX就是OPTION_NAME）\n\nmesos master配置\n必填项\n--work_dir=/var/lib/mesos/master\n这两个在单master时是不需要的\n--zk=\n--quorum==\n\n我们使用环境变量来配置\necho 'export MESOS_work_dir=/var/lib/mesos'>>/etc/profile\nsource /etc/profile\n进入build目录\n执行`./bin/mesos-master.sh --ip=127.0.0.1 >/dev/null &`\n启动master\n\nmesos agent配置\n必填项\n--master=\nhost:port \nzk://host1:port1,host2:port2,.../path zk://username:password@host1:port1,host2:port2,.../path file:///path/to/file (where file contains one of the above)\n--work_dir=VALUE \n\n`./mussh -H iplist3 -c 'echo \"export MESOS_master=10.252.81.25:5050\">>/etc/profile'`\n`./mussh -H iplist3 -c 'echo \"export MESOS_work_dir=/var/lib/mesos/agent\">>/etc/profile'\n`\n`./mussh -H iplist3 -c 'source /etc/profile'`（mussh执行source无效，还是要逐个刷新）\n`./bin/mesos-agent.sh`启动agent\n\nagent启动报错，无法在master注册\nXX exited event for master XX\n这时要检查master的hostname是不是配置的ip地址，如果不一致使用hostname \"name\"命令设置为对应ip\n\n在master访问http://127.0.0.1:5050/#/agents\n就能看到启动的agents\n![启动成功][1]\n\n\n  [1]: http://7xl4v5.com1.z0.glb.clouddn.com/%E7%81%AB%E7%8B%90%E6%88%AA%E5%9B%BE_2017-11-20T03-34-36.517Z.png","slug":"Mesos安装","published":1,"updated":"2018-11-21T16:23:04.006Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp57u3wp00042xpbeybm9foe","content":"<p>系统环境：CentOS 6.6 java7</p>\n<p>mesos安装</p>\n<p>按官网教程下载&amp;编译<br><a href=\"http://mesos.apache.org/documentation/latest/building/\" target=\"_blank\" rel=\"noopener\">http://mesos.apache.org/documentation/latest/building/</a></p>\n<p>借助mussh同时操作多个机器（需要先建立互信）</p>\n<p>示例：<code>./mussh -H iplist -c &#39;hostname -i&#39;</code>;<br>-H 指定ip<br>-c 指定执行的命令<br>iplist 一行一个ip<br>cat iplist<br>10.9.19.xx<br>10.9.19.xx<br>10.9.19.xx<br><a id=\"more\"></a></p>\n<p>问题<br>1.执行configure时</p>\n<h2 id=\"configure-error-cannot-find-libcurl\"><a href=\"#configure-error-cannot-find-libcurl\" class=\"headerlink\" title=\"configure: error: cannot find libcurl\"></a>configure: error: cannot find libcurl</h2><h2 id=\"libcurl-is-required-for-mesos-to-build\"><a href=\"#libcurl-is-required-for-mesos-to-build\" class=\"headerlink\" title=\"libcurl is required for mesos to build.\"></a>libcurl is required for mesos to build.</h2><p> <code>yum install libcurl-devel</code><br>2.libsubversion-1 is required for mesos to build.</p>\n<p><code>yum install -y subversion-devel</code><br>这两个都是之前命令中安装的东西但是到了这里又需要重新安装，应该是yum安装失败的问题<br>编译过程太慢了</p>\n<p>3.执行make时出现错误</p>\n<blockquote>\n<p>Building mesos-1.4.0.jar …<br>Exception in thread “main” java.lang.UnsupportedClassVersionError: org/apache/maven/cli/MavenCli : Unsupported major.minor version 51.0</p>\n</blockquote>\n<p>这个主要是因为你的java环境低于1.7造成的，可以尝试升级jdk版本，<br>但是<strong>我在升级之后明明java  -version提示的1.7，编译还是失败</strong>，后来查看Makefile文件发现，文件中已经写死了jdk路径，比如这种：<br><code>CONFIGURE_ARGS =  &#39;JAVA_HOME=/opt/soft/jdk/jdk1.6.0_45</code><br>最后通过修改(注意有好几个Makefile文件)<br><code>vim build/src/Makefile</code><br><code>1,$s/jdk1.6.0_45/jdk1.7.0_79/g</code>（执行替换）</p>\n<p>配置有两种<br>一个是 在通过命令行启动时添加选项 eg:–option_name=value<br>一个是 通过设置环境变量 eg:MESOS_XXX(XXX就是OPTION_NAME）</p>\n<p>mesos master配置<br>必填项<br>–work_dir=/var/lib/mesos/master<br>这两个在单master时是不需要的<br>–zk=<br>–quorum==</p>\n<p>我们使用环境变量来配置<br>echo ‘export MESOS_work_dir=/var/lib/mesos’&gt;&gt;/etc/profile<br>source /etc/profile<br>进入build目录<br>执行<code>./bin/mesos-master.sh --ip=127.0.0.1 &gt;/dev/null &amp;</code><br>启动master</p>\n<p>mesos agent配置<br>必填项<br>–master=<br>host:port<br>zk://host1:port1,host2:port2,…/path zk://username:password@host1:port1,host2:port2,…/path file:///path/to/file (where file contains one of the above)<br>–work_dir=VALUE </p>\n<p><code>./mussh -H iplist3 -c &#39;echo &quot;export MESOS_master=10.252.81.25:5050&quot;&gt;&gt;/etc/profile&#39;</code><br><code>./mussh -H iplist3 -c &#39;echo &quot;export MESOS_work_dir=/var/lib/mesos/agent&quot;&gt;&gt;/etc/profile&#39;</code><br><code>./mussh -H iplist3 -c &#39;source /etc/profile&#39;</code>（mussh执行source无效，还是要逐个刷新）<br><code>./bin/mesos-agent.sh</code>启动agent</p>\n<p>agent启动报错，无法在master注册<br>XX exited event for master XX<br>这时要检查master的hostname是不是配置的ip地址，如果不一致使用hostname “name”命令设置为对应ip</p>\n<p>在master访问<a href=\"http://127.0.0.1:5050/#/agents\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:5050/#/agents</a><br>就能看到启动的agents<br><img src=\"http://7xl4v5.com1.z0.glb.clouddn.com/%E7%81%AB%E7%8B%90%E6%88%AA%E5%9B%BE_2017-11-20T03-34-36.517Z.png\" alt=\"启动成功\"></p>\n","site":{"data":{}},"excerpt":"<p>系统环境：CentOS 6.6 java7</p>\n<p>mesos安装</p>\n<p>按官网教程下载&amp;编译<br><a href=\"http://mesos.apache.org/documentation/latest/building/\" target=\"_blank\" rel=\"noopener\">http://mesos.apache.org/documentation/latest/building/</a></p>\n<p>借助mussh同时操作多个机器（需要先建立互信）</p>\n<p>示例：<code>./mussh -H iplist -c &#39;hostname -i&#39;</code>;<br>-H 指定ip<br>-c 指定执行的命令<br>iplist 一行一个ip<br>cat iplist<br>10.9.19.xx<br>10.9.19.xx<br>10.9.19.xx<br>","more":"</p>\n<p>问题<br>1.执行configure时</p>\n<h2 id=\"configure-error-cannot-find-libcurl\"><a href=\"#configure-error-cannot-find-libcurl\" class=\"headerlink\" title=\"configure: error: cannot find libcurl\"></a>configure: error: cannot find libcurl</h2><h2 id=\"libcurl-is-required-for-mesos-to-build\"><a href=\"#libcurl-is-required-for-mesos-to-build\" class=\"headerlink\" title=\"libcurl is required for mesos to build.\"></a>libcurl is required for mesos to build.</h2><p> <code>yum install libcurl-devel</code><br>2.libsubversion-1 is required for mesos to build.</p>\n<p><code>yum install -y subversion-devel</code><br>这两个都是之前命令中安装的东西但是到了这里又需要重新安装，应该是yum安装失败的问题<br>编译过程太慢了</p>\n<p>3.执行make时出现错误</p>\n<blockquote>\n<p>Building mesos-1.4.0.jar …<br>Exception in thread “main” java.lang.UnsupportedClassVersionError: org/apache/maven/cli/MavenCli : Unsupported major.minor version 51.0</p>\n</blockquote>\n<p>这个主要是因为你的java环境低于1.7造成的，可以尝试升级jdk版本，<br>但是<strong>我在升级之后明明java  -version提示的1.7，编译还是失败</strong>，后来查看Makefile文件发现，文件中已经写死了jdk路径，比如这种：<br><code>CONFIGURE_ARGS =  &#39;JAVA_HOME=/opt/soft/jdk/jdk1.6.0_45</code><br>最后通过修改(注意有好几个Makefile文件)<br><code>vim build/src/Makefile</code><br><code>1,$s/jdk1.6.0_45/jdk1.7.0_79/g</code>（执行替换）</p>\n<p>配置有两种<br>一个是 在通过命令行启动时添加选项 eg:–option_name=value<br>一个是 通过设置环境变量 eg:MESOS_XXX(XXX就是OPTION_NAME）</p>\n<p>mesos master配置<br>必填项<br>–work_dir=/var/lib/mesos/master<br>这两个在单master时是不需要的<br>–zk=<br>–quorum==</p>\n<p>我们使用环境变量来配置<br>echo ‘export MESOS_work_dir=/var/lib/mesos’&gt;&gt;/etc/profile<br>source /etc/profile<br>进入build目录<br>执行<code>./bin/mesos-master.sh --ip=127.0.0.1 &gt;/dev/null &amp;</code><br>启动master</p>\n<p>mesos agent配置<br>必填项<br>–master=<br>host:port<br>zk://host1:port1,host2:port2,…/path zk://username:password@host1:port1,host2:port2,…/path file:///path/to/file (where file contains one of the above)<br>–work_dir=VALUE </p>\n<p><code>./mussh -H iplist3 -c &#39;echo &quot;export MESOS_master=10.252.81.25:5050&quot;&gt;&gt;/etc/profile&#39;</code><br><code>./mussh -H iplist3 -c &#39;echo &quot;export MESOS_work_dir=/var/lib/mesos/agent&quot;&gt;&gt;/etc/profile&#39;</code><br><code>./mussh -H iplist3 -c &#39;source /etc/profile&#39;</code>（mussh执行source无效，还是要逐个刷新）<br><code>./bin/mesos-agent.sh</code>启动agent</p>\n<p>agent启动报错，无法在master注册<br>XX exited event for master XX<br>这时要检查master的hostname是不是配置的ip地址，如果不一致使用hostname “name”命令设置为对应ip</p>\n<p>在master访问<a href=\"http://127.0.0.1:5050/#/agents\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:5050/#/agents</a><br>就能看到启动的agents<br><img src=\"http://7xl4v5.com1.z0.glb.clouddn.com/%E7%81%AB%E7%8B%90%E6%88%AA%E5%9B%BE_2017-11-20T03-34-36.517Z.png\" alt=\"启动成功\"></p>"},{"title":"MySQL事务隔离性测试","date":"2018-02-02T05:25:46.000Z","_content":"### 环境准备\nMySQL版本 5.5.35-rel33.0-log Percona Server with XtraDB (GPL), Release rel33.0, Revision 611\n引擎 InnoDB\n*(才发现公司用的MySQL是Percona这个公司开发的一个版本，Percona Server [产品介绍][1])*\n```\nmysql> select version();\n+--------------------+\n| version()          |\n+--------------------+\n| 5.5.35-rel33.0-log |\n+--------------------+\n\nmysql> show engines \\G;\n*************************** 6. row ***************************\n      Engine: InnoDB\n     Support: DEFAULT\n     Comment: Percona-XtraDB, Supports transactions, row-level locking, and foreign keys\nTransactions: YES\n          XA: YES\n  Savepoints: YES\n\n```\n<!--more-->\n\n### 基本概念\n隔离性：事务的操作何时对其他事务可见\n脏读/不可重复读/幻读\n\n\n### 建表\n```\nCREATE TABLE `test` (\n  `id` bigint(20) NOT NULL AUTO_INCREMENT,\n  `name` varchar(45) DEFAULT NULL,\n  `age` int(11) DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8\n```\n初始数据如下：\n```\nmysql> select * from test;\n+----+------+------+\n| id | name | age  |\n+----+------+------+\n|  1 | Tom  |   20 |\n|  2 | Jack |   22 |\n|  3 | Rose |   24 |\n|  4 | Bob  |   26 |\n+----+------+------+\n```\n### Repeatable Read 隔离级别测试\n\n**可重复读测试**\n\n启动两个客户端连接，连接一执行事务A，连接二执行事务B。\n\n1.事务A 执行查询操作：\n```\nmysql> begin;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> select * from test;\n+----+------+------+\n| id | name | age  |\n+----+------+------+\n|  1 | Tom  |   20 |\n|  2 | Jack |   22 |\n|  3 | Rose |   24 |\n|  4 | Bob  |   26 |\n+----+------+------+\n4 rows in set (0.01 sec)\n```\n2.事务B 更新数据：\n```\nmysql> begin;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> update test set age=10 where id=1;\nQuery OK, 1 row affected (0.00 sec)\nRows matched: 1  Changed: 1  Warnings: 0\n\n```\n3.事务A 再执行查询：\n```\nmysql> select * from test;\n+----+------+------+\n| id | name | age  |\n+----+------+------+\n|  1 | Tom  |   20 |\n|  2 | Jack |   22 |\n|  3 | Rose |   24 |\n|  4 | Bob  |   26 |\n+----+------+------+\n4 rows in set (0.00 sec)\n```\n4.事务B 提交：\n```\nmysql> commit;\nQuery OK, 0 rows affected (0.00 sec)\n```\n5.事务A 再次执行查询并提交，然后执行一次查询：\n```\nmysql> select * from test;\n+----+------+------+\n| id | name | age  |\n+----+------+------+\n|  1 | Tom  |   20 |\n|  2 | Jack |   22 |\n|  3 | Rose |   24 |\n|  4 | Bob  |   26 |\n+----+------+------+\n\nmysql> commit;\n\nmysql> select * from test;\n+----+------+------+\n| id | name | age  |\n+----+------+------+\n|  1 | Tom  |   10 |\n|  2 | Jack |   22 |\n|  3 | Rose |   24 |\n|  4 | Bob  |   26 |\n+----+------+------+\n```\n测试结果结果说明在RR级别下，尽管事务A执行结束前，事务B修改了数据，但是事务A中的几次查询（1,3,5）返回的结果是一致的，这样就保证了可重复读，AB事务的操作时序如下：\n|----A----|----B----|\n|--begin--|-------------|\n|--select--| begin |\n|-------------| update|\n|-------------| commit|\n|--select--|-------------|\n|commit|-------------|\n\n**幻读测试**\n1.事务A 开始并查询数据：\n```\nmysql> begin;\nmysql> select * from test where age<25;\n+----+------+------+\n| id | name | age  |\n+----+------+------+\n|  1 | Tom  |   20 |\n|  2 | Jack |   22 |\n|  3 | Rose |   24 |\n+----+------+------+\n```\n2.事务B 插入一条新纪录并提交:\n```\nmysql> begin;\nmysql> select * from test;\n+----+------+------+\n| id | name | age  |\n+----+------+------+\n|  1 | Tom  |   20 |\n|  2 | Jack |   22 |\n|  3 | Rose |   24 |\n|  4 | Bob  |   26 |\n+----+------+------+\nmysql> insert test(name,age) values(\"Tony\",18);\nmysql> commit;\n```\n此时新纪录“Tony”也满足A的查询条件\n3.事务A 再次查询：\n返回结果和上次一致，没有新纪录。\n```\nmysql> select * from test where age<25;\n+----+------+------+\n| id | name | age  |\n+----+------+------+\n|  1 | Tom  |   20 |\n|  2 | Jack |   22 |\n|  3 | Rose |   24 |\n+----+------+------+\n```\n4.事务A提交 然后执行新查询：\n事务提交后，查询返回了新纪录\"Tony\"。\n```\nmysql> commit;\nmysql> select * from test where age<25;\n+----+------+------+\n| id | name | age  |\n+----+------+------+\n|  1 | Tom  |   20 |\n|  2 | Jack |   22 |\n|  3 | Rose |   24 |\n|  5 | Tony |   18 |\n+----+------+------+\n```\n\n### Read Commit 隔离级别测试\n原本的默认级别是RR需要修改一下，只修改当前会话的事务隔离级别：\n```\nmysql> set session transaction isolation level read committed;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> select @@global.tx_isolation,@@session.tx_isolation;\n+-----------------------+------------------------+\n| @@global.tx_isolation | @@session.tx_isolation |\n+-----------------------+------------------------+\n| REPEATABLE-READ       | READ-COMMITTED         |\n+-----------------------+------------------------+\n```\n**可重复读测试：**\n和之前类似，事务A执行查询，事务B在A尚未完成时修改数据。\n1.事务A 查询:\n```\nmysql> begin;\nmysql> select * from test;\n+----+------+------+\n| id | name | age  |\n+----+------+------+\n|  1 | Tom  |   20 |\n|  2 | Jack |   22 |\n|  3 | Rose |   24 |\n|  4 | Bob  |   26 |\n+----+------+------+\n```\n2.事务B修改数据：\n```\nmysql> begin;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> update test set age=10 where id=1;\nQuery OK, 1 row affected (0.01 sec)\nRows matched: 1  Changed: 1  Warnings: 0\n```\n3.事务A 再次查询：\n此时结果还是和上次一致的，这说明并未发生\"脏读\"\n```\nmysql> select * from test;\n+----+------+------+\n| id | name | age  |\n+----+------+------+\n|  1 | Tom  |   20 |\n|  2 | Jack |   22 |\n|  3 | Rose |   24 |\n|  4 | Bob  |   26 |\n+----+------+------+\n```\n4.事务B 提交：\n```\nmysql> commit;\n```\n5.事务A 查询：\n在B提交之后A读到了B修改的数据，和之前结果不一致\n```\nmysql> select * from test;\n+----+------+------+\n| id | name | age  |\n+----+------+------+\n|  1 | Tom  |   10 |\n|  2 | Jack |   22 |\n|  3 | Rose |   24 |\n|  4 | Bob  |   26 |\n+----+------+------+\nmysql> commit;\n```\n**幻读测试**\n既然发生了不可重复读，那么幻读也会发生。\n1.事务A 查询：\n```\nmysql> begin;\nmysql> select * from test;\n+----+------+------+\n| id | name | age  |\n+----+------+------+\n|  1 | Tom  |   10 |\n|  2 | Jack |   22 |\n|  3 | Rose |   24 |\n|  4 | Bob  |   26 |\n+----+------+------+\n```\n2.事务B 新增记录&提：\n```\nmysql> begin;\nmysql> insert test(name,age) values(\"Tony\",18);\nmysql> commit;\n```\n3.事务A 再查询：\n```\nmysql> select * from test;\n+----+------+------+\n| id | name | age  |\n+----+------+------+\n|  1 | Tom  |   10 |\n|  2 | Jack |   22 |\n|  3 | Rose |   24 |\n|  4 | Bob  |   26 |\n|  6 | Tony |   18 |\n+----+------+------+\n```\n\n\n\n  [1]: https://www.percona.com/software/mysql-database/percona-server","source":"_posts/MySQL事务隔离性测试.md","raw":"title: MySQL事务隔离性测试\ndate: 2018-02-02 13:25:46\ncategories: mysql进阶\ntags: [mysql,数据库]\n---\n### 环境准备\nMySQL版本 5.5.35-rel33.0-log Percona Server with XtraDB (GPL), Release rel33.0, Revision 611\n引擎 InnoDB\n*(才发现公司用的MySQL是Percona这个公司开发的一个版本，Percona Server [产品介绍][1])*\n```\nmysql> select version();\n+--------------------+\n| version()          |\n+--------------------+\n| 5.5.35-rel33.0-log |\n+--------------------+\n\nmysql> show engines \\G;\n*************************** 6. row ***************************\n      Engine: InnoDB\n     Support: DEFAULT\n     Comment: Percona-XtraDB, Supports transactions, row-level locking, and foreign keys\nTransactions: YES\n          XA: YES\n  Savepoints: YES\n\n```\n<!--more-->\n\n### 基本概念\n隔离性：事务的操作何时对其他事务可见\n脏读/不可重复读/幻读\n\n\n### 建表\n```\nCREATE TABLE `test` (\n  `id` bigint(20) NOT NULL AUTO_INCREMENT,\n  `name` varchar(45) DEFAULT NULL,\n  `age` int(11) DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8\n```\n初始数据如下：\n```\nmysql> select * from test;\n+----+------+------+\n| id | name | age  |\n+----+------+------+\n|  1 | Tom  |   20 |\n|  2 | Jack |   22 |\n|  3 | Rose |   24 |\n|  4 | Bob  |   26 |\n+----+------+------+\n```\n### Repeatable Read 隔离级别测试\n\n**可重复读测试**\n\n启动两个客户端连接，连接一执行事务A，连接二执行事务B。\n\n1.事务A 执行查询操作：\n```\nmysql> begin;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> select * from test;\n+----+------+------+\n| id | name | age  |\n+----+------+------+\n|  1 | Tom  |   20 |\n|  2 | Jack |   22 |\n|  3 | Rose |   24 |\n|  4 | Bob  |   26 |\n+----+------+------+\n4 rows in set (0.01 sec)\n```\n2.事务B 更新数据：\n```\nmysql> begin;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> update test set age=10 where id=1;\nQuery OK, 1 row affected (0.00 sec)\nRows matched: 1  Changed: 1  Warnings: 0\n\n```\n3.事务A 再执行查询：\n```\nmysql> select * from test;\n+----+------+------+\n| id | name | age  |\n+----+------+------+\n|  1 | Tom  |   20 |\n|  2 | Jack |   22 |\n|  3 | Rose |   24 |\n|  4 | Bob  |   26 |\n+----+------+------+\n4 rows in set (0.00 sec)\n```\n4.事务B 提交：\n```\nmysql> commit;\nQuery OK, 0 rows affected (0.00 sec)\n```\n5.事务A 再次执行查询并提交，然后执行一次查询：\n```\nmysql> select * from test;\n+----+------+------+\n| id | name | age  |\n+----+------+------+\n|  1 | Tom  |   20 |\n|  2 | Jack |   22 |\n|  3 | Rose |   24 |\n|  4 | Bob  |   26 |\n+----+------+------+\n\nmysql> commit;\n\nmysql> select * from test;\n+----+------+------+\n| id | name | age  |\n+----+------+------+\n|  1 | Tom  |   10 |\n|  2 | Jack |   22 |\n|  3 | Rose |   24 |\n|  4 | Bob  |   26 |\n+----+------+------+\n```\n测试结果结果说明在RR级别下，尽管事务A执行结束前，事务B修改了数据，但是事务A中的几次查询（1,3,5）返回的结果是一致的，这样就保证了可重复读，AB事务的操作时序如下：\n|----A----|----B----|\n|--begin--|-------------|\n|--select--| begin |\n|-------------| update|\n|-------------| commit|\n|--select--|-------------|\n|commit|-------------|\n\n**幻读测试**\n1.事务A 开始并查询数据：\n```\nmysql> begin;\nmysql> select * from test where age<25;\n+----+------+------+\n| id | name | age  |\n+----+------+------+\n|  1 | Tom  |   20 |\n|  2 | Jack |   22 |\n|  3 | Rose |   24 |\n+----+------+------+\n```\n2.事务B 插入一条新纪录并提交:\n```\nmysql> begin;\nmysql> select * from test;\n+----+------+------+\n| id | name | age  |\n+----+------+------+\n|  1 | Tom  |   20 |\n|  2 | Jack |   22 |\n|  3 | Rose |   24 |\n|  4 | Bob  |   26 |\n+----+------+------+\nmysql> insert test(name,age) values(\"Tony\",18);\nmysql> commit;\n```\n此时新纪录“Tony”也满足A的查询条件\n3.事务A 再次查询：\n返回结果和上次一致，没有新纪录。\n```\nmysql> select * from test where age<25;\n+----+------+------+\n| id | name | age  |\n+----+------+------+\n|  1 | Tom  |   20 |\n|  2 | Jack |   22 |\n|  3 | Rose |   24 |\n+----+------+------+\n```\n4.事务A提交 然后执行新查询：\n事务提交后，查询返回了新纪录\"Tony\"。\n```\nmysql> commit;\nmysql> select * from test where age<25;\n+----+------+------+\n| id | name | age  |\n+----+------+------+\n|  1 | Tom  |   20 |\n|  2 | Jack |   22 |\n|  3 | Rose |   24 |\n|  5 | Tony |   18 |\n+----+------+------+\n```\n\n### Read Commit 隔离级别测试\n原本的默认级别是RR需要修改一下，只修改当前会话的事务隔离级别：\n```\nmysql> set session transaction isolation level read committed;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> select @@global.tx_isolation,@@session.tx_isolation;\n+-----------------------+------------------------+\n| @@global.tx_isolation | @@session.tx_isolation |\n+-----------------------+------------------------+\n| REPEATABLE-READ       | READ-COMMITTED         |\n+-----------------------+------------------------+\n```\n**可重复读测试：**\n和之前类似，事务A执行查询，事务B在A尚未完成时修改数据。\n1.事务A 查询:\n```\nmysql> begin;\nmysql> select * from test;\n+----+------+------+\n| id | name | age  |\n+----+------+------+\n|  1 | Tom  |   20 |\n|  2 | Jack |   22 |\n|  3 | Rose |   24 |\n|  4 | Bob  |   26 |\n+----+------+------+\n```\n2.事务B修改数据：\n```\nmysql> begin;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> update test set age=10 where id=1;\nQuery OK, 1 row affected (0.01 sec)\nRows matched: 1  Changed: 1  Warnings: 0\n```\n3.事务A 再次查询：\n此时结果还是和上次一致的，这说明并未发生\"脏读\"\n```\nmysql> select * from test;\n+----+------+------+\n| id | name | age  |\n+----+------+------+\n|  1 | Tom  |   20 |\n|  2 | Jack |   22 |\n|  3 | Rose |   24 |\n|  4 | Bob  |   26 |\n+----+------+------+\n```\n4.事务B 提交：\n```\nmysql> commit;\n```\n5.事务A 查询：\n在B提交之后A读到了B修改的数据，和之前结果不一致\n```\nmysql> select * from test;\n+----+------+------+\n| id | name | age  |\n+----+------+------+\n|  1 | Tom  |   10 |\n|  2 | Jack |   22 |\n|  3 | Rose |   24 |\n|  4 | Bob  |   26 |\n+----+------+------+\nmysql> commit;\n```\n**幻读测试**\n既然发生了不可重复读，那么幻读也会发生。\n1.事务A 查询：\n```\nmysql> begin;\nmysql> select * from test;\n+----+------+------+\n| id | name | age  |\n+----+------+------+\n|  1 | Tom  |   10 |\n|  2 | Jack |   22 |\n|  3 | Rose |   24 |\n|  4 | Bob  |   26 |\n+----+------+------+\n```\n2.事务B 新增记录&提：\n```\nmysql> begin;\nmysql> insert test(name,age) values(\"Tony\",18);\nmysql> commit;\n```\n3.事务A 再查询：\n```\nmysql> select * from test;\n+----+------+------+\n| id | name | age  |\n+----+------+------+\n|  1 | Tom  |   10 |\n|  2 | Jack |   22 |\n|  3 | Rose |   24 |\n|  4 | Bob  |   26 |\n|  6 | Tony |   18 |\n+----+------+------+\n```\n\n\n\n  [1]: https://www.percona.com/software/mysql-database/percona-server","slug":"MySQL事务隔离性测试","published":1,"updated":"2018-11-21T16:34:24.066Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp57u3wu00082xpbr6iatsb5","content":"<h3 id=\"环境准备\"><a href=\"#环境准备\" class=\"headerlink\" title=\"环境准备\"></a>环境准备</h3><p>MySQL版本 5.5.35-rel33.0-log Percona Server with XtraDB (GPL), Release rel33.0, Revision 611<br>引擎 InnoDB<br><em>(才发现公司用的MySQL是Percona这个公司开发的一个版本，Percona Server <a href=\"https://www.percona.com/software/mysql-database/percona-server\" target=\"_blank\" rel=\"noopener\">产品介绍</a>)</em><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; select version();</span><br><span class=\"line\">+--------------------+</span><br><span class=\"line\">| version()          |</span><br><span class=\"line\">+--------------------+</span><br><span class=\"line\">| 5.5.35-rel33.0-log |</span><br><span class=\"line\">+--------------------+</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; show engines \\G;</span><br><span class=\"line\">*************************** 6. row ***************************</span><br><span class=\"line\">      Engine: InnoDB</span><br><span class=\"line\">     Support: DEFAULT</span><br><span class=\"line\">     Comment: Percona-XtraDB, Supports transactions, row-level locking, and foreign keys</span><br><span class=\"line\">Transactions: YES</span><br><span class=\"line\">          XA: YES</span><br><span class=\"line\">  Savepoints: YES</span><br></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><p>隔离性：事务的操作何时对其他事务可见<br>脏读/不可重复读/幻读</p>\n<h3 id=\"建表\"><a href=\"#建表\" class=\"headerlink\" title=\"建表\"></a>建表</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CREATE TABLE `test` (</span><br><span class=\"line\">  `id` bigint(20) NOT NULL AUTO_INCREMENT,</span><br><span class=\"line\">  `name` varchar(45) DEFAULT NULL,</span><br><span class=\"line\">  `age` int(11) DEFAULT NULL,</span><br><span class=\"line\">  PRIMARY KEY (`id`)</span><br><span class=\"line\">) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8</span><br></pre></td></tr></table></figure>\n<p>初始数据如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; select * from test;</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">| id | name | age  |</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">|  1 | Tom  |   20 |</span><br><span class=\"line\">|  2 | Jack |   22 |</span><br><span class=\"line\">|  3 | Rose |   24 |</span><br><span class=\"line\">|  4 | Bob  |   26 |</span><br><span class=\"line\">+----+------+------+</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Repeatable-Read-隔离级别测试\"><a href=\"#Repeatable-Read-隔离级别测试\" class=\"headerlink\" title=\"Repeatable Read 隔离级别测试\"></a>Repeatable Read 隔离级别测试</h3><p><strong>可重复读测试</strong></p>\n<p>启动两个客户端连接，连接一执行事务A，连接二执行事务B。</p>\n<p>1.事务A 执行查询操作：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; begin;</span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; select * from test;</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">| id | name | age  |</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">|  1 | Tom  |   20 |</span><br><span class=\"line\">|  2 | Jack |   22 |</span><br><span class=\"line\">|  3 | Rose |   24 |</span><br><span class=\"line\">|  4 | Bob  |   26 |</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">4 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure></p>\n<p>2.事务B 更新数据：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; begin;</span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; update test set age=10 where id=1;</span><br><span class=\"line\">Query OK, 1 row affected (0.00 sec)</span><br><span class=\"line\">Rows matched: 1  Changed: 1  Warnings: 0</span><br></pre></td></tr></table></figure></p>\n<p>3.事务A 再执行查询：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; select * from test;</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">| id | name | age  |</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">|  1 | Tom  |   20 |</span><br><span class=\"line\">|  2 | Jack |   22 |</span><br><span class=\"line\">|  3 | Rose |   24 |</span><br><span class=\"line\">|  4 | Bob  |   26 |</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></p>\n<p>4.事务B 提交：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; commit;</span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure></p>\n<p>5.事务A 再次执行查询并提交，然后执行一次查询：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; select * from test;</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">| id | name | age  |</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">|  1 | Tom  |   20 |</span><br><span class=\"line\">|  2 | Jack |   22 |</span><br><span class=\"line\">|  3 | Rose |   24 |</span><br><span class=\"line\">|  4 | Bob  |   26 |</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; commit;</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; select * from test;</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">| id | name | age  |</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">|  1 | Tom  |   10 |</span><br><span class=\"line\">|  2 | Jack |   22 |</span><br><span class=\"line\">|  3 | Rose |   24 |</span><br><span class=\"line\">|  4 | Bob  |   26 |</span><br><span class=\"line\">+----+------+------+</span><br></pre></td></tr></table></figure></p>\n<p>测试结果结果说明在RR级别下，尽管事务A执行结束前，事务B修改了数据，但是事务A中的几次查询（1,3,5）返回的结果是一致的，这样就保证了可重复读，AB事务的操作时序如下：<br>|—-A—-|—-B—-|<br>|–begin–|————-|<br>|–select–| begin |<br>|————-| update|<br>|————-| commit|<br>|–select–|————-|<br>|commit|————-|</p>\n<p><strong>幻读测试</strong><br>1.事务A 开始并查询数据：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; begin;</span><br><span class=\"line\">mysql&gt; select * from test where age&lt;25;</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">| id | name | age  |</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">|  1 | Tom  |   20 |</span><br><span class=\"line\">|  2 | Jack |   22 |</span><br><span class=\"line\">|  3 | Rose |   24 |</span><br><span class=\"line\">+----+------+------+</span><br></pre></td></tr></table></figure></p>\n<p>2.事务B 插入一条新纪录并提交:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; begin;</span><br><span class=\"line\">mysql&gt; select * from test;</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">| id | name | age  |</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">|  1 | Tom  |   20 |</span><br><span class=\"line\">|  2 | Jack |   22 |</span><br><span class=\"line\">|  3 | Rose |   24 |</span><br><span class=\"line\">|  4 | Bob  |   26 |</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">mysql&gt; insert test(name,age) values(&quot;Tony&quot;,18);</span><br><span class=\"line\">mysql&gt; commit;</span><br></pre></td></tr></table></figure></p>\n<p>此时新纪录“Tony”也满足A的查询条件<br>3.事务A 再次查询：<br>返回结果和上次一致，没有新纪录。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; select * from test where age&lt;25;</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">| id | name | age  |</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">|  1 | Tom  |   20 |</span><br><span class=\"line\">|  2 | Jack |   22 |</span><br><span class=\"line\">|  3 | Rose |   24 |</span><br><span class=\"line\">+----+------+------+</span><br></pre></td></tr></table></figure></p>\n<p>4.事务A提交 然后执行新查询：<br>事务提交后，查询返回了新纪录”Tony”。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; commit;</span><br><span class=\"line\">mysql&gt; select * from test where age&lt;25;</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">| id | name | age  |</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">|  1 | Tom  |   20 |</span><br><span class=\"line\">|  2 | Jack |   22 |</span><br><span class=\"line\">|  3 | Rose |   24 |</span><br><span class=\"line\">|  5 | Tony |   18 |</span><br><span class=\"line\">+----+------+------+</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Read-Commit-隔离级别测试\"><a href=\"#Read-Commit-隔离级别测试\" class=\"headerlink\" title=\"Read Commit 隔离级别测试\"></a>Read Commit 隔离级别测试</h3><p>原本的默认级别是RR需要修改一下，只修改当前会话的事务隔离级别：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; set session transaction isolation level read committed;</span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; select @@global.tx_isolation,@@session.tx_isolation;</span><br><span class=\"line\">+-----------------------+------------------------+</span><br><span class=\"line\">| @@global.tx_isolation | @@session.tx_isolation |</span><br><span class=\"line\">+-----------------------+------------------------+</span><br><span class=\"line\">| REPEATABLE-READ       | READ-COMMITTED         |</span><br><span class=\"line\">+-----------------------+------------------------+</span><br></pre></td></tr></table></figure></p>\n<p><strong>可重复读测试：</strong><br>和之前类似，事务A执行查询，事务B在A尚未完成时修改数据。<br>1.事务A 查询:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; begin;</span><br><span class=\"line\">mysql&gt; select * from test;</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">| id | name | age  |</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">|  1 | Tom  |   20 |</span><br><span class=\"line\">|  2 | Jack |   22 |</span><br><span class=\"line\">|  3 | Rose |   24 |</span><br><span class=\"line\">|  4 | Bob  |   26 |</span><br><span class=\"line\">+----+------+------+</span><br></pre></td></tr></table></figure></p>\n<p>2.事务B修改数据：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; begin;</span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; update test set age=10 where id=1;</span><br><span class=\"line\">Query OK, 1 row affected (0.01 sec)</span><br><span class=\"line\">Rows matched: 1  Changed: 1  Warnings: 0</span><br></pre></td></tr></table></figure></p>\n<p>3.事务A 再次查询：<br>此时结果还是和上次一致的，这说明并未发生”脏读”<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; select * from test;</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">| id | name | age  |</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">|  1 | Tom  |   20 |</span><br><span class=\"line\">|  2 | Jack |   22 |</span><br><span class=\"line\">|  3 | Rose |   24 |</span><br><span class=\"line\">|  4 | Bob  |   26 |</span><br><span class=\"line\">+----+------+------+</span><br></pre></td></tr></table></figure></p>\n<p>4.事务B 提交：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; commit;</span><br></pre></td></tr></table></figure></p>\n<p>5.事务A 查询：<br>在B提交之后A读到了B修改的数据，和之前结果不一致<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; select * from test;</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">| id | name | age  |</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">|  1 | Tom  |   10 |</span><br><span class=\"line\">|  2 | Jack |   22 |</span><br><span class=\"line\">|  3 | Rose |   24 |</span><br><span class=\"line\">|  4 | Bob  |   26 |</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">mysql&gt; commit;</span><br></pre></td></tr></table></figure></p>\n<p><strong>幻读测试</strong><br>既然发生了不可重复读，那么幻读也会发生。<br>1.事务A 查询：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; begin;</span><br><span class=\"line\">mysql&gt; select * from test;</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">| id | name | age  |</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">|  1 | Tom  |   10 |</span><br><span class=\"line\">|  2 | Jack |   22 |</span><br><span class=\"line\">|  3 | Rose |   24 |</span><br><span class=\"line\">|  4 | Bob  |   26 |</span><br><span class=\"line\">+----+------+------+</span><br></pre></td></tr></table></figure></p>\n<p>2.事务B 新增记录&amp;提：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; begin;</span><br><span class=\"line\">mysql&gt; insert test(name,age) values(&quot;Tony&quot;,18);</span><br><span class=\"line\">mysql&gt; commit;</span><br></pre></td></tr></table></figure></p>\n<p>3.事务A 再查询：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; select * from test;</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">| id | name | age  |</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">|  1 | Tom  |   10 |</span><br><span class=\"line\">|  2 | Jack |   22 |</span><br><span class=\"line\">|  3 | Rose |   24 |</span><br><span class=\"line\">|  4 | Bob  |   26 |</span><br><span class=\"line\">|  6 | Tony |   18 |</span><br><span class=\"line\">+----+------+------+</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"环境准备\"><a href=\"#环境准备\" class=\"headerlink\" title=\"环境准备\"></a>环境准备</h3><p>MySQL版本 5.5.35-rel33.0-log Percona Server with XtraDB (GPL), Release rel33.0, Revision 611<br>引擎 InnoDB<br><em>(才发现公司用的MySQL是Percona这个公司开发的一个版本，Percona Server <a href=\"https://www.percona.com/software/mysql-database/percona-server\" target=\"_blank\" rel=\"noopener\">产品介绍</a>)</em><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; select version();</span><br><span class=\"line\">+--------------------+</span><br><span class=\"line\">| version()          |</span><br><span class=\"line\">+--------------------+</span><br><span class=\"line\">| 5.5.35-rel33.0-log |</span><br><span class=\"line\">+--------------------+</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; show engines \\G;</span><br><span class=\"line\">*************************** 6. row ***************************</span><br><span class=\"line\">      Engine: InnoDB</span><br><span class=\"line\">     Support: DEFAULT</span><br><span class=\"line\">     Comment: Percona-XtraDB, Supports transactions, row-level locking, and foreign keys</span><br><span class=\"line\">Transactions: YES</span><br><span class=\"line\">          XA: YES</span><br><span class=\"line\">  Savepoints: YES</span><br></pre></td></tr></table></figure></p>","more":"<h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><p>隔离性：事务的操作何时对其他事务可见<br>脏读/不可重复读/幻读</p>\n<h3 id=\"建表\"><a href=\"#建表\" class=\"headerlink\" title=\"建表\"></a>建表</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CREATE TABLE `test` (</span><br><span class=\"line\">  `id` bigint(20) NOT NULL AUTO_INCREMENT,</span><br><span class=\"line\">  `name` varchar(45) DEFAULT NULL,</span><br><span class=\"line\">  `age` int(11) DEFAULT NULL,</span><br><span class=\"line\">  PRIMARY KEY (`id`)</span><br><span class=\"line\">) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8</span><br></pre></td></tr></table></figure>\n<p>初始数据如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; select * from test;</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">| id | name | age  |</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">|  1 | Tom  |   20 |</span><br><span class=\"line\">|  2 | Jack |   22 |</span><br><span class=\"line\">|  3 | Rose |   24 |</span><br><span class=\"line\">|  4 | Bob  |   26 |</span><br><span class=\"line\">+----+------+------+</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Repeatable-Read-隔离级别测试\"><a href=\"#Repeatable-Read-隔离级别测试\" class=\"headerlink\" title=\"Repeatable Read 隔离级别测试\"></a>Repeatable Read 隔离级别测试</h3><p><strong>可重复读测试</strong></p>\n<p>启动两个客户端连接，连接一执行事务A，连接二执行事务B。</p>\n<p>1.事务A 执行查询操作：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; begin;</span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; select * from test;</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">| id | name | age  |</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">|  1 | Tom  |   20 |</span><br><span class=\"line\">|  2 | Jack |   22 |</span><br><span class=\"line\">|  3 | Rose |   24 |</span><br><span class=\"line\">|  4 | Bob  |   26 |</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">4 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure></p>\n<p>2.事务B 更新数据：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; begin;</span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; update test set age=10 where id=1;</span><br><span class=\"line\">Query OK, 1 row affected (0.00 sec)</span><br><span class=\"line\">Rows matched: 1  Changed: 1  Warnings: 0</span><br></pre></td></tr></table></figure></p>\n<p>3.事务A 再执行查询：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; select * from test;</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">| id | name | age  |</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">|  1 | Tom  |   20 |</span><br><span class=\"line\">|  2 | Jack |   22 |</span><br><span class=\"line\">|  3 | Rose |   24 |</span><br><span class=\"line\">|  4 | Bob  |   26 |</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></p>\n<p>4.事务B 提交：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; commit;</span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure></p>\n<p>5.事务A 再次执行查询并提交，然后执行一次查询：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; select * from test;</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">| id | name | age  |</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">|  1 | Tom  |   20 |</span><br><span class=\"line\">|  2 | Jack |   22 |</span><br><span class=\"line\">|  3 | Rose |   24 |</span><br><span class=\"line\">|  4 | Bob  |   26 |</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; commit;</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; select * from test;</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">| id | name | age  |</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">|  1 | Tom  |   10 |</span><br><span class=\"line\">|  2 | Jack |   22 |</span><br><span class=\"line\">|  3 | Rose |   24 |</span><br><span class=\"line\">|  4 | Bob  |   26 |</span><br><span class=\"line\">+----+------+------+</span><br></pre></td></tr></table></figure></p>\n<p>测试结果结果说明在RR级别下，尽管事务A执行结束前，事务B修改了数据，但是事务A中的几次查询（1,3,5）返回的结果是一致的，这样就保证了可重复读，AB事务的操作时序如下：<br>|—-A—-|—-B—-|<br>|–begin–|————-|<br>|–select–| begin |<br>|————-| update|<br>|————-| commit|<br>|–select–|————-|<br>|commit|————-|</p>\n<p><strong>幻读测试</strong><br>1.事务A 开始并查询数据：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; begin;</span><br><span class=\"line\">mysql&gt; select * from test where age&lt;25;</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">| id | name | age  |</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">|  1 | Tom  |   20 |</span><br><span class=\"line\">|  2 | Jack |   22 |</span><br><span class=\"line\">|  3 | Rose |   24 |</span><br><span class=\"line\">+----+------+------+</span><br></pre></td></tr></table></figure></p>\n<p>2.事务B 插入一条新纪录并提交:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; begin;</span><br><span class=\"line\">mysql&gt; select * from test;</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">| id | name | age  |</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">|  1 | Tom  |   20 |</span><br><span class=\"line\">|  2 | Jack |   22 |</span><br><span class=\"line\">|  3 | Rose |   24 |</span><br><span class=\"line\">|  4 | Bob  |   26 |</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">mysql&gt; insert test(name,age) values(&quot;Tony&quot;,18);</span><br><span class=\"line\">mysql&gt; commit;</span><br></pre></td></tr></table></figure></p>\n<p>此时新纪录“Tony”也满足A的查询条件<br>3.事务A 再次查询：<br>返回结果和上次一致，没有新纪录。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; select * from test where age&lt;25;</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">| id | name | age  |</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">|  1 | Tom  |   20 |</span><br><span class=\"line\">|  2 | Jack |   22 |</span><br><span class=\"line\">|  3 | Rose |   24 |</span><br><span class=\"line\">+----+------+------+</span><br></pre></td></tr></table></figure></p>\n<p>4.事务A提交 然后执行新查询：<br>事务提交后，查询返回了新纪录”Tony”。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; commit;</span><br><span class=\"line\">mysql&gt; select * from test where age&lt;25;</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">| id | name | age  |</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">|  1 | Tom  |   20 |</span><br><span class=\"line\">|  2 | Jack |   22 |</span><br><span class=\"line\">|  3 | Rose |   24 |</span><br><span class=\"line\">|  5 | Tony |   18 |</span><br><span class=\"line\">+----+------+------+</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Read-Commit-隔离级别测试\"><a href=\"#Read-Commit-隔离级别测试\" class=\"headerlink\" title=\"Read Commit 隔离级别测试\"></a>Read Commit 隔离级别测试</h3><p>原本的默认级别是RR需要修改一下，只修改当前会话的事务隔离级别：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; set session transaction isolation level read committed;</span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; select @@global.tx_isolation,@@session.tx_isolation;</span><br><span class=\"line\">+-----------------------+------------------------+</span><br><span class=\"line\">| @@global.tx_isolation | @@session.tx_isolation |</span><br><span class=\"line\">+-----------------------+------------------------+</span><br><span class=\"line\">| REPEATABLE-READ       | READ-COMMITTED         |</span><br><span class=\"line\">+-----------------------+------------------------+</span><br></pre></td></tr></table></figure></p>\n<p><strong>可重复读测试：</strong><br>和之前类似，事务A执行查询，事务B在A尚未完成时修改数据。<br>1.事务A 查询:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; begin;</span><br><span class=\"line\">mysql&gt; select * from test;</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">| id | name | age  |</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">|  1 | Tom  |   20 |</span><br><span class=\"line\">|  2 | Jack |   22 |</span><br><span class=\"line\">|  3 | Rose |   24 |</span><br><span class=\"line\">|  4 | Bob  |   26 |</span><br><span class=\"line\">+----+------+------+</span><br></pre></td></tr></table></figure></p>\n<p>2.事务B修改数据：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; begin;</span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; update test set age=10 where id=1;</span><br><span class=\"line\">Query OK, 1 row affected (0.01 sec)</span><br><span class=\"line\">Rows matched: 1  Changed: 1  Warnings: 0</span><br></pre></td></tr></table></figure></p>\n<p>3.事务A 再次查询：<br>此时结果还是和上次一致的，这说明并未发生”脏读”<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; select * from test;</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">| id | name | age  |</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">|  1 | Tom  |   20 |</span><br><span class=\"line\">|  2 | Jack |   22 |</span><br><span class=\"line\">|  3 | Rose |   24 |</span><br><span class=\"line\">|  4 | Bob  |   26 |</span><br><span class=\"line\">+----+------+------+</span><br></pre></td></tr></table></figure></p>\n<p>4.事务B 提交：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; commit;</span><br></pre></td></tr></table></figure></p>\n<p>5.事务A 查询：<br>在B提交之后A读到了B修改的数据，和之前结果不一致<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; select * from test;</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">| id | name | age  |</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">|  1 | Tom  |   10 |</span><br><span class=\"line\">|  2 | Jack |   22 |</span><br><span class=\"line\">|  3 | Rose |   24 |</span><br><span class=\"line\">|  4 | Bob  |   26 |</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">mysql&gt; commit;</span><br></pre></td></tr></table></figure></p>\n<p><strong>幻读测试</strong><br>既然发生了不可重复读，那么幻读也会发生。<br>1.事务A 查询：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; begin;</span><br><span class=\"line\">mysql&gt; select * from test;</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">| id | name | age  |</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">|  1 | Tom  |   10 |</span><br><span class=\"line\">|  2 | Jack |   22 |</span><br><span class=\"line\">|  3 | Rose |   24 |</span><br><span class=\"line\">|  4 | Bob  |   26 |</span><br><span class=\"line\">+----+------+------+</span><br></pre></td></tr></table></figure></p>\n<p>2.事务B 新增记录&amp;提：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; begin;</span><br><span class=\"line\">mysql&gt; insert test(name,age) values(&quot;Tony&quot;,18);</span><br><span class=\"line\">mysql&gt; commit;</span><br></pre></td></tr></table></figure></p>\n<p>3.事务A 再查询：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; select * from test;</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">| id | name | age  |</span><br><span class=\"line\">+----+------+------+</span><br><span class=\"line\">|  1 | Tom  |   10 |</span><br><span class=\"line\">|  2 | Jack |   22 |</span><br><span class=\"line\">|  3 | Rose |   24 |</span><br><span class=\"line\">|  4 | Bob  |   26 |</span><br><span class=\"line\">|  6 | Tony |   18 |</span><br><span class=\"line\">+----+------+------+</span><br></pre></td></tr></table></figure></p>"},{"title":"动手编写一个IOC容器","date":"2016-09-28T15:30:55.000Z","_content":"\n### 什么是IOC\n 所谓的IOC(Inversion of control)控制反转，实际是引入一个管理资源的第三方来统一管理分配资源，来代替各个资源持有者,使用者相互依赖的情况。\n\n 以打牌为例，之前玩家需要自己摸牌，现在改成由发牌人为所有玩家发牌，这个过程就叫做“控制反转”，发牌人就是IOC容器，发牌人给玩家发牌的过程就被称为“依赖注入(Dependency Injection)”。\n\n``` java\n//不使用IOC Player自己负责实例化Card\npublic Class PlayerA{\n    private Card myCard=new Card();\n    ...\n}\npublic Class PlayerB{\n    private Card myCard=new Card();\n    ...\n}\n\n\n//实例化在IOC容器（Dealer）中进行\npublic Class Dealer{\n    private Card card=new Card();\n    ...\n}\n//Player感知不到Dealer存在\npublic Class Player{\n    @Inject\n    private Card myCard;\n}\n```\n\n\n在实际的j2ee项目中，使用依赖注入有这样几个好处： <!--more-->\n1.使用IOC容器可以把加载Bean的工作集中进行，使用者不再负责资源的初始化，在编译期将资源和使用者解耦；\n2.在使用单例模式的情况下可以避免重复的创建相同对象，减少资源占用；\n\n### IOC容器工作过程\n\n那么IOC容器怎么来实现依赖注入呢，这里提供一个基于注解的简单的IOC实现方案：\n第一步：\n我们将所有被IOC容器管理的类称为Bean，在项目启动时需要扫描当前所有的java Bean并放入到一个BeanMap中，并且将他们实例化，BeanMap保存BeanClass和Bean实例的对应关系。\n第二步：\n遍历BeanMap中的Bean，逐个判断Bean的成员变量中是否有@Inject注解，如果有，就从BeanMap中取出这个成员变量类对应的对象，注入给这个Bean。\n\n\n\n### 编写代码\n根据上面的流程我们需要定义这几个工具类：\n**ClassUtil**：扫描项目package下的所有Class\n**ClassHelper**: 调用ClassUtil，并返回需要的Bean\n**ReflectionUtil**: 返回对象实例，调用Settter方法实现注入\n**BeanHelper**: 初始化BeanMap\n>代码参考《架构探险》一书\n\n*ClassUtil:*\n需要通过ClassLoader获得项目的所有资源，分别查找文件和jar包中的类\n得到这个ClassSet之后，我们可以根据已经定义的注解来过滤出不同的Bean\n``` java\npublic static Set<Class<?>> getClassSet(String packageName) {\n        Set<Class<?>> classSet = new HashSet<Class<?>>();\n        try {\n            Enumeration<URL> urls = getClassLoader().getResources(\n                    packageName.replace(\".\", \"/\"));\n            while (urls.hasMoreElements()) {\n                URL url = urls.nextElement();\n                if (url != null) {\n                    String protocol = url.getProtocol();\n                    if (protocol.equals(\"file\")) {\n                        String packagePath = url.getPath().replaceAll(\"%20\", \" \");\n                        addClassFromFile(classSet, packagePath, packageName);\n                    } else if (protocol.equals(\"jar\")) {\n                        addClassFromJar(classSet, url);\n                    }\n                }\n            }\n        } catch (Exception e) {\n            log.error(\"get class set failed\", e);\n            throw new RuntimeException(e);\n        }\n        return classSet;\n    }\n```\n*BeanHelper:*\n在初始化时立即将所有bean实例化，放入BeanMap中\n``` java\nprivate static final Map<Class<?>,Object> BEAN_MAP=new HashMap<Class<?>, Object>();\n    static {\n        Set<Class<?>> beanClass=ClassHelper.getBeanClassSet();\n        for(Class<?> cls:beanClass){\n            //通过反射获取对象实例\n            Object obj=ReflectionUtil.getInstance(cls);\n            BEAN_MAP.put(cls,obj);\n        }\n    }\n```\n之后就可以在IOCHelper中实现依赖注入了。\n``` java\npublic class IOCHelper {\n    static{\n        Map<Class<?>,Object> beanMap=BeanHelper.getBeanMap();\n\n        if(!CollectionsUtil.isEmpty(beanMap)){\n            for(Map.Entry<Class<?>,Object> beanEntry:beanMap.entrySet()){\n                //实例化对象由容器统一管理\n                Class<?> beanClass=beanEntry.getKey();\n                Object beanInstance=beanEntry.getValue();\n                Field[] fields=beanClass.getDeclaredFields();\n                if(fields.length!=0){\n                    for(Field beanField:fields){\n                    //判断是否需要注入\n                        if(beanField.isAnnotationPresent(Inject.class)){\n                            Class<?> beanFieldClass=beanField.getType();\n                            Object beanFieldInstance=beanMap.get(beanFieldClass);\n                            if(beanFieldInstance!=null){\n                                ReflectionUtil.setField(beanInstance,beanField,beanFieldInstance);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n```\n**测试：**\n定义一个Service\n``` java\n@Service\npublic class LoginService {\n    public LoginService(){}\n    public void login(){\n        System.out.println(\"login...\");\n    }\n}\n```\n再定义一个Controller，依赖于Service\n``` java\n@Controller\npublic class IndexController {\n    @Inject\n    private LoginService loginService;\n    public void login(){\n        System.out.println(\"call login method\");\n        loginService.login();\n    }\n\n}\n```\n测试IOCHelper,是否注入了Service(@service,@Controller标记的类会被装配成Bean)\n``` java\n\npublic class Start {\n\n    public static void main(String[] arg){\n        ClassUtil.loadClass(IOCHelper.class.getName(), true);\n        IndexController controller= BeanHelper.getBean(IndexController.class);\n        controller.login();\n    }\n}\n```\n\n### 总结\n到这里相信你已经了解了IOC容器的大概工作方式，这里的IOCHelper还存在很多问题：\n1. 只支持Bean的setter注入，没有支持构造器注入。\n2. BeanMap中所有的Class都是单例的，每次getBean得到的都是同一实例。\n3. 不支持集合类型的对象注入\n4. 这里BeanMap不支持并发访问\n\n\n[完整代码地址][1]\n\n\n  [1]: https://github.com/xianfengsong/concise-framework/tree/master/src/main/java/com/throwsnew/conciseframework","source":"_posts/ioc-one.md","raw":"# 动手编写一个IOC容器#\n\ntitle: 动手编写一个IOC容器\ndate: 2016-09-28 23:30:55\ncategories: \ntags: [Spring]\n---\n\n### 什么是IOC\n 所谓的IOC(Inversion of control)控制反转，实际是引入一个管理资源的第三方来统一管理分配资源，来代替各个资源持有者,使用者相互依赖的情况。\n\n 以打牌为例，之前玩家需要自己摸牌，现在改成由发牌人为所有玩家发牌，这个过程就叫做“控制反转”，发牌人就是IOC容器，发牌人给玩家发牌的过程就被称为“依赖注入(Dependency Injection)”。\n\n``` java\n//不使用IOC Player自己负责实例化Card\npublic Class PlayerA{\n    private Card myCard=new Card();\n    ...\n}\npublic Class PlayerB{\n    private Card myCard=new Card();\n    ...\n}\n\n\n//实例化在IOC容器（Dealer）中进行\npublic Class Dealer{\n    private Card card=new Card();\n    ...\n}\n//Player感知不到Dealer存在\npublic Class Player{\n    @Inject\n    private Card myCard;\n}\n```\n\n\n在实际的j2ee项目中，使用依赖注入有这样几个好处： <!--more-->\n1.使用IOC容器可以把加载Bean的工作集中进行，使用者不再负责资源的初始化，在编译期将资源和使用者解耦；\n2.在使用单例模式的情况下可以避免重复的创建相同对象，减少资源占用；\n\n### IOC容器工作过程\n\n那么IOC容器怎么来实现依赖注入呢，这里提供一个基于注解的简单的IOC实现方案：\n第一步：\n我们将所有被IOC容器管理的类称为Bean，在项目启动时需要扫描当前所有的java Bean并放入到一个BeanMap中，并且将他们实例化，BeanMap保存BeanClass和Bean实例的对应关系。\n第二步：\n遍历BeanMap中的Bean，逐个判断Bean的成员变量中是否有@Inject注解，如果有，就从BeanMap中取出这个成员变量类对应的对象，注入给这个Bean。\n\n\n\n### 编写代码\n根据上面的流程我们需要定义这几个工具类：\n**ClassUtil**：扫描项目package下的所有Class\n**ClassHelper**: 调用ClassUtil，并返回需要的Bean\n**ReflectionUtil**: 返回对象实例，调用Settter方法实现注入\n**BeanHelper**: 初始化BeanMap\n>代码参考《架构探险》一书\n\n*ClassUtil:*\n需要通过ClassLoader获得项目的所有资源，分别查找文件和jar包中的类\n得到这个ClassSet之后，我们可以根据已经定义的注解来过滤出不同的Bean\n``` java\npublic static Set<Class<?>> getClassSet(String packageName) {\n        Set<Class<?>> classSet = new HashSet<Class<?>>();\n        try {\n            Enumeration<URL> urls = getClassLoader().getResources(\n                    packageName.replace(\".\", \"/\"));\n            while (urls.hasMoreElements()) {\n                URL url = urls.nextElement();\n                if (url != null) {\n                    String protocol = url.getProtocol();\n                    if (protocol.equals(\"file\")) {\n                        String packagePath = url.getPath().replaceAll(\"%20\", \" \");\n                        addClassFromFile(classSet, packagePath, packageName);\n                    } else if (protocol.equals(\"jar\")) {\n                        addClassFromJar(classSet, url);\n                    }\n                }\n            }\n        } catch (Exception e) {\n            log.error(\"get class set failed\", e);\n            throw new RuntimeException(e);\n        }\n        return classSet;\n    }\n```\n*BeanHelper:*\n在初始化时立即将所有bean实例化，放入BeanMap中\n``` java\nprivate static final Map<Class<?>,Object> BEAN_MAP=new HashMap<Class<?>, Object>();\n    static {\n        Set<Class<?>> beanClass=ClassHelper.getBeanClassSet();\n        for(Class<?> cls:beanClass){\n            //通过反射获取对象实例\n            Object obj=ReflectionUtil.getInstance(cls);\n            BEAN_MAP.put(cls,obj);\n        }\n    }\n```\n之后就可以在IOCHelper中实现依赖注入了。\n``` java\npublic class IOCHelper {\n    static{\n        Map<Class<?>,Object> beanMap=BeanHelper.getBeanMap();\n\n        if(!CollectionsUtil.isEmpty(beanMap)){\n            for(Map.Entry<Class<?>,Object> beanEntry:beanMap.entrySet()){\n                //实例化对象由容器统一管理\n                Class<?> beanClass=beanEntry.getKey();\n                Object beanInstance=beanEntry.getValue();\n                Field[] fields=beanClass.getDeclaredFields();\n                if(fields.length!=0){\n                    for(Field beanField:fields){\n                    //判断是否需要注入\n                        if(beanField.isAnnotationPresent(Inject.class)){\n                            Class<?> beanFieldClass=beanField.getType();\n                            Object beanFieldInstance=beanMap.get(beanFieldClass);\n                            if(beanFieldInstance!=null){\n                                ReflectionUtil.setField(beanInstance,beanField,beanFieldInstance);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n```\n**测试：**\n定义一个Service\n``` java\n@Service\npublic class LoginService {\n    public LoginService(){}\n    public void login(){\n        System.out.println(\"login...\");\n    }\n}\n```\n再定义一个Controller，依赖于Service\n``` java\n@Controller\npublic class IndexController {\n    @Inject\n    private LoginService loginService;\n    public void login(){\n        System.out.println(\"call login method\");\n        loginService.login();\n    }\n\n}\n```\n测试IOCHelper,是否注入了Service(@service,@Controller标记的类会被装配成Bean)\n``` java\n\npublic class Start {\n\n    public static void main(String[] arg){\n        ClassUtil.loadClass(IOCHelper.class.getName(), true);\n        IndexController controller= BeanHelper.getBean(IndexController.class);\n        controller.login();\n    }\n}\n```\n\n### 总结\n到这里相信你已经了解了IOC容器的大概工作方式，这里的IOCHelper还存在很多问题：\n1. 只支持Bean的setter注入，没有支持构造器注入。\n2. BeanMap中所有的Class都是单例的，每次getBean得到的都是同一实例。\n3. 不支持集合类型的对象注入\n4. 这里BeanMap不支持并发访问\n\n\n[完整代码地址][1]\n\n\n  [1]: https://github.com/xianfengsong/concise-framework/tree/master/src/main/java/com/throwsnew/conciseframework","slug":"ioc-one","published":1,"updated":"2018-11-21T16:27:13.905Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp57u3wx000a2xpblx1n0a55","content":"<h3 id=\"什么是IOC\"><a href=\"#什么是IOC\" class=\"headerlink\" title=\"什么是IOC\"></a>什么是IOC</h3><p> 所谓的IOC(Inversion of control)控制反转，实际是引入一个管理资源的第三方来统一管理分配资源，来代替各个资源持有者,使用者相互依赖的情况。</p>\n<p> 以打牌为例，之前玩家需要自己摸牌，现在改成由发牌人为所有玩家发牌，这个过程就叫做“控制反转”，发牌人就是IOC容器，发牌人给玩家发牌的过程就被称为“依赖注入(Dependency Injection)”。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//不使用IOC Player自己负责实例化Card</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Class PlayerA&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Card myCard=<span class=\"keyword\">new</span> Card();</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> Class PlayerB&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Card myCard=<span class=\"keyword\">new</span> Card();</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//实例化在IOC容器（Dealer）中进行</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Class Dealer&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Card card=<span class=\"keyword\">new</span> Card();</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//Player感知不到Dealer存在</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Class Player&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Inject</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Card myCard;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在实际的j2ee项目中，使用依赖注入有这样几个好处： <a id=\"more\"></a><br>1.使用IOC容器可以把加载Bean的工作集中进行，使用者不再负责资源的初始化，在编译期将资源和使用者解耦；<br>2.在使用单例模式的情况下可以避免重复的创建相同对象，减少资源占用；</p>\n<h3 id=\"IOC容器工作过程\"><a href=\"#IOC容器工作过程\" class=\"headerlink\" title=\"IOC容器工作过程\"></a>IOC容器工作过程</h3><p>那么IOC容器怎么来实现依赖注入呢，这里提供一个基于注解的简单的IOC实现方案：<br>第一步：<br>我们将所有被IOC容器管理的类称为Bean，在项目启动时需要扫描当前所有的java Bean并放入到一个BeanMap中，并且将他们实例化，BeanMap保存BeanClass和Bean实例的对应关系。<br>第二步：<br>遍历BeanMap中的Bean，逐个判断Bean的成员变量中是否有@Inject注解，如果有，就从BeanMap中取出这个成员变量类对应的对象，注入给这个Bean。</p>\n<h3 id=\"编写代码\"><a href=\"#编写代码\" class=\"headerlink\" title=\"编写代码\"></a>编写代码</h3><p>根据上面的流程我们需要定义这几个工具类：<br><strong>ClassUtil</strong>：扫描项目package下的所有Class<br><strong>ClassHelper</strong>: 调用ClassUtil，并返回需要的Bean<br><strong>ReflectionUtil</strong>: 返回对象实例，调用Settter方法实现注入<br><strong>BeanHelper</strong>: 初始化BeanMap</p>\n<blockquote>\n<p>代码参考《架构探险》一书</p>\n</blockquote>\n<p><em>ClassUtil:</em><br>需要通过ClassLoader获得项目的所有资源，分别查找文件和jar包中的类<br>得到这个ClassSet之后，我们可以根据已经定义的注解来过滤出不同的Bean<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Set&lt;Class&lt;?&gt;&gt; getClassSet(String packageName) &#123;</span><br><span class=\"line\">        Set&lt;Class&lt;?&gt;&gt; classSet = <span class=\"keyword\">new</span> HashSet&lt;Class&lt;?&gt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Enumeration&lt;URL&gt; urls = getClassLoader().getResources(</span><br><span class=\"line\">                    packageName.replace(<span class=\"string\">\".\"</span>, <span class=\"string\">\"/\"</span>));</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (urls.hasMoreElements()) &#123;</span><br><span class=\"line\">                URL url = urls.nextElement();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (url != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    String protocol = url.getProtocol();</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (protocol.equals(<span class=\"string\">\"file\"</span>)) &#123;</span><br><span class=\"line\">                        String packagePath = url.getPath().replaceAll(<span class=\"string\">\"%20\"</span>, <span class=\"string\">\" \"</span>);</span><br><span class=\"line\">                        addClassFromFile(classSet, packagePath, packageName);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (protocol.equals(<span class=\"string\">\"jar\"</span>)) &#123;</span><br><span class=\"line\">                        addClassFromJar(classSet, url);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            log.error(<span class=\"string\">\"get class set failed\"</span>, e);</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> classSet;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p><em>BeanHelper:</em><br>在初始化时立即将所有bean实例化，放入BeanMap中<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Map&lt;Class&lt;?&gt;,Object&gt; BEAN_MAP=<span class=\"keyword\">new</span> HashMap&lt;Class&lt;?&gt;, Object&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        Set&lt;Class&lt;?&gt;&gt; beanClass=ClassHelper.getBeanClassSet();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(Class&lt;?&gt; cls:beanClass)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//通过反射获取对象实例</span></span><br><span class=\"line\">            Object obj=ReflectionUtil.getInstance(cls);</span><br><span class=\"line\">            BEAN_MAP.put(cls,obj);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>之后就可以在IOCHelper中实现依赖注入了。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IOCHelper</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span>&#123;</span><br><span class=\"line\">        Map&lt;Class&lt;?&gt;,Object&gt; beanMap=BeanHelper.getBeanMap();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!CollectionsUtil.isEmpty(beanMap))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(Map.Entry&lt;Class&lt;?&gt;,Object&gt; beanEntry:beanMap.entrySet())&#123;</span><br><span class=\"line\">                <span class=\"comment\">//实例化对象由容器统一管理</span></span><br><span class=\"line\">                Class&lt;?&gt; beanClass=beanEntry.getKey();</span><br><span class=\"line\">                Object beanInstance=beanEntry.getValue();</span><br><span class=\"line\">                Field[] fields=beanClass.getDeclaredFields();</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(fields.length!=<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">for</span>(Field beanField:fields)&#123;</span><br><span class=\"line\">                    <span class=\"comment\">//判断是否需要注入</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span>(beanField.isAnnotationPresent(Inject.class))&#123;</span><br><span class=\"line\">                            Class&lt;?&gt; beanFieldClass=beanField.getType();</span><br><span class=\"line\">                            Object beanFieldInstance=beanMap.get(beanFieldClass);</span><br><span class=\"line\">                            <span class=\"keyword\">if</span>(beanFieldInstance!=<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                                ReflectionUtil.setField(beanInstance,beanField,beanFieldInstance);</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>测试：</strong><br>定义一个Service<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LoginService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LoginService</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">login</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"login...\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>再定义一个Controller，依赖于Service<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Controller</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IndexController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Inject</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> LoginService loginService;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">login</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"call login method\"</span>);</span><br><span class=\"line\">        loginService.login();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>测试IOCHelper,是否注入了Service(@service,@Controller标记的类会被装配成Bean)<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Start</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] arg)</span></span>&#123;</span><br><span class=\"line\">        ClassUtil.loadClass(IOCHelper.class.getName(), <span class=\"keyword\">true</span>);</span><br><span class=\"line\">        IndexController controller= BeanHelper.getBean(IndexController.class);</span><br><span class=\"line\">        controller.login();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>到这里相信你已经了解了IOC容器的大概工作方式，这里的IOCHelper还存在很多问题：</p>\n<ol>\n<li>只支持Bean的setter注入，没有支持构造器注入。</li>\n<li>BeanMap中所有的Class都是单例的，每次getBean得到的都是同一实例。</li>\n<li>不支持集合类型的对象注入</li>\n<li>这里BeanMap不支持并发访问</li>\n</ol>\n<p><a href=\"https://github.com/xianfengsong/concise-framework/tree/master/src/main/java/com/throwsnew/conciseframework\" target=\"_blank\" rel=\"noopener\">完整代码地址</a></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"什么是IOC\"><a href=\"#什么是IOC\" class=\"headerlink\" title=\"什么是IOC\"></a>什么是IOC</h3><p> 所谓的IOC(Inversion of control)控制反转，实际是引入一个管理资源的第三方来统一管理分配资源，来代替各个资源持有者,使用者相互依赖的情况。</p>\n<p> 以打牌为例，之前玩家需要自己摸牌，现在改成由发牌人为所有玩家发牌，这个过程就叫做“控制反转”，发牌人就是IOC容器，发牌人给玩家发牌的过程就被称为“依赖注入(Dependency Injection)”。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//不使用IOC Player自己负责实例化Card</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Class PlayerA&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Card myCard=<span class=\"keyword\">new</span> Card();</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> Class PlayerB&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Card myCard=<span class=\"keyword\">new</span> Card();</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//实例化在IOC容器（Dealer）中进行</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Class Dealer&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Card card=<span class=\"keyword\">new</span> Card();</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//Player感知不到Dealer存在</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Class Player&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Inject</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Card myCard;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在实际的j2ee项目中，使用依赖注入有这样几个好处：","more":"<br>1.使用IOC容器可以把加载Bean的工作集中进行，使用者不再负责资源的初始化，在编译期将资源和使用者解耦；<br>2.在使用单例模式的情况下可以避免重复的创建相同对象，减少资源占用；</p>\n<h3 id=\"IOC容器工作过程\"><a href=\"#IOC容器工作过程\" class=\"headerlink\" title=\"IOC容器工作过程\"></a>IOC容器工作过程</h3><p>那么IOC容器怎么来实现依赖注入呢，这里提供一个基于注解的简单的IOC实现方案：<br>第一步：<br>我们将所有被IOC容器管理的类称为Bean，在项目启动时需要扫描当前所有的java Bean并放入到一个BeanMap中，并且将他们实例化，BeanMap保存BeanClass和Bean实例的对应关系。<br>第二步：<br>遍历BeanMap中的Bean，逐个判断Bean的成员变量中是否有@Inject注解，如果有，就从BeanMap中取出这个成员变量类对应的对象，注入给这个Bean。</p>\n<h3 id=\"编写代码\"><a href=\"#编写代码\" class=\"headerlink\" title=\"编写代码\"></a>编写代码</h3><p>根据上面的流程我们需要定义这几个工具类：<br><strong>ClassUtil</strong>：扫描项目package下的所有Class<br><strong>ClassHelper</strong>: 调用ClassUtil，并返回需要的Bean<br><strong>ReflectionUtil</strong>: 返回对象实例，调用Settter方法实现注入<br><strong>BeanHelper</strong>: 初始化BeanMap</p>\n<blockquote>\n<p>代码参考《架构探险》一书</p>\n</blockquote>\n<p><em>ClassUtil:</em><br>需要通过ClassLoader获得项目的所有资源，分别查找文件和jar包中的类<br>得到这个ClassSet之后，我们可以根据已经定义的注解来过滤出不同的Bean<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Set&lt;Class&lt;?&gt;&gt; getClassSet(String packageName) &#123;</span><br><span class=\"line\">        Set&lt;Class&lt;?&gt;&gt; classSet = <span class=\"keyword\">new</span> HashSet&lt;Class&lt;?&gt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Enumeration&lt;URL&gt; urls = getClassLoader().getResources(</span><br><span class=\"line\">                    packageName.replace(<span class=\"string\">\".\"</span>, <span class=\"string\">\"/\"</span>));</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (urls.hasMoreElements()) &#123;</span><br><span class=\"line\">                URL url = urls.nextElement();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (url != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    String protocol = url.getProtocol();</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (protocol.equals(<span class=\"string\">\"file\"</span>)) &#123;</span><br><span class=\"line\">                        String packagePath = url.getPath().replaceAll(<span class=\"string\">\"%20\"</span>, <span class=\"string\">\" \"</span>);</span><br><span class=\"line\">                        addClassFromFile(classSet, packagePath, packageName);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (protocol.equals(<span class=\"string\">\"jar\"</span>)) &#123;</span><br><span class=\"line\">                        addClassFromJar(classSet, url);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            log.error(<span class=\"string\">\"get class set failed\"</span>, e);</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> classSet;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p><em>BeanHelper:</em><br>在初始化时立即将所有bean实例化，放入BeanMap中<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Map&lt;Class&lt;?&gt;,Object&gt; BEAN_MAP=<span class=\"keyword\">new</span> HashMap&lt;Class&lt;?&gt;, Object&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        Set&lt;Class&lt;?&gt;&gt; beanClass=ClassHelper.getBeanClassSet();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(Class&lt;?&gt; cls:beanClass)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//通过反射获取对象实例</span></span><br><span class=\"line\">            Object obj=ReflectionUtil.getInstance(cls);</span><br><span class=\"line\">            BEAN_MAP.put(cls,obj);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>之后就可以在IOCHelper中实现依赖注入了。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IOCHelper</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span>&#123;</span><br><span class=\"line\">        Map&lt;Class&lt;?&gt;,Object&gt; beanMap=BeanHelper.getBeanMap();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!CollectionsUtil.isEmpty(beanMap))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(Map.Entry&lt;Class&lt;?&gt;,Object&gt; beanEntry:beanMap.entrySet())&#123;</span><br><span class=\"line\">                <span class=\"comment\">//实例化对象由容器统一管理</span></span><br><span class=\"line\">                Class&lt;?&gt; beanClass=beanEntry.getKey();</span><br><span class=\"line\">                Object beanInstance=beanEntry.getValue();</span><br><span class=\"line\">                Field[] fields=beanClass.getDeclaredFields();</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(fields.length!=<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">for</span>(Field beanField:fields)&#123;</span><br><span class=\"line\">                    <span class=\"comment\">//判断是否需要注入</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span>(beanField.isAnnotationPresent(Inject.class))&#123;</span><br><span class=\"line\">                            Class&lt;?&gt; beanFieldClass=beanField.getType();</span><br><span class=\"line\">                            Object beanFieldInstance=beanMap.get(beanFieldClass);</span><br><span class=\"line\">                            <span class=\"keyword\">if</span>(beanFieldInstance!=<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                                ReflectionUtil.setField(beanInstance,beanField,beanFieldInstance);</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>测试：</strong><br>定义一个Service<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LoginService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LoginService</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">login</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"login...\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>再定义一个Controller，依赖于Service<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Controller</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IndexController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Inject</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> LoginService loginService;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">login</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"call login method\"</span>);</span><br><span class=\"line\">        loginService.login();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>测试IOCHelper,是否注入了Service(@service,@Controller标记的类会被装配成Bean)<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Start</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] arg)</span></span>&#123;</span><br><span class=\"line\">        ClassUtil.loadClass(IOCHelper.class.getName(), <span class=\"keyword\">true</span>);</span><br><span class=\"line\">        IndexController controller= BeanHelper.getBean(IndexController.class);</span><br><span class=\"line\">        controller.login();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>到这里相信你已经了解了IOC容器的大概工作方式，这里的IOCHelper还存在很多问题：</p>\n<ol>\n<li>只支持Bean的setter注入，没有支持构造器注入。</li>\n<li>BeanMap中所有的Class都是单例的，每次getBean得到的都是同一实例。</li>\n<li>不支持集合类型的对象注入</li>\n<li>这里BeanMap不支持并发访问</li>\n</ol>\n<p><a href=\"https://github.com/xianfengsong/concise-framework/tree/master/src/main/java/com/throwsnew/conciseframework\" target=\"_blank\" rel=\"noopener\">完整代码地址</a></p>"},{"title":"JAVA基础————两分钟看懂注解Annotation","date":"2016-01-25T16:05:46.000Z","_content":"## 什么是注解\n\n**注解是一种描述程序的[元数据][q1]，我们可以把他当做一种特殊的注释**　  \n> [官方文档][q2] : *Annotations, a form of metadata, provide data about a program that is not part of the program itself.*　\n\n+ 注解可以为编译器提供信息，如@Override，@SuppressWarnings\n+ 可以代替xml等文件，为程序保存所需的配置\n+ 可以在程序运行时根据注解执行一些操作，如Spring中的@Autowired\n\n<!--more-->\n\n## 注解的语法\n### 声明注解\n注解的定义与接口类似，也可以为注解添加属性。在实现注解时，方法名是对象属性名，返回值是属性值的类型。如 @Override的定义：\n```java\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.SOURCE)\npublic @interface Override{}\n```\n自定义并实例化注解：\n```java\n@interface Developer{\n  String [] name();\n  int level() default 0;\n}\n//一个注解对象\n@Developer(name={\"j\",\"p\"},level=2)\n```\n### 内置注解\njava提供几个内置注解来描述自定义的注解 \n **@Target**：应用到什么对象\n\n| 名称        | 定义   |\n| -------- | :-----  |\n| ElementType.ANNOTATION_TYPE| 应用于注解 |\n| ElementType.FIELD        |   属性    |\n| ElementType.METHOD        |     方法   |\n| ElementType.TYPE       |    类的任何元素   |\n|[...更多内容][更多]|[...更多内容][更多]|\n\n\n **@Retention**：注解存储的位置\n\n| 名称|定义|\n|--|--|\n|RetentionPolicy.SOURCE|保留在源码阶段，被编译器忽略|\n|RetentionPolicy.CLASS|保留至编译阶段，被JVM忽略|\n|RetentionPolicy.RUNTIME|保留至JVM可以在运行时使用|\n**@Inherited**：\n类的注解默认不会被继承给子类，如果需要应该在定义时指定@Inherited（只适用于一个类的注解）\n\n **@Document** : \n\n如果定义注解时指定@Document那么注解会被添加到用用对象的javadoc文档中\n\n## 使用注解\n\n我们已经了解了注解的基本语法，那么应该怎么在程序中处理注解呢？\n\n![举个例子][img]\n\n\n&#160; &#160; &#160;假设公司办公楼里有不同类型的一些房间，而每天都会有各种身份的人来公司，如何让程序来控制这些人对不同房间的访问权限呢？\n\n----------\n&#160; &#160; &#160;\n通常我们会将权限关系保存在xml等文件中，但同时也可以使用注解来保存各类房间允许进入的人员信息，并在程序中根据注解作出处理。\n\n1.定义房间：\n\n```java\npublic class Room {\n    public void open(String name){\n        System.out.println(name+\" came in\");}\n    }\n}\n```\n\n2.创建注解时选择RETENTION.RUNTIME，这样我们可以通过反射获取注解信息：\n```java\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\npublic @interface Accessible {\n    //保存允许进入房间的人员\n    String [] value ();\n}\n```\n3.创建WashRoom,MeetingRoom,BossRoom，并在open方法上添加注解：\n```java\n//例：洗手间 任何人都可以进入\npublic class WashRoom extends Room {\n    @Accessible({\"Boss\",\"Staff\",\"Visitor\"})\n    @Override\n    public void open(String name){\n        System.out.println(\"this is washroom\");\n        super.open(name);\n    }\n}\n```\n4.处理注解：\n```java\n//初始化房间和人员\nRoom[] rooms = {new WashRoom(), new MeetingRoom(), new BossRoom()};\nString[] persons = {\"Boss\", \"Staff\", \"Visitor\"};\n\nfor (String person : persons) {\n    for (Room room : rooms) {\n\n        Method[] methods = room.getClass().getMethods();\n\n            for (Method method : methods) {\n                //用反射获取带有注解的方法\n                if (method.isAnnotationPresent(Accessible.class)) {\n                    Accessible accessAnnotation = method.getAnnotation(Accessible.class);\n                    //获得注解内容\n                    List<String> nameList = Arrays.asList(accessAnnotation.value());\n                    if (nameList.contains(person)) {\n                        try {\n                            method.invoke(room, person);\n                        } catch (Exception e) {\n                            e.printStackTrace();\n                        }\n                    } else {\n                            System.out.println(\"forbidden！\");\n                        }\n                    }\n                }\n            }\n        }\n```\n# 全文完～\n### 参考\noracle java文档：https://docs.oracle.com/javase/tutorial/java/annotations/index.html\nJava深度历险（六）——Java注解 http://www.infoq.com/cn/articles/cf-java-annotation\n\n\n  [img]:  http://7xl4v5.com1.z0.glb.clouddn.com/example.jpg\n  [更多]: https://docs.oracle.com/javase/tutorial/java/annotations/predefined.html\n  \n[q1]: http://www.ruanyifeng.com/blog/2007/03/metadata.html\n\n[q2]: https://docs.oracle.com/javase/tutorial/java/annotations/index.html\n\n\n","source":"_posts/java-annotation.md","raw":"# JAVA基础————两分钟学会注解Annotation\n\ntitle: JAVA基础————两分钟看懂注解Annotation\ndate: 2016-01-26 00:05:46\ncategories: \ntags: [java基础,注解,annotation]\n\n---\n## 什么是注解\n\n**注解是一种描述程序的[元数据][q1]，我们可以把他当做一种特殊的注释**　  \n> [官方文档][q2] : *Annotations, a form of metadata, provide data about a program that is not part of the program itself.*　\n\n+ 注解可以为编译器提供信息，如@Override，@SuppressWarnings\n+ 可以代替xml等文件，为程序保存所需的配置\n+ 可以在程序运行时根据注解执行一些操作，如Spring中的@Autowired\n\n<!--more-->\n\n## 注解的语法\n### 声明注解\n注解的定义与接口类似，也可以为注解添加属性。在实现注解时，方法名是对象属性名，返回值是属性值的类型。如 @Override的定义：\n```java\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.SOURCE)\npublic @interface Override{}\n```\n自定义并实例化注解：\n```java\n@interface Developer{\n  String [] name();\n  int level() default 0;\n}\n//一个注解对象\n@Developer(name={\"j\",\"p\"},level=2)\n```\n### 内置注解\njava提供几个内置注解来描述自定义的注解 \n **@Target**：应用到什么对象\n\n| 名称        | 定义   |\n| -------- | :-----  |\n| ElementType.ANNOTATION_TYPE| 应用于注解 |\n| ElementType.FIELD        |   属性    |\n| ElementType.METHOD        |     方法   |\n| ElementType.TYPE       |    类的任何元素   |\n|[...更多内容][更多]|[...更多内容][更多]|\n\n\n **@Retention**：注解存储的位置\n\n| 名称|定义|\n|--|--|\n|RetentionPolicy.SOURCE|保留在源码阶段，被编译器忽略|\n|RetentionPolicy.CLASS|保留至编译阶段，被JVM忽略|\n|RetentionPolicy.RUNTIME|保留至JVM可以在运行时使用|\n**@Inherited**：\n类的注解默认不会被继承给子类，如果需要应该在定义时指定@Inherited（只适用于一个类的注解）\n\n **@Document** : \n\n如果定义注解时指定@Document那么注解会被添加到用用对象的javadoc文档中\n\n## 使用注解\n\n我们已经了解了注解的基本语法，那么应该怎么在程序中处理注解呢？\n\n![举个例子][img]\n\n\n&#160; &#160; &#160;假设公司办公楼里有不同类型的一些房间，而每天都会有各种身份的人来公司，如何让程序来控制这些人对不同房间的访问权限呢？\n\n----------\n&#160; &#160; &#160;\n通常我们会将权限关系保存在xml等文件中，但同时也可以使用注解来保存各类房间允许进入的人员信息，并在程序中根据注解作出处理。\n\n1.定义房间：\n\n```java\npublic class Room {\n    public void open(String name){\n        System.out.println(name+\" came in\");}\n    }\n}\n```\n\n2.创建注解时选择RETENTION.RUNTIME，这样我们可以通过反射获取注解信息：\n```java\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\npublic @interface Accessible {\n    //保存允许进入房间的人员\n    String [] value ();\n}\n```\n3.创建WashRoom,MeetingRoom,BossRoom，并在open方法上添加注解：\n```java\n//例：洗手间 任何人都可以进入\npublic class WashRoom extends Room {\n    @Accessible({\"Boss\",\"Staff\",\"Visitor\"})\n    @Override\n    public void open(String name){\n        System.out.println(\"this is washroom\");\n        super.open(name);\n    }\n}\n```\n4.处理注解：\n```java\n//初始化房间和人员\nRoom[] rooms = {new WashRoom(), new MeetingRoom(), new BossRoom()};\nString[] persons = {\"Boss\", \"Staff\", \"Visitor\"};\n\nfor (String person : persons) {\n    for (Room room : rooms) {\n\n        Method[] methods = room.getClass().getMethods();\n\n            for (Method method : methods) {\n                //用反射获取带有注解的方法\n                if (method.isAnnotationPresent(Accessible.class)) {\n                    Accessible accessAnnotation = method.getAnnotation(Accessible.class);\n                    //获得注解内容\n                    List<String> nameList = Arrays.asList(accessAnnotation.value());\n                    if (nameList.contains(person)) {\n                        try {\n                            method.invoke(room, person);\n                        } catch (Exception e) {\n                            e.printStackTrace();\n                        }\n                    } else {\n                            System.out.println(\"forbidden！\");\n                        }\n                    }\n                }\n            }\n        }\n```\n# 全文完～\n### 参考\noracle java文档：https://docs.oracle.com/javase/tutorial/java/annotations/index.html\nJava深度历险（六）——Java注解 http://www.infoq.com/cn/articles/cf-java-annotation\n\n\n  [img]:  http://7xl4v5.com1.z0.glb.clouddn.com/example.jpg\n  [更多]: https://docs.oracle.com/javase/tutorial/java/annotations/predefined.html\n  \n[q1]: http://www.ruanyifeng.com/blog/2007/03/metadata.html\n\n[q2]: https://docs.oracle.com/javase/tutorial/java/annotations/index.html\n\n\n","slug":"java-annotation","published":1,"updated":"2018-11-21T16:22:17.310Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp57u3wz000b2xpbde8ovrpi","content":"<h2 id=\"什么是注解\"><a href=\"#什么是注解\" class=\"headerlink\" title=\"什么是注解\"></a>什么是注解</h2><p><strong>注解是一种描述程序的<a href=\"http://www.ruanyifeng.com/blog/2007/03/metadata.html\" target=\"_blank\" rel=\"noopener\">元数据</a>，我们可以把他当做一种特殊的注释</strong>　  </p>\n<blockquote>\n<p><a href=\"https://docs.oracle.com/javase/tutorial/java/annotations/index.html\" target=\"_blank\" rel=\"noopener\">官方文档</a> : <em>Annotations, a form of metadata, provide data about a program that is not part of the program itself.</em>　</p>\n</blockquote>\n<ul>\n<li>注解可以为编译器提供信息，如@Override，@SuppressWarnings</li>\n<li>可以代替xml等文件，为程序保存所需的配置</li>\n<li>可以在程序运行时根据注解执行一些操作，如Spring中的@Autowired</li>\n</ul>\n<a id=\"more\"></a>\n<h2 id=\"注解的语法\"><a href=\"#注解的语法\" class=\"headerlink\" title=\"注解的语法\"></a>注解的语法</h2><h3 id=\"声明注解\"><a href=\"#声明注解\" class=\"headerlink\" title=\"声明注解\"></a>声明注解</h3><p>注解的定义与接口类似，也可以为注解添加属性。在实现注解时，方法名是对象属性名，返回值是属性值的类型。如 @Override的定义：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target</span>(ElementType.METHOD)</span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Override&#123;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>自定义并实例化注解：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@interface</span> Developer&#123;</span><br><span class=\"line\">  String [] name();</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">level</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> 0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//一个注解对象</span></span><br><span class=\"line\"><span class=\"meta\">@Developer</span>(name=&#123;<span class=\"string\">\"j\"</span>,<span class=\"string\">\"p\"</span>&#125;,level=<span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"内置注解\"><a href=\"#内置注解\" class=\"headerlink\" title=\"内置注解\"></a>内置注解</h3><p>java提供几个内置注解来描述自定义的注解<br> <strong>@Target</strong>：应用到什么对象</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th style=\"text-align:left\">定义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ElementType.ANNOTATION_TYPE</td>\n<td style=\"text-align:left\">应用于注解</td>\n</tr>\n<tr>\n<td>ElementType.FIELD</td>\n<td style=\"text-align:left\">属性</td>\n</tr>\n<tr>\n<td>ElementType.METHOD</td>\n<td style=\"text-align:left\">方法</td>\n</tr>\n<tr>\n<td>ElementType.TYPE</td>\n<td style=\"text-align:left\">类的任何元素</td>\n</tr>\n<tr>\n<td><a href=\"https://docs.oracle.com/javase/tutorial/java/annotations/predefined.html\" target=\"_blank\" rel=\"noopener\">…更多内容</a></td>\n<td style=\"text-align:left\"><a href=\"https://docs.oracle.com/javase/tutorial/java/annotations/predefined.html\" target=\"_blank\" rel=\"noopener\">…更多内容</a></td>\n</tr>\n</tbody>\n</table>\n<p> <strong>@Retention</strong>：注解存储的位置</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>定义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>RetentionPolicy.SOURCE</td>\n<td>保留在源码阶段，被编译器忽略</td>\n</tr>\n<tr>\n<td>RetentionPolicy.CLASS</td>\n<td>保留至编译阶段，被JVM忽略</td>\n</tr>\n<tr>\n<td>RetentionPolicy.RUNTIME</td>\n<td>保留至JVM可以在运行时使用</td>\n</tr>\n</tbody>\n</table>\n<p><strong>@Inherited</strong>：<br>类的注解默认不会被继承给子类，如果需要应该在定义时指定@Inherited（只适用于一个类的注解）</p>\n<p> <strong>@Document</strong> : </p>\n<p>如果定义注解时指定@Document那么注解会被添加到用用对象的javadoc文档中</p>\n<h2 id=\"使用注解\"><a href=\"#使用注解\" class=\"headerlink\" title=\"使用注解\"></a>使用注解</h2><p>我们已经了解了注解的基本语法，那么应该怎么在程序中处理注解呢？</p>\n<p><img src=\"http://7xl4v5.com1.z0.glb.clouddn.com/example.jpg\" alt=\"举个例子\"></p>\n<p>&#160; &#160; &#160;假设公司办公楼里有不同类型的一些房间，而每天都会有各种身份的人来公司，如何让程序来控制这些人对不同房间的访问权限呢？</p>\n<hr>\n<p>&#160; &#160; &#160;<br>通常我们会将权限关系保存在xml等文件中，但同时也可以使用注解来保存各类房间允许进入的人员信息，并在程序中根据注解作出处理。</p>\n<p>1.定义房间：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Room</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">open</span><span class=\"params\">(String name)</span></span>&#123;</span><br><span class=\"line\">        System.out.println(name+<span class=\"string\">\" came in\"</span>);&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2.创建注解时选择RETENTION.RUNTIME，这样我们可以通过反射获取注解信息：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class=\"line\"><span class=\"meta\">@Target</span>(ElementType.METHOD)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Accessible &#123;</span><br><span class=\"line\">    <span class=\"comment\">//保存允许进入房间的人员</span></span><br><span class=\"line\">    String [] value ();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>3.创建WashRoom,MeetingRoom,BossRoom，并在open方法上添加注解：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//例：洗手间 任何人都可以进入</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WashRoom</span> <span class=\"keyword\">extends</span> <span class=\"title\">Room</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Accessible</span>(&#123;<span class=\"string\">\"Boss\"</span>,<span class=\"string\">\"Staff\"</span>,<span class=\"string\">\"Visitor\"</span>&#125;)</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">open</span><span class=\"params\">(String name)</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"this is washroom\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.open(name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>4.处理注解：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//初始化房间和人员</span></span><br><span class=\"line\">Room[] rooms = &#123;<span class=\"keyword\">new</span> WashRoom(), <span class=\"keyword\">new</span> MeetingRoom(), <span class=\"keyword\">new</span> BossRoom()&#125;;</span><br><span class=\"line\">String[] persons = &#123;<span class=\"string\">\"Boss\"</span>, <span class=\"string\">\"Staff\"</span>, <span class=\"string\">\"Visitor\"</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (String person : persons) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Room room : rooms) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Method[] methods = room.getClass().getMethods();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Method method : methods) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//用反射获取带有注解的方法</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (method.isAnnotationPresent(Accessible.class)) &#123;</span><br><span class=\"line\">                    Accessible accessAnnotation = method.getAnnotation(Accessible.class);</span><br><span class=\"line\">                    <span class=\"comment\">//获得注解内容</span></span><br><span class=\"line\">                    List&lt;String&gt; nameList = Arrays.asList(accessAnnotation.value());</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (nameList.contains(person)) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                            method.invoke(room, person);</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                            e.printStackTrace();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                            System.out.println(<span class=\"string\">\"forbidden！\"</span>);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"全文完～\"><a href=\"#全文完～\" class=\"headerlink\" title=\"全文完～\"></a>全文完～</h1><h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p>oracle java文档：<a href=\"https://docs.oracle.com/javase/tutorial/java/annotations/index.html\" target=\"_blank\" rel=\"noopener\">https://docs.oracle.com/javase/tutorial/java/annotations/index.html</a><br>Java深度历险（六）——Java注解 <a href=\"http://www.infoq.com/cn/articles/cf-java-annotation\" target=\"_blank\" rel=\"noopener\">http://www.infoq.com/cn/articles/cf-java-annotation</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"什么是注解\"><a href=\"#什么是注解\" class=\"headerlink\" title=\"什么是注解\"></a>什么是注解</h2><p><strong>注解是一种描述程序的<a href=\"http://www.ruanyifeng.com/blog/2007/03/metadata.html\" target=\"_blank\" rel=\"noopener\">元数据</a>，我们可以把他当做一种特殊的注释</strong>　  </p>\n<blockquote>\n<p><a href=\"https://docs.oracle.com/javase/tutorial/java/annotations/index.html\" target=\"_blank\" rel=\"noopener\">官方文档</a> : <em>Annotations, a form of metadata, provide data about a program that is not part of the program itself.</em>　</p>\n</blockquote>\n<ul>\n<li>注解可以为编译器提供信息，如@Override，@SuppressWarnings</li>\n<li>可以代替xml等文件，为程序保存所需的配置</li>\n<li>可以在程序运行时根据注解执行一些操作，如Spring中的@Autowired</li>\n</ul>","more":"<h2 id=\"注解的语法\"><a href=\"#注解的语法\" class=\"headerlink\" title=\"注解的语法\"></a>注解的语法</h2><h3 id=\"声明注解\"><a href=\"#声明注解\" class=\"headerlink\" title=\"声明注解\"></a>声明注解</h3><p>注解的定义与接口类似，也可以为注解添加属性。在实现注解时，方法名是对象属性名，返回值是属性值的类型。如 @Override的定义：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target</span>(ElementType.METHOD)</span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Override&#123;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>自定义并实例化注解：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@interface</span> Developer&#123;</span><br><span class=\"line\">  String [] name();</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">level</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> 0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//一个注解对象</span></span><br><span class=\"line\"><span class=\"meta\">@Developer</span>(name=&#123;<span class=\"string\">\"j\"</span>,<span class=\"string\">\"p\"</span>&#125;,level=<span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"内置注解\"><a href=\"#内置注解\" class=\"headerlink\" title=\"内置注解\"></a>内置注解</h3><p>java提供几个内置注解来描述自定义的注解<br> <strong>@Target</strong>：应用到什么对象</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th style=\"text-align:left\">定义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ElementType.ANNOTATION_TYPE</td>\n<td style=\"text-align:left\">应用于注解</td>\n</tr>\n<tr>\n<td>ElementType.FIELD</td>\n<td style=\"text-align:left\">属性</td>\n</tr>\n<tr>\n<td>ElementType.METHOD</td>\n<td style=\"text-align:left\">方法</td>\n</tr>\n<tr>\n<td>ElementType.TYPE</td>\n<td style=\"text-align:left\">类的任何元素</td>\n</tr>\n<tr>\n<td><a href=\"https://docs.oracle.com/javase/tutorial/java/annotations/predefined.html\" target=\"_blank\" rel=\"noopener\">…更多内容</a></td>\n<td style=\"text-align:left\"><a href=\"https://docs.oracle.com/javase/tutorial/java/annotations/predefined.html\" target=\"_blank\" rel=\"noopener\">…更多内容</a></td>\n</tr>\n</tbody>\n</table>\n<p> <strong>@Retention</strong>：注解存储的位置</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>定义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>RetentionPolicy.SOURCE</td>\n<td>保留在源码阶段，被编译器忽略</td>\n</tr>\n<tr>\n<td>RetentionPolicy.CLASS</td>\n<td>保留至编译阶段，被JVM忽略</td>\n</tr>\n<tr>\n<td>RetentionPolicy.RUNTIME</td>\n<td>保留至JVM可以在运行时使用</td>\n</tr>\n</tbody>\n</table>\n<p><strong>@Inherited</strong>：<br>类的注解默认不会被继承给子类，如果需要应该在定义时指定@Inherited（只适用于一个类的注解）</p>\n<p> <strong>@Document</strong> : </p>\n<p>如果定义注解时指定@Document那么注解会被添加到用用对象的javadoc文档中</p>\n<h2 id=\"使用注解\"><a href=\"#使用注解\" class=\"headerlink\" title=\"使用注解\"></a>使用注解</h2><p>我们已经了解了注解的基本语法，那么应该怎么在程序中处理注解呢？</p>\n<p><img src=\"http://7xl4v5.com1.z0.glb.clouddn.com/example.jpg\" alt=\"举个例子\"></p>\n<p>&#160; &#160; &#160;假设公司办公楼里有不同类型的一些房间，而每天都会有各种身份的人来公司，如何让程序来控制这些人对不同房间的访问权限呢？</p>\n<hr>\n<p>&#160; &#160; &#160;<br>通常我们会将权限关系保存在xml等文件中，但同时也可以使用注解来保存各类房间允许进入的人员信息，并在程序中根据注解作出处理。</p>\n<p>1.定义房间：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Room</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">open</span><span class=\"params\">(String name)</span></span>&#123;</span><br><span class=\"line\">        System.out.println(name+<span class=\"string\">\" came in\"</span>);&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2.创建注解时选择RETENTION.RUNTIME，这样我们可以通过反射获取注解信息：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class=\"line\"><span class=\"meta\">@Target</span>(ElementType.METHOD)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Accessible &#123;</span><br><span class=\"line\">    <span class=\"comment\">//保存允许进入房间的人员</span></span><br><span class=\"line\">    String [] value ();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>3.创建WashRoom,MeetingRoom,BossRoom，并在open方法上添加注解：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//例：洗手间 任何人都可以进入</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WashRoom</span> <span class=\"keyword\">extends</span> <span class=\"title\">Room</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Accessible</span>(&#123;<span class=\"string\">\"Boss\"</span>,<span class=\"string\">\"Staff\"</span>,<span class=\"string\">\"Visitor\"</span>&#125;)</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">open</span><span class=\"params\">(String name)</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"this is washroom\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.open(name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>4.处理注解：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//初始化房间和人员</span></span><br><span class=\"line\">Room[] rooms = &#123;<span class=\"keyword\">new</span> WashRoom(), <span class=\"keyword\">new</span> MeetingRoom(), <span class=\"keyword\">new</span> BossRoom()&#125;;</span><br><span class=\"line\">String[] persons = &#123;<span class=\"string\">\"Boss\"</span>, <span class=\"string\">\"Staff\"</span>, <span class=\"string\">\"Visitor\"</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (String person : persons) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Room room : rooms) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Method[] methods = room.getClass().getMethods();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Method method : methods) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//用反射获取带有注解的方法</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (method.isAnnotationPresent(Accessible.class)) &#123;</span><br><span class=\"line\">                    Accessible accessAnnotation = method.getAnnotation(Accessible.class);</span><br><span class=\"line\">                    <span class=\"comment\">//获得注解内容</span></span><br><span class=\"line\">                    List&lt;String&gt; nameList = Arrays.asList(accessAnnotation.value());</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (nameList.contains(person)) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                            method.invoke(room, person);</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                            e.printStackTrace();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                            System.out.println(<span class=\"string\">\"forbidden！\"</span>);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"全文完～\"><a href=\"#全文完～\" class=\"headerlink\" title=\"全文完～\"></a>全文完～</h1><h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p>oracle java文档：<a href=\"https://docs.oracle.com/javase/tutorial/java/annotations/index.html\" target=\"_blank\" rel=\"noopener\">https://docs.oracle.com/javase/tutorial/java/annotations/index.html</a><br>Java深度历险（六）——Java注解 <a href=\"http://www.infoq.com/cn/articles/cf-java-annotation\" target=\"_blank\" rel=\"noopener\">http://www.infoq.com/cn/articles/cf-java-annotation</a></p>"},{"title":"Sendmail的一些坑","date":"2015-12-26T15:05:46.000Z","_content":"## 简介\nSendmail是一个linux邮件服务系统，可以使用它来搭建邮件服务器。\n\n 关于邮件的几个名词：\n>MTA(Mail Transfer Agent)                             邮件传送代理，运行在邮件服务器的程序，负责接收发送邮件  \n\n>MUA(Mail User Agent) 用户端代理，提供查看编辑提交邮件的功能（如foxmail）  \n\n  >MDA(Mail Delivery Agent)主要的功能就是将MTA接收的信件依照信件的流向（送到哪里）将该信件放置到本机账户下的邮件文件中（收件箱），或者再经由MTA将信件送到下个MTA。如果信件的流向是到本机，这个邮件代理的功能就不只是将由MTA传来的邮件放置到每个用户的收件箱，它还可以具有邮件过滤（filtering）与其他相关功能[^foot]。\n\n<!--more-->\n\n## 安装\n我使用的是CentOS6.2 sendmail 8.14.4\n\n```shell\n#安装sendmail和配置工具sendmail-cf\nyum install -y sendmail\nyum install -y sendmail-cf\n#SMTP认证服务\nyum install -y saslauthd\n```\n## 配置sendmail\nsendmail的配置文件主要是XXX.mc文件和XXX.cf文件，mc后缀文件可以看做是配置文件的人类阅读版，通过sendmail-cf工具将它生成为cf后缀的外星人版配置文件   \n>vim /etc/mail/sendmail.mc\n\n具体操作请参考--[传送门](http://www.centoscn.com/CentosServer/lighttpd/2013/0726/650.html)\n\n## 常见问题\n### 1.发出的邮件被其他MTA识别为垃圾\n\n设置域名指向（上节链接），添加spf记录 [操作教程](https://www.renfei.org/blog/introduction-to-spf.html)\n同时注意控制发信频率\n### 2.在哪查看sendmail日志?\n**日志位置**： /var/log/maillog  \n**调整日志级别（详细程度）**： 修改配置文件define(`confLOG_LEVEL', `16')dnl 默认为9\n或者调用命令时指定sendmail -O LogLevel=14\n[日志级别说明](http://www-01.ibm.com/support/knowledgecenter/ssw_aix_71/com.ibm.aix.networkcomm/sendmail_debugflags.htm?lang=zh)\n### 3.sendmail日志都是什么意思?\n**注意sendmail并不保证发出的邮件一定会被发到收件人接收**，所以日志中的信息只是接收端MTA反馈的连接信息。\n具体格式，慢慢读吧-----[sendmail日志格式](http://www.softpanorama.net/Mail/Sendmail/sendmail_logs_format.shtml)\n### 4.sendmail性能参数\nhttp://www.5dmail.net/html/2008-4-27/200842733006.htm  \n### 5.一些相关的网站，文章\nhttp://www.5dmail.net/  \n**sendmail官网**https://www.sendmail.com/sm/open_source/\nhttp://park.jobdeer.com/discussion/19/%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81%E9%82%A3%E7%82%B9%E4%BA%8B\n**看邮件头**http://www.qqexmail.net/tips/st_security_look_head.asp\n\n[^foot]:http://wenku.baidu.com/link?url=iK74BiQS1clzFxTy4B4eBcG6u4gR9EMZ-CY58DwhrNqsJSYt6P9nk-aUzGPqXxgoTM5qAj51J4F-aPUhf3vaidDopNr6SrU3VgwPhWwHws_\n","source":"_posts/sendmail.md","raw":"title: Sendmail的一些坑\ndate: 2015-12-26 23:05:46\ncategories: \ntags: [邮件]\n\n---\n## 简介\nSendmail是一个linux邮件服务系统，可以使用它来搭建邮件服务器。\n\n 关于邮件的几个名词：\n>MTA(Mail Transfer Agent)                             邮件传送代理，运行在邮件服务器的程序，负责接收发送邮件  \n\n>MUA(Mail User Agent) 用户端代理，提供查看编辑提交邮件的功能（如foxmail）  \n\n  >MDA(Mail Delivery Agent)主要的功能就是将MTA接收的信件依照信件的流向（送到哪里）将该信件放置到本机账户下的邮件文件中（收件箱），或者再经由MTA将信件送到下个MTA。如果信件的流向是到本机，这个邮件代理的功能就不只是将由MTA传来的邮件放置到每个用户的收件箱，它还可以具有邮件过滤（filtering）与其他相关功能[^foot]。\n\n<!--more-->\n\n## 安装\n我使用的是CentOS6.2 sendmail 8.14.4\n\n```shell\n#安装sendmail和配置工具sendmail-cf\nyum install -y sendmail\nyum install -y sendmail-cf\n#SMTP认证服务\nyum install -y saslauthd\n```\n## 配置sendmail\nsendmail的配置文件主要是XXX.mc文件和XXX.cf文件，mc后缀文件可以看做是配置文件的人类阅读版，通过sendmail-cf工具将它生成为cf后缀的外星人版配置文件   \n>vim /etc/mail/sendmail.mc\n\n具体操作请参考--[传送门](http://www.centoscn.com/CentosServer/lighttpd/2013/0726/650.html)\n\n## 常见问题\n### 1.发出的邮件被其他MTA识别为垃圾\n\n设置域名指向（上节链接），添加spf记录 [操作教程](https://www.renfei.org/blog/introduction-to-spf.html)\n同时注意控制发信频率\n### 2.在哪查看sendmail日志?\n**日志位置**： /var/log/maillog  \n**调整日志级别（详细程度）**： 修改配置文件define(`confLOG_LEVEL', `16')dnl 默认为9\n或者调用命令时指定sendmail -O LogLevel=14\n[日志级别说明](http://www-01.ibm.com/support/knowledgecenter/ssw_aix_71/com.ibm.aix.networkcomm/sendmail_debugflags.htm?lang=zh)\n### 3.sendmail日志都是什么意思?\n**注意sendmail并不保证发出的邮件一定会被发到收件人接收**，所以日志中的信息只是接收端MTA反馈的连接信息。\n具体格式，慢慢读吧-----[sendmail日志格式](http://www.softpanorama.net/Mail/Sendmail/sendmail_logs_format.shtml)\n### 4.sendmail性能参数\nhttp://www.5dmail.net/html/2008-4-27/200842733006.htm  \n### 5.一些相关的网站，文章\nhttp://www.5dmail.net/  \n**sendmail官网**https://www.sendmail.com/sm/open_source/\nhttp://park.jobdeer.com/discussion/19/%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81%E9%82%A3%E7%82%B9%E4%BA%8B\n**看邮件头**http://www.qqexmail.net/tips/st_security_look_head.asp\n\n[^foot]:http://wenku.baidu.com/link?url=iK74BiQS1clzFxTy4B4eBcG6u4gR9EMZ-CY58DwhrNqsJSYt6P9nk-aUzGPqXxgoTM5qAj51J4F-aPUhf3vaidDopNr6SrU3VgwPhWwHws_\n","slug":"sendmail","published":1,"updated":"2018-11-21T16:24:04.824Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp57u3x0000e2xpbfi3qy8k7","content":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>Sendmail是一个linux邮件服务系统，可以使用它来搭建邮件服务器。</p>\n<p> 关于邮件的几个名词：</p>\n<blockquote>\n<p>MTA(Mail Transfer Agent)                             邮件传送代理，运行在邮件服务器的程序，负责接收发送邮件  </p>\n</blockquote>\n<blockquote>\n<p>MUA(Mail User Agent) 用户端代理，提供查看编辑提交邮件的功能（如foxmail）  </p>\n</blockquote>\n<blockquote>\n<p>MDA(Mail Delivery Agent)主要的功能就是将MTA接收的信件依照信件的流向（送到哪里）将该信件放置到本机账户下的邮件文件中（收件箱），或者再经由MTA将信件送到下个MTA。如果信件的流向是到本机，这个邮件代理的功能就不只是将由MTA传来的邮件放置到每个用户的收件箱，它还可以具有邮件过滤（filtering）与其他相关功能<a href=\"http://wenku.baidu.com/link?url=iK74BiQS1clzFxTy4B4eBcG6u4gR9EMZ-CY58DwhrNqsJSYt6P9nk-aUzGPqXxgoTM5qAj51J4F-aPUhf3vaidDopNr6SrU3VgwPhWwHws_\" target=\"_blank\" rel=\"noopener\">^foot</a>。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>我使用的是CentOS6.2 sendmail 8.14.4</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span>安装sendmail和配置工具sendmail-cf</span><br><span class=\"line\">yum install -y sendmail</span><br><span class=\"line\">yum install -y sendmail-cf</span><br><span class=\"line\"><span class=\"meta\">#</span>SMTP认证服务</span><br><span class=\"line\">yum install -y saslauthd</span><br></pre></td></tr></table></figure>\n<h2 id=\"配置sendmail\"><a href=\"#配置sendmail\" class=\"headerlink\" title=\"配置sendmail\"></a>配置sendmail</h2><p>sendmail的配置文件主要是XXX.mc文件和XXX.cf文件，mc后缀文件可以看做是配置文件的人类阅读版，通过sendmail-cf工具将它生成为cf后缀的外星人版配置文件   </p>\n<blockquote>\n<p>vim /etc/mail/sendmail.mc</p>\n</blockquote>\n<p>具体操作请参考–<a href=\"http://www.centoscn.com/CentosServer/lighttpd/2013/0726/650.html\" target=\"_blank\" rel=\"noopener\">传送门</a></p>\n<h2 id=\"常见问题\"><a href=\"#常见问题\" class=\"headerlink\" title=\"常见问题\"></a>常见问题</h2><h3 id=\"1-发出的邮件被其他MTA识别为垃圾\"><a href=\"#1-发出的邮件被其他MTA识别为垃圾\" class=\"headerlink\" title=\"1.发出的邮件被其他MTA识别为垃圾\"></a>1.发出的邮件被其他MTA识别为垃圾</h3><p>设置域名指向（上节链接），添加spf记录 <a href=\"https://www.renfei.org/blog/introduction-to-spf.html\" target=\"_blank\" rel=\"noopener\">操作教程</a><br>同时注意控制发信频率</p>\n<h3 id=\"2-在哪查看sendmail日志\"><a href=\"#2-在哪查看sendmail日志\" class=\"headerlink\" title=\"2.在哪查看sendmail日志?\"></a>2.在哪查看sendmail日志?</h3><p><strong>日志位置</strong>： /var/log/maillog<br><strong>调整日志级别（详细程度）</strong>： 修改配置文件define(<code>confLOG_LEVEL&#39;,</code>16’)dnl 默认为9<br>或者调用命令时指定sendmail -O LogLevel=14<br><a href=\"http://www-01.ibm.com/support/knowledgecenter/ssw_aix_71/com.ibm.aix.networkcomm/sendmail_debugflags.htm?lang=zh\" target=\"_blank\" rel=\"noopener\">日志级别说明</a></p>\n<h3 id=\"3-sendmail日志都是什么意思\"><a href=\"#3-sendmail日志都是什么意思\" class=\"headerlink\" title=\"3.sendmail日志都是什么意思?\"></a>3.sendmail日志都是什么意思?</h3><p><strong>注意sendmail并不保证发出的邮件一定会被发到收件人接收</strong>，所以日志中的信息只是接收端MTA反馈的连接信息。<br>具体格式，慢慢读吧—–<a href=\"http://www.softpanorama.net/Mail/Sendmail/sendmail_logs_format.shtml\" target=\"_blank\" rel=\"noopener\">sendmail日志格式</a></p>\n<h3 id=\"4-sendmail性能参数\"><a href=\"#4-sendmail性能参数\" class=\"headerlink\" title=\"4.sendmail性能参数\"></a>4.sendmail性能参数</h3><p><a href=\"http://www.5dmail.net/html/2008-4-27/200842733006.htm\" target=\"_blank\" rel=\"noopener\">http://www.5dmail.net/html/2008-4-27/200842733006.htm</a>  </p>\n<h3 id=\"5-一些相关的网站，文章\"><a href=\"#5-一些相关的网站，文章\" class=\"headerlink\" title=\"5.一些相关的网站，文章\"></a>5.一些相关的网站，文章</h3><p><a href=\"http://www.5dmail.net/\" target=\"_blank\" rel=\"noopener\">http://www.5dmail.net/</a><br><strong>sendmail官网</strong><a href=\"https://www.sendmail.com/sm/open_source/\" target=\"_blank\" rel=\"noopener\">https://www.sendmail.com/sm/open_source/</a><br><a href=\"http://park.jobdeer.com/discussion/19/%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81%E9%82%A3%E7%82%B9%E4%BA%8B\" target=\"_blank\" rel=\"noopener\">http://park.jobdeer.com/discussion/19/%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81%E9%82%A3%E7%82%B9%E4%BA%8B</a><br><strong>看邮件头</strong><a href=\"http://www.qqexmail.net/tips/st_security_look_head.asp\" target=\"_blank\" rel=\"noopener\">http://www.qqexmail.net/tips/st_security_look_head.asp</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>Sendmail是一个linux邮件服务系统，可以使用它来搭建邮件服务器。</p>\n<p> 关于邮件的几个名词：</p>\n<blockquote>\n<p>MTA(Mail Transfer Agent)                             邮件传送代理，运行在邮件服务器的程序，负责接收发送邮件  </p>\n</blockquote>\n<blockquote>\n<p>MUA(Mail User Agent) 用户端代理，提供查看编辑提交邮件的功能（如foxmail）  </p>\n</blockquote>\n<blockquote>\n<p>MDA(Mail Delivery Agent)主要的功能就是将MTA接收的信件依照信件的流向（送到哪里）将该信件放置到本机账户下的邮件文件中（收件箱），或者再经由MTA将信件送到下个MTA。如果信件的流向是到本机，这个邮件代理的功能就不只是将由MTA传来的邮件放置到每个用户的收件箱，它还可以具有邮件过滤（filtering）与其他相关功能<a href=\"http://wenku.baidu.com/link?url=iK74BiQS1clzFxTy4B4eBcG6u4gR9EMZ-CY58DwhrNqsJSYt6P9nk-aUzGPqXxgoTM5qAj51J4F-aPUhf3vaidDopNr6SrU3VgwPhWwHws_\" target=\"_blank\" rel=\"noopener\">^foot</a>。</p>\n</blockquote>","more":"<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>我使用的是CentOS6.2 sendmail 8.14.4</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span>安装sendmail和配置工具sendmail-cf</span><br><span class=\"line\">yum install -y sendmail</span><br><span class=\"line\">yum install -y sendmail-cf</span><br><span class=\"line\"><span class=\"meta\">#</span>SMTP认证服务</span><br><span class=\"line\">yum install -y saslauthd</span><br></pre></td></tr></table></figure>\n<h2 id=\"配置sendmail\"><a href=\"#配置sendmail\" class=\"headerlink\" title=\"配置sendmail\"></a>配置sendmail</h2><p>sendmail的配置文件主要是XXX.mc文件和XXX.cf文件，mc后缀文件可以看做是配置文件的人类阅读版，通过sendmail-cf工具将它生成为cf后缀的外星人版配置文件   </p>\n<blockquote>\n<p>vim /etc/mail/sendmail.mc</p>\n</blockquote>\n<p>具体操作请参考–<a href=\"http://www.centoscn.com/CentosServer/lighttpd/2013/0726/650.html\" target=\"_blank\" rel=\"noopener\">传送门</a></p>\n<h2 id=\"常见问题\"><a href=\"#常见问题\" class=\"headerlink\" title=\"常见问题\"></a>常见问题</h2><h3 id=\"1-发出的邮件被其他MTA识别为垃圾\"><a href=\"#1-发出的邮件被其他MTA识别为垃圾\" class=\"headerlink\" title=\"1.发出的邮件被其他MTA识别为垃圾\"></a>1.发出的邮件被其他MTA识别为垃圾</h3><p>设置域名指向（上节链接），添加spf记录 <a href=\"https://www.renfei.org/blog/introduction-to-spf.html\" target=\"_blank\" rel=\"noopener\">操作教程</a><br>同时注意控制发信频率</p>\n<h3 id=\"2-在哪查看sendmail日志\"><a href=\"#2-在哪查看sendmail日志\" class=\"headerlink\" title=\"2.在哪查看sendmail日志?\"></a>2.在哪查看sendmail日志?</h3><p><strong>日志位置</strong>： /var/log/maillog<br><strong>调整日志级别（详细程度）</strong>： 修改配置文件define(<code>confLOG_LEVEL&#39;,</code>16’)dnl 默认为9<br>或者调用命令时指定sendmail -O LogLevel=14<br><a href=\"http://www-01.ibm.com/support/knowledgecenter/ssw_aix_71/com.ibm.aix.networkcomm/sendmail_debugflags.htm?lang=zh\" target=\"_blank\" rel=\"noopener\">日志级别说明</a></p>\n<h3 id=\"3-sendmail日志都是什么意思\"><a href=\"#3-sendmail日志都是什么意思\" class=\"headerlink\" title=\"3.sendmail日志都是什么意思?\"></a>3.sendmail日志都是什么意思?</h3><p><strong>注意sendmail并不保证发出的邮件一定会被发到收件人接收</strong>，所以日志中的信息只是接收端MTA反馈的连接信息。<br>具体格式，慢慢读吧—–<a href=\"http://www.softpanorama.net/Mail/Sendmail/sendmail_logs_format.shtml\" target=\"_blank\" rel=\"noopener\">sendmail日志格式</a></p>\n<h3 id=\"4-sendmail性能参数\"><a href=\"#4-sendmail性能参数\" class=\"headerlink\" title=\"4.sendmail性能参数\"></a>4.sendmail性能参数</h3><p><a href=\"http://www.5dmail.net/html/2008-4-27/200842733006.htm\" target=\"_blank\" rel=\"noopener\">http://www.5dmail.net/html/2008-4-27/200842733006.htm</a>  </p>\n<h3 id=\"5-一些相关的网站，文章\"><a href=\"#5-一些相关的网站，文章\" class=\"headerlink\" title=\"5.一些相关的网站，文章\"></a>5.一些相关的网站，文章</h3><p><a href=\"http://www.5dmail.net/\" target=\"_blank\" rel=\"noopener\">http://www.5dmail.net/</a><br><strong>sendmail官网</strong><a href=\"https://www.sendmail.com/sm/open_source/\" target=\"_blank\" rel=\"noopener\">https://www.sendmail.com/sm/open_source/</a><br><a href=\"http://park.jobdeer.com/discussion/19/%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81%E9%82%A3%E7%82%B9%E4%BA%8B\" target=\"_blank\" rel=\"noopener\">http://park.jobdeer.com/discussion/19/%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81%E9%82%A3%E7%82%B9%E4%BA%8B</a><br><strong>看邮件头</strong><a href=\"http://www.qqexmail.net/tips/st_security_look_head.asp\" target=\"_blank\" rel=\"noopener\">http://www.qqexmail.net/tips/st_security_look_head.asp</a></p>"},{"title":"Shell in Action（一）文本编辑-修改hosts","date":"2015-11-30T16:32:36.000Z","_content":"\n　把自己工作环境换成linux之后总会遇到各种无语的问题，比如我在web开发时会经常要切换测试环境或者本地环境的hosts，但是在用firefox的hosts插件时发现每次修改都会卡死，最后忍无可忍打算写一个切换hosts环境的脚本，有问题欢迎指正~\n\n\n\n##问题分析\n　我们都知道hosts文件就长这样，#是注释符、ip和域名用空格分开\n下面是测试文件testhosts，用DEV和TEST区分不同环境：\n\n```\n#DEV\n74.125.207.84 accounts.a.com\n74.125.207.83 accounts.b.com\n#TEST\n64.233.168.106 www.c.com\n64.233.168.107 www.d.com\n#END\n```\n**解决步骤**\n\n\n　　1.读取用户要切换的环境\n　　2.读取hosts文件，在指定的行前添加注释\n　　3.维护一个值 保存hosts所处环境 提示用户当前hosts环境\n<!--more-->\n###一、修改host文件\n\n##ed命令\n　ed （edit）命令 可以逐行的修改文本，[[a]](#1)分为‘寻址’‘操作命令’‘文件名’三个部分\n　ed [address]command textfile\n在命令行 输入 `info ed` 查看ed完整说明 \n**寻址**\n\n| 选项        | 说明           |\n|:------------- |:-------------| \n| number      | 第number行，从0开始 | \n|+number      | 从本行后第number行开始 | \n| -number      | 从本行前第number行开始 | \n|   ，    | 1,3表示从1到3行 一个逗号表示全文 | \n| /pattern/|下一个包含/partten/的行|\n| \\$partten\\$|上一个包含partten的行|\n\n**命令部分**\n\n| 选项        | 说明           |\n|:------------- |:-------------| \n| a  | add 追加文本 | \n|c | change| \n| d   | 删除当前指向的行 | \n| i   |insert | \n| wq   |和vim一样 write&quit | \n| s/pattern/replace/  |将符合pattern的替换为replace文本 | \ned操作文本时会将文件拷贝到缓冲区，在编辑后写入文件，在命令行输入ed后程序会等待用户输入，我们用echo和管道向ed发送指令\n\n**eg1:** 在testhosts第一行添加文本（句点表示退出add模式 相当于vim的ESC）\n```shell\n(echo '0a';echo '#hosts for test';echo '.';echo 'wq')|ed testhosts\n```\n**eg2:** 把.com替换为.com.cn\n```shell\n(echo ',s/com/com.cn/';echo '.';echo 'wq')|ed testhosts\n```\n##sed命令\n　sed（stream edit），接受输入流并进行编辑，再把结果写到输出流；\n由于sed是面向流的，在使用时我们要通过管道为sed指定输入流并将输出重定向到修改后的文件: \n`cat file|sed 'command' file > newfile`\n或者使用\"sed -i file\"可以直接编辑并保存到文件 :\n`sed -i 'command' file`\n\n**sed**也是对文件逐行编辑，寻址方式和ed基本相同，但是不支持对匹配的地址进行+n/-n操作。\n\n**eg**: 使用sed将testhosts文件DEV与TEST间的hosts注释掉\n`sed -i '/#DEV/,/#TEST/s/ /#' testhosts`\n\n###二、创建永久环境变量\n    \n　在使用环境变量要注意：\n\n - 当前命令行shell和使用sh或./执行脚本创建的子shell不在同一进程中\n - 普通自定义变量不会在子shell中生效，而全局环境变量可以在子shell中使用\n - 当前命令行定义的环境变量会在退出shell退出后失效\n![举个例子][1]\n\n\n在命令行输入:\n``` \nroot@song-pc:/# echo $$\n30687\nroot@song-pc:/# export global=\"parent global\"\n```\n\n创建脚本child.sh：\n\n```\n#!/bin/bash\necho $$;\necho $global;\nexport global=\"child global\";\n```\n执行脚本，打印global\n```\nroot@song-pc:/# ./child.sh \n30794\nparent global\nroot@song-pc:/# echo $global\nparent global\n```\n$变量表示当前shell的进程id，可见命令行执行的脚本属于另一个进程，而且子进程定义的环境变量在父进程中无效；\n如果要脚本中对环境变量的修改生效,可以使用source命令（.命令）执行脚本，这用方式会在当前进程中执行脚本，但是我们定义的环境变量仍在shell关闭后失效；\n\n**通过文件保存变量：**\nlinux系统下环境配置通常保存在这几个文件中[[b]](#2)：\n- /etc/profile:System wide environment and startup programs, for login setup（所有用户可用）\n- /etc/bashrc ：System wide functions and aliases（每一个运行bash shell的用户执行此文件.当bash shell被打开时,该文件被读取）\n- ~/.bashrc：包含专用于你的bash shell的bash信息,当登录时以及每次打开新的shell时,该文件被读取.（每个用户都有一个.bashrc文件，在用户目录下）\n \n为了保证记录hosts环境的变量不会失效，我选择修改 .bashrc的方式，在修改文件后执行 source命令保存，同时可以避免其他用户修改。\n\n###三.编写脚本\n**switch_hosts.sh:** \n```  \n#!/bin/bash\n#切换本机hosts环境\n#2015-10-15 sxf 2.0 \nfile=\"/etc/hosts\";\ntype=0;\nenv[1]=\"开发\" env[2]=\"测试\"  env[3]=\"线上\";\n\necho \"现在是 ${env[$HOSTS]} 环境\";\nread -p \"选择切换到：1.开发  2.测试  3.线上 : \" type;\n\nif [ $HOSTS -eq $type ];\nthen\n        echo \"环境不变\"\n        return\nfi\ncase $type in\n1)\n        echo \"正切换到开发环境。。\"\n                sed -i '/#DEV/,/#END/s/^ /# /' $file;\n                sed -i '/#DEV/,/#TEST/s/# / /' $file;\n        ;;\n2)\n        echo \"正切换到测试环境\"\n                sed -i '/#DEV/,/#END/s/^ /# /' $file;\n                sed -i '/#TEST/,/#END/s/# / /' $file;\n        ;;\n3)\n        echo \"正切换到线上\"\n                sed -i '/#DEV/,/#END/s/^ /# /' $file;\n        ;;\n*)\n        echo \"输入错误\"\n        return\n        ;;\nesac\nsed -i \"s/HOSTS=$HOSTS/HOSTS=$type/\" .bashrc;\nsource .bashrc;\ncat $file;\nservice nscd restart;\n```\n为了使source .bashrc命令生效，要使用source switch_hosts.sh的方式执行，service nscd restart命令用来刷新DNS缓存；\n\n\n[a] <span id = \"1\">http://biancheng.dnbcw.info/shell/242647.html</span>\n[b] <span id = \"2\">http://blog.csdn.net/chenchong08/article/details/7833242</span>\n\n  [1]: http://7xl4v5.com1.z0.glb.clouddn.com/example.jpg\n","source":"_posts/shell-in-action-1.md","raw":"title: Shell in Action（一）文本编辑-修改hosts\ndate: 2015-12-01 00:32:36\ncategories: \ntags: [shell,Linux]\n---\n\n　把自己工作环境换成linux之后总会遇到各种无语的问题，比如我在web开发时会经常要切换测试环境或者本地环境的hosts，但是在用firefox的hosts插件时发现每次修改都会卡死，最后忍无可忍打算写一个切换hosts环境的脚本，有问题欢迎指正~\n\n\n\n##问题分析\n　我们都知道hosts文件就长这样，#是注释符、ip和域名用空格分开\n下面是测试文件testhosts，用DEV和TEST区分不同环境：\n\n```\n#DEV\n74.125.207.84 accounts.a.com\n74.125.207.83 accounts.b.com\n#TEST\n64.233.168.106 www.c.com\n64.233.168.107 www.d.com\n#END\n```\n**解决步骤**\n\n\n　　1.读取用户要切换的环境\n　　2.读取hosts文件，在指定的行前添加注释\n　　3.维护一个值 保存hosts所处环境 提示用户当前hosts环境\n<!--more-->\n###一、修改host文件\n\n##ed命令\n　ed （edit）命令 可以逐行的修改文本，[[a]](#1)分为‘寻址’‘操作命令’‘文件名’三个部分\n　ed [address]command textfile\n在命令行 输入 `info ed` 查看ed完整说明 \n**寻址**\n\n| 选项        | 说明           |\n|:------------- |:-------------| \n| number      | 第number行，从0开始 | \n|+number      | 从本行后第number行开始 | \n| -number      | 从本行前第number行开始 | \n|   ，    | 1,3表示从1到3行 一个逗号表示全文 | \n| /pattern/|下一个包含/partten/的行|\n| \\$partten\\$|上一个包含partten的行|\n\n**命令部分**\n\n| 选项        | 说明           |\n|:------------- |:-------------| \n| a  | add 追加文本 | \n|c | change| \n| d   | 删除当前指向的行 | \n| i   |insert | \n| wq   |和vim一样 write&quit | \n| s/pattern/replace/  |将符合pattern的替换为replace文本 | \ned操作文本时会将文件拷贝到缓冲区，在编辑后写入文件，在命令行输入ed后程序会等待用户输入，我们用echo和管道向ed发送指令\n\n**eg1:** 在testhosts第一行添加文本（句点表示退出add模式 相当于vim的ESC）\n```shell\n(echo '0a';echo '#hosts for test';echo '.';echo 'wq')|ed testhosts\n```\n**eg2:** 把.com替换为.com.cn\n```shell\n(echo ',s/com/com.cn/';echo '.';echo 'wq')|ed testhosts\n```\n##sed命令\n　sed（stream edit），接受输入流并进行编辑，再把结果写到输出流；\n由于sed是面向流的，在使用时我们要通过管道为sed指定输入流并将输出重定向到修改后的文件: \n`cat file|sed 'command' file > newfile`\n或者使用\"sed -i file\"可以直接编辑并保存到文件 :\n`sed -i 'command' file`\n\n**sed**也是对文件逐行编辑，寻址方式和ed基本相同，但是不支持对匹配的地址进行+n/-n操作。\n\n**eg**: 使用sed将testhosts文件DEV与TEST间的hosts注释掉\n`sed -i '/#DEV/,/#TEST/s/ /#' testhosts`\n\n###二、创建永久环境变量\n    \n　在使用环境变量要注意：\n\n - 当前命令行shell和使用sh或./执行脚本创建的子shell不在同一进程中\n - 普通自定义变量不会在子shell中生效，而全局环境变量可以在子shell中使用\n - 当前命令行定义的环境变量会在退出shell退出后失效\n![举个例子][1]\n\n\n在命令行输入:\n``` \nroot@song-pc:/# echo $$\n30687\nroot@song-pc:/# export global=\"parent global\"\n```\n\n创建脚本child.sh：\n\n```\n#!/bin/bash\necho $$;\necho $global;\nexport global=\"child global\";\n```\n执行脚本，打印global\n```\nroot@song-pc:/# ./child.sh \n30794\nparent global\nroot@song-pc:/# echo $global\nparent global\n```\n$变量表示当前shell的进程id，可见命令行执行的脚本属于另一个进程，而且子进程定义的环境变量在父进程中无效；\n如果要脚本中对环境变量的修改生效,可以使用source命令（.命令）执行脚本，这用方式会在当前进程中执行脚本，但是我们定义的环境变量仍在shell关闭后失效；\n\n**通过文件保存变量：**\nlinux系统下环境配置通常保存在这几个文件中[[b]](#2)：\n- /etc/profile:System wide environment and startup programs, for login setup（所有用户可用）\n- /etc/bashrc ：System wide functions and aliases（每一个运行bash shell的用户执行此文件.当bash shell被打开时,该文件被读取）\n- ~/.bashrc：包含专用于你的bash shell的bash信息,当登录时以及每次打开新的shell时,该文件被读取.（每个用户都有一个.bashrc文件，在用户目录下）\n \n为了保证记录hosts环境的变量不会失效，我选择修改 .bashrc的方式，在修改文件后执行 source命令保存，同时可以避免其他用户修改。\n\n###三.编写脚本\n**switch_hosts.sh:** \n```  \n#!/bin/bash\n#切换本机hosts环境\n#2015-10-15 sxf 2.0 \nfile=\"/etc/hosts\";\ntype=0;\nenv[1]=\"开发\" env[2]=\"测试\"  env[3]=\"线上\";\n\necho \"现在是 ${env[$HOSTS]} 环境\";\nread -p \"选择切换到：1.开发  2.测试  3.线上 : \" type;\n\nif [ $HOSTS -eq $type ];\nthen\n        echo \"环境不变\"\n        return\nfi\ncase $type in\n1)\n        echo \"正切换到开发环境。。\"\n                sed -i '/#DEV/,/#END/s/^ /# /' $file;\n                sed -i '/#DEV/,/#TEST/s/# / /' $file;\n        ;;\n2)\n        echo \"正切换到测试环境\"\n                sed -i '/#DEV/,/#END/s/^ /# /' $file;\n                sed -i '/#TEST/,/#END/s/# / /' $file;\n        ;;\n3)\n        echo \"正切换到线上\"\n                sed -i '/#DEV/,/#END/s/^ /# /' $file;\n        ;;\n*)\n        echo \"输入错误\"\n        return\n        ;;\nesac\nsed -i \"s/HOSTS=$HOSTS/HOSTS=$type/\" .bashrc;\nsource .bashrc;\ncat $file;\nservice nscd restart;\n```\n为了使source .bashrc命令生效，要使用source switch_hosts.sh的方式执行，service nscd restart命令用来刷新DNS缓存；\n\n\n[a] <span id = \"1\">http://biancheng.dnbcw.info/shell/242647.html</span>\n[b] <span id = \"2\">http://blog.csdn.net/chenchong08/article/details/7833242</span>\n\n  [1]: http://7xl4v5.com1.z0.glb.clouddn.com/example.jpg\n","slug":"shell-in-action-1","published":1,"updated":"2018-11-21T16:24:15.250Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp57u3x1000f2xpbzutr2qr4","content":"<p>　把自己工作环境换成linux之后总会遇到各种无语的问题，比如我在web开发时会经常要切换测试环境或者本地环境的hosts，但是在用firefox的hosts插件时发现每次修改都会卡死，最后忍无可忍打算写一个切换hosts环境的脚本，有问题欢迎指正~</p>\n<p>##问题分析<br>　我们都知道hosts文件就长这样，#是注释符、ip和域名用空格分开<br>下面是测试文件testhosts，用DEV和TEST区分不同环境：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#DEV</span><br><span class=\"line\">74.125.207.84 accounts.a.com</span><br><span class=\"line\">74.125.207.83 accounts.b.com</span><br><span class=\"line\">#TEST</span><br><span class=\"line\">64.233.168.106 www.c.com</span><br><span class=\"line\">64.233.168.107 www.d.com</span><br><span class=\"line\">#END</span><br></pre></td></tr></table></figure>\n<p><strong>解决步骤</strong></p>\n<p>　　1.读取用户要切换的环境<br>　　2.读取hosts文件，在指定的行前添加注释<br>　　3.维护一个值 保存hosts所处环境 提示用户当前hosts环境<br><a id=\"more\"></a></p>\n<p>###一、修改host文件</p>\n<p>##ed命令<br>　ed （edit）命令 可以逐行的修改文本，<a href=\"#1\">[a]</a>分为‘寻址’‘操作命令’‘文件名’三个部分<br>　ed [address]command textfile<br>在命令行 输入 <code>info ed</code> 查看ed完整说明<br><strong>寻址</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">选项</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">number</td>\n<td style=\"text-align:left\">第number行，从0开始</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">+number</td>\n<td style=\"text-align:left\">从本行后第number行开始</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">-number</td>\n<td style=\"text-align:left\">从本行前第number行开始</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">，</td>\n<td style=\"text-align:left\">1,3表示从1到3行 一个逗号表示全文</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">/pattern/</td>\n<td style=\"text-align:left\">下一个包含/partten/的行</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">\\$partten\\$</td>\n<td style=\"text-align:left\">上一个包含partten的行</td>\n</tr>\n</tbody>\n</table>\n<p><strong>命令部分</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">选项</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">a</td>\n<td style=\"text-align:left\">add 追加文本</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">c</td>\n<td style=\"text-align:left\">change</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">d</td>\n<td style=\"text-align:left\">删除当前指向的行</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">i</td>\n<td style=\"text-align:left\">insert</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">wq</td>\n<td style=\"text-align:left\">和vim一样 write&amp;quit</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">s/pattern/replace/</td>\n<td style=\"text-align:left\">将符合pattern的替换为replace文本</td>\n</tr>\n</tbody>\n</table>\n<p>ed操作文本时会将文件拷贝到缓冲区，在编辑后写入文件，在命令行输入ed后程序会等待用户输入，我们用echo和管道向ed发送指令</p>\n<p><strong>eg1:</strong> 在testhosts第一行添加文本（句点表示退出add模式 相当于vim的ESC）<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(echo '0a';echo '#hosts for test';echo '.';echo 'wq')|ed testhosts</span><br></pre></td></tr></table></figure></p>\n<p><strong>eg2:</strong> 把.com替换为.com.cn<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(echo ',s/com/com.cn/';echo '.';echo 'wq')|ed testhosts</span><br></pre></td></tr></table></figure></p>\n<p>##sed命令<br>　sed（stream edit），接受输入流并进行编辑，再把结果写到输出流；<br>由于sed是面向流的，在使用时我们要通过管道为sed指定输入流并将输出重定向到修改后的文件:<br><code>cat file|sed &#39;command&#39; file &gt; newfile</code><br>或者使用”sed -i file”可以直接编辑并保存到文件 :<br><code>sed -i &#39;command&#39; file</code></p>\n<p><strong>sed</strong>也是对文件逐行编辑，寻址方式和ed基本相同，但是不支持对匹配的地址进行+n/-n操作。</p>\n<p><strong>eg</strong>: 使用sed将testhosts文件DEV与TEST间的hosts注释掉<br><code>sed -i &#39;/#DEV/,/#TEST/s/ /#&#39; testhosts</code></p>\n<p>###二、创建永久环境变量</p>\n<p>　在使用环境变量要注意：</p>\n<ul>\n<li>当前命令行shell和使用sh或./执行脚本创建的子shell不在同一进程中</li>\n<li>普通自定义变量不会在子shell中生效，而全局环境变量可以在子shell中使用</li>\n<li>当前命令行定义的环境变量会在退出shell退出后失效<br><img src=\"http://7xl4v5.com1.z0.glb.clouddn.com/example.jpg\" alt=\"举个例子\"></li>\n</ul>\n<p>在命令行输入:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@song-pc:/# echo $$</span><br><span class=\"line\">30687</span><br><span class=\"line\">root@song-pc:/# export global=&quot;parent global&quot;</span><br></pre></td></tr></table></figure></p>\n<p>创建脚本child.sh：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/bash</span><br><span class=\"line\">echo $$;</span><br><span class=\"line\">echo $global;</span><br><span class=\"line\">export global=&quot;child global&quot;;</span><br></pre></td></tr></table></figure>\n<p>执行脚本，打印global<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@song-pc:/# ./child.sh </span><br><span class=\"line\">30794</span><br><span class=\"line\">parent global</span><br><span class=\"line\">root@song-pc:/# echo $global</span><br><span class=\"line\">parent global</span><br></pre></td></tr></table></figure></p>\n<p>$变量表示当前shell的进程id，可见命令行执行的脚本属于另一个进程，而且子进程定义的环境变量在父进程中无效；<br>如果要脚本中对环境变量的修改生效,可以使用source命令（.命令）执行脚本，这用方式会在当前进程中执行脚本，但是我们定义的环境变量仍在shell关闭后失效；</p>\n<p><strong>通过文件保存变量：</strong><br>linux系统下环境配置通常保存在这几个文件中<a href=\"#2\">[b]</a>：</p>\n<ul>\n<li>/etc/profile:System wide environment and startup programs, for login setup（所有用户可用）</li>\n<li>/etc/bashrc ：System wide functions and aliases（每一个运行bash shell的用户执行此文件.当bash shell被打开时,该文件被读取）</li>\n<li>~/.bashrc：包含专用于你的bash shell的bash信息,当登录时以及每次打开新的shell时,该文件被读取.（每个用户都有一个.bashrc文件，在用户目录下）</li>\n</ul>\n<p>为了保证记录hosts环境的变量不会失效，我选择修改 .bashrc的方式，在修改文件后执行 source命令保存，同时可以避免其他用户修改。</p>\n<p>###三.编写脚本<br><strong>switch_hosts.sh:</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/bash</span><br><span class=\"line\">#切换本机hosts环境</span><br><span class=\"line\">#2015-10-15 sxf 2.0 </span><br><span class=\"line\">file=&quot;/etc/hosts&quot;;</span><br><span class=\"line\">type=0;</span><br><span class=\"line\">env[1]=&quot;开发&quot; env[2]=&quot;测试&quot;  env[3]=&quot;线上&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">echo &quot;现在是 $&#123;env[$HOSTS]&#125; 环境&quot;;</span><br><span class=\"line\">read -p &quot;选择切换到：1.开发  2.测试  3.线上 : &quot; type;</span><br><span class=\"line\"></span><br><span class=\"line\">if [ $HOSTS -eq $type ];</span><br><span class=\"line\">then</span><br><span class=\"line\">        echo &quot;环境不变&quot;</span><br><span class=\"line\">        return</span><br><span class=\"line\">fi</span><br><span class=\"line\">case $type in</span><br><span class=\"line\">1)</span><br><span class=\"line\">        echo &quot;正切换到开发环境。。&quot;</span><br><span class=\"line\">                sed -i &apos;/#DEV/,/#END/s/^ /# /&apos; $file;</span><br><span class=\"line\">                sed -i &apos;/#DEV/,/#TEST/s/# / /&apos; $file;</span><br><span class=\"line\">        ;;</span><br><span class=\"line\">2)</span><br><span class=\"line\">        echo &quot;正切换到测试环境&quot;</span><br><span class=\"line\">                sed -i &apos;/#DEV/,/#END/s/^ /# /&apos; $file;</span><br><span class=\"line\">                sed -i &apos;/#TEST/,/#END/s/# / /&apos; $file;</span><br><span class=\"line\">        ;;</span><br><span class=\"line\">3)</span><br><span class=\"line\">        echo &quot;正切换到线上&quot;</span><br><span class=\"line\">                sed -i &apos;/#DEV/,/#END/s/^ /# /&apos; $file;</span><br><span class=\"line\">        ;;</span><br><span class=\"line\">*)</span><br><span class=\"line\">        echo &quot;输入错误&quot;</span><br><span class=\"line\">        return</span><br><span class=\"line\">        ;;</span><br><span class=\"line\">esac</span><br><span class=\"line\">sed -i &quot;s/HOSTS=$HOSTS/HOSTS=$type/&quot; .bashrc;</span><br><span class=\"line\">source .bashrc;</span><br><span class=\"line\">cat $file;</span><br><span class=\"line\">service nscd restart;</span><br></pre></td></tr></table></figure></p>\n<p>为了使source .bashrc命令生效，要使用source switch_hosts.sh的方式执行，service nscd restart命令用来刷新DNS缓存；</p>\n<p>[a] <span id=\"1\"><a href=\"http://biancheng.dnbcw.info/shell/242647.html\" target=\"_blank\" rel=\"noopener\">http://biancheng.dnbcw.info/shell/242647.html</a></span><br>[b] <span id=\"2\"><a href=\"http://blog.csdn.net/chenchong08/article/details/7833242\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/chenchong08/article/details/7833242</a></span></p>\n","site":{"data":{}},"excerpt":"<p>　把自己工作环境换成linux之后总会遇到各种无语的问题，比如我在web开发时会经常要切换测试环境或者本地环境的hosts，但是在用firefox的hosts插件时发现每次修改都会卡死，最后忍无可忍打算写一个切换hosts环境的脚本，有问题欢迎指正~</p>\n<p>##问题分析<br>　我们都知道hosts文件就长这样，#是注释符、ip和域名用空格分开<br>下面是测试文件testhosts，用DEV和TEST区分不同环境：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#DEV</span><br><span class=\"line\">74.125.207.84 accounts.a.com</span><br><span class=\"line\">74.125.207.83 accounts.b.com</span><br><span class=\"line\">#TEST</span><br><span class=\"line\">64.233.168.106 www.c.com</span><br><span class=\"line\">64.233.168.107 www.d.com</span><br><span class=\"line\">#END</span><br></pre></td></tr></table></figure>\n<p><strong>解决步骤</strong></p>\n<p>　　1.读取用户要切换的环境<br>　　2.读取hosts文件，在指定的行前添加注释<br>　　3.维护一个值 保存hosts所处环境 提示用户当前hosts环境<br>","more":"</p>\n<p>###一、修改host文件</p>\n<p>##ed命令<br>　ed （edit）命令 可以逐行的修改文本，<a href=\"#1\">[a]</a>分为‘寻址’‘操作命令’‘文件名’三个部分<br>　ed [address]command textfile<br>在命令行 输入 <code>info ed</code> 查看ed完整说明<br><strong>寻址</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">选项</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">number</td>\n<td style=\"text-align:left\">第number行，从0开始</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">+number</td>\n<td style=\"text-align:left\">从本行后第number行开始</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">-number</td>\n<td style=\"text-align:left\">从本行前第number行开始</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">，</td>\n<td style=\"text-align:left\">1,3表示从1到3行 一个逗号表示全文</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">/pattern/</td>\n<td style=\"text-align:left\">下一个包含/partten/的行</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">\\$partten\\$</td>\n<td style=\"text-align:left\">上一个包含partten的行</td>\n</tr>\n</tbody>\n</table>\n<p><strong>命令部分</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">选项</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">a</td>\n<td style=\"text-align:left\">add 追加文本</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">c</td>\n<td style=\"text-align:left\">change</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">d</td>\n<td style=\"text-align:left\">删除当前指向的行</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">i</td>\n<td style=\"text-align:left\">insert</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">wq</td>\n<td style=\"text-align:left\">和vim一样 write&amp;quit</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">s/pattern/replace/</td>\n<td style=\"text-align:left\">将符合pattern的替换为replace文本</td>\n</tr>\n</tbody>\n</table>\n<p>ed操作文本时会将文件拷贝到缓冲区，在编辑后写入文件，在命令行输入ed后程序会等待用户输入，我们用echo和管道向ed发送指令</p>\n<p><strong>eg1:</strong> 在testhosts第一行添加文本（句点表示退出add模式 相当于vim的ESC）<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(echo '0a';echo '#hosts for test';echo '.';echo 'wq')|ed testhosts</span><br></pre></td></tr></table></figure></p>\n<p><strong>eg2:</strong> 把.com替换为.com.cn<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(echo ',s/com/com.cn/';echo '.';echo 'wq')|ed testhosts</span><br></pre></td></tr></table></figure></p>\n<p>##sed命令<br>　sed（stream edit），接受输入流并进行编辑，再把结果写到输出流；<br>由于sed是面向流的，在使用时我们要通过管道为sed指定输入流并将输出重定向到修改后的文件:<br><code>cat file|sed &#39;command&#39; file &gt; newfile</code><br>或者使用”sed -i file”可以直接编辑并保存到文件 :<br><code>sed -i &#39;command&#39; file</code></p>\n<p><strong>sed</strong>也是对文件逐行编辑，寻址方式和ed基本相同，但是不支持对匹配的地址进行+n/-n操作。</p>\n<p><strong>eg</strong>: 使用sed将testhosts文件DEV与TEST间的hosts注释掉<br><code>sed -i &#39;/#DEV/,/#TEST/s/ /#&#39; testhosts</code></p>\n<p>###二、创建永久环境变量</p>\n<p>　在使用环境变量要注意：</p>\n<ul>\n<li>当前命令行shell和使用sh或./执行脚本创建的子shell不在同一进程中</li>\n<li>普通自定义变量不会在子shell中生效，而全局环境变量可以在子shell中使用</li>\n<li>当前命令行定义的环境变量会在退出shell退出后失效<br><img src=\"http://7xl4v5.com1.z0.glb.clouddn.com/example.jpg\" alt=\"举个例子\"></li>\n</ul>\n<p>在命令行输入:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@song-pc:/# echo $$</span><br><span class=\"line\">30687</span><br><span class=\"line\">root@song-pc:/# export global=&quot;parent global&quot;</span><br></pre></td></tr></table></figure></p>\n<p>创建脚本child.sh：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/bash</span><br><span class=\"line\">echo $$;</span><br><span class=\"line\">echo $global;</span><br><span class=\"line\">export global=&quot;child global&quot;;</span><br></pre></td></tr></table></figure>\n<p>执行脚本，打印global<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@song-pc:/# ./child.sh </span><br><span class=\"line\">30794</span><br><span class=\"line\">parent global</span><br><span class=\"line\">root@song-pc:/# echo $global</span><br><span class=\"line\">parent global</span><br></pre></td></tr></table></figure></p>\n<p>$变量表示当前shell的进程id，可见命令行执行的脚本属于另一个进程，而且子进程定义的环境变量在父进程中无效；<br>如果要脚本中对环境变量的修改生效,可以使用source命令（.命令）执行脚本，这用方式会在当前进程中执行脚本，但是我们定义的环境变量仍在shell关闭后失效；</p>\n<p><strong>通过文件保存变量：</strong><br>linux系统下环境配置通常保存在这几个文件中<a href=\"#2\">[b]</a>：</p>\n<ul>\n<li>/etc/profile:System wide environment and startup programs, for login setup（所有用户可用）</li>\n<li>/etc/bashrc ：System wide functions and aliases（每一个运行bash shell的用户执行此文件.当bash shell被打开时,该文件被读取）</li>\n<li>~/.bashrc：包含专用于你的bash shell的bash信息,当登录时以及每次打开新的shell时,该文件被读取.（每个用户都有一个.bashrc文件，在用户目录下）</li>\n</ul>\n<p>为了保证记录hosts环境的变量不会失效，我选择修改 .bashrc的方式，在修改文件后执行 source命令保存，同时可以避免其他用户修改。</p>\n<p>###三.编写脚本<br><strong>switch_hosts.sh:</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/bash</span><br><span class=\"line\">#切换本机hosts环境</span><br><span class=\"line\">#2015-10-15 sxf 2.0 </span><br><span class=\"line\">file=&quot;/etc/hosts&quot;;</span><br><span class=\"line\">type=0;</span><br><span class=\"line\">env[1]=&quot;开发&quot; env[2]=&quot;测试&quot;  env[3]=&quot;线上&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">echo &quot;现在是 $&#123;env[$HOSTS]&#125; 环境&quot;;</span><br><span class=\"line\">read -p &quot;选择切换到：1.开发  2.测试  3.线上 : &quot; type;</span><br><span class=\"line\"></span><br><span class=\"line\">if [ $HOSTS -eq $type ];</span><br><span class=\"line\">then</span><br><span class=\"line\">        echo &quot;环境不变&quot;</span><br><span class=\"line\">        return</span><br><span class=\"line\">fi</span><br><span class=\"line\">case $type in</span><br><span class=\"line\">1)</span><br><span class=\"line\">        echo &quot;正切换到开发环境。。&quot;</span><br><span class=\"line\">                sed -i &apos;/#DEV/,/#END/s/^ /# /&apos; $file;</span><br><span class=\"line\">                sed -i &apos;/#DEV/,/#TEST/s/# / /&apos; $file;</span><br><span class=\"line\">        ;;</span><br><span class=\"line\">2)</span><br><span class=\"line\">        echo &quot;正切换到测试环境&quot;</span><br><span class=\"line\">                sed -i &apos;/#DEV/,/#END/s/^ /# /&apos; $file;</span><br><span class=\"line\">                sed -i &apos;/#TEST/,/#END/s/# / /&apos; $file;</span><br><span class=\"line\">        ;;</span><br><span class=\"line\">3)</span><br><span class=\"line\">        echo &quot;正切换到线上&quot;</span><br><span class=\"line\">                sed -i &apos;/#DEV/,/#END/s/^ /# /&apos; $file;</span><br><span class=\"line\">        ;;</span><br><span class=\"line\">*)</span><br><span class=\"line\">        echo &quot;输入错误&quot;</span><br><span class=\"line\">        return</span><br><span class=\"line\">        ;;</span><br><span class=\"line\">esac</span><br><span class=\"line\">sed -i &quot;s/HOSTS=$HOSTS/HOSTS=$type/&quot; .bashrc;</span><br><span class=\"line\">source .bashrc;</span><br><span class=\"line\">cat $file;</span><br><span class=\"line\">service nscd restart;</span><br></pre></td></tr></table></figure></p>\n<p>为了使source .bashrc命令生效，要使用source switch_hosts.sh的方式执行，service nscd restart命令用来刷新DNS缓存；</p>\n<p>[a] <span id=\"1\"><a href=\"http://biancheng.dnbcw.info/shell/242647.html\" target=\"_blank\" rel=\"noopener\">http://biancheng.dnbcw.info/shell/242647.html</a></span><br>[b] <span id=\"2\"><a href=\"http://blog.csdn.net/chenchong08/article/details/7833242\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/chenchong08/article/details/7833242</a></span></p>"},{"title":"zookeeper,kafka集群安装","date":"2017-07-25T16:09:46.000Z","_content":"\n系统版本 CentOS 6.6\njava version 1.7\nzookeeper版本 3.4.10\nkafka版本 0.11.0.1\n\n## 安装zookeeper\n\n### 1.下载\n```bash\nwget https://mirrors.tuna.tsinghua.edu.cn/apache/zookeeper/zookeeper-3.4.10/zookeeper-3.4.10.tar.gz\ntar -xvf zookeeper-3.4.10.tar.gz\n```\n<!--more-->\n\n### 2.修改配置文件\n\n\n把zoo_sample.cfg改成zoo.cfg\n```bash\ncd zookeeper-3.4.10/conf\nmv zoo_sample.cfg zoo.cfg\n```\n配置文件说明：\n\n>tickTime=2000\ndataDir=/var/lib/zookeeper\nclientPort=2181\ninitLimit=5\nsyncLimit=2\nserver.1=192.168.185.153:2888:3888\nserver.2=192.168.185.154:2888:3888\nserver.3=10.252.81.25:2888:3888\n\n\n- **tickTime**: 默认2000ms,zk的基本时间单位，用来做发送心跳消息的时间间隔，会话超时的最小时间是2×tickTime.\n- **dataDir**: 存储内存数据库快照的位置，也是更新数据库的事务日志的默认存储位置\n- **clientPort**: 给客户端连接的端口\n- **initLimit**: 用来配置 Zookeeper Leader接受Follower初始化连接时最长能忍受多少个心跳时间间隔数,默认5，即5×tickTime=10000ms\n- **syncLimit**:  Leader 与 Follower 之间发送消息，请求和应答时间长度，最长不能超过多少个 tickTime 的时间长度，总的时间长度就是 2*2000=4 秒\n- **server.x**: server.id=ip:port1:port2,使用伪集群模式时可以填写相同的ip（但是端口要不同）,port1是集群中实例通信的端口，port2是用来选举leader的端口\n\n在每个机器依次执行 1 2 两步，并使用相同的配置文件。\n\n### 3.创建myid文件\n在配置的dataDir目录创建一个名为myid的文件，文件内容是配置的server.id的id对应的数字，用来告知机器它代表的server。\n```\necho \"3\">/var/lib/zookeeper/myid\n```\n最后执行 `bash bin/zkServer.sh start` 逐个启动zk\n\n### 4.测试\n执行`bin/zkCli.sh -server 127.0.0.1:2181`启动客户端建立连接\n看到`Welcome to ZooKeeper!`表示连接成功。\n\n## 安装kafka\n在安装并启动zookeeper之后，就可以安装kafka了。\n### 1.下载\n```bash\nwget http://mirror.bit.edu.cn/apache/kafka/0.11.0.1/kafka_2.11-0.11.0.1.tgz\ntar -xzf kafka_2.11-0.11.0.1.tgz\n```\n### 2.修改配置文件\nconf/server.properties文件 \n默认配置简要介绍如下，[完整配置参考](https://kafka.apache.org/documentation/#configuration)：\n```bash\n# broker的唯一id\nbroker.id=0\n\n# 接收请求发送响应的线程数\nnumnetwork.threads=3\n\n# 处理请求的线程数（包含磁盘i/o）\nnum.io.threads=8\n# The send buffer (SO_SNDBUF) used by the socket server\nsocket.send.buffer.bytes=102400\n# The receive buffer (SO_RCVBUF) used by the socket server\nsocket.receive.buffer.bytes=102400\n# The maximum size of a request that the socket server will accept (protection against OOM)\nsocket.request.max.bytes=104857600\n\n#Log Basics #\n# 保存日志文件位置\nlog.dirs=/tmp/kafka-logs\n# 每个主题默认的分区数\nnum.partitions=1\n# 每个数据目录的数量，用于启动时的日志恢复和关机时的flush\n# 对于具有位于RAID阵列中的数据目录的安装，建议增加此值。\nnum.recovery.threads.per.data.dir=1\n\n#Internal Topic Settings  #############################\n# offset topic的备份数   \noffsets.topic.replication.factor=1\ntransaction.state.log.replication.factor=1\ntransaction.state.log.min.isr=1\n\n##Log Retention Policy 日志保留策略##################\n\n# 至少保留多久\nlog.retention.hours=168\n\n# 最大日志，超过会划分新日志\nlog.segment.bytes=1073741824\n\n# 检查日志是否删除的时间间隔\nlog.retention.check.interval.ms=300000\n\n## Zookeeper #####\n\n# Zookeeper 连接地址\nzookeeper.connect=localhost:2181\n# Zookeeper 连接 Timeout \nzookeeper.connection.timeout.ms=6000\n\n\n### Group Coordinator Settings####################\n#0.11.0.0引入的新配置，指定当新成员加入组时，GroupCoordinator将延迟初始消费者重新平衡（rebalance）的时间（毫秒），重新平衡将进一步延迟group.initial.rebalance.delay.ms的值，最大值为max.poll.interval.ms。\n#测试环境配置为0减少等待时间，生产环境建议配置3秒\ngroup.initial.rebalance.delay.ms=0\n```\n修改这几个字段\n>broker.id=yourid\nnum.parttions=3\noffsets.topic.replication.factor=3\ntransaction.state.log.replication.factor=3\ntransaction.state.log.min.isr=2\nzookeeper.connect=192.168.185.153:2181,192.168.185.154:2181,10.252.81.25:2181\n\n### 3.启动kafka\n```bash\nbin/kafka-server-start.sh config/server.properties &\n```\n### 4.测试\n\n创建话题\"hello-kafka\",复制2份，使用2个partition\n```bash\n>bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 2 --partitions 2 --topic hello-kafka\n```\n>Created topic \"hello-kafka\".\n\n查看kafka状态\n```bash\nbin/kafka-topics.sh --describe --zookeeper localhost:2181 --topic hello-kafka\n```\n输出\n>Topic:hello-kafka\tPartitionCount:2\tReplicationFactor:2\tConfigs:\n\tTopic: hello-kafka\tPartition: 0\tLeader: 3\tReplicas: 3,2\tIsr: 3,2\n\tTopic: hello-kafka\tPartition: 1\tLeader: 1\tReplicas: 1,3\tIsr: 1\n\n连接zookeeper服务端，看到kafka在zookeeper保存的话题等信息\n```bash\n[zk: 127.0.0.1:2181(CONNECTED) 2] ls /\n[isr_change_notification, zookeeper, admin, consumers, cluster, config, latest_producer_id_block, controller, brokers, controller_epoch]\n\n[zk: 127.0.0.1:2181(CONNECTED) 5] ls /brokers/topics\n[hello, my-test, my-replicated-topi, my-replicated-topic, hello-kafka]\n```\n\n\n参考\nzookeeper介绍 ：https://www.ibm.com/developerworks/cn/opensource/os-cn-zookeeper/\nzookeeper官方文档 ：http://zookeeper.apache.org/doc/r3.4.10/zookeeperStarted.html\nkafka官方文档 ：https://kafka.apache.org/documentation/\nkafka文档翻译 ：http://www.orchome.com/472\n\n\n\n","source":"_posts/zookeeper,kafka集群安装.md","raw":"# zookeeper,kafka集群安装\n\ntitle: zookeeper,kafka集群安装\ndate: 2017-07-26 00:09:46\ncategories: \ntags: [kafaka,zookeeper,集群]\n\n---\n\n系统版本 CentOS 6.6\njava version 1.7\nzookeeper版本 3.4.10\nkafka版本 0.11.0.1\n\n## 安装zookeeper\n\n### 1.下载\n```bash\nwget https://mirrors.tuna.tsinghua.edu.cn/apache/zookeeper/zookeeper-3.4.10/zookeeper-3.4.10.tar.gz\ntar -xvf zookeeper-3.4.10.tar.gz\n```\n<!--more-->\n\n### 2.修改配置文件\n\n\n把zoo_sample.cfg改成zoo.cfg\n```bash\ncd zookeeper-3.4.10/conf\nmv zoo_sample.cfg zoo.cfg\n```\n配置文件说明：\n\n>tickTime=2000\ndataDir=/var/lib/zookeeper\nclientPort=2181\ninitLimit=5\nsyncLimit=2\nserver.1=192.168.185.153:2888:3888\nserver.2=192.168.185.154:2888:3888\nserver.3=10.252.81.25:2888:3888\n\n\n- **tickTime**: 默认2000ms,zk的基本时间单位，用来做发送心跳消息的时间间隔，会话超时的最小时间是2×tickTime.\n- **dataDir**: 存储内存数据库快照的位置，也是更新数据库的事务日志的默认存储位置\n- **clientPort**: 给客户端连接的端口\n- **initLimit**: 用来配置 Zookeeper Leader接受Follower初始化连接时最长能忍受多少个心跳时间间隔数,默认5，即5×tickTime=10000ms\n- **syncLimit**:  Leader 与 Follower 之间发送消息，请求和应答时间长度，最长不能超过多少个 tickTime 的时间长度，总的时间长度就是 2*2000=4 秒\n- **server.x**: server.id=ip:port1:port2,使用伪集群模式时可以填写相同的ip（但是端口要不同）,port1是集群中实例通信的端口，port2是用来选举leader的端口\n\n在每个机器依次执行 1 2 两步，并使用相同的配置文件。\n\n### 3.创建myid文件\n在配置的dataDir目录创建一个名为myid的文件，文件内容是配置的server.id的id对应的数字，用来告知机器它代表的server。\n```\necho \"3\">/var/lib/zookeeper/myid\n```\n最后执行 `bash bin/zkServer.sh start` 逐个启动zk\n\n### 4.测试\n执行`bin/zkCli.sh -server 127.0.0.1:2181`启动客户端建立连接\n看到`Welcome to ZooKeeper!`表示连接成功。\n\n## 安装kafka\n在安装并启动zookeeper之后，就可以安装kafka了。\n### 1.下载\n```bash\nwget http://mirror.bit.edu.cn/apache/kafka/0.11.0.1/kafka_2.11-0.11.0.1.tgz\ntar -xzf kafka_2.11-0.11.0.1.tgz\n```\n### 2.修改配置文件\nconf/server.properties文件 \n默认配置简要介绍如下，[完整配置参考](https://kafka.apache.org/documentation/#configuration)：\n```bash\n# broker的唯一id\nbroker.id=0\n\n# 接收请求发送响应的线程数\nnumnetwork.threads=3\n\n# 处理请求的线程数（包含磁盘i/o）\nnum.io.threads=8\n# The send buffer (SO_SNDBUF) used by the socket server\nsocket.send.buffer.bytes=102400\n# The receive buffer (SO_RCVBUF) used by the socket server\nsocket.receive.buffer.bytes=102400\n# The maximum size of a request that the socket server will accept (protection against OOM)\nsocket.request.max.bytes=104857600\n\n#Log Basics #\n# 保存日志文件位置\nlog.dirs=/tmp/kafka-logs\n# 每个主题默认的分区数\nnum.partitions=1\n# 每个数据目录的数量，用于启动时的日志恢复和关机时的flush\n# 对于具有位于RAID阵列中的数据目录的安装，建议增加此值。\nnum.recovery.threads.per.data.dir=1\n\n#Internal Topic Settings  #############################\n# offset topic的备份数   \noffsets.topic.replication.factor=1\ntransaction.state.log.replication.factor=1\ntransaction.state.log.min.isr=1\n\n##Log Retention Policy 日志保留策略##################\n\n# 至少保留多久\nlog.retention.hours=168\n\n# 最大日志，超过会划分新日志\nlog.segment.bytes=1073741824\n\n# 检查日志是否删除的时间间隔\nlog.retention.check.interval.ms=300000\n\n## Zookeeper #####\n\n# Zookeeper 连接地址\nzookeeper.connect=localhost:2181\n# Zookeeper 连接 Timeout \nzookeeper.connection.timeout.ms=6000\n\n\n### Group Coordinator Settings####################\n#0.11.0.0引入的新配置，指定当新成员加入组时，GroupCoordinator将延迟初始消费者重新平衡（rebalance）的时间（毫秒），重新平衡将进一步延迟group.initial.rebalance.delay.ms的值，最大值为max.poll.interval.ms。\n#测试环境配置为0减少等待时间，生产环境建议配置3秒\ngroup.initial.rebalance.delay.ms=0\n```\n修改这几个字段\n>broker.id=yourid\nnum.parttions=3\noffsets.topic.replication.factor=3\ntransaction.state.log.replication.factor=3\ntransaction.state.log.min.isr=2\nzookeeper.connect=192.168.185.153:2181,192.168.185.154:2181,10.252.81.25:2181\n\n### 3.启动kafka\n```bash\nbin/kafka-server-start.sh config/server.properties &\n```\n### 4.测试\n\n创建话题\"hello-kafka\",复制2份，使用2个partition\n```bash\n>bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 2 --partitions 2 --topic hello-kafka\n```\n>Created topic \"hello-kafka\".\n\n查看kafka状态\n```bash\nbin/kafka-topics.sh --describe --zookeeper localhost:2181 --topic hello-kafka\n```\n输出\n>Topic:hello-kafka\tPartitionCount:2\tReplicationFactor:2\tConfigs:\n\tTopic: hello-kafka\tPartition: 0\tLeader: 3\tReplicas: 3,2\tIsr: 3,2\n\tTopic: hello-kafka\tPartition: 1\tLeader: 1\tReplicas: 1,3\tIsr: 1\n\n连接zookeeper服务端，看到kafka在zookeeper保存的话题等信息\n```bash\n[zk: 127.0.0.1:2181(CONNECTED) 2] ls /\n[isr_change_notification, zookeeper, admin, consumers, cluster, config, latest_producer_id_block, controller, brokers, controller_epoch]\n\n[zk: 127.0.0.1:2181(CONNECTED) 5] ls /brokers/topics\n[hello, my-test, my-replicated-topi, my-replicated-topic, hello-kafka]\n```\n\n\n参考\nzookeeper介绍 ：https://www.ibm.com/developerworks/cn/opensource/os-cn-zookeeper/\nzookeeper官方文档 ：http://zookeeper.apache.org/doc/r3.4.10/zookeeperStarted.html\nkafka官方文档 ：https://kafka.apache.org/documentation/\nkafka文档翻译 ：http://www.orchome.com/472\n\n\n\n","slug":"zookeeper,kafka集群安装","published":1,"updated":"2018-11-21T16:24:30.257Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp57u3x3000j2xpb3ratgcjk","content":"<p>系统版本 CentOS 6.6<br>java version 1.7<br>zookeeper版本 3.4.10<br>kafka版本 0.11.0.1</p>\n<h2 id=\"安装zookeeper\"><a href=\"#安装zookeeper\" class=\"headerlink\" title=\"安装zookeeper\"></a>安装zookeeper</h2><h3 id=\"1-下载\"><a href=\"#1-下载\" class=\"headerlink\" title=\"1.下载\"></a>1.下载</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://mirrors.tuna.tsinghua.edu.cn/apache/zookeeper/zookeeper-3.4.10/zookeeper-3.4.10.tar.gz</span><br><span class=\"line\">tar -xvf zookeeper-3.4.10.tar.gz</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h3 id=\"2-修改配置文件\"><a href=\"#2-修改配置文件\" class=\"headerlink\" title=\"2.修改配置文件\"></a>2.修改配置文件</h3><p>把zoo_sample.cfg改成zoo.cfg<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> zookeeper-3.4.10/conf</span><br><span class=\"line\">mv zoo_sample.cfg zoo.cfg</span><br></pre></td></tr></table></figure></p>\n<p>配置文件说明：</p>\n<blockquote>\n<p>tickTime=2000<br>dataDir=/var/lib/zookeeper<br>clientPort=2181<br>initLimit=5<br>syncLimit=2<br>server.1=192.168.185.153:2888:3888<br>server.2=192.168.185.154:2888:3888<br>server.3=10.252.81.25:2888:3888</p>\n</blockquote>\n<ul>\n<li><strong>tickTime</strong>: 默认2000ms,zk的基本时间单位，用来做发送心跳消息的时间间隔，会话超时的最小时间是2×tickTime.</li>\n<li><strong>dataDir</strong>: 存储内存数据库快照的位置，也是更新数据库的事务日志的默认存储位置</li>\n<li><strong>clientPort</strong>: 给客户端连接的端口</li>\n<li><strong>initLimit</strong>: 用来配置 Zookeeper Leader接受Follower初始化连接时最长能忍受多少个心跳时间间隔数,默认5，即5×tickTime=10000ms</li>\n<li><strong>syncLimit</strong>:  Leader 与 Follower 之间发送消息，请求和应答时间长度，最长不能超过多少个 tickTime 的时间长度，总的时间长度就是 2*2000=4 秒</li>\n<li><strong>server.x</strong>: server.id=ip:port1:port2,使用伪集群模式时可以填写相同的ip（但是端口要不同）,port1是集群中实例通信的端口，port2是用来选举leader的端口</li>\n</ul>\n<p>在每个机器依次执行 1 2 两步，并使用相同的配置文件。</p>\n<h3 id=\"3-创建myid文件\"><a href=\"#3-创建myid文件\" class=\"headerlink\" title=\"3.创建myid文件\"></a>3.创建myid文件</h3><p>在配置的dataDir目录创建一个名为myid的文件，文件内容是配置的server.id的id对应的数字，用来告知机器它代表的server。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo &quot;3&quot;&gt;/var/lib/zookeeper/myid</span><br></pre></td></tr></table></figure></p>\n<p>最后执行 <code>bash bin/zkServer.sh start</code> 逐个启动zk</p>\n<h3 id=\"4-测试\"><a href=\"#4-测试\" class=\"headerlink\" title=\"4.测试\"></a>4.测试</h3><p>执行<code>bin/zkCli.sh -server 127.0.0.1:2181</code>启动客户端建立连接<br>看到<code>Welcome to ZooKeeper!</code>表示连接成功。</p>\n<h2 id=\"安装kafka\"><a href=\"#安装kafka\" class=\"headerlink\" title=\"安装kafka\"></a>安装kafka</h2><p>在安装并启动zookeeper之后，就可以安装kafka了。</p>\n<h3 id=\"1-下载-1\"><a href=\"#1-下载-1\" class=\"headerlink\" title=\"1.下载\"></a>1.下载</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget http://mirror.bit.edu.cn/apache/kafka/0.11.0.1/kafka_2.11-0.11.0.1.tgz</span><br><span class=\"line\">tar -xzf kafka_2.11-0.11.0.1.tgz</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-修改配置文件-1\"><a href=\"#2-修改配置文件-1\" class=\"headerlink\" title=\"2.修改配置文件\"></a>2.修改配置文件</h3><p>conf/server.properties文件<br>默认配置简要介绍如下，<a href=\"https://kafka.apache.org/documentation/#configuration\" target=\"_blank\" rel=\"noopener\">完整配置参考</a>：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># broker的唯一id</span></span><br><span class=\"line\">broker.id=0</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 接收请求发送响应的线程数</span></span><br><span class=\"line\">numnetwork.threads=3</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 处理请求的线程数（包含磁盘i/o）</span></span><br><span class=\"line\">num.io.threads=8</span><br><span class=\"line\"><span class=\"comment\"># The send buffer (SO_SNDBUF) used by the socket server</span></span><br><span class=\"line\">socket.send.buffer.bytes=102400</span><br><span class=\"line\"><span class=\"comment\"># The receive buffer (SO_RCVBUF) used by the socket server</span></span><br><span class=\"line\">socket.receive.buffer.bytes=102400</span><br><span class=\"line\"><span class=\"comment\"># The maximum size of a request that the socket server will accept (protection against OOM)</span></span><br><span class=\"line\">socket.request.max.bytes=104857600</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#Log Basics #</span></span><br><span class=\"line\"><span class=\"comment\"># 保存日志文件位置</span></span><br><span class=\"line\">log.dirs=/tmp/kafka-logs</span><br><span class=\"line\"><span class=\"comment\"># 每个主题默认的分区数</span></span><br><span class=\"line\">num.partitions=1</span><br><span class=\"line\"><span class=\"comment\"># 每个数据目录的数量，用于启动时的日志恢复和关机时的flush</span></span><br><span class=\"line\"><span class=\"comment\"># 对于具有位于RAID阵列中的数据目录的安装，建议增加此值。</span></span><br><span class=\"line\">num.recovery.threads.per.data.dir=1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#Internal Topic Settings  #############################</span></span><br><span class=\"line\"><span class=\"comment\"># offset topic的备份数   </span></span><br><span class=\"line\">offsets.topic.replication.factor=1</span><br><span class=\"line\">transaction.state.log.replication.factor=1</span><br><span class=\"line\">transaction.state.log.min.isr=1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">##Log Retention Policy 日志保留策略##################</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 至少保留多久</span></span><br><span class=\"line\">log.retention.hours=168</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 最大日志，超过会划分新日志</span></span><br><span class=\"line\">log.segment.bytes=1073741824</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 检查日志是否删除的时间间隔</span></span><br><span class=\"line\">log.retention.check.interval.ms=300000</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## Zookeeper #####</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Zookeeper 连接地址</span></span><br><span class=\"line\">zookeeper.connect=localhost:2181</span><br><span class=\"line\"><span class=\"comment\"># Zookeeper 连接 Timeout </span></span><br><span class=\"line\">zookeeper.connection.timeout.ms=6000</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">### Group Coordinator Settings####################</span></span><br><span class=\"line\"><span class=\"comment\">#0.11.0.0引入的新配置，指定当新成员加入组时，GroupCoordinator将延迟初始消费者重新平衡（rebalance）的时间（毫秒），重新平衡将进一步延迟group.initial.rebalance.delay.ms的值，最大值为max.poll.interval.ms。</span></span><br><span class=\"line\"><span class=\"comment\">#测试环境配置为0减少等待时间，生产环境建议配置3秒</span></span><br><span class=\"line\">group.initial.rebalance.delay.ms=0</span><br></pre></td></tr></table></figure></p>\n<p>修改这几个字段</p>\n<blockquote>\n<p>broker.id=yourid<br>num.parttions=3<br>offsets.topic.replication.factor=3<br>transaction.state.log.replication.factor=3<br>transaction.state.log.min.isr=2<br>zookeeper.connect=192.168.185.153:2181,192.168.185.154:2181,10.252.81.25:2181</p>\n</blockquote>\n<h3 id=\"3-启动kafka\"><a href=\"#3-启动kafka\" class=\"headerlink\" title=\"3.启动kafka\"></a>3.启动kafka</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bin/kafka-server-start.sh config/server.properties &amp;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-测试-1\"><a href=\"#4-测试-1\" class=\"headerlink\" title=\"4.测试\"></a>4.测试</h3><p>创建话题”hello-kafka”,复制2份，使用2个partition<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 2 --partitions 2 --topic hello-kafka</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>Created topic “hello-kafka”.</p>\n</blockquote>\n<p>查看kafka状态<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bin/kafka-topics.sh --describe --zookeeper localhost:2181 --topic hello-kafka</span><br></pre></td></tr></table></figure></p>\n<p>输出</p>\n<blockquote>\n<p>Topic:hello-kafka    PartitionCount:2    ReplicationFactor:2    Configs:<br>    Topic: hello-kafka    Partition: 0    Leader: 3    Replicas: 3,2    Isr: 3,2<br>    Topic: hello-kafka    Partition: 1    Leader: 1    Replicas: 1,3    Isr: 1</p>\n</blockquote>\n<p>连接zookeeper服务端，看到kafka在zookeeper保存的话题等信息<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[zk: 127.0.0.1:2181(CONNECTED) 2] ls /</span><br><span class=\"line\">[isr_change_notification, zookeeper, admin, consumers, cluster, config, latest_producer_id_block, controller, brokers, controller_epoch]</span><br><span class=\"line\"></span><br><span class=\"line\">[zk: 127.0.0.1:2181(CONNECTED) 5] ls /brokers/topics</span><br><span class=\"line\">[hello, my-test, my-replicated-topi, my-replicated-topic, hello-kafka]</span><br></pre></td></tr></table></figure></p>\n<p>参考<br>zookeeper介绍 ：<a href=\"https://www.ibm.com/developerworks/cn/opensource/os-cn-zookeeper/\" target=\"_blank\" rel=\"noopener\">https://www.ibm.com/developerworks/cn/opensource/os-cn-zookeeper/</a><br>zookeeper官方文档 ：<a href=\"http://zookeeper.apache.org/doc/r3.4.10/zookeeperStarted.html\" target=\"_blank\" rel=\"noopener\">http://zookeeper.apache.org/doc/r3.4.10/zookeeperStarted.html</a><br>kafka官方文档 ：<a href=\"https://kafka.apache.org/documentation/\" target=\"_blank\" rel=\"noopener\">https://kafka.apache.org/documentation/</a><br>kafka文档翻译 ：<a href=\"http://www.orchome.com/472\" target=\"_blank\" rel=\"noopener\">http://www.orchome.com/472</a></p>\n","site":{"data":{}},"excerpt":"<p>系统版本 CentOS 6.6<br>java version 1.7<br>zookeeper版本 3.4.10<br>kafka版本 0.11.0.1</p>\n<h2 id=\"安装zookeeper\"><a href=\"#安装zookeeper\" class=\"headerlink\" title=\"安装zookeeper\"></a>安装zookeeper</h2><h3 id=\"1-下载\"><a href=\"#1-下载\" class=\"headerlink\" title=\"1.下载\"></a>1.下载</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://mirrors.tuna.tsinghua.edu.cn/apache/zookeeper/zookeeper-3.4.10/zookeeper-3.4.10.tar.gz</span><br><span class=\"line\">tar -xvf zookeeper-3.4.10.tar.gz</span><br></pre></td></tr></table></figure>","more":"<h3 id=\"2-修改配置文件\"><a href=\"#2-修改配置文件\" class=\"headerlink\" title=\"2.修改配置文件\"></a>2.修改配置文件</h3><p>把zoo_sample.cfg改成zoo.cfg<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> zookeeper-3.4.10/conf</span><br><span class=\"line\">mv zoo_sample.cfg zoo.cfg</span><br></pre></td></tr></table></figure></p>\n<p>配置文件说明：</p>\n<blockquote>\n<p>tickTime=2000<br>dataDir=/var/lib/zookeeper<br>clientPort=2181<br>initLimit=5<br>syncLimit=2<br>server.1=192.168.185.153:2888:3888<br>server.2=192.168.185.154:2888:3888<br>server.3=10.252.81.25:2888:3888</p>\n</blockquote>\n<ul>\n<li><strong>tickTime</strong>: 默认2000ms,zk的基本时间单位，用来做发送心跳消息的时间间隔，会话超时的最小时间是2×tickTime.</li>\n<li><strong>dataDir</strong>: 存储内存数据库快照的位置，也是更新数据库的事务日志的默认存储位置</li>\n<li><strong>clientPort</strong>: 给客户端连接的端口</li>\n<li><strong>initLimit</strong>: 用来配置 Zookeeper Leader接受Follower初始化连接时最长能忍受多少个心跳时间间隔数,默认5，即5×tickTime=10000ms</li>\n<li><strong>syncLimit</strong>:  Leader 与 Follower 之间发送消息，请求和应答时间长度，最长不能超过多少个 tickTime 的时间长度，总的时间长度就是 2*2000=4 秒</li>\n<li><strong>server.x</strong>: server.id=ip:port1:port2,使用伪集群模式时可以填写相同的ip（但是端口要不同）,port1是集群中实例通信的端口，port2是用来选举leader的端口</li>\n</ul>\n<p>在每个机器依次执行 1 2 两步，并使用相同的配置文件。</p>\n<h3 id=\"3-创建myid文件\"><a href=\"#3-创建myid文件\" class=\"headerlink\" title=\"3.创建myid文件\"></a>3.创建myid文件</h3><p>在配置的dataDir目录创建一个名为myid的文件，文件内容是配置的server.id的id对应的数字，用来告知机器它代表的server。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo &quot;3&quot;&gt;/var/lib/zookeeper/myid</span><br></pre></td></tr></table></figure></p>\n<p>最后执行 <code>bash bin/zkServer.sh start</code> 逐个启动zk</p>\n<h3 id=\"4-测试\"><a href=\"#4-测试\" class=\"headerlink\" title=\"4.测试\"></a>4.测试</h3><p>执行<code>bin/zkCli.sh -server 127.0.0.1:2181</code>启动客户端建立连接<br>看到<code>Welcome to ZooKeeper!</code>表示连接成功。</p>\n<h2 id=\"安装kafka\"><a href=\"#安装kafka\" class=\"headerlink\" title=\"安装kafka\"></a>安装kafka</h2><p>在安装并启动zookeeper之后，就可以安装kafka了。</p>\n<h3 id=\"1-下载-1\"><a href=\"#1-下载-1\" class=\"headerlink\" title=\"1.下载\"></a>1.下载</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget http://mirror.bit.edu.cn/apache/kafka/0.11.0.1/kafka_2.11-0.11.0.1.tgz</span><br><span class=\"line\">tar -xzf kafka_2.11-0.11.0.1.tgz</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-修改配置文件-1\"><a href=\"#2-修改配置文件-1\" class=\"headerlink\" title=\"2.修改配置文件\"></a>2.修改配置文件</h3><p>conf/server.properties文件<br>默认配置简要介绍如下，<a href=\"https://kafka.apache.org/documentation/#configuration\" target=\"_blank\" rel=\"noopener\">完整配置参考</a>：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># broker的唯一id</span></span><br><span class=\"line\">broker.id=0</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 接收请求发送响应的线程数</span></span><br><span class=\"line\">numnetwork.threads=3</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 处理请求的线程数（包含磁盘i/o）</span></span><br><span class=\"line\">num.io.threads=8</span><br><span class=\"line\"><span class=\"comment\"># The send buffer (SO_SNDBUF) used by the socket server</span></span><br><span class=\"line\">socket.send.buffer.bytes=102400</span><br><span class=\"line\"><span class=\"comment\"># The receive buffer (SO_RCVBUF) used by the socket server</span></span><br><span class=\"line\">socket.receive.buffer.bytes=102400</span><br><span class=\"line\"><span class=\"comment\"># The maximum size of a request that the socket server will accept (protection against OOM)</span></span><br><span class=\"line\">socket.request.max.bytes=104857600</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#Log Basics #</span></span><br><span class=\"line\"><span class=\"comment\"># 保存日志文件位置</span></span><br><span class=\"line\">log.dirs=/tmp/kafka-logs</span><br><span class=\"line\"><span class=\"comment\"># 每个主题默认的分区数</span></span><br><span class=\"line\">num.partitions=1</span><br><span class=\"line\"><span class=\"comment\"># 每个数据目录的数量，用于启动时的日志恢复和关机时的flush</span></span><br><span class=\"line\"><span class=\"comment\"># 对于具有位于RAID阵列中的数据目录的安装，建议增加此值。</span></span><br><span class=\"line\">num.recovery.threads.per.data.dir=1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#Internal Topic Settings  #############################</span></span><br><span class=\"line\"><span class=\"comment\"># offset topic的备份数   </span></span><br><span class=\"line\">offsets.topic.replication.factor=1</span><br><span class=\"line\">transaction.state.log.replication.factor=1</span><br><span class=\"line\">transaction.state.log.min.isr=1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">##Log Retention Policy 日志保留策略##################</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 至少保留多久</span></span><br><span class=\"line\">log.retention.hours=168</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 最大日志，超过会划分新日志</span></span><br><span class=\"line\">log.segment.bytes=1073741824</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 检查日志是否删除的时间间隔</span></span><br><span class=\"line\">log.retention.check.interval.ms=300000</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## Zookeeper #####</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Zookeeper 连接地址</span></span><br><span class=\"line\">zookeeper.connect=localhost:2181</span><br><span class=\"line\"><span class=\"comment\"># Zookeeper 连接 Timeout </span></span><br><span class=\"line\">zookeeper.connection.timeout.ms=6000</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">### Group Coordinator Settings####################</span></span><br><span class=\"line\"><span class=\"comment\">#0.11.0.0引入的新配置，指定当新成员加入组时，GroupCoordinator将延迟初始消费者重新平衡（rebalance）的时间（毫秒），重新平衡将进一步延迟group.initial.rebalance.delay.ms的值，最大值为max.poll.interval.ms。</span></span><br><span class=\"line\"><span class=\"comment\">#测试环境配置为0减少等待时间，生产环境建议配置3秒</span></span><br><span class=\"line\">group.initial.rebalance.delay.ms=0</span><br></pre></td></tr></table></figure></p>\n<p>修改这几个字段</p>\n<blockquote>\n<p>broker.id=yourid<br>num.parttions=3<br>offsets.topic.replication.factor=3<br>transaction.state.log.replication.factor=3<br>transaction.state.log.min.isr=2<br>zookeeper.connect=192.168.185.153:2181,192.168.185.154:2181,10.252.81.25:2181</p>\n</blockquote>\n<h3 id=\"3-启动kafka\"><a href=\"#3-启动kafka\" class=\"headerlink\" title=\"3.启动kafka\"></a>3.启动kafka</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bin/kafka-server-start.sh config/server.properties &amp;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-测试-1\"><a href=\"#4-测试-1\" class=\"headerlink\" title=\"4.测试\"></a>4.测试</h3><p>创建话题”hello-kafka”,复制2份，使用2个partition<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 2 --partitions 2 --topic hello-kafka</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>Created topic “hello-kafka”.</p>\n</blockquote>\n<p>查看kafka状态<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bin/kafka-topics.sh --describe --zookeeper localhost:2181 --topic hello-kafka</span><br></pre></td></tr></table></figure></p>\n<p>输出</p>\n<blockquote>\n<p>Topic:hello-kafka    PartitionCount:2    ReplicationFactor:2    Configs:<br>    Topic: hello-kafka    Partition: 0    Leader: 3    Replicas: 3,2    Isr: 3,2<br>    Topic: hello-kafka    Partition: 1    Leader: 1    Replicas: 1,3    Isr: 1</p>\n</blockquote>\n<p>连接zookeeper服务端，看到kafka在zookeeper保存的话题等信息<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[zk: 127.0.0.1:2181(CONNECTED) 2] ls /</span><br><span class=\"line\">[isr_change_notification, zookeeper, admin, consumers, cluster, config, latest_producer_id_block, controller, brokers, controller_epoch]</span><br><span class=\"line\"></span><br><span class=\"line\">[zk: 127.0.0.1:2181(CONNECTED) 5] ls /brokers/topics</span><br><span class=\"line\">[hello, my-test, my-replicated-topi, my-replicated-topic, hello-kafka]</span><br></pre></td></tr></table></figure></p>\n<p>参考<br>zookeeper介绍 ：<a href=\"https://www.ibm.com/developerworks/cn/opensource/os-cn-zookeeper/\" target=\"_blank\" rel=\"noopener\">https://www.ibm.com/developerworks/cn/opensource/os-cn-zookeeper/</a><br>zookeeper官方文档 ：<a href=\"http://zookeeper.apache.org/doc/r3.4.10/zookeeperStarted.html\" target=\"_blank\" rel=\"noopener\">http://zookeeper.apache.org/doc/r3.4.10/zookeeperStarted.html</a><br>kafka官方文档 ：<a href=\"https://kafka.apache.org/documentation/\" target=\"_blank\" rel=\"noopener\">https://kafka.apache.org/documentation/</a><br>kafka文档翻译 ：<a href=\"http://www.orchome.com/472\" target=\"_blank\" rel=\"noopener\">http://www.orchome.com/472</a></p>"},{"title":"图解redis主从","date":"2017-10-22T13:15:46.000Z","_content":"\n### 一、建立连接\n\n当slave收到客户端发来的slave of 命令之后，首先会在redisServer结构体中保存master的host和ip地址，然后建立一个到master的socket连接。\n连接成功后，slave会发送PING命令来测试连接是否可用，成功获得响应后，执行REPLCONF命令把自己的listen_port发送到master,后者会在redisClient中包存slave的监听端口。\n<!--more-->\n\n![连接][1]\n### 二、初次同步数据\n连接成功后，slave会发送**PSYNC**命令请求同步数据，由于第一次同步，所以会执行一次**完整重同步**的过程，master收到请求后执行**BGSAVE**命令创建RDB文件[^code]，然后把数据发送到slave \n![full同步][2]\n### 三、命令传播（propagate）\n同步完成后，master收到的写命令，会由master发送到slave，保证数据同步。命令在master执行成功后会立刻向客户端发送结果，因此命令传播是**异步执行**的，因此redis只能保证主从数据的**最终一致性**。\n在命令传播的过程中，master不只把数据发送给slave,还会保存在AOF文件，和复制积压缓冲区(backlog buffer)内。[a]\n![此处输入图片的描述][3]\n### 四、增量重同步\n刚才提到的backlog buffer是一个FIFO的定长队列(环形队列实现)，默认1MB大小，可以通过`repl_backlog_size`配置。它的作用是保存最近的更新命令并记录offsetr。当slave断线重连时，如果能根据offset在buffer中找到丢失的数据,那么只需增量的复制丢失数据即可，不需要进行完成的重同步。\n![此处输入图片的描述][4]\n\n### 五、心跳消息\nslave定时向master发送REPLCONF命令，通知master当前的自己offset，当master发现slave复制落后时，会主动发送丢失了命令。\n心跳消息让master了解slave的连接状态，如果当前slave数量小于min-slave，master会拒绝写命令。info命令输出的lag值反应了slave的上次通信时间。（master也会主动向slave发送PING命令）\n```\n# Replication\nrole:master\nconnected_slaves:2\nslave0:ip=127.0.0.1,port=6381,state=online,offset=4518,lag=1\nslave1:ip=127.0.0.1,port=6380,state=online,offset=4518,lag=1\n```\n![heart][5]\n\n### 六、 补充\n这是一次重新连接的日志，从服务器发送同步请求，master回复rdb文件。日志中**Partial resynchronization not possible (no cached master)**表示尝试增量同步失败，在我使用redis 2.8.19版本时似乎无法模拟出增量同步的情况，每次断线重连都是完整同步，按照作者说明关闭了slave的aof也不行(同步时不能进行write aof)，[github上这个问题对应的issue][6]\n**从服务器**\n```[15846] 11 Jan 20:25:34.722 * DB loaded from disk: 2.233 seconds\n[15846] 11 Jan 20:25:34.722 * The server is now ready to accept connections on port 6380\n[15846] 11 Jan 20:25:35.490 * Connecting to MASTER 127.0.0.1:6379\n[15846] 11 Jan 20:25:35.491 * MASTER <-> SLAVE sync started\n[15846] 11 Jan 20:25:35.491 * Non blocking connect for SYNC fired the event.\n[15846] 11 Jan 20:25:35.491 * Master replied to PING, replication can continue...\n[15846] 11 Jan 20:25:35.491 * Partial resynchronization not possible (no cached master)\n[15846] 11 Jan 20:25:35.495 * Full resync from master: 13cb06d81ed35702e1cf20dba3aa1159b9a068bd:15931\n[15846] 11 Jan 20:25:41.428 * MASTER <-> SLAVE sync: receiving 225990523 bytes from master\n[15846] 11 Jan 20:25:44.383 * MASTER <-> SLAVE sync: Flushing old data\n[15846] 11 Jan 20:25:44.560 * MASTER <-> SLAVE sync: Loading DB in memory\n[15846] 11 Jan 20:25:46.948 * MASTER <-> SLAVE sync: Finished with success```\n**主服务器：**\n```[14562] 11 Jan 20:23:17.478 # Connection with slave 127.0.0.1:6380 lost.\n[14562] 11 Jan 20:23:29.644 # Connection with slave 127.0.0.1:6381 lost.\n[14562] 11 Jan 20:25:35.492 * Slave 127.0.0.1:6380 asks for synchronization\n[14562] 11 Jan 20:25:35.492 * Full resync requested by slave 127.0.0.1:6380\n[14562] 11 Jan 20:25:35.492 * Starting BGSAVE for SYNC with target: disk\n[14562] 11 Jan 20:25:35.494 * Background saving started by pid 15849\n[14562] 11 Jan 20:25:40.504 * Slave 127.0.0.1:6381 asks for synchronization\n[14562] 11 Jan 20:25:40.504 * Full resync requested by slave 127.0.0.1:6381\n[14562] 11 Jan 20:25:40.504 * Waiting for end of BGSAVE for SYNC\n[15849] 11 Jan 20:25:41.341 * DB saved on disk\n[15849] 11 Jan 20:25:41.342 * RDB: 76 MB of memory used by copy-on-write\n[14562] 11 Jan 20:25:41.427 * Background saving terminated with success\n[14562] 11 Jan 20:25:44.180 * Synchronization with slave 127.0.0.1:6381 succeeded\n[14562] 11 Jan 20:25:44.461 * Synchronization with slave 127.0.0.1:6380 succeeded```\n\n\n[^code]: 当配置设置同步方式为Disk-backed时才会把RDB文件写入磁盘，Diskless模式会直接把RDB文件写到slave的socket\n\n\n  [1]: http://7xl4v5.com1.z0.glb.clouddn.com/redis/conn1.png\n  [2]: http://7xl4v5.com1.z0.glb.clouddn.com/redis/FULLSYNC.png\n  [3]: http://7xl4v5.com1.z0.glb.clouddn.com/redis/prpogate2.png\n  [4]: http://7xl4v5.com1.z0.glb.clouddn.com/%E7%81%AB%E7%8B%90%E6%88%AA%E5%9B%BE_2018-01-13T07-02-09.810Z.png\n  [5]: http://7xl4v5.com1.z0.glb.clouddn.com/redis/ping.png\n  [6]: https://github.com/antirez/redis/issues/4102","source":"_posts/图解redis主从.md","raw":"\ntitle: 图解redis主从\ndate: 2017-10-22 21:15:46\ncategories: redis进阶\ntags: [redis,nosql,源码]\n---\n\n### 一、建立连接\n\n当slave收到客户端发来的slave of 命令之后，首先会在redisServer结构体中保存master的host和ip地址，然后建立一个到master的socket连接。\n连接成功后，slave会发送PING命令来测试连接是否可用，成功获得响应后，执行REPLCONF命令把自己的listen_port发送到master,后者会在redisClient中包存slave的监听端口。\n<!--more-->\n\n![连接][1]\n### 二、初次同步数据\n连接成功后，slave会发送**PSYNC**命令请求同步数据，由于第一次同步，所以会执行一次**完整重同步**的过程，master收到请求后执行**BGSAVE**命令创建RDB文件[^code]，然后把数据发送到slave \n![full同步][2]\n### 三、命令传播（propagate）\n同步完成后，master收到的写命令，会由master发送到slave，保证数据同步。命令在master执行成功后会立刻向客户端发送结果，因此命令传播是**异步执行**的，因此redis只能保证主从数据的**最终一致性**。\n在命令传播的过程中，master不只把数据发送给slave,还会保存在AOF文件，和复制积压缓冲区(backlog buffer)内。[a]\n![此处输入图片的描述][3]\n### 四、增量重同步\n刚才提到的backlog buffer是一个FIFO的定长队列(环形队列实现)，默认1MB大小，可以通过`repl_backlog_size`配置。它的作用是保存最近的更新命令并记录offsetr。当slave断线重连时，如果能根据offset在buffer中找到丢失的数据,那么只需增量的复制丢失数据即可，不需要进行完成的重同步。\n![此处输入图片的描述][4]\n\n### 五、心跳消息\nslave定时向master发送REPLCONF命令，通知master当前的自己offset，当master发现slave复制落后时，会主动发送丢失了命令。\n心跳消息让master了解slave的连接状态，如果当前slave数量小于min-slave，master会拒绝写命令。info命令输出的lag值反应了slave的上次通信时间。（master也会主动向slave发送PING命令）\n```\n# Replication\nrole:master\nconnected_slaves:2\nslave0:ip=127.0.0.1,port=6381,state=online,offset=4518,lag=1\nslave1:ip=127.0.0.1,port=6380,state=online,offset=4518,lag=1\n```\n![heart][5]\n\n### 六、 补充\n这是一次重新连接的日志，从服务器发送同步请求，master回复rdb文件。日志中**Partial resynchronization not possible (no cached master)**表示尝试增量同步失败，在我使用redis 2.8.19版本时似乎无法模拟出增量同步的情况，每次断线重连都是完整同步，按照作者说明关闭了slave的aof也不行(同步时不能进行write aof)，[github上这个问题对应的issue][6]\n**从服务器**\n```[15846] 11 Jan 20:25:34.722 * DB loaded from disk: 2.233 seconds\n[15846] 11 Jan 20:25:34.722 * The server is now ready to accept connections on port 6380\n[15846] 11 Jan 20:25:35.490 * Connecting to MASTER 127.0.0.1:6379\n[15846] 11 Jan 20:25:35.491 * MASTER <-> SLAVE sync started\n[15846] 11 Jan 20:25:35.491 * Non blocking connect for SYNC fired the event.\n[15846] 11 Jan 20:25:35.491 * Master replied to PING, replication can continue...\n[15846] 11 Jan 20:25:35.491 * Partial resynchronization not possible (no cached master)\n[15846] 11 Jan 20:25:35.495 * Full resync from master: 13cb06d81ed35702e1cf20dba3aa1159b9a068bd:15931\n[15846] 11 Jan 20:25:41.428 * MASTER <-> SLAVE sync: receiving 225990523 bytes from master\n[15846] 11 Jan 20:25:44.383 * MASTER <-> SLAVE sync: Flushing old data\n[15846] 11 Jan 20:25:44.560 * MASTER <-> SLAVE sync: Loading DB in memory\n[15846] 11 Jan 20:25:46.948 * MASTER <-> SLAVE sync: Finished with success```\n**主服务器：**\n```[14562] 11 Jan 20:23:17.478 # Connection with slave 127.0.0.1:6380 lost.\n[14562] 11 Jan 20:23:29.644 # Connection with slave 127.0.0.1:6381 lost.\n[14562] 11 Jan 20:25:35.492 * Slave 127.0.0.1:6380 asks for synchronization\n[14562] 11 Jan 20:25:35.492 * Full resync requested by slave 127.0.0.1:6380\n[14562] 11 Jan 20:25:35.492 * Starting BGSAVE for SYNC with target: disk\n[14562] 11 Jan 20:25:35.494 * Background saving started by pid 15849\n[14562] 11 Jan 20:25:40.504 * Slave 127.0.0.1:6381 asks for synchronization\n[14562] 11 Jan 20:25:40.504 * Full resync requested by slave 127.0.0.1:6381\n[14562] 11 Jan 20:25:40.504 * Waiting for end of BGSAVE for SYNC\n[15849] 11 Jan 20:25:41.341 * DB saved on disk\n[15849] 11 Jan 20:25:41.342 * RDB: 76 MB of memory used by copy-on-write\n[14562] 11 Jan 20:25:41.427 * Background saving terminated with success\n[14562] 11 Jan 20:25:44.180 * Synchronization with slave 127.0.0.1:6381 succeeded\n[14562] 11 Jan 20:25:44.461 * Synchronization with slave 127.0.0.1:6380 succeeded```\n\n\n[^code]: 当配置设置同步方式为Disk-backed时才会把RDB文件写入磁盘，Diskless模式会直接把RDB文件写到slave的socket\n\n\n  [1]: http://7xl4v5.com1.z0.glb.clouddn.com/redis/conn1.png\n  [2]: http://7xl4v5.com1.z0.glb.clouddn.com/redis/FULLSYNC.png\n  [3]: http://7xl4v5.com1.z0.glb.clouddn.com/redis/prpogate2.png\n  [4]: http://7xl4v5.com1.z0.glb.clouddn.com/%E7%81%AB%E7%8B%90%E6%88%AA%E5%9B%BE_2018-01-13T07-02-09.810Z.png\n  [5]: http://7xl4v5.com1.z0.glb.clouddn.com/redis/ping.png\n  [6]: https://github.com/antirez/redis/issues/4102","slug":"图解redis主从","published":1,"updated":"2018-11-21T16:34:51.689Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp57u3x4000l2xpb3hrui7hq","content":"<h3 id=\"一、建立连接\"><a href=\"#一、建立连接\" class=\"headerlink\" title=\"一、建立连接\"></a>一、建立连接</h3><p>当slave收到客户端发来的slave of 命令之后，首先会在redisServer结构体中保存master的host和ip地址，然后建立一个到master的socket连接。<br>连接成功后，slave会发送PING命令来测试连接是否可用，成功获得响应后，执行REPLCONF命令把自己的listen_port发送到master,后者会在redisClient中包存slave的监听端口。<br><a id=\"more\"></a></p>\n<p><img src=\"http://7xl4v5.com1.z0.glb.clouddn.com/redis/conn1.png\" alt=\"连接\"></p>\n<h3 id=\"二、初次同步数据\"><a href=\"#二、初次同步数据\" class=\"headerlink\" title=\"二、初次同步数据\"></a>二、初次同步数据</h3><p>连接成功后，slave会发送<strong>PSYNC</strong>命令请求同步数据，由于第一次同步，所以会执行一次<strong>完整重同步</strong>的过程，master收到请求后执行<strong>BGSAVE</strong>命令创建RDB文件<a href=\"当配置设置同步方式为Disk-backed时才会把RDB文件写入磁盘，Diskless模式会直接把RDB文件写到slave的socket\">^code</a>，然后把数据发送到slave<br><img src=\"http://7xl4v5.com1.z0.glb.clouddn.com/redis/FULLSYNC.png\" alt=\"full同步\"></p>\n<h3 id=\"三、命令传播（propagate）\"><a href=\"#三、命令传播（propagate）\" class=\"headerlink\" title=\"三、命令传播（propagate）\"></a>三、命令传播（propagate）</h3><p>同步完成后，master收到的写命令，会由master发送到slave，保证数据同步。命令在master执行成功后会立刻向客户端发送结果，因此命令传播是<strong>异步执行</strong>的，因此redis只能保证主从数据的<strong>最终一致性</strong>。<br>在命令传播的过程中，master不只把数据发送给slave,还会保存在AOF文件，和复制积压缓冲区(backlog buffer)内。[a]<br><img src=\"http://7xl4v5.com1.z0.glb.clouddn.com/redis/prpogate2.png\" alt=\"此处输入图片的描述\"></p>\n<h3 id=\"四、增量重同步\"><a href=\"#四、增量重同步\" class=\"headerlink\" title=\"四、增量重同步\"></a>四、增量重同步</h3><p>刚才提到的backlog buffer是一个FIFO的定长队列(环形队列实现)，默认1MB大小，可以通过<code>repl_backlog_size</code>配置。它的作用是保存最近的更新命令并记录offsetr。当slave断线重连时，如果能根据offset在buffer中找到丢失的数据,那么只需增量的复制丢失数据即可，不需要进行完成的重同步。<br><img src=\"http://7xl4v5.com1.z0.glb.clouddn.com/%E7%81%AB%E7%8B%90%E6%88%AA%E5%9B%BE_2018-01-13T07-02-09.810Z.png\" alt=\"此处输入图片的描述\"></p>\n<h3 id=\"五、心跳消息\"><a href=\"#五、心跳消息\" class=\"headerlink\" title=\"五、心跳消息\"></a>五、心跳消息</h3><p>slave定时向master发送REPLCONF命令，通知master当前的自己offset，当master发现slave复制落后时，会主动发送丢失了命令。<br>心跳消息让master了解slave的连接状态，如果当前slave数量小于min-slave，master会拒绝写命令。info命令输出的lag值反应了slave的上次通信时间。（master也会主动向slave发送PING命令）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Replication</span><br><span class=\"line\">role:master</span><br><span class=\"line\">connected_slaves:2</span><br><span class=\"line\">slave0:ip=127.0.0.1,port=6381,state=online,offset=4518,lag=1</span><br><span class=\"line\">slave1:ip=127.0.0.1,port=6380,state=online,offset=4518,lag=1</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"http://7xl4v5.com1.z0.glb.clouddn.com/redis/ping.png\" alt=\"heart\"></p>\n<h3 id=\"六、-补充\"><a href=\"#六、-补充\" class=\"headerlink\" title=\"六、 补充\"></a>六、 补充</h3><p>这是一次重新连接的日志，从服务器发送同步请求，master回复rdb文件。日志中<strong>Partial resynchronization not possible (no cached master)</strong>表示尝试增量同步失败，在我使用redis 2.8.19版本时似乎无法模拟出增量同步的情况，每次断线重连都是完整同步，按照作者说明关闭了slave的aof也不行(同步时不能进行write aof)，<a href=\"https://github.com/antirez/redis/issues/4102\" target=\"_blank\" rel=\"noopener\">github上这个问题对应的issue</a><br><strong>从服务器</strong><br><figure class=\"highlight plain\"><figcaption><span>11 Jan 20:25:34.722 * DB loaded from disk: 2.233 seconds</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[15846] 11 Jan 20:25:34.722 * The server is now ready to accept connections on port 6380</span><br><span class=\"line\">[15846] 11 Jan 20:25:35.490 * Connecting to MASTER 127.0.0.1:6379</span><br><span class=\"line\">[15846] 11 Jan 20:25:35.491 * MASTER &lt;-&gt; SLAVE sync started</span><br><span class=\"line\">[15846] 11 Jan 20:25:35.491 * Non blocking connect for SYNC fired the event.</span><br><span class=\"line\">[15846] 11 Jan 20:25:35.491 * Master replied to PING, replication can continue...</span><br><span class=\"line\">[15846] 11 Jan 20:25:35.491 * Partial resynchronization not possible (no cached master)</span><br><span class=\"line\">[15846] 11 Jan 20:25:35.495 * Full resync from master: 13cb06d81ed35702e1cf20dba3aa1159b9a068bd:15931</span><br><span class=\"line\">[15846] 11 Jan 20:25:41.428 * MASTER &lt;-&gt; SLAVE sync: receiving 225990523 bytes from master</span><br><span class=\"line\">[15846] 11 Jan 20:25:44.383 * MASTER &lt;-&gt; SLAVE sync: Flushing old data</span><br><span class=\"line\">[15846] 11 Jan 20:25:44.560 * MASTER &lt;-&gt; SLAVE sync: Loading DB in memory</span><br><span class=\"line\">[15846] 11 Jan 20:25:46.948 * MASTER &lt;-&gt; SLAVE sync: Finished with success</span><br></pre></td></tr></table></figure></p>\n<p><strong>主服务器：</strong><br><figure class=\"highlight plain\"><figcaption><span>11 Jan 20:23:17.478 # Connection with slave 127.0.0.1:6380 lost.</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[14562] 11 Jan 20:23:29.644 # Connection with slave 127.0.0.1:6381 lost.</span><br><span class=\"line\">[14562] 11 Jan 20:25:35.492 * Slave 127.0.0.1:6380 asks for synchronization</span><br><span class=\"line\">[14562] 11 Jan 20:25:35.492 * Full resync requested by slave 127.0.0.1:6380</span><br><span class=\"line\">[14562] 11 Jan 20:25:35.492 * Starting BGSAVE for SYNC with target: disk</span><br><span class=\"line\">[14562] 11 Jan 20:25:35.494 * Background saving started by pid 15849</span><br><span class=\"line\">[14562] 11 Jan 20:25:40.504 * Slave 127.0.0.1:6381 asks for synchronization</span><br><span class=\"line\">[14562] 11 Jan 20:25:40.504 * Full resync requested by slave 127.0.0.1:6381</span><br><span class=\"line\">[14562] 11 Jan 20:25:40.504 * Waiting for end of BGSAVE for SYNC</span><br><span class=\"line\">[15849] 11 Jan 20:25:41.341 * DB saved on disk</span><br><span class=\"line\">[15849] 11 Jan 20:25:41.342 * RDB: 76 MB of memory used by copy-on-write</span><br><span class=\"line\">[14562] 11 Jan 20:25:41.427 * Background saving terminated with success</span><br><span class=\"line\">[14562] 11 Jan 20:25:44.180 * Synchronization with slave 127.0.0.1:6381 succeeded</span><br><span class=\"line\">[14562] 11 Jan 20:25:44.461 * Synchronization with slave 127.0.0.1:6380 succeeded</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"一、建立连接\"><a href=\"#一、建立连接\" class=\"headerlink\" title=\"一、建立连接\"></a>一、建立连接</h3><p>当slave收到客户端发来的slave of 命令之后，首先会在redisServer结构体中保存master的host和ip地址，然后建立一个到master的socket连接。<br>连接成功后，slave会发送PING命令来测试连接是否可用，成功获得响应后，执行REPLCONF命令把自己的listen_port发送到master,后者会在redisClient中包存slave的监听端口。<br>","more":"</p>\n<p><img src=\"http://7xl4v5.com1.z0.glb.clouddn.com/redis/conn1.png\" alt=\"连接\"></p>\n<h3 id=\"二、初次同步数据\"><a href=\"#二、初次同步数据\" class=\"headerlink\" title=\"二、初次同步数据\"></a>二、初次同步数据</h3><p>连接成功后，slave会发送<strong>PSYNC</strong>命令请求同步数据，由于第一次同步，所以会执行一次<strong>完整重同步</strong>的过程，master收到请求后执行<strong>BGSAVE</strong>命令创建RDB文件<a href=\"当配置设置同步方式为Disk-backed时才会把RDB文件写入磁盘，Diskless模式会直接把RDB文件写到slave的socket\">^code</a>，然后把数据发送到slave<br><img src=\"http://7xl4v5.com1.z0.glb.clouddn.com/redis/FULLSYNC.png\" alt=\"full同步\"></p>\n<h3 id=\"三、命令传播（propagate）\"><a href=\"#三、命令传播（propagate）\" class=\"headerlink\" title=\"三、命令传播（propagate）\"></a>三、命令传播（propagate）</h3><p>同步完成后，master收到的写命令，会由master发送到slave，保证数据同步。命令在master执行成功后会立刻向客户端发送结果，因此命令传播是<strong>异步执行</strong>的，因此redis只能保证主从数据的<strong>最终一致性</strong>。<br>在命令传播的过程中，master不只把数据发送给slave,还会保存在AOF文件，和复制积压缓冲区(backlog buffer)内。[a]<br><img src=\"http://7xl4v5.com1.z0.glb.clouddn.com/redis/prpogate2.png\" alt=\"此处输入图片的描述\"></p>\n<h3 id=\"四、增量重同步\"><a href=\"#四、增量重同步\" class=\"headerlink\" title=\"四、增量重同步\"></a>四、增量重同步</h3><p>刚才提到的backlog buffer是一个FIFO的定长队列(环形队列实现)，默认1MB大小，可以通过<code>repl_backlog_size</code>配置。它的作用是保存最近的更新命令并记录offsetr。当slave断线重连时，如果能根据offset在buffer中找到丢失的数据,那么只需增量的复制丢失数据即可，不需要进行完成的重同步。<br><img src=\"http://7xl4v5.com1.z0.glb.clouddn.com/%E7%81%AB%E7%8B%90%E6%88%AA%E5%9B%BE_2018-01-13T07-02-09.810Z.png\" alt=\"此处输入图片的描述\"></p>\n<h3 id=\"五、心跳消息\"><a href=\"#五、心跳消息\" class=\"headerlink\" title=\"五、心跳消息\"></a>五、心跳消息</h3><p>slave定时向master发送REPLCONF命令，通知master当前的自己offset，当master发现slave复制落后时，会主动发送丢失了命令。<br>心跳消息让master了解slave的连接状态，如果当前slave数量小于min-slave，master会拒绝写命令。info命令输出的lag值反应了slave的上次通信时间。（master也会主动向slave发送PING命令）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Replication</span><br><span class=\"line\">role:master</span><br><span class=\"line\">connected_slaves:2</span><br><span class=\"line\">slave0:ip=127.0.0.1,port=6381,state=online,offset=4518,lag=1</span><br><span class=\"line\">slave1:ip=127.0.0.1,port=6380,state=online,offset=4518,lag=1</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"http://7xl4v5.com1.z0.glb.clouddn.com/redis/ping.png\" alt=\"heart\"></p>\n<h3 id=\"六、-补充\"><a href=\"#六、-补充\" class=\"headerlink\" title=\"六、 补充\"></a>六、 补充</h3><p>这是一次重新连接的日志，从服务器发送同步请求，master回复rdb文件。日志中<strong>Partial resynchronization not possible (no cached master)</strong>表示尝试增量同步失败，在我使用redis 2.8.19版本时似乎无法模拟出增量同步的情况，每次断线重连都是完整同步，按照作者说明关闭了slave的aof也不行(同步时不能进行write aof)，<a href=\"https://github.com/antirez/redis/issues/4102\" target=\"_blank\" rel=\"noopener\">github上这个问题对应的issue</a><br><strong>从服务器</strong><br><figure class=\"highlight plain\"><figcaption><span>11 Jan 20:25:34.722 * DB loaded from disk: 2.233 seconds</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[15846] 11 Jan 20:25:34.722 * The server is now ready to accept connections on port 6380</span><br><span class=\"line\">[15846] 11 Jan 20:25:35.490 * Connecting to MASTER 127.0.0.1:6379</span><br><span class=\"line\">[15846] 11 Jan 20:25:35.491 * MASTER &lt;-&gt; SLAVE sync started</span><br><span class=\"line\">[15846] 11 Jan 20:25:35.491 * Non blocking connect for SYNC fired the event.</span><br><span class=\"line\">[15846] 11 Jan 20:25:35.491 * Master replied to PING, replication can continue...</span><br><span class=\"line\">[15846] 11 Jan 20:25:35.491 * Partial resynchronization not possible (no cached master)</span><br><span class=\"line\">[15846] 11 Jan 20:25:35.495 * Full resync from master: 13cb06d81ed35702e1cf20dba3aa1159b9a068bd:15931</span><br><span class=\"line\">[15846] 11 Jan 20:25:41.428 * MASTER &lt;-&gt; SLAVE sync: receiving 225990523 bytes from master</span><br><span class=\"line\">[15846] 11 Jan 20:25:44.383 * MASTER &lt;-&gt; SLAVE sync: Flushing old data</span><br><span class=\"line\">[15846] 11 Jan 20:25:44.560 * MASTER &lt;-&gt; SLAVE sync: Loading DB in memory</span><br><span class=\"line\">[15846] 11 Jan 20:25:46.948 * MASTER &lt;-&gt; SLAVE sync: Finished with success</span><br></pre></td></tr></table></figure></p>\n<p><strong>主服务器：</strong><br><figure class=\"highlight plain\"><figcaption><span>11 Jan 20:23:17.478 # Connection with slave 127.0.0.1:6380 lost.</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[14562] 11 Jan 20:23:29.644 # Connection with slave 127.0.0.1:6381 lost.</span><br><span class=\"line\">[14562] 11 Jan 20:25:35.492 * Slave 127.0.0.1:6380 asks for synchronization</span><br><span class=\"line\">[14562] 11 Jan 20:25:35.492 * Full resync requested by slave 127.0.0.1:6380</span><br><span class=\"line\">[14562] 11 Jan 20:25:35.492 * Starting BGSAVE for SYNC with target: disk</span><br><span class=\"line\">[14562] 11 Jan 20:25:35.494 * Background saving started by pid 15849</span><br><span class=\"line\">[14562] 11 Jan 20:25:40.504 * Slave 127.0.0.1:6381 asks for synchronization</span><br><span class=\"line\">[14562] 11 Jan 20:25:40.504 * Full resync requested by slave 127.0.0.1:6381</span><br><span class=\"line\">[14562] 11 Jan 20:25:40.504 * Waiting for end of BGSAVE for SYNC</span><br><span class=\"line\">[15849] 11 Jan 20:25:41.341 * DB saved on disk</span><br><span class=\"line\">[15849] 11 Jan 20:25:41.342 * RDB: 76 MB of memory used by copy-on-write</span><br><span class=\"line\">[14562] 11 Jan 20:25:41.427 * Background saving terminated with success</span><br><span class=\"line\">[14562] 11 Jan 20:25:44.180 * Synchronization with slave 127.0.0.1:6381 succeeded</span><br><span class=\"line\">[14562] 11 Jan 20:25:44.461 * Synchronization with slave 127.0.0.1:6380 succeeded</span><br></pre></td></tr></table></figure></p>"},{"title":"jenkins on kubernetes实践","date":"2017-08-26T13:05:46.000Z","_content":"\n**jenkins是什么？**\nJenkins是一个开源的持续集成工具，可用于自动化的执行与构建，测试和交付或部署软件有关的各种任务,有非常丰富的插件支持。\n**kubernetes是什么？**\nKubernetes是容器集群管理系统，是一个开源的平台，可以实现容器集群的自动化部署、自动扩缩容、维护等功能。[这个视频生动地介绍了k8s][1]\n**jenkins on k8s 有什么好处？**\njenkins通过单Master多个Slave的方式提供服务，Master保存了任务的配置信息，安装的插件等等，而slave主要负责执行任务，在使用中存在以下几个问题：\n<!--more-->\n1. 当存在多个slave时，运行slave的机器难以统一管理，每次添加新节点时总要做大量的重复工作。\n2. 由于不同业务的构建频率并不相同，在使用会发现有很多slave大多数时间都处于空闲状态，造成资源浪费\n3. jenkins默认采取保守的调度方式，造成某些slave的负载过高，任务不能平均分配\n![jenkins架构][2]\n\n使用k8s管理jenkins具有以下优势：\n\n1. 使用docker运行jenkins保证环境的一致性，可以根据不同业务选择合适的镜像\n2. k8s对抽象后的资源（pods）进行统一的管理调度，提供资源隔离和共享，使机器计算资源变得弹性可扩展,避免资源浪费。\n3. k8s提供容器的自愈功能，能够保证始终有一定数量的容器是可用的\n4. k8s默认的调度器提供了针对节点当前资源分配容器的调度策略，调度器支持插件化部署便于自定义。\n\n### **一，搭建环境**\n\n#### 工具准备\n\n> kubernetes v1.8.4\ndocker v1.12.6\njenkins master镜像 jenkins/jenkins:lts（v2.73.3）\nslave镜像 jenkinsci/jnlp-slave\nKubernetes plugin (v1.1)\n\n#### 安装kubernetes集群\n\n中文教程：https://www.kubernetes.org.cn/2906.html\n安装成功之后访问dashboard地址就可以看到集群的控制面板：\n![dashboard][3]\n集群安装完成后，创建命名空间kubernetes-plugin\n```\nkubectl create namespace kubernetes-plugin\nkubectl config set-context $(kubectl config current-context) --namespace=kubernetes-plugin\nkubectl create -f service-account.yml\n```\n\n### **二，创建StatefulSet**\n>**StatefulSet(有状态副本集)**：Deployments适用于运行无状态应用，StatefulSet则为有状态的应用提供了支持，可以为应用提供有序的部署和扩展，稳定的持久化存储，我们使用SS来运行jenkins master。\n\n创建完整的Stateful Set需要依次创建一下对象：\n1、Persistent Volume\n2、Persistent Volume Claim\n3、StatefulSet\n4、Service\n\n\n#### **创建PersistentVolume：**\n\n为了保存应用运行时的数据需要先创建k8s的卷文件，K8s中存在Volume和PersistentVolume两种类型：\n\n >- Volume：与docker中的volume不同在于Volume生命周期是和pod绑定的，与pod中的container无关。k8s为Volume提供了多种类型文件系统（cephfs,nfs...,简单起见我直接选择了hostPath，使用的node节点本地的存储系统）\n >- PersistentVolume:从名字可以看出来，PV的生命周期独立于使用它的pod，不会像volume随pod消失而消失，而是做为一个集群中的资源存在（像node节点一样），同时PV屏蔽了使用具体存储系统的细节。\n\nk8s中的对象都是通过[yaml文件][4]来定义的，首先创建名为`jenkins-volume.yml`的文件:\n\n**注意**：PV的创建有静态，动态两种方式，动态创建可以减少管理员的操作步骤，需要提供指定的[StorageClass][5]。为了测试方便，所以我们直接选择静态创建，manual是一个不存在的storage class\n```\nkind: PersistentVolume\napiVersion: v1\nmetadata:\n  name: jenkins-volume\n  labels:\n    type: local\nspec:\n  storageClassName: manual\n  capacity:\n    storage: 10Gi\n  accessModes:\n    - ReadWriteOnce\n  hostPath:\n    path: \"/tmp/data\"\n\n```\nmaster节点执行下面的命令，PV就手动创建完了\n`kubectl create -f jenkins-volume1.yaml`\n#### **创建PersistentVolumeClaim：**\n>PersistentVolumeClaim(PVC):\n持久化存储卷索取，如果说PV是集群中的资源，PVC就是资源的消费者，PVC可以指定需要的资源大小和访问方式,pod不会和PV直接接触，而是通过PVC来请求资源，PV的生成阶段叫做provision,生成PV后会绑定到PVC对象，然后才能被其他对象使用。\n\nPV和PVC的生命周期如下图：\n![pv life][6]\n\n创建文件`jenkins-claim.yaml`\n**注意：** name必须为jenkins-home-jenkins-0否则会绑定失败\n```\nkind: PersistentVolumeClaim\napiVersion: v1\nmetadata:\n  name: jenkins-home-jenkins-0\nspec:\n  storageClassName: manual\n  accessModes:\n    - ReadWriteOnce\n  resources:\n    requests:\n      storage: 3Gi\n```\n执行命令`kubectl create -f jenkins-claim.yaml`\n然后查看PVC是否创建成功，status为bound说明PVC已经绑定\n```\n[root@master ~]# kubectl describe pvc jenkins-home-jenkins-0\nName:          jenkins-home-jenkins-0\nNamespace:     kubernetes-plugin\nStorageClass:  manual\nStatus:        Bound\nVolume:        jenkins-volume\nLabels:        <none>\nAnnotations:   pv.kubernetes.io/bind-completed=yes\n               pv.kubernetes.io/bound-by-controller=yes\nCapacity:      10Gi\nAccess Modes:  RWO\nEvents:        <none>\n```\n#### **创建StatefulSet和Service：**\n\n从kubernetes-plugin github仓库下载jenkins.yml文件\n```\nwget https://raw.githubusercontent.com/jenkinsci/kubernetes-plugin/master/src/main/kubernetes/jenkins.yml\n```\n修改jenkins.yml：\n去掉87行`externalTrafficPolicy: Local`（这是GKE使用的）\n修改83行` type: LoadBalancer`改为` type: NodePort`\n\n**注意：** \nservice type=ClusterIP时只允许从集群内部访问， type设置为NodePort是为了从集群外的机器访问jenkins,请谨慎使用，开启NodePort会在所有节点（含master）的统一固定端口开放服务。\n\n执行命令\n```\n[root@master ~]# kubectl create -f jenkins.yml \nstatefulset \"jenkins\" created\nservice \"jenkins\" created\n```\n访问jenkins master,地址为`masterip:32058`\n```\n#查看映射的端口\n[root@master ~]# kubectl get service jenkins\nNAME      TYPE       CLUSTER-IP    EXTERNAL-IP   PORT(S)                        AGE\njenkins   NodePort   10.96.82.68   <none>        80:32058/TCP,50000:30345/TCP   1m\n```\n查看pod : jenkins-0的容器日志，粘贴下面的密码进入jenkins,jenkins安装完成。\n> Jenkins initial setup is required. An admin user has been created and a password generated.\nPlease use the following password to proceed to installation:\n70aa7b41ba894855abccd09306625b8a \n\n刷新dashboard，切换命名空间到kubernetes-plugin,结果如下：\n![success][7]\n\n### 问题分析\n1.创建stateful set时失败，提示\"PersistentVolumeClaim is not bound: \"jenkins-home-jenkins-0\"：\"\n因为采用静态创建PV时，StatefulSet会按照固定名称查找PVC，PVC的名字要满足\n>PVC_name == volumeClaimTemplates_name + \"-\" + pod_name\n\n这里的名字就是`jenkins-home-jenkins-0`\n\n2.pod启动失败，jenkins用户没有目录权限\n错误提示\"touch: cannot touch ‘/var/jenkins_home/copy_reference_file.log’: Permission denied\nCan not write to /var/jenkins_home/copy_reference_file.log. Wrong volume permissions?\"\n要确保节点目录开放权限,在node上执行命令：\n```\nsudo chown -R 1000:1000 /var/jenkins_home/\nsudo chown -R 1000:1000 /tmp/data\n##如果仍然失败，尝试在node上重启docker\nsystemctl restart docker\n\n```\n注意pv指定的hostPath权限也要修改，否则是无效的\n\n\n\n###  三 ，配置jenkins\n#### 创建jenkins服务账号\n```\nwget https://raw.githubusercontent.com/jenkinsci/kubernetes-plugin/master/src/main/kubernetes/service-account.yml\nkubectl create -f service-account.yml\n```\n#### 配置插件\n访问`http://masterip:32058/pluginManager/`,搜索插件Kubernetes plugin安装；\n访问 http://masterip:32058/configure\n选择新建云--kubernetes,在URl填写api server地址，\n执行kubectl describe命令，复制output中的token，填入到 ‘Kubernetes server certificate key’\n```\n[root@master ~]# kubectl get secret \nNAME                  TYPE                                  DATA      AGE\ndefault-token-4kb54   kubernetes.io/service-account-token   3         1d\njenkins-token-wzbsx   kubernetes.io/service-account-token   3         1d\n[root@master ~]# kubectl describe secret/jenkins-token-wzbsx\n...\n```\njenkins url,tunnel填写service的CLUSTER-IP即可，结果如图：\n![peizhi1][8]\n选择add pod template，填写下面的内容，retain slave可以设置运行jenkins slave 的container空闲后能存活多久。\n![content][9]\n插件配置完成。\n### 四 ，测试\n#### 1. 扩容测试\n**StatefulSet扩容：**\n首先需要手动创建PV，PVC(见第二步),然后执行扩容命令\n` kubectl scale statefulset/jenkins --replicas=２`\n查看StatefulSet,此时已经拥有两个master节点，访问service时会**随机**将请求发送给后端的master。\n```\n[root@master ~]# kubectl get statefulset/jenkins \nNAME      DESIRED   CURRENT   AGE\njenkins   2         2         5d\n```\n虽然通过k8s可以轻松实现jenkins master节点的拓展，但是由于jenkins存储数据的方式通过本地文件存储，master之间的数据同步还是一个麻烦的问题，参考[jenkins存储模型][10]。\n\n*jenkins master上保存的文件：*\n```\nls /temp/data\njenkins.CLI.xml\njenkins.install.InstallUtil.lastExecVersion\njenkins.install.UpgradeWizard.state\njenkins.model.ArtifactManagerConfiguration.xml\njenkins.model.JenkinsLocationConfiguration.xml\njobs\nlogs\nnodeMonitors.xml\nnodes\n```\n\n#### 2. 高可用测试\n现在stateful set中已经有两个pod,在jenkins-1所在的节点执行`docker stop`停止运行jenkins-master的容器，同时在命令行查看pod的状态，可以看到jenkins-1异常（Error状态）之后慢慢恢复了运行状态（Running）：\n```\n[root@master ~]# kubectl get pods -w\nNAME        READY     STATUS    RESTARTS   AGE\njenkins-0   1/1       Running   0          1d\njenkins-1   0/1       Running   1         20h\njenkins-1   1/1       Running   1         20h\njenkins-1   0/1       Error     1         20h\njenkins-1   0/1       CrashLoopBackOff   1         20h\njenkins-1   0/1       Running   2         20h\njenkins-1   1/1       Running   2         20h\n```\n`kubectl describe pod jenkins-1`查看pod的事件日志，k8s通过探针(probe)接口检测到服务停止之后自动执行了拉取镜像，重启container的操作。\n```\nEvents:\n  Type     Reason      Age                From                              Message\n  ----     ------      ----               ----                              -------\n  Warning  Unhealthy   27m (x2 over 27m)  kubelet, iz8pscwd1fv6kprs1zw21kz  Readiness probe failed: HTTP probe failed with statuscode: 503\n  Warning  Unhealthy   27m (x2 over 27m)  kubelet, iz8pscwd1fv6kprs1zw21kz  Liveness probe failed: HTTP probe failed with statuscode: 503\n  Warning  Unhealthy   24m                kubelet, iz8pscwd1fv6kprs1zw21kz  Readiness probe failed: Get http://192.168.24.4:8080/login: dial tcp 192.168.24.4:8080: getsockopt: connection refused\n  Warning  BackOff     20m (x2 over 20m)  kubelet, iz8pscwd1fv6kprs1zw21kz  Back-off restarting failed container\n  Warning  FailedSync  20m (x2 over 20m)  kubelet, iz8pscwd1fv6kprs1zw21kz  Error syncing pod\n  Normal   Pulling     19m (x3 over 20h)  kubelet, iz8pscwd1fv6kprs1zw21kz  pulling image \"jenkins/jenkins:lts-alpine\"\n  Normal   Started     19m (x3 over 20h)  kubelet, iz8pscwd1fv6kprs1zw21kz  Started container\n  Normal   Pulled      19m (x3 over 20h)  kubelet, iz8pscwd1fv6kprs1zw21kz  Successfully pulled image \"jenkins/jenkins:lts-alpine\"\n  Normal   Created     19m (x3 over 20h)  kubelet, iz8pscwd1fv6kprs1zw21kz  Created container\n```\n#### 3. jenkins构建测试\n当前集群中使用的jenkins slave镜像只包含一个java运行环境来运行jenkins-slave.jar,在实际使用中需要自定义合适的镜像。选择自定义镜像之后需要修改插件的配置，同样name命名为jnlp替换默认镜像，arguments安装工具提示填写即可。\n![container][11]\n创建job，同时开始构建,k8s会在不同节点上创建pod来运行任务\n![此处输入图片的描述][13]\n构建全部完成后，资源随即被释放\n![此处输入图片的描述][14]\n\n**jenkins默认调度策略**\n1. 尝试在上次构建的节点上构建，指定某台slave之后会一直使用。\n2.当队列有2个构建时，不会立刻创建两个executor,而是先创建一个executor然后尝试等待executor空闲，目的是保证每个executor被充分利用。\n**k8s调度策略**\n1. 使用Pod.spec.nodeSelector根据label为pod选择node\n2.调度器scheduler有Predicates，Priorities两个阶段，分别负责节点过滤和评分排序，各个阶段都有k8s提供的检查项，我们可以自由组合。\n（比如PodFitsResources检查cpu内存等资源，PodFitsHostPorts检查端口占用，SelectorSpreadPriority要求一个服务尽量分散分布）[自定义schduler参考][15]\n**资源不足时会发生什么**\n当前集群中有3个节点，我在node2运行一个CPU占用限制在80%的程序,然后设置jenkins插件ContainerTemplate的request和limit均为`cpu 500m,内存500Mi`,（500m代表单核CPU的50%）看一下pod会怎么调度\nk8s仍然尝试在node2分配节点（为什么其他节点不行），结果POD处于pending状态：\n```\"status\": {\n    \"phase\": \"Pending\",\n    \"conditions\": [\n      {\n        \"type\": \"PodScheduled\",\n        \"status\": \"False\",\n        \"lastProbeTime\": null,\n        \"lastTransitionTime\": \"2017-12-09T08:29:10Z\",\n        \"reason\": \"Unschedulable\",\n        \"message\": \"No nodes are available that match all of the predicates: Insufficient cpu (4), PodToleratesNodeTaints (1).\"\n      }\n    ],\n    \"qosClass\": \"Guaranteed\"\n```\n最后pod被删除，而jenkins任务会阻塞一直到有其他空闲的slave出现。\n### **四 ，总结**\n本文介绍了在k8s集群部署jenkins服务的方式和k8s带来的资源管理便捷，由于我也是刚开始接触k8s,所用的实例只是搭建了用于测试的实验环境，离在实际生产环境中使用还有问题需要验证。\n\n\n  [1]: http://docs.kubernetes.org.cn/227.html\n  [2]: http://7xl4v5.com1.z0.glb.clouddn.com/jenkins-arch.png\n  [3]: http://7xl4v5.com1.z0.glb.clouddn.com/kongzhimianban.png\n  [4]: http://www.ruanyifeng.com/blog/2016/07/yaml.html\n  [5]: https://kubernetes.io/docs/concepts/storage/storage-classes/\n  [6]: http://7xl4v5.com1.z0.glb.clouddn.com/pvlife.png\n  [7]: http://7xl4v5.com1.z0.glb.clouddn.com/success.png\n  [8]: http://7xl4v5.com1.z0.glb.clouddn.com/config1.png\n  [9]: http://7xl4v5.com1.z0.glb.clouddn.com/config.png\n  [10]: https://yq.aliyun.com/articles/224376\n  [11]: http://7xl4v5.com1.z0.glb.clouddn.com/%E7%81%AB%E7%8B%90%E6%88%AA%E5%9B%BE_2017-12-08T08-06-23.616Z.png\n  [12]: http://7xl4v5.com1.z0.glb.clouddn.com/jobs.png\n  [13]: http://7xl4v5.com1.z0.glb.clouddn.com/pods1.png\n  [14]: http://7xl4v5.com1.z0.glb.clouddn.com/result2.png\n  [15]: http://dockone.io/article/2885","source":"_posts/jenkins on kubernetes实践.md","raw":"# jenkins on kubernetes实践\n\ntitle: jenkins on kubernetes实践\ndate: 2017-08-26 21:05:46\ncategories: 容器技术\ntags: [jenkins,docker,kubernetes]\n\n------\n\n**jenkins是什么？**\nJenkins是一个开源的持续集成工具，可用于自动化的执行与构建，测试和交付或部署软件有关的各种任务,有非常丰富的插件支持。\n**kubernetes是什么？**\nKubernetes是容器集群管理系统，是一个开源的平台，可以实现容器集群的自动化部署、自动扩缩容、维护等功能。[这个视频生动地介绍了k8s][1]\n**jenkins on k8s 有什么好处？**\njenkins通过单Master多个Slave的方式提供服务，Master保存了任务的配置信息，安装的插件等等，而slave主要负责执行任务，在使用中存在以下几个问题：\n<!--more-->\n1. 当存在多个slave时，运行slave的机器难以统一管理，每次添加新节点时总要做大量的重复工作。\n2. 由于不同业务的构建频率并不相同，在使用会发现有很多slave大多数时间都处于空闲状态，造成资源浪费\n3. jenkins默认采取保守的调度方式，造成某些slave的负载过高，任务不能平均分配\n![jenkins架构][2]\n\n使用k8s管理jenkins具有以下优势：\n\n1. 使用docker运行jenkins保证环境的一致性，可以根据不同业务选择合适的镜像\n2. k8s对抽象后的资源（pods）进行统一的管理调度，提供资源隔离和共享，使机器计算资源变得弹性可扩展,避免资源浪费。\n3. k8s提供容器的自愈功能，能够保证始终有一定数量的容器是可用的\n4. k8s默认的调度器提供了针对节点当前资源分配容器的调度策略，调度器支持插件化部署便于自定义。\n\n### **一，搭建环境**\n\n#### 工具准备\n\n> kubernetes v1.8.4\ndocker v1.12.6\njenkins master镜像 jenkins/jenkins:lts（v2.73.3）\nslave镜像 jenkinsci/jnlp-slave\nKubernetes plugin (v1.1)\n\n#### 安装kubernetes集群\n\n中文教程：https://www.kubernetes.org.cn/2906.html\n安装成功之后访问dashboard地址就可以看到集群的控制面板：\n![dashboard][3]\n集群安装完成后，创建命名空间kubernetes-plugin\n```\nkubectl create namespace kubernetes-plugin\nkubectl config set-context $(kubectl config current-context) --namespace=kubernetes-plugin\nkubectl create -f service-account.yml\n```\n\n### **二，创建StatefulSet**\n>**StatefulSet(有状态副本集)**：Deployments适用于运行无状态应用，StatefulSet则为有状态的应用提供了支持，可以为应用提供有序的部署和扩展，稳定的持久化存储，我们使用SS来运行jenkins master。\n\n创建完整的Stateful Set需要依次创建一下对象：\n1、Persistent Volume\n2、Persistent Volume Claim\n3、StatefulSet\n4、Service\n\n\n#### **创建PersistentVolume：**\n\n为了保存应用运行时的数据需要先创建k8s的卷文件，K8s中存在Volume和PersistentVolume两种类型：\n\n >- Volume：与docker中的volume不同在于Volume生命周期是和pod绑定的，与pod中的container无关。k8s为Volume提供了多种类型文件系统（cephfs,nfs...,简单起见我直接选择了hostPath，使用的node节点本地的存储系统）\n >- PersistentVolume:从名字可以看出来，PV的生命周期独立于使用它的pod，不会像volume随pod消失而消失，而是做为一个集群中的资源存在（像node节点一样），同时PV屏蔽了使用具体存储系统的细节。\n\nk8s中的对象都是通过[yaml文件][4]来定义的，首先创建名为`jenkins-volume.yml`的文件:\n\n**注意**：PV的创建有静态，动态两种方式，动态创建可以减少管理员的操作步骤，需要提供指定的[StorageClass][5]。为了测试方便，所以我们直接选择静态创建，manual是一个不存在的storage class\n```\nkind: PersistentVolume\napiVersion: v1\nmetadata:\n  name: jenkins-volume\n  labels:\n    type: local\nspec:\n  storageClassName: manual\n  capacity:\n    storage: 10Gi\n  accessModes:\n    - ReadWriteOnce\n  hostPath:\n    path: \"/tmp/data\"\n\n```\nmaster节点执行下面的命令，PV就手动创建完了\n`kubectl create -f jenkins-volume1.yaml`\n#### **创建PersistentVolumeClaim：**\n>PersistentVolumeClaim(PVC):\n持久化存储卷索取，如果说PV是集群中的资源，PVC就是资源的消费者，PVC可以指定需要的资源大小和访问方式,pod不会和PV直接接触，而是通过PVC来请求资源，PV的生成阶段叫做provision,生成PV后会绑定到PVC对象，然后才能被其他对象使用。\n\nPV和PVC的生命周期如下图：\n![pv life][6]\n\n创建文件`jenkins-claim.yaml`\n**注意：** name必须为jenkins-home-jenkins-0否则会绑定失败\n```\nkind: PersistentVolumeClaim\napiVersion: v1\nmetadata:\n  name: jenkins-home-jenkins-0\nspec:\n  storageClassName: manual\n  accessModes:\n    - ReadWriteOnce\n  resources:\n    requests:\n      storage: 3Gi\n```\n执行命令`kubectl create -f jenkins-claim.yaml`\n然后查看PVC是否创建成功，status为bound说明PVC已经绑定\n```\n[root@master ~]# kubectl describe pvc jenkins-home-jenkins-0\nName:          jenkins-home-jenkins-0\nNamespace:     kubernetes-plugin\nStorageClass:  manual\nStatus:        Bound\nVolume:        jenkins-volume\nLabels:        <none>\nAnnotations:   pv.kubernetes.io/bind-completed=yes\n               pv.kubernetes.io/bound-by-controller=yes\nCapacity:      10Gi\nAccess Modes:  RWO\nEvents:        <none>\n```\n#### **创建StatefulSet和Service：**\n\n从kubernetes-plugin github仓库下载jenkins.yml文件\n```\nwget https://raw.githubusercontent.com/jenkinsci/kubernetes-plugin/master/src/main/kubernetes/jenkins.yml\n```\n修改jenkins.yml：\n去掉87行`externalTrafficPolicy: Local`（这是GKE使用的）\n修改83行` type: LoadBalancer`改为` type: NodePort`\n\n**注意：** \nservice type=ClusterIP时只允许从集群内部访问， type设置为NodePort是为了从集群外的机器访问jenkins,请谨慎使用，开启NodePort会在所有节点（含master）的统一固定端口开放服务。\n\n执行命令\n```\n[root@master ~]# kubectl create -f jenkins.yml \nstatefulset \"jenkins\" created\nservice \"jenkins\" created\n```\n访问jenkins master,地址为`masterip:32058`\n```\n#查看映射的端口\n[root@master ~]# kubectl get service jenkins\nNAME      TYPE       CLUSTER-IP    EXTERNAL-IP   PORT(S)                        AGE\njenkins   NodePort   10.96.82.68   <none>        80:32058/TCP,50000:30345/TCP   1m\n```\n查看pod : jenkins-0的容器日志，粘贴下面的密码进入jenkins,jenkins安装完成。\n> Jenkins initial setup is required. An admin user has been created and a password generated.\nPlease use the following password to proceed to installation:\n70aa7b41ba894855abccd09306625b8a \n\n刷新dashboard，切换命名空间到kubernetes-plugin,结果如下：\n![success][7]\n\n### 问题分析\n1.创建stateful set时失败，提示\"PersistentVolumeClaim is not bound: \"jenkins-home-jenkins-0\"：\"\n因为采用静态创建PV时，StatefulSet会按照固定名称查找PVC，PVC的名字要满足\n>PVC_name == volumeClaimTemplates_name + \"-\" + pod_name\n\n这里的名字就是`jenkins-home-jenkins-0`\n\n2.pod启动失败，jenkins用户没有目录权限\n错误提示\"touch: cannot touch ‘/var/jenkins_home/copy_reference_file.log’: Permission denied\nCan not write to /var/jenkins_home/copy_reference_file.log. Wrong volume permissions?\"\n要确保节点目录开放权限,在node上执行命令：\n```\nsudo chown -R 1000:1000 /var/jenkins_home/\nsudo chown -R 1000:1000 /tmp/data\n##如果仍然失败，尝试在node上重启docker\nsystemctl restart docker\n\n```\n注意pv指定的hostPath权限也要修改，否则是无效的\n\n\n\n###  三 ，配置jenkins\n#### 创建jenkins服务账号\n```\nwget https://raw.githubusercontent.com/jenkinsci/kubernetes-plugin/master/src/main/kubernetes/service-account.yml\nkubectl create -f service-account.yml\n```\n#### 配置插件\n访问`http://masterip:32058/pluginManager/`,搜索插件Kubernetes plugin安装；\n访问 http://masterip:32058/configure\n选择新建云--kubernetes,在URl填写api server地址，\n执行kubectl describe命令，复制output中的token，填入到 ‘Kubernetes server certificate key’\n```\n[root@master ~]# kubectl get secret \nNAME                  TYPE                                  DATA      AGE\ndefault-token-4kb54   kubernetes.io/service-account-token   3         1d\njenkins-token-wzbsx   kubernetes.io/service-account-token   3         1d\n[root@master ~]# kubectl describe secret/jenkins-token-wzbsx\n...\n```\njenkins url,tunnel填写service的CLUSTER-IP即可，结果如图：\n![peizhi1][8]\n选择add pod template，填写下面的内容，retain slave可以设置运行jenkins slave 的container空闲后能存活多久。\n![content][9]\n插件配置完成。\n### 四 ，测试\n#### 1. 扩容测试\n**StatefulSet扩容：**\n首先需要手动创建PV，PVC(见第二步),然后执行扩容命令\n` kubectl scale statefulset/jenkins --replicas=２`\n查看StatefulSet,此时已经拥有两个master节点，访问service时会**随机**将请求发送给后端的master。\n```\n[root@master ~]# kubectl get statefulset/jenkins \nNAME      DESIRED   CURRENT   AGE\njenkins   2         2         5d\n```\n虽然通过k8s可以轻松实现jenkins master节点的拓展，但是由于jenkins存储数据的方式通过本地文件存储，master之间的数据同步还是一个麻烦的问题，参考[jenkins存储模型][10]。\n\n*jenkins master上保存的文件：*\n```\nls /temp/data\njenkins.CLI.xml\njenkins.install.InstallUtil.lastExecVersion\njenkins.install.UpgradeWizard.state\njenkins.model.ArtifactManagerConfiguration.xml\njenkins.model.JenkinsLocationConfiguration.xml\njobs\nlogs\nnodeMonitors.xml\nnodes\n```\n\n#### 2. 高可用测试\n现在stateful set中已经有两个pod,在jenkins-1所在的节点执行`docker stop`停止运行jenkins-master的容器，同时在命令行查看pod的状态，可以看到jenkins-1异常（Error状态）之后慢慢恢复了运行状态（Running）：\n```\n[root@master ~]# kubectl get pods -w\nNAME        READY     STATUS    RESTARTS   AGE\njenkins-0   1/1       Running   0          1d\njenkins-1   0/1       Running   1         20h\njenkins-1   1/1       Running   1         20h\njenkins-1   0/1       Error     1         20h\njenkins-1   0/1       CrashLoopBackOff   1         20h\njenkins-1   0/1       Running   2         20h\njenkins-1   1/1       Running   2         20h\n```\n`kubectl describe pod jenkins-1`查看pod的事件日志，k8s通过探针(probe)接口检测到服务停止之后自动执行了拉取镜像，重启container的操作。\n```\nEvents:\n  Type     Reason      Age                From                              Message\n  ----     ------      ----               ----                              -------\n  Warning  Unhealthy   27m (x2 over 27m)  kubelet, iz8pscwd1fv6kprs1zw21kz  Readiness probe failed: HTTP probe failed with statuscode: 503\n  Warning  Unhealthy   27m (x2 over 27m)  kubelet, iz8pscwd1fv6kprs1zw21kz  Liveness probe failed: HTTP probe failed with statuscode: 503\n  Warning  Unhealthy   24m                kubelet, iz8pscwd1fv6kprs1zw21kz  Readiness probe failed: Get http://192.168.24.4:8080/login: dial tcp 192.168.24.4:8080: getsockopt: connection refused\n  Warning  BackOff     20m (x2 over 20m)  kubelet, iz8pscwd1fv6kprs1zw21kz  Back-off restarting failed container\n  Warning  FailedSync  20m (x2 over 20m)  kubelet, iz8pscwd1fv6kprs1zw21kz  Error syncing pod\n  Normal   Pulling     19m (x3 over 20h)  kubelet, iz8pscwd1fv6kprs1zw21kz  pulling image \"jenkins/jenkins:lts-alpine\"\n  Normal   Started     19m (x3 over 20h)  kubelet, iz8pscwd1fv6kprs1zw21kz  Started container\n  Normal   Pulled      19m (x3 over 20h)  kubelet, iz8pscwd1fv6kprs1zw21kz  Successfully pulled image \"jenkins/jenkins:lts-alpine\"\n  Normal   Created     19m (x3 over 20h)  kubelet, iz8pscwd1fv6kprs1zw21kz  Created container\n```\n#### 3. jenkins构建测试\n当前集群中使用的jenkins slave镜像只包含一个java运行环境来运行jenkins-slave.jar,在实际使用中需要自定义合适的镜像。选择自定义镜像之后需要修改插件的配置，同样name命名为jnlp替换默认镜像，arguments安装工具提示填写即可。\n![container][11]\n创建job，同时开始构建,k8s会在不同节点上创建pod来运行任务\n![此处输入图片的描述][13]\n构建全部完成后，资源随即被释放\n![此处输入图片的描述][14]\n\n**jenkins默认调度策略**\n1. 尝试在上次构建的节点上构建，指定某台slave之后会一直使用。\n2.当队列有2个构建时，不会立刻创建两个executor,而是先创建一个executor然后尝试等待executor空闲，目的是保证每个executor被充分利用。\n**k8s调度策略**\n1. 使用Pod.spec.nodeSelector根据label为pod选择node\n2.调度器scheduler有Predicates，Priorities两个阶段，分别负责节点过滤和评分排序，各个阶段都有k8s提供的检查项，我们可以自由组合。\n（比如PodFitsResources检查cpu内存等资源，PodFitsHostPorts检查端口占用，SelectorSpreadPriority要求一个服务尽量分散分布）[自定义schduler参考][15]\n**资源不足时会发生什么**\n当前集群中有3个节点，我在node2运行一个CPU占用限制在80%的程序,然后设置jenkins插件ContainerTemplate的request和limit均为`cpu 500m,内存500Mi`,（500m代表单核CPU的50%）看一下pod会怎么调度\nk8s仍然尝试在node2分配节点（为什么其他节点不行），结果POD处于pending状态：\n```\"status\": {\n    \"phase\": \"Pending\",\n    \"conditions\": [\n      {\n        \"type\": \"PodScheduled\",\n        \"status\": \"False\",\n        \"lastProbeTime\": null,\n        \"lastTransitionTime\": \"2017-12-09T08:29:10Z\",\n        \"reason\": \"Unschedulable\",\n        \"message\": \"No nodes are available that match all of the predicates: Insufficient cpu (4), PodToleratesNodeTaints (1).\"\n      }\n    ],\n    \"qosClass\": \"Guaranteed\"\n```\n最后pod被删除，而jenkins任务会阻塞一直到有其他空闲的slave出现。\n### **四 ，总结**\n本文介绍了在k8s集群部署jenkins服务的方式和k8s带来的资源管理便捷，由于我也是刚开始接触k8s,所用的实例只是搭建了用于测试的实验环境，离在实际生产环境中使用还有问题需要验证。\n\n\n  [1]: http://docs.kubernetes.org.cn/227.html\n  [2]: http://7xl4v5.com1.z0.glb.clouddn.com/jenkins-arch.png\n  [3]: http://7xl4v5.com1.z0.glb.clouddn.com/kongzhimianban.png\n  [4]: http://www.ruanyifeng.com/blog/2016/07/yaml.html\n  [5]: https://kubernetes.io/docs/concepts/storage/storage-classes/\n  [6]: http://7xl4v5.com1.z0.glb.clouddn.com/pvlife.png\n  [7]: http://7xl4v5.com1.z0.glb.clouddn.com/success.png\n  [8]: http://7xl4v5.com1.z0.glb.clouddn.com/config1.png\n  [9]: http://7xl4v5.com1.z0.glb.clouddn.com/config.png\n  [10]: https://yq.aliyun.com/articles/224376\n  [11]: http://7xl4v5.com1.z0.glb.clouddn.com/%E7%81%AB%E7%8B%90%E6%88%AA%E5%9B%BE_2017-12-08T08-06-23.616Z.png\n  [12]: http://7xl4v5.com1.z0.glb.clouddn.com/jobs.png\n  [13]: http://7xl4v5.com1.z0.glb.clouddn.com/pods1.png\n  [14]: http://7xl4v5.com1.z0.glb.clouddn.com/result2.png\n  [15]: http://dockone.io/article/2885","slug":"jenkins on kubernetes实践","published":1,"updated":"2018-11-21T16:22:49.717Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp57u41k001m2xpb4ocn0uiz","content":"<p><strong>jenkins是什么？</strong><br>Jenkins是一个开源的持续集成工具，可用于自动化的执行与构建，测试和交付或部署软件有关的各种任务,有非常丰富的插件支持。<br><strong>kubernetes是什么？</strong><br>Kubernetes是容器集群管理系统，是一个开源的平台，可以实现容器集群的自动化部署、自动扩缩容、维护等功能。<a href=\"http://docs.kubernetes.org.cn/227.html\" target=\"_blank\" rel=\"noopener\">这个视频生动地介绍了k8s</a><br><strong>jenkins on k8s 有什么好处？</strong><br>jenkins通过单Master多个Slave的方式提供服务，Master保存了任务的配置信息，安装的插件等等，而slave主要负责执行任务，在使用中存在以下几个问题：<br><a id=\"more\"></a></p>\n<ol>\n<li>当存在多个slave时，运行slave的机器难以统一管理，每次添加新节点时总要做大量的重复工作。</li>\n<li>由于不同业务的构建频率并不相同，在使用会发现有很多slave大多数时间都处于空闲状态，造成资源浪费</li>\n<li>jenkins默认采取保守的调度方式，造成某些slave的负载过高，任务不能平均分配<br><img src=\"http://7xl4v5.com1.z0.glb.clouddn.com/jenkins-arch.png\" alt=\"jenkins架构\"></li>\n</ol>\n<p>使用k8s管理jenkins具有以下优势：</p>\n<ol>\n<li>使用docker运行jenkins保证环境的一致性，可以根据不同业务选择合适的镜像</li>\n<li>k8s对抽象后的资源（pods）进行统一的管理调度，提供资源隔离和共享，使机器计算资源变得弹性可扩展,避免资源浪费。</li>\n<li>k8s提供容器的自愈功能，能够保证始终有一定数量的容器是可用的</li>\n<li>k8s默认的调度器提供了针对节点当前资源分配容器的调度策略，调度器支持插件化部署便于自定义。</li>\n</ol>\n<h3 id=\"一，搭建环境\"><a href=\"#一，搭建环境\" class=\"headerlink\" title=\"一，搭建环境\"></a><strong>一，搭建环境</strong></h3><h4 id=\"工具准备\"><a href=\"#工具准备\" class=\"headerlink\" title=\"工具准备\"></a>工具准备</h4><blockquote>\n<p>kubernetes v1.8.4<br>docker v1.12.6<br>jenkins master镜像 jenkins/jenkins:lts（v2.73.3）<br>slave镜像 jenkinsci/jnlp-slave<br>Kubernetes plugin (v1.1)</p>\n</blockquote>\n<h4 id=\"安装kubernetes集群\"><a href=\"#安装kubernetes集群\" class=\"headerlink\" title=\"安装kubernetes集群\"></a>安装kubernetes集群</h4><p>中文教程：<a href=\"https://www.kubernetes.org.cn/2906.html\" target=\"_blank\" rel=\"noopener\">https://www.kubernetes.org.cn/2906.html</a><br>安装成功之后访问dashboard地址就可以看到集群的控制面板：<br><img src=\"http://7xl4v5.com1.z0.glb.clouddn.com/kongzhimianban.png\" alt=\"dashboard\"><br>集群安装完成后，创建命名空间kubernetes-plugin<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl create namespace kubernetes-plugin</span><br><span class=\"line\">kubectl config set-context $(kubectl config current-context) --namespace=kubernetes-plugin</span><br><span class=\"line\">kubectl create -f service-account.yml</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"二，创建StatefulSet\"><a href=\"#二，创建StatefulSet\" class=\"headerlink\" title=\"二，创建StatefulSet\"></a><strong>二，创建StatefulSet</strong></h3><blockquote>\n<p><strong>StatefulSet(有状态副本集)</strong>：Deployments适用于运行无状态应用，StatefulSet则为有状态的应用提供了支持，可以为应用提供有序的部署和扩展，稳定的持久化存储，我们使用SS来运行jenkins master。</p>\n</blockquote>\n<p>创建完整的Stateful Set需要依次创建一下对象：<br>1、Persistent Volume<br>2、Persistent Volume Claim<br>3、StatefulSet<br>4、Service</p>\n<h4 id=\"创建PersistentVolume：\"><a href=\"#创建PersistentVolume：\" class=\"headerlink\" title=\"创建PersistentVolume：\"></a><strong>创建PersistentVolume：</strong></h4><p>为了保存应用运行时的数据需要先创建k8s的卷文件，K8s中存在Volume和PersistentVolume两种类型：</p>\n<blockquote>\n<ul>\n<li>Volume：与docker中的volume不同在于Volume生命周期是和pod绑定的，与pod中的container无关。k8s为Volume提供了多种类型文件系统（cephfs,nfs…,简单起见我直接选择了hostPath，使用的node节点本地的存储系统）</li>\n<li>PersistentVolume:从名字可以看出来，PV的生命周期独立于使用它的pod，不会像volume随pod消失而消失，而是做为一个集群中的资源存在（像node节点一样），同时PV屏蔽了使用具体存储系统的细节。</li>\n</ul>\n</blockquote>\n<p>k8s中的对象都是通过<a href=\"http://www.ruanyifeng.com/blog/2016/07/yaml.html\" target=\"_blank\" rel=\"noopener\">yaml文件</a>来定义的，首先创建名为<code>jenkins-volume.yml</code>的文件:</p>\n<p><strong>注意</strong>：PV的创建有静态，动态两种方式，动态创建可以减少管理员的操作步骤，需要提供指定的<a href=\"https://kubernetes.io/docs/concepts/storage/storage-classes/\" target=\"_blank\" rel=\"noopener\">StorageClass</a>。为了测试方便，所以我们直接选择静态创建，manual是一个不存在的storage class<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kind: PersistentVolume</span><br><span class=\"line\">apiVersion: v1</span><br><span class=\"line\">metadata:</span><br><span class=\"line\">  name: jenkins-volume</span><br><span class=\"line\">  labels:</span><br><span class=\"line\">    type: local</span><br><span class=\"line\">spec:</span><br><span class=\"line\">  storageClassName: manual</span><br><span class=\"line\">  capacity:</span><br><span class=\"line\">    storage: 10Gi</span><br><span class=\"line\">  accessModes:</span><br><span class=\"line\">    - ReadWriteOnce</span><br><span class=\"line\">  hostPath:</span><br><span class=\"line\">    path: &quot;/tmp/data&quot;</span><br></pre></td></tr></table></figure></p>\n<p>master节点执行下面的命令，PV就手动创建完了<br><code>kubectl create -f jenkins-volume1.yaml</code></p>\n<h4 id=\"创建PersistentVolumeClaim：\"><a href=\"#创建PersistentVolumeClaim：\" class=\"headerlink\" title=\"创建PersistentVolumeClaim：\"></a><strong>创建PersistentVolumeClaim：</strong></h4><blockquote>\n<p>PersistentVolumeClaim(PVC):<br>持久化存储卷索取，如果说PV是集群中的资源，PVC就是资源的消费者，PVC可以指定需要的资源大小和访问方式,pod不会和PV直接接触，而是通过PVC来请求资源，PV的生成阶段叫做provision,生成PV后会绑定到PVC对象，然后才能被其他对象使用。</p>\n</blockquote>\n<p>PV和PVC的生命周期如下图：<br><img src=\"http://7xl4v5.com1.z0.glb.clouddn.com/pvlife.png\" alt=\"pv life\"></p>\n<p>创建文件<code>jenkins-claim.yaml</code><br><strong>注意：</strong> name必须为jenkins-home-jenkins-0否则会绑定失败<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kind: PersistentVolumeClaim</span><br><span class=\"line\">apiVersion: v1</span><br><span class=\"line\">metadata:</span><br><span class=\"line\">  name: jenkins-home-jenkins-0</span><br><span class=\"line\">spec:</span><br><span class=\"line\">  storageClassName: manual</span><br><span class=\"line\">  accessModes:</span><br><span class=\"line\">    - ReadWriteOnce</span><br><span class=\"line\">  resources:</span><br><span class=\"line\">    requests:</span><br><span class=\"line\">      storage: 3Gi</span><br></pre></td></tr></table></figure></p>\n<p>执行命令<code>kubectl create -f jenkins-claim.yaml</code><br>然后查看PVC是否创建成功，status为bound说明PVC已经绑定<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@master ~]# kubectl describe pvc jenkins-home-jenkins-0</span><br><span class=\"line\">Name:          jenkins-home-jenkins-0</span><br><span class=\"line\">Namespace:     kubernetes-plugin</span><br><span class=\"line\">StorageClass:  manual</span><br><span class=\"line\">Status:        Bound</span><br><span class=\"line\">Volume:        jenkins-volume</span><br><span class=\"line\">Labels:        &lt;none&gt;</span><br><span class=\"line\">Annotations:   pv.kubernetes.io/bind-completed=yes</span><br><span class=\"line\">               pv.kubernetes.io/bound-by-controller=yes</span><br><span class=\"line\">Capacity:      10Gi</span><br><span class=\"line\">Access Modes:  RWO</span><br><span class=\"line\">Events:        &lt;none&gt;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"创建StatefulSet和Service：\"><a href=\"#创建StatefulSet和Service：\" class=\"headerlink\" title=\"创建StatefulSet和Service：\"></a><strong>创建StatefulSet和Service：</strong></h4><p>从kubernetes-plugin github仓库下载jenkins.yml文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://raw.githubusercontent.com/jenkinsci/kubernetes-plugin/master/src/main/kubernetes/jenkins.yml</span><br></pre></td></tr></table></figure></p>\n<p>修改jenkins.yml：<br>去掉87行<code>externalTrafficPolicy: Local</code>（这是GKE使用的）<br>修改83行<code>type: LoadBalancer</code>改为<code>type: NodePort</code></p>\n<p><strong>注意：</strong><br>service type=ClusterIP时只允许从集群内部访问， type设置为NodePort是为了从集群外的机器访问jenkins,请谨慎使用，开启NodePort会在所有节点（含master）的统一固定端口开放服务。</p>\n<p>执行命令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@master ~]# kubectl create -f jenkins.yml </span><br><span class=\"line\">statefulset &quot;jenkins&quot; created</span><br><span class=\"line\">service &quot;jenkins&quot; created</span><br></pre></td></tr></table></figure></p>\n<p>访问jenkins master,地址为<code>masterip:32058</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#查看映射的端口</span><br><span class=\"line\">[root@master ~]# kubectl get service jenkins</span><br><span class=\"line\">NAME      TYPE       CLUSTER-IP    EXTERNAL-IP   PORT(S)                        AGE</span><br><span class=\"line\">jenkins   NodePort   10.96.82.68   &lt;none&gt;        80:32058/TCP,50000:30345/TCP   1m</span><br></pre></td></tr></table></figure></p>\n<p>查看pod : jenkins-0的容器日志，粘贴下面的密码进入jenkins,jenkins安装完成。</p>\n<blockquote>\n<p>Jenkins initial setup is required. An admin user has been created and a password generated.<br>Please use the following password to proceed to installation:<br>70aa7b41ba894855abccd09306625b8a </p>\n</blockquote>\n<p>刷新dashboard，切换命名空间到kubernetes-plugin,结果如下：<br><img src=\"http://7xl4v5.com1.z0.glb.clouddn.com/success.png\" alt=\"success\"></p>\n<h3 id=\"问题分析\"><a href=\"#问题分析\" class=\"headerlink\" title=\"问题分析\"></a>问题分析</h3><p>1.创建stateful set时失败，提示”PersistentVolumeClaim is not bound: “jenkins-home-jenkins-0”：”<br>因为采用静态创建PV时，StatefulSet会按照固定名称查找PVC，PVC的名字要满足</p>\n<blockquote>\n<p>PVC_name == volumeClaimTemplates_name + “-“ + pod_name</p>\n</blockquote>\n<p>这里的名字就是<code>jenkins-home-jenkins-0</code></p>\n<p>2.pod启动失败，jenkins用户没有目录权限<br>错误提示”touch: cannot touch ‘/var/jenkins_home/copy_reference_file.log’: Permission denied<br>Can not write to /var/jenkins_home/copy_reference_file.log. Wrong volume permissions?”<br>要确保节点目录开放权限,在node上执行命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo chown -R 1000:1000 /var/jenkins_home/</span><br><span class=\"line\">sudo chown -R 1000:1000 /tmp/data</span><br><span class=\"line\">##如果仍然失败，尝试在node上重启docker</span><br><span class=\"line\">systemctl restart docker</span><br></pre></td></tr></table></figure></p>\n<p>注意pv指定的hostPath权限也要修改，否则是无效的</p>\n<h3 id=\"三-，配置jenkins\"><a href=\"#三-，配置jenkins\" class=\"headerlink\" title=\"三 ，配置jenkins\"></a>三 ，配置jenkins</h3><h4 id=\"创建jenkins服务账号\"><a href=\"#创建jenkins服务账号\" class=\"headerlink\" title=\"创建jenkins服务账号\"></a>创建jenkins服务账号</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://raw.githubusercontent.com/jenkinsci/kubernetes-plugin/master/src/main/kubernetes/service-account.yml</span><br><span class=\"line\">kubectl create -f service-account.yml</span><br></pre></td></tr></table></figure>\n<h4 id=\"配置插件\"><a href=\"#配置插件\" class=\"headerlink\" title=\"配置插件\"></a>配置插件</h4><p>访问<code>http://masterip:32058/pluginManager/</code>,搜索插件Kubernetes plugin安装；<br>访问 <a href=\"http://masterip:32058/configure\" target=\"_blank\" rel=\"noopener\">http://masterip:32058/configure</a><br>选择新建云–kubernetes,在URl填写api server地址，<br>执行kubectl describe命令，复制output中的token，填入到 ‘Kubernetes server certificate key’<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@master ~]# kubectl get secret </span><br><span class=\"line\">NAME                  TYPE                                  DATA      AGE</span><br><span class=\"line\">default-token-4kb54   kubernetes.io/service-account-token   3         1d</span><br><span class=\"line\">jenkins-token-wzbsx   kubernetes.io/service-account-token   3         1d</span><br><span class=\"line\">[root@master ~]# kubectl describe secret/jenkins-token-wzbsx</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n<p>jenkins url,tunnel填写service的CLUSTER-IP即可，结果如图：<br><img src=\"http://7xl4v5.com1.z0.glb.clouddn.com/config1.png\" alt=\"peizhi1\"><br>选择add pod template，填写下面的内容，retain slave可以设置运行jenkins slave 的container空闲后能存活多久。<br><img src=\"http://7xl4v5.com1.z0.glb.clouddn.com/config.png\" alt=\"content\"><br>插件配置完成。</p>\n<h3 id=\"四-，测试\"><a href=\"#四-，测试\" class=\"headerlink\" title=\"四 ，测试\"></a>四 ，测试</h3><h4 id=\"1-扩容测试\"><a href=\"#1-扩容测试\" class=\"headerlink\" title=\"1. 扩容测试\"></a>1. 扩容测试</h4><p><strong>StatefulSet扩容：</strong><br>首先需要手动创建PV，PVC(见第二步),然后执行扩容命令<br><code>kubectl scale statefulset/jenkins --replicas=２</code><br>查看StatefulSet,此时已经拥有两个master节点，访问service时会<strong>随机</strong>将请求发送给后端的master。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@master ~]# kubectl get statefulset/jenkins </span><br><span class=\"line\">NAME      DESIRED   CURRENT   AGE</span><br><span class=\"line\">jenkins   2         2         5d</span><br></pre></td></tr></table></figure></p>\n<p>虽然通过k8s可以轻松实现jenkins master节点的拓展，但是由于jenkins存储数据的方式通过本地文件存储，master之间的数据同步还是一个麻烦的问题，参考<a href=\"https://yq.aliyun.com/articles/224376\" target=\"_blank\" rel=\"noopener\">jenkins存储模型</a>。</p>\n<p><em>jenkins master上保存的文件：</em><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls /temp/data</span><br><span class=\"line\">jenkins.CLI.xml</span><br><span class=\"line\">jenkins.install.InstallUtil.lastExecVersion</span><br><span class=\"line\">jenkins.install.UpgradeWizard.state</span><br><span class=\"line\">jenkins.model.ArtifactManagerConfiguration.xml</span><br><span class=\"line\">jenkins.model.JenkinsLocationConfiguration.xml</span><br><span class=\"line\">jobs</span><br><span class=\"line\">logs</span><br><span class=\"line\">nodeMonitors.xml</span><br><span class=\"line\">nodes</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"2-高可用测试\"><a href=\"#2-高可用测试\" class=\"headerlink\" title=\"2. 高可用测试\"></a>2. 高可用测试</h4><p>现在stateful set中已经有两个pod,在jenkins-1所在的节点执行<code>docker stop</code>停止运行jenkins-master的容器，同时在命令行查看pod的状态，可以看到jenkins-1异常（Error状态）之后慢慢恢复了运行状态（Running）：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@master ~]# kubectl get pods -w</span><br><span class=\"line\">NAME        READY     STATUS    RESTARTS   AGE</span><br><span class=\"line\">jenkins-0   1/1       Running   0          1d</span><br><span class=\"line\">jenkins-1   0/1       Running   1         20h</span><br><span class=\"line\">jenkins-1   1/1       Running   1         20h</span><br><span class=\"line\">jenkins-1   0/1       Error     1         20h</span><br><span class=\"line\">jenkins-1   0/1       CrashLoopBackOff   1         20h</span><br><span class=\"line\">jenkins-1   0/1       Running   2         20h</span><br><span class=\"line\">jenkins-1   1/1       Running   2         20h</span><br></pre></td></tr></table></figure></p>\n<p><code>kubectl describe pod jenkins-1</code>查看pod的事件日志，k8s通过探针(probe)接口检测到服务停止之后自动执行了拉取镜像，重启container的操作。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Events:</span><br><span class=\"line\">  Type     Reason      Age                From                              Message</span><br><span class=\"line\">  ----     ------      ----               ----                              -------</span><br><span class=\"line\">  Warning  Unhealthy   27m (x2 over 27m)  kubelet, iz8pscwd1fv6kprs1zw21kz  Readiness probe failed: HTTP probe failed with statuscode: 503</span><br><span class=\"line\">  Warning  Unhealthy   27m (x2 over 27m)  kubelet, iz8pscwd1fv6kprs1zw21kz  Liveness probe failed: HTTP probe failed with statuscode: 503</span><br><span class=\"line\">  Warning  Unhealthy   24m                kubelet, iz8pscwd1fv6kprs1zw21kz  Readiness probe failed: Get http://192.168.24.4:8080/login: dial tcp 192.168.24.4:8080: getsockopt: connection refused</span><br><span class=\"line\">  Warning  BackOff     20m (x2 over 20m)  kubelet, iz8pscwd1fv6kprs1zw21kz  Back-off restarting failed container</span><br><span class=\"line\">  Warning  FailedSync  20m (x2 over 20m)  kubelet, iz8pscwd1fv6kprs1zw21kz  Error syncing pod</span><br><span class=\"line\">  Normal   Pulling     19m (x3 over 20h)  kubelet, iz8pscwd1fv6kprs1zw21kz  pulling image &quot;jenkins/jenkins:lts-alpine&quot;</span><br><span class=\"line\">  Normal   Started     19m (x3 over 20h)  kubelet, iz8pscwd1fv6kprs1zw21kz  Started container</span><br><span class=\"line\">  Normal   Pulled      19m (x3 over 20h)  kubelet, iz8pscwd1fv6kprs1zw21kz  Successfully pulled image &quot;jenkins/jenkins:lts-alpine&quot;</span><br><span class=\"line\">  Normal   Created     19m (x3 over 20h)  kubelet, iz8pscwd1fv6kprs1zw21kz  Created container</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"3-jenkins构建测试\"><a href=\"#3-jenkins构建测试\" class=\"headerlink\" title=\"3. jenkins构建测试\"></a>3. jenkins构建测试</h4><p>当前集群中使用的jenkins slave镜像只包含一个java运行环境来运行jenkins-slave.jar,在实际使用中需要自定义合适的镜像。选择自定义镜像之后需要修改插件的配置，同样name命名为jnlp替换默认镜像，arguments安装工具提示填写即可。<br><img src=\"http://7xl4v5.com1.z0.glb.clouddn.com/%E7%81%AB%E7%8B%90%E6%88%AA%E5%9B%BE_2017-12-08T08-06-23.616Z.png\" alt=\"container\"><br>创建job，同时开始构建,k8s会在不同节点上创建pod来运行任务<br><img src=\"http://7xl4v5.com1.z0.glb.clouddn.com/pods1.png\" alt=\"此处输入图片的描述\"><br>构建全部完成后，资源随即被释放<br><img src=\"http://7xl4v5.com1.z0.glb.clouddn.com/result2.png\" alt=\"此处输入图片的描述\"></p>\n<p><strong>jenkins默认调度策略</strong></p>\n<ol>\n<li>尝试在上次构建的节点上构建，指定某台slave之后会一直使用。<br>2.当队列有2个构建时，不会立刻创建两个executor,而是先创建一个executor然后尝试等待executor空闲，目的是保证每个executor被充分利用。<br><strong>k8s调度策略</strong></li>\n<li>使用Pod.spec.nodeSelector根据label为pod选择node<br>2.调度器scheduler有Predicates，Priorities两个阶段，分别负责节点过滤和评分排序，各个阶段都有k8s提供的检查项，我们可以自由组合。<br>（比如PodFitsResources检查cpu内存等资源，PodFitsHostPorts检查端口占用，SelectorSpreadPriority要求一个服务尽量分散分布）<a href=\"http://dockone.io/article/2885\" target=\"_blank\" rel=\"noopener\">自定义schduler参考</a><br><strong>资源不足时会发生什么</strong><br>当前集群中有3个节点，我在node2运行一个CPU占用限制在80%的程序,然后设置jenkins插件ContainerTemplate的request和limit均为<code>cpu 500m,内存500Mi</code>,（500m代表单核CPU的50%）看一下pod会怎么调度<br>k8s仍然尝试在node2分配节点（为什么其他节点不行），结果POD处于pending状态：<figure class=\"highlight plain\"><figcaption><span>&#123;</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;phase&quot;: &quot;Pending&quot;,</span><br><span class=\"line\">&quot;conditions&quot;: [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    &quot;type&quot;: &quot;PodScheduled&quot;,</span><br><span class=\"line\">    &quot;status&quot;: &quot;False&quot;,</span><br><span class=\"line\">    &quot;lastProbeTime&quot;: null,</span><br><span class=\"line\">    &quot;lastTransitionTime&quot;: &quot;2017-12-09T08:29:10Z&quot;,</span><br><span class=\"line\">    &quot;reason&quot;: &quot;Unschedulable&quot;,</span><br><span class=\"line\">    &quot;message&quot;: &quot;No nodes are available that match all of the predicates: Insufficient cpu (4), PodToleratesNodeTaints (1).&quot;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">],</span><br><span class=\"line\">&quot;qosClass&quot;: &quot;Guaranteed&quot;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>最后pod被删除，而jenkins任务会阻塞一直到有其他空闲的slave出现。</p>\n<h3 id=\"四-，总结\"><a href=\"#四-，总结\" class=\"headerlink\" title=\"四 ，总结\"></a><strong>四 ，总结</strong></h3><p>本文介绍了在k8s集群部署jenkins服务的方式和k8s带来的资源管理便捷，由于我也是刚开始接触k8s,所用的实例只是搭建了用于测试的实验环境，离在实际生产环境中使用还有问题需要验证。</p>\n","site":{"data":{}},"excerpt":"<p><strong>jenkins是什么？</strong><br>Jenkins是一个开源的持续集成工具，可用于自动化的执行与构建，测试和交付或部署软件有关的各种任务,有非常丰富的插件支持。<br><strong>kubernetes是什么？</strong><br>Kubernetes是容器集群管理系统，是一个开源的平台，可以实现容器集群的自动化部署、自动扩缩容、维护等功能。<a href=\"http://docs.kubernetes.org.cn/227.html\" target=\"_blank\" rel=\"noopener\">这个视频生动地介绍了k8s</a><br><strong>jenkins on k8s 有什么好处？</strong><br>jenkins通过单Master多个Slave的方式提供服务，Master保存了任务的配置信息，安装的插件等等，而slave主要负责执行任务，在使用中存在以下几个问题：<br>","more":"</p>\n<ol>\n<li>当存在多个slave时，运行slave的机器难以统一管理，每次添加新节点时总要做大量的重复工作。</li>\n<li>由于不同业务的构建频率并不相同，在使用会发现有很多slave大多数时间都处于空闲状态，造成资源浪费</li>\n<li>jenkins默认采取保守的调度方式，造成某些slave的负载过高，任务不能平均分配<br><img src=\"http://7xl4v5.com1.z0.glb.clouddn.com/jenkins-arch.png\" alt=\"jenkins架构\"></li>\n</ol>\n<p>使用k8s管理jenkins具有以下优势：</p>\n<ol>\n<li>使用docker运行jenkins保证环境的一致性，可以根据不同业务选择合适的镜像</li>\n<li>k8s对抽象后的资源（pods）进行统一的管理调度，提供资源隔离和共享，使机器计算资源变得弹性可扩展,避免资源浪费。</li>\n<li>k8s提供容器的自愈功能，能够保证始终有一定数量的容器是可用的</li>\n<li>k8s默认的调度器提供了针对节点当前资源分配容器的调度策略，调度器支持插件化部署便于自定义。</li>\n</ol>\n<h3 id=\"一，搭建环境\"><a href=\"#一，搭建环境\" class=\"headerlink\" title=\"一，搭建环境\"></a><strong>一，搭建环境</strong></h3><h4 id=\"工具准备\"><a href=\"#工具准备\" class=\"headerlink\" title=\"工具准备\"></a>工具准备</h4><blockquote>\n<p>kubernetes v1.8.4<br>docker v1.12.6<br>jenkins master镜像 jenkins/jenkins:lts（v2.73.3）<br>slave镜像 jenkinsci/jnlp-slave<br>Kubernetes plugin (v1.1)</p>\n</blockquote>\n<h4 id=\"安装kubernetes集群\"><a href=\"#安装kubernetes集群\" class=\"headerlink\" title=\"安装kubernetes集群\"></a>安装kubernetes集群</h4><p>中文教程：<a href=\"https://www.kubernetes.org.cn/2906.html\" target=\"_blank\" rel=\"noopener\">https://www.kubernetes.org.cn/2906.html</a><br>安装成功之后访问dashboard地址就可以看到集群的控制面板：<br><img src=\"http://7xl4v5.com1.z0.glb.clouddn.com/kongzhimianban.png\" alt=\"dashboard\"><br>集群安装完成后，创建命名空间kubernetes-plugin<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl create namespace kubernetes-plugin</span><br><span class=\"line\">kubectl config set-context $(kubectl config current-context) --namespace=kubernetes-plugin</span><br><span class=\"line\">kubectl create -f service-account.yml</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"二，创建StatefulSet\"><a href=\"#二，创建StatefulSet\" class=\"headerlink\" title=\"二，创建StatefulSet\"></a><strong>二，创建StatefulSet</strong></h3><blockquote>\n<p><strong>StatefulSet(有状态副本集)</strong>：Deployments适用于运行无状态应用，StatefulSet则为有状态的应用提供了支持，可以为应用提供有序的部署和扩展，稳定的持久化存储，我们使用SS来运行jenkins master。</p>\n</blockquote>\n<p>创建完整的Stateful Set需要依次创建一下对象：<br>1、Persistent Volume<br>2、Persistent Volume Claim<br>3、StatefulSet<br>4、Service</p>\n<h4 id=\"创建PersistentVolume：\"><a href=\"#创建PersistentVolume：\" class=\"headerlink\" title=\"创建PersistentVolume：\"></a><strong>创建PersistentVolume：</strong></h4><p>为了保存应用运行时的数据需要先创建k8s的卷文件，K8s中存在Volume和PersistentVolume两种类型：</p>\n<blockquote>\n<ul>\n<li>Volume：与docker中的volume不同在于Volume生命周期是和pod绑定的，与pod中的container无关。k8s为Volume提供了多种类型文件系统（cephfs,nfs…,简单起见我直接选择了hostPath，使用的node节点本地的存储系统）</li>\n<li>PersistentVolume:从名字可以看出来，PV的生命周期独立于使用它的pod，不会像volume随pod消失而消失，而是做为一个集群中的资源存在（像node节点一样），同时PV屏蔽了使用具体存储系统的细节。</li>\n</ul>\n</blockquote>\n<p>k8s中的对象都是通过<a href=\"http://www.ruanyifeng.com/blog/2016/07/yaml.html\" target=\"_blank\" rel=\"noopener\">yaml文件</a>来定义的，首先创建名为<code>jenkins-volume.yml</code>的文件:</p>\n<p><strong>注意</strong>：PV的创建有静态，动态两种方式，动态创建可以减少管理员的操作步骤，需要提供指定的<a href=\"https://kubernetes.io/docs/concepts/storage/storage-classes/\" target=\"_blank\" rel=\"noopener\">StorageClass</a>。为了测试方便，所以我们直接选择静态创建，manual是一个不存在的storage class<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kind: PersistentVolume</span><br><span class=\"line\">apiVersion: v1</span><br><span class=\"line\">metadata:</span><br><span class=\"line\">  name: jenkins-volume</span><br><span class=\"line\">  labels:</span><br><span class=\"line\">    type: local</span><br><span class=\"line\">spec:</span><br><span class=\"line\">  storageClassName: manual</span><br><span class=\"line\">  capacity:</span><br><span class=\"line\">    storage: 10Gi</span><br><span class=\"line\">  accessModes:</span><br><span class=\"line\">    - ReadWriteOnce</span><br><span class=\"line\">  hostPath:</span><br><span class=\"line\">    path: &quot;/tmp/data&quot;</span><br></pre></td></tr></table></figure></p>\n<p>master节点执行下面的命令，PV就手动创建完了<br><code>kubectl create -f jenkins-volume1.yaml</code></p>\n<h4 id=\"创建PersistentVolumeClaim：\"><a href=\"#创建PersistentVolumeClaim：\" class=\"headerlink\" title=\"创建PersistentVolumeClaim：\"></a><strong>创建PersistentVolumeClaim：</strong></h4><blockquote>\n<p>PersistentVolumeClaim(PVC):<br>持久化存储卷索取，如果说PV是集群中的资源，PVC就是资源的消费者，PVC可以指定需要的资源大小和访问方式,pod不会和PV直接接触，而是通过PVC来请求资源，PV的生成阶段叫做provision,生成PV后会绑定到PVC对象，然后才能被其他对象使用。</p>\n</blockquote>\n<p>PV和PVC的生命周期如下图：<br><img src=\"http://7xl4v5.com1.z0.glb.clouddn.com/pvlife.png\" alt=\"pv life\"></p>\n<p>创建文件<code>jenkins-claim.yaml</code><br><strong>注意：</strong> name必须为jenkins-home-jenkins-0否则会绑定失败<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kind: PersistentVolumeClaim</span><br><span class=\"line\">apiVersion: v1</span><br><span class=\"line\">metadata:</span><br><span class=\"line\">  name: jenkins-home-jenkins-0</span><br><span class=\"line\">spec:</span><br><span class=\"line\">  storageClassName: manual</span><br><span class=\"line\">  accessModes:</span><br><span class=\"line\">    - ReadWriteOnce</span><br><span class=\"line\">  resources:</span><br><span class=\"line\">    requests:</span><br><span class=\"line\">      storage: 3Gi</span><br></pre></td></tr></table></figure></p>\n<p>执行命令<code>kubectl create -f jenkins-claim.yaml</code><br>然后查看PVC是否创建成功，status为bound说明PVC已经绑定<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@master ~]# kubectl describe pvc jenkins-home-jenkins-0</span><br><span class=\"line\">Name:          jenkins-home-jenkins-0</span><br><span class=\"line\">Namespace:     kubernetes-plugin</span><br><span class=\"line\">StorageClass:  manual</span><br><span class=\"line\">Status:        Bound</span><br><span class=\"line\">Volume:        jenkins-volume</span><br><span class=\"line\">Labels:        &lt;none&gt;</span><br><span class=\"line\">Annotations:   pv.kubernetes.io/bind-completed=yes</span><br><span class=\"line\">               pv.kubernetes.io/bound-by-controller=yes</span><br><span class=\"line\">Capacity:      10Gi</span><br><span class=\"line\">Access Modes:  RWO</span><br><span class=\"line\">Events:        &lt;none&gt;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"创建StatefulSet和Service：\"><a href=\"#创建StatefulSet和Service：\" class=\"headerlink\" title=\"创建StatefulSet和Service：\"></a><strong>创建StatefulSet和Service：</strong></h4><p>从kubernetes-plugin github仓库下载jenkins.yml文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://raw.githubusercontent.com/jenkinsci/kubernetes-plugin/master/src/main/kubernetes/jenkins.yml</span><br></pre></td></tr></table></figure></p>\n<p>修改jenkins.yml：<br>去掉87行<code>externalTrafficPolicy: Local</code>（这是GKE使用的）<br>修改83行<code>type: LoadBalancer</code>改为<code>type: NodePort</code></p>\n<p><strong>注意：</strong><br>service type=ClusterIP时只允许从集群内部访问， type设置为NodePort是为了从集群外的机器访问jenkins,请谨慎使用，开启NodePort会在所有节点（含master）的统一固定端口开放服务。</p>\n<p>执行命令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@master ~]# kubectl create -f jenkins.yml </span><br><span class=\"line\">statefulset &quot;jenkins&quot; created</span><br><span class=\"line\">service &quot;jenkins&quot; created</span><br></pre></td></tr></table></figure></p>\n<p>访问jenkins master,地址为<code>masterip:32058</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#查看映射的端口</span><br><span class=\"line\">[root@master ~]# kubectl get service jenkins</span><br><span class=\"line\">NAME      TYPE       CLUSTER-IP    EXTERNAL-IP   PORT(S)                        AGE</span><br><span class=\"line\">jenkins   NodePort   10.96.82.68   &lt;none&gt;        80:32058/TCP,50000:30345/TCP   1m</span><br></pre></td></tr></table></figure></p>\n<p>查看pod : jenkins-0的容器日志，粘贴下面的密码进入jenkins,jenkins安装完成。</p>\n<blockquote>\n<p>Jenkins initial setup is required. An admin user has been created and a password generated.<br>Please use the following password to proceed to installation:<br>70aa7b41ba894855abccd09306625b8a </p>\n</blockquote>\n<p>刷新dashboard，切换命名空间到kubernetes-plugin,结果如下：<br><img src=\"http://7xl4v5.com1.z0.glb.clouddn.com/success.png\" alt=\"success\"></p>\n<h3 id=\"问题分析\"><a href=\"#问题分析\" class=\"headerlink\" title=\"问题分析\"></a>问题分析</h3><p>1.创建stateful set时失败，提示”PersistentVolumeClaim is not bound: “jenkins-home-jenkins-0”：”<br>因为采用静态创建PV时，StatefulSet会按照固定名称查找PVC，PVC的名字要满足</p>\n<blockquote>\n<p>PVC_name == volumeClaimTemplates_name + “-“ + pod_name</p>\n</blockquote>\n<p>这里的名字就是<code>jenkins-home-jenkins-0</code></p>\n<p>2.pod启动失败，jenkins用户没有目录权限<br>错误提示”touch: cannot touch ‘/var/jenkins_home/copy_reference_file.log’: Permission denied<br>Can not write to /var/jenkins_home/copy_reference_file.log. Wrong volume permissions?”<br>要确保节点目录开放权限,在node上执行命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo chown -R 1000:1000 /var/jenkins_home/</span><br><span class=\"line\">sudo chown -R 1000:1000 /tmp/data</span><br><span class=\"line\">##如果仍然失败，尝试在node上重启docker</span><br><span class=\"line\">systemctl restart docker</span><br></pre></td></tr></table></figure></p>\n<p>注意pv指定的hostPath权限也要修改，否则是无效的</p>\n<h3 id=\"三-，配置jenkins\"><a href=\"#三-，配置jenkins\" class=\"headerlink\" title=\"三 ，配置jenkins\"></a>三 ，配置jenkins</h3><h4 id=\"创建jenkins服务账号\"><a href=\"#创建jenkins服务账号\" class=\"headerlink\" title=\"创建jenkins服务账号\"></a>创建jenkins服务账号</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://raw.githubusercontent.com/jenkinsci/kubernetes-plugin/master/src/main/kubernetes/service-account.yml</span><br><span class=\"line\">kubectl create -f service-account.yml</span><br></pre></td></tr></table></figure>\n<h4 id=\"配置插件\"><a href=\"#配置插件\" class=\"headerlink\" title=\"配置插件\"></a>配置插件</h4><p>访问<code>http://masterip:32058/pluginManager/</code>,搜索插件Kubernetes plugin安装；<br>访问 <a href=\"http://masterip:32058/configure\" target=\"_blank\" rel=\"noopener\">http://masterip:32058/configure</a><br>选择新建云–kubernetes,在URl填写api server地址，<br>执行kubectl describe命令，复制output中的token，填入到 ‘Kubernetes server certificate key’<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@master ~]# kubectl get secret </span><br><span class=\"line\">NAME                  TYPE                                  DATA      AGE</span><br><span class=\"line\">default-token-4kb54   kubernetes.io/service-account-token   3         1d</span><br><span class=\"line\">jenkins-token-wzbsx   kubernetes.io/service-account-token   3         1d</span><br><span class=\"line\">[root@master ~]# kubectl describe secret/jenkins-token-wzbsx</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n<p>jenkins url,tunnel填写service的CLUSTER-IP即可，结果如图：<br><img src=\"http://7xl4v5.com1.z0.glb.clouddn.com/config1.png\" alt=\"peizhi1\"><br>选择add pod template，填写下面的内容，retain slave可以设置运行jenkins slave 的container空闲后能存活多久。<br><img src=\"http://7xl4v5.com1.z0.glb.clouddn.com/config.png\" alt=\"content\"><br>插件配置完成。</p>\n<h3 id=\"四-，测试\"><a href=\"#四-，测试\" class=\"headerlink\" title=\"四 ，测试\"></a>四 ，测试</h3><h4 id=\"1-扩容测试\"><a href=\"#1-扩容测试\" class=\"headerlink\" title=\"1. 扩容测试\"></a>1. 扩容测试</h4><p><strong>StatefulSet扩容：</strong><br>首先需要手动创建PV，PVC(见第二步),然后执行扩容命令<br><code>kubectl scale statefulset/jenkins --replicas=２</code><br>查看StatefulSet,此时已经拥有两个master节点，访问service时会<strong>随机</strong>将请求发送给后端的master。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@master ~]# kubectl get statefulset/jenkins </span><br><span class=\"line\">NAME      DESIRED   CURRENT   AGE</span><br><span class=\"line\">jenkins   2         2         5d</span><br></pre></td></tr></table></figure></p>\n<p>虽然通过k8s可以轻松实现jenkins master节点的拓展，但是由于jenkins存储数据的方式通过本地文件存储，master之间的数据同步还是一个麻烦的问题，参考<a href=\"https://yq.aliyun.com/articles/224376\" target=\"_blank\" rel=\"noopener\">jenkins存储模型</a>。</p>\n<p><em>jenkins master上保存的文件：</em><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls /temp/data</span><br><span class=\"line\">jenkins.CLI.xml</span><br><span class=\"line\">jenkins.install.InstallUtil.lastExecVersion</span><br><span class=\"line\">jenkins.install.UpgradeWizard.state</span><br><span class=\"line\">jenkins.model.ArtifactManagerConfiguration.xml</span><br><span class=\"line\">jenkins.model.JenkinsLocationConfiguration.xml</span><br><span class=\"line\">jobs</span><br><span class=\"line\">logs</span><br><span class=\"line\">nodeMonitors.xml</span><br><span class=\"line\">nodes</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"2-高可用测试\"><a href=\"#2-高可用测试\" class=\"headerlink\" title=\"2. 高可用测试\"></a>2. 高可用测试</h4><p>现在stateful set中已经有两个pod,在jenkins-1所在的节点执行<code>docker stop</code>停止运行jenkins-master的容器，同时在命令行查看pod的状态，可以看到jenkins-1异常（Error状态）之后慢慢恢复了运行状态（Running）：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@master ~]# kubectl get pods -w</span><br><span class=\"line\">NAME        READY     STATUS    RESTARTS   AGE</span><br><span class=\"line\">jenkins-0   1/1       Running   0          1d</span><br><span class=\"line\">jenkins-1   0/1       Running   1         20h</span><br><span class=\"line\">jenkins-1   1/1       Running   1         20h</span><br><span class=\"line\">jenkins-1   0/1       Error     1         20h</span><br><span class=\"line\">jenkins-1   0/1       CrashLoopBackOff   1         20h</span><br><span class=\"line\">jenkins-1   0/1       Running   2         20h</span><br><span class=\"line\">jenkins-1   1/1       Running   2         20h</span><br></pre></td></tr></table></figure></p>\n<p><code>kubectl describe pod jenkins-1</code>查看pod的事件日志，k8s通过探针(probe)接口检测到服务停止之后自动执行了拉取镜像，重启container的操作。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Events:</span><br><span class=\"line\">  Type     Reason      Age                From                              Message</span><br><span class=\"line\">  ----     ------      ----               ----                              -------</span><br><span class=\"line\">  Warning  Unhealthy   27m (x2 over 27m)  kubelet, iz8pscwd1fv6kprs1zw21kz  Readiness probe failed: HTTP probe failed with statuscode: 503</span><br><span class=\"line\">  Warning  Unhealthy   27m (x2 over 27m)  kubelet, iz8pscwd1fv6kprs1zw21kz  Liveness probe failed: HTTP probe failed with statuscode: 503</span><br><span class=\"line\">  Warning  Unhealthy   24m                kubelet, iz8pscwd1fv6kprs1zw21kz  Readiness probe failed: Get http://192.168.24.4:8080/login: dial tcp 192.168.24.4:8080: getsockopt: connection refused</span><br><span class=\"line\">  Warning  BackOff     20m (x2 over 20m)  kubelet, iz8pscwd1fv6kprs1zw21kz  Back-off restarting failed container</span><br><span class=\"line\">  Warning  FailedSync  20m (x2 over 20m)  kubelet, iz8pscwd1fv6kprs1zw21kz  Error syncing pod</span><br><span class=\"line\">  Normal   Pulling     19m (x3 over 20h)  kubelet, iz8pscwd1fv6kprs1zw21kz  pulling image &quot;jenkins/jenkins:lts-alpine&quot;</span><br><span class=\"line\">  Normal   Started     19m (x3 over 20h)  kubelet, iz8pscwd1fv6kprs1zw21kz  Started container</span><br><span class=\"line\">  Normal   Pulled      19m (x3 over 20h)  kubelet, iz8pscwd1fv6kprs1zw21kz  Successfully pulled image &quot;jenkins/jenkins:lts-alpine&quot;</span><br><span class=\"line\">  Normal   Created     19m (x3 over 20h)  kubelet, iz8pscwd1fv6kprs1zw21kz  Created container</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"3-jenkins构建测试\"><a href=\"#3-jenkins构建测试\" class=\"headerlink\" title=\"3. jenkins构建测试\"></a>3. jenkins构建测试</h4><p>当前集群中使用的jenkins slave镜像只包含一个java运行环境来运行jenkins-slave.jar,在实际使用中需要自定义合适的镜像。选择自定义镜像之后需要修改插件的配置，同样name命名为jnlp替换默认镜像，arguments安装工具提示填写即可。<br><img src=\"http://7xl4v5.com1.z0.glb.clouddn.com/%E7%81%AB%E7%8B%90%E6%88%AA%E5%9B%BE_2017-12-08T08-06-23.616Z.png\" alt=\"container\"><br>创建job，同时开始构建,k8s会在不同节点上创建pod来运行任务<br><img src=\"http://7xl4v5.com1.z0.glb.clouddn.com/pods1.png\" alt=\"此处输入图片的描述\"><br>构建全部完成后，资源随即被释放<br><img src=\"http://7xl4v5.com1.z0.glb.clouddn.com/result2.png\" alt=\"此处输入图片的描述\"></p>\n<p><strong>jenkins默认调度策略</strong></p>\n<ol>\n<li>尝试在上次构建的节点上构建，指定某台slave之后会一直使用。<br>2.当队列有2个构建时，不会立刻创建两个executor,而是先创建一个executor然后尝试等待executor空闲，目的是保证每个executor被充分利用。<br><strong>k8s调度策略</strong></li>\n<li>使用Pod.spec.nodeSelector根据label为pod选择node<br>2.调度器scheduler有Predicates，Priorities两个阶段，分别负责节点过滤和评分排序，各个阶段都有k8s提供的检查项，我们可以自由组合。<br>（比如PodFitsResources检查cpu内存等资源，PodFitsHostPorts检查端口占用，SelectorSpreadPriority要求一个服务尽量分散分布）<a href=\"http://dockone.io/article/2885\" target=\"_blank\" rel=\"noopener\">自定义schduler参考</a><br><strong>资源不足时会发生什么</strong><br>当前集群中有3个节点，我在node2运行一个CPU占用限制在80%的程序,然后设置jenkins插件ContainerTemplate的request和limit均为<code>cpu 500m,内存500Mi</code>,（500m代表单核CPU的50%）看一下pod会怎么调度<br>k8s仍然尝试在node2分配节点（为什么其他节点不行），结果POD处于pending状态：<figure class=\"highlight plain\"><figcaption><span>&#123;</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;phase&quot;: &quot;Pending&quot;,</span><br><span class=\"line\">&quot;conditions&quot;: [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    &quot;type&quot;: &quot;PodScheduled&quot;,</span><br><span class=\"line\">    &quot;status&quot;: &quot;False&quot;,</span><br><span class=\"line\">    &quot;lastProbeTime&quot;: null,</span><br><span class=\"line\">    &quot;lastTransitionTime&quot;: &quot;2017-12-09T08:29:10Z&quot;,</span><br><span class=\"line\">    &quot;reason&quot;: &quot;Unschedulable&quot;,</span><br><span class=\"line\">    &quot;message&quot;: &quot;No nodes are available that match all of the predicates: Insufficient cpu (4), PodToleratesNodeTaints (1).&quot;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">],</span><br><span class=\"line\">&quot;qosClass&quot;: &quot;Guaranteed&quot;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>最后pod被删除，而jenkins任务会阻塞一直到有其他空闲的slave出现。</p>\n<h3 id=\"四-，总结\"><a href=\"#四-，总结\" class=\"headerlink\" title=\"四 ，总结\"></a><strong>四 ，总结</strong></h3><p>本文介绍了在k8s集群部署jenkins服务的方式和k8s带来的资源管理便捷，由于我也是刚开始接触k8s,所用的实例只是搭建了用于测试的实验环境，离在实际生产环境中使用还有问题需要验证。</p>"},{"title":"为什么Redis使用ziplist能节省内存？","date":"2017-09-12T13:15:46.000Z","_content":"\n\n**环境准备:**\nredis 2.8.19 单机模式\n保存500万条用户信息数据，key是用户名 ，value是json格式字符串，包含邮箱等信息，内容如下:\n`userid:  \"tomcat125\"\ninfo:  \"[null,\\\"tomcat125@gmail.com\\\",188XXXXXXXX,\\\"\\\",null,null,\\\"\\xe9\\x9c\\x8d\\xe6\\xb3\\x13\\xx4\\xb8\\xs0\\\",\\\"1\\\",null,\\\"tom123321\\\"]\"`\n\n\nredis和ziplist配置有关的有这几个，默认值如下：\n<!--more-->\n\n`config get *ziplist*`\n >1) \"hash-max-ziplist-entries\"\n 2) \"512\"\n 3) \"hash-max-ziplist-value\"\n 4) \"64\"\n 5) \"list-max-ziplist-entries\"\n 6) \"512\"\n 7) \"list-max-ziplist-value\"\n 8) \"64\"\n 9) \"zset-max-ziplist-entries\"\n10) \"128\"\n11) \"zset-max-ziplist-value\"\n12) \"64\"\n\n\n-entries表示ziplsit对多保存数据项的个数，超出之后不能再使用ziplist\n-value表示每个数据项的最大字节数，超出之后不能再使用ziplist\n\n## 一.使用ziplist真的能节省内存吗？\n\n在这我用hash对象用户信息，对比一下使用ziplist前后的内存差异：\n为了使用hash保存，对用户名做hash然后取模得到一个hashkey\n然后保存时执行命令：`hset hashkey username info`\n\n### 使用hashtable保存：\nziplist设置：\n>config get hash*\n1) \"hash-max-ziplist-entries\"\n2) \"512\"\n3) \"hash-max-ziplist-value\"\n4) \"64\"\n\nhash对象信息(hashtable保存)：\n>“debug object nozip:3134”\nValue at:0x7f4957621d40 refcount:1 \n**encoding**:**hashtable** \n**serializedlength:39927** \nlru:3356615 lru_seconds_idle:24\n\n\n\n内存占用：\n>“dbsize”\n(integer) 12000\ninfo Memory\n\\# Memory\nused_memory:1102326968\n**used_memory_human:1.03G**\nused_memory_rss:1150930944\nused_memory_peak:1102463200\nused_memory_peak_human:1.03G\nused_memory_lua:35840\nmem_fragmentation_ratio:1.04\n\n\n\n清理内存，重启redis\n```bash\nredis>flushall\nsystemctl stop redis.service\nsystemctl start redis.service\n```\n\n\n### 使用ziplist保存:\n修改ziplist设置(json串平均长度150)：\n>\"config get hash*\"\n1) \"hash-max-ziplist-entries\"\n2) \"1000\"\n3) \"hash-max-ziplist-value\"\n4) \"250\"\n\n\nhash对象信息（ziplist保存）：\n>\"debug object nozip:3134\"\nValue at:0x7f490d21c150 refcount:1\n**encoding:ziplist** \n**serializedlength:18713** \nlru:3360532 lru_seconds_idle:93\n\n\n\n内存占用：\n\n>\"dbsize\"\n(integer) 12000\ninfo Memory\n\\# Memory\nused_memory:573333824\n**used_memory_human:546.77M**\nused_memory_rss:633442304\nused_memory_peak:1102178520\nused_memory_peak_human:1.03G\nused_memory_lua:35840\nmem_fragmentation_ratio:1.10\n\n\n\n\n在上面的例子中可以看到利用ziplist在保存12000个hash对象时，**used_memory节省了近50%**\n同一个key的serializedlength也差不多是原来的一半(39927-18731)，但是serializedLength表示的不是key的实际内存占用，而是保存到rdb文件之后key的占用字节数，小于key的实际内存占用。\n（[参考serializedLength源][1]）\n\n## 二.ziplist为什么能节省内存？\n\n从debug object的输出信息来看，两次分别是使用hashtable和ziplist保存的，为什么ziplist会比hashtable节省内存呢，这要从二者的数据结构说起。\n### 1.hashtable结构：\nhashtable使用字典保存，字典包含两个hashtable,hashtable由entry数组构成，数组中的节点包含一个next指针，形成一个单向链表。\nredis字典定义：\n```c\n//dict.h\n//字典\ntypedef struct dict {\n    dictType *type;\n    void *privdata;\n    dictht ht[2];\n    int rehashidx; /* rehashing not in progress if rehashidx == -1 */\n    int iterators; /* number of iterators currently running */\n} dict;\n//字典内部hashtable\ntypedef struct dictht {\n    dictEntry **table;\n    unsigned long size;\n    unsigned long sizemask;\n    unsigned long used;\n} dictht;\n//hashtable节点\ntypedef struct dictEntry {\n    void *key;\n    union {\n        void *val;\n        uint64_t u64;\n        int64_t s64;\n    } v;\n    struct dictEntry *next;\n} dictEntry;\n```\n下图展示了一个普通状态下的字典,数据保存在ht[0]，ht[1]在扩容时使用：\n![ht][2]\n### 2.ziplist结构：\n**zlbytes**：表示ziplist占用字节数，在执行resize操作时使用\n**zltail**：表示最后节点的偏移量，也是避免了整体遍历list\n**zllen**：表示ziplist节点个数（节点数超过65535,zllen字段值无效,需要遍历才能得到真实数量）\n**zlend**：表示ziplist结束的标识符\n\n**ziplist节点数据结构（抽象）：**\n每个压缩列表节点都由previous_entry_length、encoding、content三个部分组成（不是指实际结构体的字段）\n**previous_entry_length**：前一个节点的长度，用来由后向前遍历，根据前一个节点的长度，可能需要一个或五个字节。\n**encoding**：记录节点保存的数据类型和数据长度。\n**content**：节点保存的数据内容。\nziplist节点结构体（和上面的有点不一样）:\n```c\n//ziplist.c\ntypedef struct zlentry {\n    unsigned int prevrawlensize, prevrawlen;\n    unsigned int lensize, len;\n    unsigned int headersize;\n    unsigned char encoding;\n    unsigned char *p;\n} zlentry;\n```\n下图展示了一个ziplist的基本结构：\n![ziplist][3]\n\n可以看到，ziplist采用了一段连续的内存来存储数据，相比hashtable减少了内存碎片，和指针的内存占用。而且当节点较少时，ziplist更容易被加载到CPU缓存中。\n\n## 三，调试源码\n眼见为实，现在通过vs2012启动redis server，调试redis源码对比hashtable和ziplist的处理过程。\n\n### 调试hashtable保存hash对象\nserver启动后，首先在t_hash.c 的hsetCommand函数打断点\n```c\n//t_hash.c\nvoid hsetCommand(redisClient *c) {\n    int update;\n    robj *o;\n\n    if ((o = hashTypeLookupWriteOrCreate(c,c->argv[1])) == NULL) return;\n    hashTypeTryConversion(o,c->argv,2,3);\n    hashTypeTryObjectEncoding(o,&c->argv[2], &c->argv[3]);\n    update = hashTypeSet(o,c->argv[2],c->argv[3]);\n    addReply(c, update ? shared.czero : shared.cone);\n    signalModifiedKey(c->db,c->argv[1]);\n    server.dirty++;\n}\n```\n在客户端执行命令,修改ziplist配置最大长度改成10，然后添加一个value长度超过10的hash对象：\n```\n127.0.0.1:6379> config set hash-max-ziplist-value 10\n127.0.0.1:6379> hset hash_key fieldkey abcdefghijklmn\n```\n\n进入t_hash.c文件的函数hashTypeSet,在这里redis判断对象编码为hashtable，使用字典保存:\n```c\n//t_hash.c\nelse if (o->encoding == REDIS_ENCODING_HT) {\n        if (dictReplace(o->ptr, field, value)) { /* Insert */\n            incrRefCount(field);\n        } else { /* Update */\n            update = 1;\n        }\n        incrRefCount(value);\n```\n在dict.c文件dictAdd标记断点，开始分别保存key&value到dict：\n```c\n//dict.c\nint dictAdd(dict *d, void *key, void *val)\n{\n    //往字典中添加一个只有key的dictEntry\n    dictEntry *entry = dictAddRaw(d,key);\n\n    if (!entry) return DICT_ERR;\n    //保存entry值的内容\n    dictSetVal(d, entry, val);\n    return DICT_OK;\n}\n```\n首先redis调用函数dictAddRaw()保存hash key\n```c\n//dict.c\ndictEntry *dictAddRaw(dict *d, void *key)\n{\n    int index;\n    dictEntry *entry;\n    dictht *ht;\n    //因为redis采用渐进式rehash，首先要做rehash检查\n    if (dictIsRehashing(d)) _dictRehashStep(d);\n\n    /* Get the index of the new element, or -1 if\n     * the element already exists. */\n    if ((index = _dictKeyIndex(d, key)) == -1)\n        return NULL;\n\n    // 如果字典正在rehash，则插入到新表ht[1]，否则到旧表ht[0]\n    ht = dictIsRehashing(d) ? &d->ht[1] : &d->ht[0];\n    /* 申请内存 保存新的entry节点*/\n    entry = zmalloc(sizeof(*entry));\n    entry->next = ht->table[index];\n    ht->table[index] = entry;\n    ht->used++;\n\n    /* 保存entry key的内容 */\n    dictSetKey(d, entry, key);\n    return entry;\n}\n```\n**估算内存**\n因为内存对齐的原因，sizeof(dictEntry)=24，为entry申请了24字节内存。估算一个节点的字节数 **47byte**(key 9bytes,val 14bytes,entry 24bytes)\n### 调试ziplist保存hash对象\n首先清理数据，修改ziplist配置放宽value长度限制，保存同样内容：\n```\n127.0.0.1:6379> flushall\n127.0.0.1:6379> config set hash-max-ziplist-value 15\n127.0.0.1:6379> hset hash_key fieldkey abcdefghijklmn\n```\n此时还是在t_hash.c文件的函数hashTypeSet打断点,redis选择用ziplist编码保存hash对象\n```c\n//t_hash.c hashTypeSet()\nif (o->encoding == REDIS_ENCODING_ZIPLIST) {\n        unsigned char *zl, *fptr, *vptr;\n\n        field = getDecodedObject(field);\n        value = getDecodedObject(value);\n\n        zl = o->ptr;\n        fptr = ziplistIndex(zl, ZIPLIST_HEAD);\n        if (fptr != NULL) {\n            //略\n        }\n\n        if (!update) {\n            /* Push new field/value pair onto the tail of the ziplist */\n            zl = ziplistPush(zl, field->ptr, (unsigned int)sdslen(field->ptr), ZIPLIST_TAIL);\n            zl = ziplistPush(zl, value->ptr, (unsigned int)sdslen(value->ptr), ZIPLIST_TAIL);\n        }\n        o->ptr = zl;\n        //引用计数\n        decrRefCount(field);\n        decrRefCount(value);\n\n        /*检查是否要换成hashtable编码*/\n        if (hashTypeLength(o) > server.hash_max_ziplist_entries)\n            hashTypeConvert(o, REDIS_ENCODING_HT);\n    }\n```\n在ziplistPush内部调用了 ziplistInsert()函数，打开ziplist.c文件，在__ziplistInsert()函数打断点：\n\n```c   \n//ziplist.c\nstatic unsigned char *__ziplistInsert(unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen) {\n    //当前ziplist的长度\n    size_t curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), reqlen;\n    unsigned int prevlensize, prevlen = 0;\n    size_t offset;\n    int nextdiff = 0;\n    unsigned char encoding = 0;\n    long long value = 123456789; \n    zlentry tail;\n\n    if (p[0] != ZIP_END) {\n        // 如果p节点后面还有节点，取出p节点前一个节点的长度信息和存储该长度值所需要的字节数信息\n        ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);\n    } else {\n        // 如果p节点为ziplist结束标识，则取出尾节点，即最后一个节点\n        unsigned char *ptail = ZIPLIST_ENTRY_TAIL(zl);\n        if (ptail[0] != ZIP_END) {\n            prevlen = zipRawEntryLength(ptail);\n        }\n    }\n\n    // 尝试看能否将s保存为整数，如果可以则返回1，且value和encoding分别保存新值和编码信息\n    if (zipTryEncoding(s,slen,&value,&encoding)) {\n        // 如果s可以保存为整数，则进一步计算保存该数值所需要的字节数\n        reqlen = zipIntSize(encoding);\n    } else {\n        // 如果s不能保存为整数，则直接使用其字符串长度\n        reqlen = slen;\n    }\n    \n    // 计算编码prevlen所需要的字节数，prevlen用于保存前一个节点的长度\n    reqlen += zipPrevEncodeLength(NULL,prevlen);\n    // 计算编码slen所需要的长度\n    reqlen += zipEncodeLength(NULL,encoding,slen);\n\n    \n    // 当插入的位置不是ziplist尾部时，需要确保下一个节点（即p节点）的prevlen能够用来保存即将插入节点的长度\n    // 这里计算两者差值\n    nextdiff = (p[0] != ZIP_END) ? zipPrevLenByteDiff(p,reqlen) : 0;\n\n    // ziplistResize操作会重新分配空间，需要事前记录p节点偏移量\n    offset = p-zl;\n    zl = ziplistResize(zl,curlen+reqlen+nextdiff);\n    // 重新取得p节点\n    p = zl+offset;\n\n    /* Apply memory move when necessary and update tail offset. */\n    if (p[0] != ZIP_END) {\n        /* 将原来 p-nextdiff 开始的数据全部后移，中间出现reqlen个字节保存即将插入的数据 \n            主要需要考虑一下几种情况：\n            nextdiff == 0：p节点中用来存储原先前一个节点长度信息的数据区域正好保存待插入节点的长度\n            nextdiff == 4：原先p节点只需要1个字节来存储上一个节点的长度，现在需要5个字节。那就将p-4后面的数据偏移到p+reqlen\n            nextdiff == -4：原先p节点需要5个字节来存储上一个节点的长度，现在只需要1个字节。那就将p+4后面的数据偏移到p+reqlen\n        */\n        memmove(p+reqlen,p-nextdiff,curlen-offset-1+nextdiff);\n\n        // 为p节点的prevlen设置新值，即待插入节点的长度\n        zipPrevEncodeLength(p+reqlen,reqlen);\n\n        // 更新尾节点偏移量\n        ZIPLIST_TAIL_OFFSET(zl) =\n            intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+reqlen);\n\n        tail = zipEntry(p+reqlen);\n        // 同样，如果p节点不是尾节点，尾节点的偏移量还需要加上nextdiff值\n        if (p[reqlen+tail.headersize+tail.len] != ZIP_END) {\n            ZIPLIST_TAIL_OFFSET(zl) =\n                intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+nextdiff);\n        }\n    } else {\n        // 如果p节点指向zlend，更新zltail值，待添加节点为尾部节点\n        ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(p-zl);\n    }\n    \n    // 同样，如果nextdiff的值不为0，说明原节点（此时的首地址为p+reqlen）的长度发生改变，需要执行级联更新操作\n    if (nextdiff != 0) {\n        offset = p-zl;\n        //这里可能造成连锁更新\n        zl = __ziplistCascadeUpdate(zl,p+reqlen);\n        p = zl+offset;\n    }\n\n    // 下面才是真正执行插入操作\n    /* Write the entry */\n    // 填写上一节点的长度\n    p += zipPrevEncodeLength(p,prevlen);\n    // 填写当前节点的长度\n    p += zipEncodeLength(p,encoding,slen);\n    // 根据编码方式执行相应的插入操作\n    if (ZIP_IS_STR(encoding)) {\n        memcpy(p,s,slen);\n    } else {\n        zipSaveInteger(p,value,encoding);\n    }\n    // 长度加1\n    ZIPLIST_INCR_LENGTH(zl,1);\n    return zl;\n}\n\n```\n**估算内存**\ncurlen表示当前ziplist的占用字节数,curlen初始值11，保存\"fieldkey\"后变为21，保存\"abcdefghijklmn\"变成38，估计一个节点占用**27字节**。\n\n**注意：**当在ziplist头部执行增加或删除操作时，如果节点长度过长（超过255），previous_entry_length要使用5个字节保存，这时会执行__ziplistCascadeUpdate()函数，可能触发连锁更新，最坏情况要更新每一个后继节点（previous_entry_length从一个字节变成5个字节后，所有节点长度都超过了255）。\n\n## 总结\n**ziplist的优点**\n内存占用少 容易被加载到CPU缓存\n结构紧凑 减少内存碎片\n\n**ziplist的缺点**\n连锁更新（头部插入 或 删除，对头部的操作主要是在用ziplist保存list类型对象时发送，保存hash对象不需要在头部更新。）\n查询复杂度从O（1）变成O（N）（保存hash对象时）\n\n\t\n\n参考：\n[Redis内置数据结构之压缩列表ziplist][4]\n[vs2012调试redis][5]\n[《redis设计与实现》][6]\n\n\n  [1]: https://github.com/antirez/redis/blob/4082c38a60eedd524c78ef48c1b241105f4ddc50/src/debug.c#L337-L343\n  [2]: http://7xl4v5.com1.z0.glb.clouddn.com/ht.png\n  [3]: http://7xl4v5.com1.z0.glb.clouddn.com/ziplist.png\n  [4]: http://blog.csdn.net/xiejingfa/article/details/51072326\n  [5]: http://blog.csdn.net/Rongbo_J/article/details/45288223\n  [6]: http://www.duokan.com/book/53962","source":"_posts/为什么Redis使用ziplist能节省内存.md","raw":"\ntitle: 为什么Redis使用ziplist能节省内存？\ndate: 2017-09-12 21:15:46\ncategories: redis进阶\ntags: [redis,源码,nosql]\n\n---\n\n\n**环境准备:**\nredis 2.8.19 单机模式\n保存500万条用户信息数据，key是用户名 ，value是json格式字符串，包含邮箱等信息，内容如下:\n`userid:  \"tomcat125\"\ninfo:  \"[null,\\\"tomcat125@gmail.com\\\",188XXXXXXXX,\\\"\\\",null,null,\\\"\\xe9\\x9c\\x8d\\xe6\\xb3\\x13\\xx4\\xb8\\xs0\\\",\\\"1\\\",null,\\\"tom123321\\\"]\"`\n\n\nredis和ziplist配置有关的有这几个，默认值如下：\n<!--more-->\n\n`config get *ziplist*`\n >1) \"hash-max-ziplist-entries\"\n 2) \"512\"\n 3) \"hash-max-ziplist-value\"\n 4) \"64\"\n 5) \"list-max-ziplist-entries\"\n 6) \"512\"\n 7) \"list-max-ziplist-value\"\n 8) \"64\"\n 9) \"zset-max-ziplist-entries\"\n10) \"128\"\n11) \"zset-max-ziplist-value\"\n12) \"64\"\n\n\n-entries表示ziplsit对多保存数据项的个数，超出之后不能再使用ziplist\n-value表示每个数据项的最大字节数，超出之后不能再使用ziplist\n\n## 一.使用ziplist真的能节省内存吗？\n\n在这我用hash对象用户信息，对比一下使用ziplist前后的内存差异：\n为了使用hash保存，对用户名做hash然后取模得到一个hashkey\n然后保存时执行命令：`hset hashkey username info`\n\n### 使用hashtable保存：\nziplist设置：\n>config get hash*\n1) \"hash-max-ziplist-entries\"\n2) \"512\"\n3) \"hash-max-ziplist-value\"\n4) \"64\"\n\nhash对象信息(hashtable保存)：\n>“debug object nozip:3134”\nValue at:0x7f4957621d40 refcount:1 \n**encoding**:**hashtable** \n**serializedlength:39927** \nlru:3356615 lru_seconds_idle:24\n\n\n\n内存占用：\n>“dbsize”\n(integer) 12000\ninfo Memory\n\\# Memory\nused_memory:1102326968\n**used_memory_human:1.03G**\nused_memory_rss:1150930944\nused_memory_peak:1102463200\nused_memory_peak_human:1.03G\nused_memory_lua:35840\nmem_fragmentation_ratio:1.04\n\n\n\n清理内存，重启redis\n```bash\nredis>flushall\nsystemctl stop redis.service\nsystemctl start redis.service\n```\n\n\n### 使用ziplist保存:\n修改ziplist设置(json串平均长度150)：\n>\"config get hash*\"\n1) \"hash-max-ziplist-entries\"\n2) \"1000\"\n3) \"hash-max-ziplist-value\"\n4) \"250\"\n\n\nhash对象信息（ziplist保存）：\n>\"debug object nozip:3134\"\nValue at:0x7f490d21c150 refcount:1\n**encoding:ziplist** \n**serializedlength:18713** \nlru:3360532 lru_seconds_idle:93\n\n\n\n内存占用：\n\n>\"dbsize\"\n(integer) 12000\ninfo Memory\n\\# Memory\nused_memory:573333824\n**used_memory_human:546.77M**\nused_memory_rss:633442304\nused_memory_peak:1102178520\nused_memory_peak_human:1.03G\nused_memory_lua:35840\nmem_fragmentation_ratio:1.10\n\n\n\n\n在上面的例子中可以看到利用ziplist在保存12000个hash对象时，**used_memory节省了近50%**\n同一个key的serializedlength也差不多是原来的一半(39927-18731)，但是serializedLength表示的不是key的实际内存占用，而是保存到rdb文件之后key的占用字节数，小于key的实际内存占用。\n（[参考serializedLength源][1]）\n\n## 二.ziplist为什么能节省内存？\n\n从debug object的输出信息来看，两次分别是使用hashtable和ziplist保存的，为什么ziplist会比hashtable节省内存呢，这要从二者的数据结构说起。\n### 1.hashtable结构：\nhashtable使用字典保存，字典包含两个hashtable,hashtable由entry数组构成，数组中的节点包含一个next指针，形成一个单向链表。\nredis字典定义：\n```c\n//dict.h\n//字典\ntypedef struct dict {\n    dictType *type;\n    void *privdata;\n    dictht ht[2];\n    int rehashidx; /* rehashing not in progress if rehashidx == -1 */\n    int iterators; /* number of iterators currently running */\n} dict;\n//字典内部hashtable\ntypedef struct dictht {\n    dictEntry **table;\n    unsigned long size;\n    unsigned long sizemask;\n    unsigned long used;\n} dictht;\n//hashtable节点\ntypedef struct dictEntry {\n    void *key;\n    union {\n        void *val;\n        uint64_t u64;\n        int64_t s64;\n    } v;\n    struct dictEntry *next;\n} dictEntry;\n```\n下图展示了一个普通状态下的字典,数据保存在ht[0]，ht[1]在扩容时使用：\n![ht][2]\n### 2.ziplist结构：\n**zlbytes**：表示ziplist占用字节数，在执行resize操作时使用\n**zltail**：表示最后节点的偏移量，也是避免了整体遍历list\n**zllen**：表示ziplist节点个数（节点数超过65535,zllen字段值无效,需要遍历才能得到真实数量）\n**zlend**：表示ziplist结束的标识符\n\n**ziplist节点数据结构（抽象）：**\n每个压缩列表节点都由previous_entry_length、encoding、content三个部分组成（不是指实际结构体的字段）\n**previous_entry_length**：前一个节点的长度，用来由后向前遍历，根据前一个节点的长度，可能需要一个或五个字节。\n**encoding**：记录节点保存的数据类型和数据长度。\n**content**：节点保存的数据内容。\nziplist节点结构体（和上面的有点不一样）:\n```c\n//ziplist.c\ntypedef struct zlentry {\n    unsigned int prevrawlensize, prevrawlen;\n    unsigned int lensize, len;\n    unsigned int headersize;\n    unsigned char encoding;\n    unsigned char *p;\n} zlentry;\n```\n下图展示了一个ziplist的基本结构：\n![ziplist][3]\n\n可以看到，ziplist采用了一段连续的内存来存储数据，相比hashtable减少了内存碎片，和指针的内存占用。而且当节点较少时，ziplist更容易被加载到CPU缓存中。\n\n## 三，调试源码\n眼见为实，现在通过vs2012启动redis server，调试redis源码对比hashtable和ziplist的处理过程。\n\n### 调试hashtable保存hash对象\nserver启动后，首先在t_hash.c 的hsetCommand函数打断点\n```c\n//t_hash.c\nvoid hsetCommand(redisClient *c) {\n    int update;\n    robj *o;\n\n    if ((o = hashTypeLookupWriteOrCreate(c,c->argv[1])) == NULL) return;\n    hashTypeTryConversion(o,c->argv,2,3);\n    hashTypeTryObjectEncoding(o,&c->argv[2], &c->argv[3]);\n    update = hashTypeSet(o,c->argv[2],c->argv[3]);\n    addReply(c, update ? shared.czero : shared.cone);\n    signalModifiedKey(c->db,c->argv[1]);\n    server.dirty++;\n}\n```\n在客户端执行命令,修改ziplist配置最大长度改成10，然后添加一个value长度超过10的hash对象：\n```\n127.0.0.1:6379> config set hash-max-ziplist-value 10\n127.0.0.1:6379> hset hash_key fieldkey abcdefghijklmn\n```\n\n进入t_hash.c文件的函数hashTypeSet,在这里redis判断对象编码为hashtable，使用字典保存:\n```c\n//t_hash.c\nelse if (o->encoding == REDIS_ENCODING_HT) {\n        if (dictReplace(o->ptr, field, value)) { /* Insert */\n            incrRefCount(field);\n        } else { /* Update */\n            update = 1;\n        }\n        incrRefCount(value);\n```\n在dict.c文件dictAdd标记断点，开始分别保存key&value到dict：\n```c\n//dict.c\nint dictAdd(dict *d, void *key, void *val)\n{\n    //往字典中添加一个只有key的dictEntry\n    dictEntry *entry = dictAddRaw(d,key);\n\n    if (!entry) return DICT_ERR;\n    //保存entry值的内容\n    dictSetVal(d, entry, val);\n    return DICT_OK;\n}\n```\n首先redis调用函数dictAddRaw()保存hash key\n```c\n//dict.c\ndictEntry *dictAddRaw(dict *d, void *key)\n{\n    int index;\n    dictEntry *entry;\n    dictht *ht;\n    //因为redis采用渐进式rehash，首先要做rehash检查\n    if (dictIsRehashing(d)) _dictRehashStep(d);\n\n    /* Get the index of the new element, or -1 if\n     * the element already exists. */\n    if ((index = _dictKeyIndex(d, key)) == -1)\n        return NULL;\n\n    // 如果字典正在rehash，则插入到新表ht[1]，否则到旧表ht[0]\n    ht = dictIsRehashing(d) ? &d->ht[1] : &d->ht[0];\n    /* 申请内存 保存新的entry节点*/\n    entry = zmalloc(sizeof(*entry));\n    entry->next = ht->table[index];\n    ht->table[index] = entry;\n    ht->used++;\n\n    /* 保存entry key的内容 */\n    dictSetKey(d, entry, key);\n    return entry;\n}\n```\n**估算内存**\n因为内存对齐的原因，sizeof(dictEntry)=24，为entry申请了24字节内存。估算一个节点的字节数 **47byte**(key 9bytes,val 14bytes,entry 24bytes)\n### 调试ziplist保存hash对象\n首先清理数据，修改ziplist配置放宽value长度限制，保存同样内容：\n```\n127.0.0.1:6379> flushall\n127.0.0.1:6379> config set hash-max-ziplist-value 15\n127.0.0.1:6379> hset hash_key fieldkey abcdefghijklmn\n```\n此时还是在t_hash.c文件的函数hashTypeSet打断点,redis选择用ziplist编码保存hash对象\n```c\n//t_hash.c hashTypeSet()\nif (o->encoding == REDIS_ENCODING_ZIPLIST) {\n        unsigned char *zl, *fptr, *vptr;\n\n        field = getDecodedObject(field);\n        value = getDecodedObject(value);\n\n        zl = o->ptr;\n        fptr = ziplistIndex(zl, ZIPLIST_HEAD);\n        if (fptr != NULL) {\n            //略\n        }\n\n        if (!update) {\n            /* Push new field/value pair onto the tail of the ziplist */\n            zl = ziplistPush(zl, field->ptr, (unsigned int)sdslen(field->ptr), ZIPLIST_TAIL);\n            zl = ziplistPush(zl, value->ptr, (unsigned int)sdslen(value->ptr), ZIPLIST_TAIL);\n        }\n        o->ptr = zl;\n        //引用计数\n        decrRefCount(field);\n        decrRefCount(value);\n\n        /*检查是否要换成hashtable编码*/\n        if (hashTypeLength(o) > server.hash_max_ziplist_entries)\n            hashTypeConvert(o, REDIS_ENCODING_HT);\n    }\n```\n在ziplistPush内部调用了 ziplistInsert()函数，打开ziplist.c文件，在__ziplistInsert()函数打断点：\n\n```c   \n//ziplist.c\nstatic unsigned char *__ziplistInsert(unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen) {\n    //当前ziplist的长度\n    size_t curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), reqlen;\n    unsigned int prevlensize, prevlen = 0;\n    size_t offset;\n    int nextdiff = 0;\n    unsigned char encoding = 0;\n    long long value = 123456789; \n    zlentry tail;\n\n    if (p[0] != ZIP_END) {\n        // 如果p节点后面还有节点，取出p节点前一个节点的长度信息和存储该长度值所需要的字节数信息\n        ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);\n    } else {\n        // 如果p节点为ziplist结束标识，则取出尾节点，即最后一个节点\n        unsigned char *ptail = ZIPLIST_ENTRY_TAIL(zl);\n        if (ptail[0] != ZIP_END) {\n            prevlen = zipRawEntryLength(ptail);\n        }\n    }\n\n    // 尝试看能否将s保存为整数，如果可以则返回1，且value和encoding分别保存新值和编码信息\n    if (zipTryEncoding(s,slen,&value,&encoding)) {\n        // 如果s可以保存为整数，则进一步计算保存该数值所需要的字节数\n        reqlen = zipIntSize(encoding);\n    } else {\n        // 如果s不能保存为整数，则直接使用其字符串长度\n        reqlen = slen;\n    }\n    \n    // 计算编码prevlen所需要的字节数，prevlen用于保存前一个节点的长度\n    reqlen += zipPrevEncodeLength(NULL,prevlen);\n    // 计算编码slen所需要的长度\n    reqlen += zipEncodeLength(NULL,encoding,slen);\n\n    \n    // 当插入的位置不是ziplist尾部时，需要确保下一个节点（即p节点）的prevlen能够用来保存即将插入节点的长度\n    // 这里计算两者差值\n    nextdiff = (p[0] != ZIP_END) ? zipPrevLenByteDiff(p,reqlen) : 0;\n\n    // ziplistResize操作会重新分配空间，需要事前记录p节点偏移量\n    offset = p-zl;\n    zl = ziplistResize(zl,curlen+reqlen+nextdiff);\n    // 重新取得p节点\n    p = zl+offset;\n\n    /* Apply memory move when necessary and update tail offset. */\n    if (p[0] != ZIP_END) {\n        /* 将原来 p-nextdiff 开始的数据全部后移，中间出现reqlen个字节保存即将插入的数据 \n            主要需要考虑一下几种情况：\n            nextdiff == 0：p节点中用来存储原先前一个节点长度信息的数据区域正好保存待插入节点的长度\n            nextdiff == 4：原先p节点只需要1个字节来存储上一个节点的长度，现在需要5个字节。那就将p-4后面的数据偏移到p+reqlen\n            nextdiff == -4：原先p节点需要5个字节来存储上一个节点的长度，现在只需要1个字节。那就将p+4后面的数据偏移到p+reqlen\n        */\n        memmove(p+reqlen,p-nextdiff,curlen-offset-1+nextdiff);\n\n        // 为p节点的prevlen设置新值，即待插入节点的长度\n        zipPrevEncodeLength(p+reqlen,reqlen);\n\n        // 更新尾节点偏移量\n        ZIPLIST_TAIL_OFFSET(zl) =\n            intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+reqlen);\n\n        tail = zipEntry(p+reqlen);\n        // 同样，如果p节点不是尾节点，尾节点的偏移量还需要加上nextdiff值\n        if (p[reqlen+tail.headersize+tail.len] != ZIP_END) {\n            ZIPLIST_TAIL_OFFSET(zl) =\n                intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+nextdiff);\n        }\n    } else {\n        // 如果p节点指向zlend，更新zltail值，待添加节点为尾部节点\n        ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(p-zl);\n    }\n    \n    // 同样，如果nextdiff的值不为0，说明原节点（此时的首地址为p+reqlen）的长度发生改变，需要执行级联更新操作\n    if (nextdiff != 0) {\n        offset = p-zl;\n        //这里可能造成连锁更新\n        zl = __ziplistCascadeUpdate(zl,p+reqlen);\n        p = zl+offset;\n    }\n\n    // 下面才是真正执行插入操作\n    /* Write the entry */\n    // 填写上一节点的长度\n    p += zipPrevEncodeLength(p,prevlen);\n    // 填写当前节点的长度\n    p += zipEncodeLength(p,encoding,slen);\n    // 根据编码方式执行相应的插入操作\n    if (ZIP_IS_STR(encoding)) {\n        memcpy(p,s,slen);\n    } else {\n        zipSaveInteger(p,value,encoding);\n    }\n    // 长度加1\n    ZIPLIST_INCR_LENGTH(zl,1);\n    return zl;\n}\n\n```\n**估算内存**\ncurlen表示当前ziplist的占用字节数,curlen初始值11，保存\"fieldkey\"后变为21，保存\"abcdefghijklmn\"变成38，估计一个节点占用**27字节**。\n\n**注意：**当在ziplist头部执行增加或删除操作时，如果节点长度过长（超过255），previous_entry_length要使用5个字节保存，这时会执行__ziplistCascadeUpdate()函数，可能触发连锁更新，最坏情况要更新每一个后继节点（previous_entry_length从一个字节变成5个字节后，所有节点长度都超过了255）。\n\n## 总结\n**ziplist的优点**\n内存占用少 容易被加载到CPU缓存\n结构紧凑 减少内存碎片\n\n**ziplist的缺点**\n连锁更新（头部插入 或 删除，对头部的操作主要是在用ziplist保存list类型对象时发送，保存hash对象不需要在头部更新。）\n查询复杂度从O（1）变成O（N）（保存hash对象时）\n\n\t\n\n参考：\n[Redis内置数据结构之压缩列表ziplist][4]\n[vs2012调试redis][5]\n[《redis设计与实现》][6]\n\n\n  [1]: https://github.com/antirez/redis/blob/4082c38a60eedd524c78ef48c1b241105f4ddc50/src/debug.c#L337-L343\n  [2]: http://7xl4v5.com1.z0.glb.clouddn.com/ht.png\n  [3]: http://7xl4v5.com1.z0.glb.clouddn.com/ziplist.png\n  [4]: http://blog.csdn.net/xiejingfa/article/details/51072326\n  [5]: http://blog.csdn.net/Rongbo_J/article/details/45288223\n  [6]: http://www.duokan.com/book/53962","slug":"为什么Redis使用ziplist能节省内存","published":1,"updated":"2018-11-21T16:34:40.367Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp57u41l001o2xpbjxas1hcu","content":"<p><strong>环境准备:</strong><br>redis 2.8.19 单机模式<br>保存500万条用户信息数据，key是用户名 ，value是json格式字符串，包含邮箱等信息，内容如下:<br><code>userid:  &quot;tomcat125&quot;\ninfo:  &quot;[null,\\&quot;tomcat125@gmail.com\\&quot;,188XXXXXXXX,\\&quot;\\&quot;,null,null,\\&quot;\\xe9\\x9c\\x8d\\xe6\\xb3\\x13\\xx4\\xb8\\xs0\\&quot;,\\&quot;1\\&quot;,null,\\&quot;tom123321\\&quot;]&quot;</code></p>\n<p>redis和ziplist配置有关的有这几个，默认值如下：<br><a id=\"more\"></a></p>\n<p><code>config get *ziplist*</code></p>\n<blockquote>\n<p>1) “hash-max-ziplist-entries”<br> 2) “512”<br> 3) “hash-max-ziplist-value”<br> 4) “64”<br> 5) “list-max-ziplist-entries”<br> 6) “512”<br> 7) “list-max-ziplist-value”<br> 8) “64”<br> 9) “zset-max-ziplist-entries”<br>10) “128”<br>11) “zset-max-ziplist-value”<br>12) “64”</p>\n</blockquote>\n<p>-entries表示ziplsit对多保存数据项的个数，超出之后不能再使用ziplist<br>-value表示每个数据项的最大字节数，超出之后不能再使用ziplist</p>\n<h2 id=\"一-使用ziplist真的能节省内存吗？\"><a href=\"#一-使用ziplist真的能节省内存吗？\" class=\"headerlink\" title=\"一.使用ziplist真的能节省内存吗？\"></a>一.使用ziplist真的能节省内存吗？</h2><p>在这我用hash对象用户信息，对比一下使用ziplist前后的内存差异：<br>为了使用hash保存，对用户名做hash然后取模得到一个hashkey<br>然后保存时执行命令：<code>hset hashkey username info</code></p>\n<h3 id=\"使用hashtable保存：\"><a href=\"#使用hashtable保存：\" class=\"headerlink\" title=\"使用hashtable保存：\"></a>使用hashtable保存：</h3><p>ziplist设置：</p>\n<blockquote>\n<p>config get hash*<br>1) “hash-max-ziplist-entries”<br>2) “512”<br>3) “hash-max-ziplist-value”<br>4) “64”</p>\n</blockquote>\n<p>hash对象信息(hashtable保存)：</p>\n<blockquote>\n<p>“debug object nozip:3134”<br>Value at:0x7f4957621d40 refcount:1<br><strong>encoding</strong>:<strong>hashtable</strong><br><strong>serializedlength:39927</strong><br>lru:3356615 lru_seconds_idle:24</p>\n</blockquote>\n<p>内存占用：</p>\n<blockquote>\n<p>“dbsize”<br>(integer) 12000<br>info Memory<br># Memory<br>used_memory:1102326968<br><strong>used_memory_human:1.03G</strong><br>used_memory_rss:1150930944<br>used_memory_peak:1102463200<br>used_memory_peak_human:1.03G<br>used_memory_lua:35840<br>mem_fragmentation_ratio:1.04</p>\n</blockquote>\n<p>清理内存，重启redis<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt;flushall</span><br><span class=\"line\">systemctl stop redis.service</span><br><span class=\"line\">systemctl start redis.service</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"使用ziplist保存\"><a href=\"#使用ziplist保存\" class=\"headerlink\" title=\"使用ziplist保存:\"></a>使用ziplist保存:</h3><p>修改ziplist设置(json串平均长度150)：</p>\n<blockquote>\n<p>“config get hash*”<br>1) “hash-max-ziplist-entries”<br>2) “1000”<br>3) “hash-max-ziplist-value”<br>4) “250”</p>\n</blockquote>\n<p>hash对象信息（ziplist保存）：</p>\n<blockquote>\n<p>“debug object nozip:3134”<br>Value at:0x7f490d21c150 refcount:1<br><strong>encoding:ziplist</strong><br><strong>serializedlength:18713</strong><br>lru:3360532 lru_seconds_idle:93</p>\n</blockquote>\n<p>内存占用：</p>\n<blockquote>\n<p>“dbsize”<br>(integer) 12000<br>info Memory<br># Memory<br>used_memory:573333824<br><strong>used_memory_human:546.77M</strong><br>used_memory_rss:633442304<br>used_memory_peak:1102178520<br>used_memory_peak_human:1.03G<br>used_memory_lua:35840<br>mem_fragmentation_ratio:1.10</p>\n</blockquote>\n<p>在上面的例子中可以看到利用ziplist在保存12000个hash对象时，<strong>used_memory节省了近50%</strong><br>同一个key的serializedlength也差不多是原来的一半(39927-18731)，但是serializedLength表示的不是key的实际内存占用，而是保存到rdb文件之后key的占用字节数，小于key的实际内存占用。<br>（<a href=\"https://github.com/antirez/redis/blob/4082c38a60eedd524c78ef48c1b241105f4ddc50/src/debug.c#L337-L343\" target=\"_blank\" rel=\"noopener\">参考serializedLength源</a>）</p>\n<h2 id=\"二-ziplist为什么能节省内存？\"><a href=\"#二-ziplist为什么能节省内存？\" class=\"headerlink\" title=\"二.ziplist为什么能节省内存？\"></a>二.ziplist为什么能节省内存？</h2><p>从debug object的输出信息来看，两次分别是使用hashtable和ziplist保存的，为什么ziplist会比hashtable节省内存呢，这要从二者的数据结构说起。</p>\n<h3 id=\"1-hashtable结构：\"><a href=\"#1-hashtable结构：\" class=\"headerlink\" title=\"1.hashtable结构：\"></a>1.hashtable结构：</h3><p>hashtable使用字典保存，字典包含两个hashtable,hashtable由entry数组构成，数组中的节点包含一个next指针，形成一个单向链表。<br>redis字典定义：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//dict.h</span></span><br><span class=\"line\"><span class=\"comment\">//字典</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dict</span> &#123;</span></span><br><span class=\"line\">    dictType *type;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> *privdata;</span><br><span class=\"line\">    dictht ht[<span class=\"number\">2</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> rehashidx; <span class=\"comment\">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> iterators; <span class=\"comment\">/* number of iterators currently running */</span></span><br><span class=\"line\">&#125; dict;</span><br><span class=\"line\"><span class=\"comment\">//字典内部hashtable</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictht</span> &#123;</span></span><br><span class=\"line\">    dictEntry **table;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> size;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> sizemask;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> used;</span><br><span class=\"line\">&#125; dictht;</span><br><span class=\"line\"><span class=\"comment\">//hashtable节点</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictEntry</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *key;</span><br><span class=\"line\">    <span class=\"keyword\">union</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">void</span> *val;</span><br><span class=\"line\">        <span class=\"keyword\">uint64_t</span> u64;</span><br><span class=\"line\">        <span class=\"keyword\">int64_t</span> s64;</span><br><span class=\"line\">    &#125; v;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictEntry</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125; dictEntry;</span><br></pre></td></tr></table></figure></p>\n<p>下图展示了一个普通状态下的字典,数据保存在ht[0]，ht<a href=\"https://github.com/antirez/redis/blob/4082c38a60eedd524c78ef48c1b241105f4ddc50/src/debug.c#L337-L343\" target=\"_blank\" rel=\"noopener\">1</a>在扩容时使用：<br><img src=\"http://7xl4v5.com1.z0.glb.clouddn.com/ht.png\" alt=\"ht\"></p>\n<h3 id=\"2-ziplist结构：\"><a href=\"#2-ziplist结构：\" class=\"headerlink\" title=\"2.ziplist结构：\"></a>2.ziplist结构：</h3><p><strong>zlbytes</strong>：表示ziplist占用字节数，在执行resize操作时使用<br><strong>zltail</strong>：表示最后节点的偏移量，也是避免了整体遍历list<br><strong>zllen</strong>：表示ziplist节点个数（节点数超过65535,zllen字段值无效,需要遍历才能得到真实数量）<br><strong>zlend</strong>：表示ziplist结束的标识符</p>\n<p><strong>ziplist节点数据结构（抽象）：</strong><br>每个压缩列表节点都由previous_entry_length、encoding、content三个部分组成（不是指实际结构体的字段）<br><strong>previous_entry_length</strong>：前一个节点的长度，用来由后向前遍历，根据前一个节点的长度，可能需要一个或五个字节。<br><strong>encoding</strong>：记录节点保存的数据类型和数据长度。<br><strong>content</strong>：节点保存的数据内容。<br>ziplist节点结构体（和上面的有点不一样）:<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//ziplist.c</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zlentry</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> prevrawlensize, prevrawlen;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> lensize, len;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> headersize;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> encoding;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *p;</span><br><span class=\"line\">&#125; zlentry;</span><br></pre></td></tr></table></figure></p>\n<p>下图展示了一个ziplist的基本结构：<br><img src=\"http://7xl4v5.com1.z0.glb.clouddn.com/ziplist.png\" alt=\"ziplist\"></p>\n<p>可以看到，ziplist采用了一段连续的内存来存储数据，相比hashtable减少了内存碎片，和指针的内存占用。而且当节点较少时，ziplist更容易被加载到CPU缓存中。</p>\n<h2 id=\"三，调试源码\"><a href=\"#三，调试源码\" class=\"headerlink\" title=\"三，调试源码\"></a>三，调试源码</h2><p>眼见为实，现在通过vs2012启动redis server，调试redis源码对比hashtable和ziplist的处理过程。</p>\n<h3 id=\"调试hashtable保存hash对象\"><a href=\"#调试hashtable保存hash对象\" class=\"headerlink\" title=\"调试hashtable保存hash对象\"></a>调试hashtable保存hash对象</h3><p>server启动后，首先在t_hash.c 的hsetCommand函数打断点<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//t_hash.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">hsetCommand</span><span class=\"params\">(redisClient *c)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> update;</span><br><span class=\"line\">    robj *o;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((o = hashTypeLookupWriteOrCreate(c,c-&gt;argv[<span class=\"number\">1</span>])) == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    hashTypeTryConversion(o,c-&gt;argv,<span class=\"number\">2</span>,<span class=\"number\">3</span>);</span><br><span class=\"line\">    hashTypeTryObjectEncoding(o,&amp;c-&gt;argv[<span class=\"number\">2</span>], &amp;c-&gt;argv[<span class=\"number\">3</span>]);</span><br><span class=\"line\">    update = hashTypeSet(o,c-&gt;argv[<span class=\"number\">2</span>],c-&gt;argv[<span class=\"number\">3</span>]);</span><br><span class=\"line\">    addReply(c, update ? shared.czero : shared.cone);</span><br><span class=\"line\">    signalModifiedKey(c-&gt;db,c-&gt;argv[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    server.dirty++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在客户端执行命令,修改ziplist配置最大长度改成10，然后添加一个value长度超过10的hash对象：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; config set hash-max-ziplist-value 10</span><br><span class=\"line\">127.0.0.1:6379&gt; hset hash_key fieldkey abcdefghijklmn</span><br></pre></td></tr></table></figure></p>\n<p>进入t_hash.c文件的函数hashTypeSet,在这里redis判断对象编码为hashtable，使用字典保存:<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//t_hash.c</span></span><br><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (o-&gt;encoding == REDIS_ENCODING_HT) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dictReplace(o-&gt;ptr, field, value)) &#123; <span class=\"comment\">/* Insert */</span></span><br><span class=\"line\">            incrRefCount(field);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">/* Update */</span></span><br><span class=\"line\">            update = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        incrRefCount(value);</span><br></pre></td></tr></table></figure></p>\n<p>在dict.c文件dictAdd标记断点，开始分别保存key&amp;value到dict：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//dict.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dictAdd</span><span class=\"params\">(dict *d, <span class=\"keyword\">void</span> *key, <span class=\"keyword\">void</span> *val)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//往字典中添加一个只有key的dictEntry</span></span><br><span class=\"line\">    dictEntry *entry = dictAddRaw(d,key);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!entry) <span class=\"keyword\">return</span> DICT_ERR;</span><br><span class=\"line\">    <span class=\"comment\">//保存entry值的内容</span></span><br><span class=\"line\">    dictSetVal(d, entry, val);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> DICT_OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>首先redis调用函数dictAddRaw()保存hash key<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//dict.c</span></span><br><span class=\"line\"><span class=\"function\">dictEntry *<span class=\"title\">dictAddRaw</span><span class=\"params\">(dict *d, <span class=\"keyword\">void</span> *key)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> index;</span><br><span class=\"line\">    dictEntry *entry;</span><br><span class=\"line\">    dictht *ht;</span><br><span class=\"line\">    <span class=\"comment\">//因为redis采用渐进式rehash，首先要做rehash检查</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dictIsRehashing(d)) _dictRehashStep(d);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Get the index of the new element, or -1 if</span></span><br><span class=\"line\"><span class=\"comment\">     * the element already exists. */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((index = _dictKeyIndex(d, key)) == <span class=\"number\">-1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果字典正在rehash，则插入到新表ht[1]，否则到旧表ht[0]</span></span><br><span class=\"line\">    ht = dictIsRehashing(d) ? &amp;d-&gt;ht[<span class=\"number\">1</span>] : &amp;d-&gt;ht[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"comment\">/* 申请内存 保存新的entry节点*/</span></span><br><span class=\"line\">    entry = zmalloc(<span class=\"keyword\">sizeof</span>(*entry));</span><br><span class=\"line\">    entry-&gt;next = ht-&gt;table[index];</span><br><span class=\"line\">    ht-&gt;table[index] = entry;</span><br><span class=\"line\">    ht-&gt;used++;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* 保存entry key的内容 */</span></span><br><span class=\"line\">    dictSetKey(d, entry, key);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> entry;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>估算内存</strong><br>因为内存对齐的原因，sizeof(dictEntry)=24，为entry申请了24字节内存。估算一个节点的字节数 <strong>47byte</strong>(key 9bytes,val 14bytes,entry 24bytes)</p>\n<h3 id=\"调试ziplist保存hash对象\"><a href=\"#调试ziplist保存hash对象\" class=\"headerlink\" title=\"调试ziplist保存hash对象\"></a>调试ziplist保存hash对象</h3><p>首先清理数据，修改ziplist配置放宽value长度限制，保存同样内容：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; flushall</span><br><span class=\"line\">127.0.0.1:6379&gt; config set hash-max-ziplist-value 15</span><br><span class=\"line\">127.0.0.1:6379&gt; hset hash_key fieldkey abcdefghijklmn</span><br></pre></td></tr></table></figure></p>\n<p>此时还是在t_hash.c文件的函数hashTypeSet打断点,redis选择用ziplist编码保存hash对象<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//t_hash.c hashTypeSet()</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (o-&gt;encoding == REDIS_ENCODING_ZIPLIST) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *zl, *fptr, *vptr;</span><br><span class=\"line\"></span><br><span class=\"line\">        field = getDecodedObject(field);</span><br><span class=\"line\">        value = getDecodedObject(value);</span><br><span class=\"line\"></span><br><span class=\"line\">        zl = o-&gt;ptr;</span><br><span class=\"line\">        fptr = ziplistIndex(zl, ZIPLIST_HEAD);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (fptr != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//略</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!update) &#123;</span><br><span class=\"line\">            <span class=\"comment\">/* Push new field/value pair onto the tail of the ziplist */</span></span><br><span class=\"line\">            zl = ziplistPush(zl, field-&gt;ptr, (<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>)sdslen(field-&gt;ptr), ZIPLIST_TAIL);</span><br><span class=\"line\">            zl = ziplistPush(zl, value-&gt;ptr, (<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>)sdslen(value-&gt;ptr), ZIPLIST_TAIL);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        o-&gt;ptr = zl;</span><br><span class=\"line\">        <span class=\"comment\">//引用计数</span></span><br><span class=\"line\">        decrRefCount(field);</span><br><span class=\"line\">        decrRefCount(value);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*检查是否要换成hashtable编码*/</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (hashTypeLength(o) &gt; server.hash_max_ziplist_entries)</span><br><span class=\"line\">            hashTypeConvert(o, REDIS_ENCODING_HT);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>在ziplistPush内部调用了 ziplistInsert()函数，打开ziplist.c文件，在__ziplistInsert()函数打断点：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//ziplist.c</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *__ziplistInsert(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *zl, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *p, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *s, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> slen) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//当前ziplist的长度</span></span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), reqlen;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> prevlensize, prevlen = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> offset;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> nextdiff = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> encoding = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> value = <span class=\"number\">123456789</span>; </span><br><span class=\"line\">    zlentry tail;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p[<span class=\"number\">0</span>] != ZIP_END) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果p节点后面还有节点，取出p节点前一个节点的长度信息和存储该长度值所需要的字节数信息</span></span><br><span class=\"line\">        ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果p节点为ziplist结束标识，则取出尾节点，即最后一个节点</span></span><br><span class=\"line\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *ptail = ZIPLIST_ENTRY_TAIL(zl);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ptail[<span class=\"number\">0</span>] != ZIP_END) &#123;</span><br><span class=\"line\">            prevlen = zipRawEntryLength(ptail);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 尝试看能否将s保存为整数，如果可以则返回1，且value和encoding分别保存新值和编码信息</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (zipTryEncoding(s,slen,&amp;value,&amp;encoding)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果s可以保存为整数，则进一步计算保存该数值所需要的字节数</span></span><br><span class=\"line\">        reqlen = zipIntSize(encoding);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果s不能保存为整数，则直接使用其字符串长度</span></span><br><span class=\"line\">        reqlen = slen;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 计算编码prevlen所需要的字节数，prevlen用于保存前一个节点的长度</span></span><br><span class=\"line\">    reqlen += zipPrevEncodeLength(<span class=\"literal\">NULL</span>,prevlen);</span><br><span class=\"line\">    <span class=\"comment\">// 计算编码slen所需要的长度</span></span><br><span class=\"line\">    reqlen += zipEncodeLength(<span class=\"literal\">NULL</span>,encoding,slen);</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 当插入的位置不是ziplist尾部时，需要确保下一个节点（即p节点）的prevlen能够用来保存即将插入节点的长度</span></span><br><span class=\"line\">    <span class=\"comment\">// 这里计算两者差值</span></span><br><span class=\"line\">    nextdiff = (p[<span class=\"number\">0</span>] != ZIP_END) ? zipPrevLenByteDiff(p,reqlen) : <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ziplistResize操作会重新分配空间，需要事前记录p节点偏移量</span></span><br><span class=\"line\">    offset = p-zl;</span><br><span class=\"line\">    zl = ziplistResize(zl,curlen+reqlen+nextdiff);</span><br><span class=\"line\">    <span class=\"comment\">// 重新取得p节点</span></span><br><span class=\"line\">    p = zl+offset;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Apply memory move when necessary and update tail offset. */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p[<span class=\"number\">0</span>] != ZIP_END) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/* 将原来 p-nextdiff 开始的数据全部后移，中间出现reqlen个字节保存即将插入的数据 </span></span><br><span class=\"line\"><span class=\"comment\">            主要需要考虑一下几种情况：</span></span><br><span class=\"line\"><span class=\"comment\">            nextdiff == 0：p节点中用来存储原先前一个节点长度信息的数据区域正好保存待插入节点的长度</span></span><br><span class=\"line\"><span class=\"comment\">            nextdiff == 4：原先p节点只需要1个字节来存储上一个节点的长度，现在需要5个字节。那就将p-4后面的数据偏移到p+reqlen</span></span><br><span class=\"line\"><span class=\"comment\">            nextdiff == -4：原先p节点需要5个字节来存储上一个节点的长度，现在只需要1个字节。那就将p+4后面的数据偏移到p+reqlen</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">        memmove(p+reqlen,p-nextdiff,curlen-offset<span class=\"number\">-1</span>+nextdiff);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 为p节点的prevlen设置新值，即待插入节点的长度</span></span><br><span class=\"line\">        zipPrevEncodeLength(p+reqlen,reqlen);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 更新尾节点偏移量</span></span><br><span class=\"line\">        ZIPLIST_TAIL_OFFSET(zl) =</span><br><span class=\"line\">            intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+reqlen);</span><br><span class=\"line\"></span><br><span class=\"line\">        tail = zipEntry(p+reqlen);</span><br><span class=\"line\">        <span class=\"comment\">// 同样，如果p节点不是尾节点，尾节点的偏移量还需要加上nextdiff值</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p[reqlen+tail.headersize+tail.len] != ZIP_END) &#123;</span><br><span class=\"line\">            ZIPLIST_TAIL_OFFSET(zl) =</span><br><span class=\"line\">                intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+nextdiff);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果p节点指向zlend，更新zltail值，待添加节点为尾部节点</span></span><br><span class=\"line\">        ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(p-zl);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 同样，如果nextdiff的值不为0，说明原节点（此时的首地址为p+reqlen）的长度发生改变，需要执行级联更新操作</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nextdiff != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        offset = p-zl;</span><br><span class=\"line\">        <span class=\"comment\">//这里可能造成连锁更新</span></span><br><span class=\"line\">        zl = __ziplistCascadeUpdate(zl,p+reqlen);</span><br><span class=\"line\">        p = zl+offset;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 下面才是真正执行插入操作</span></span><br><span class=\"line\">    <span class=\"comment\">/* Write the entry */</span></span><br><span class=\"line\">    <span class=\"comment\">// 填写上一节点的长度</span></span><br><span class=\"line\">    p += zipPrevEncodeLength(p,prevlen);</span><br><span class=\"line\">    <span class=\"comment\">// 填写当前节点的长度</span></span><br><span class=\"line\">    p += zipEncodeLength(p,encoding,slen);</span><br><span class=\"line\">    <span class=\"comment\">// 根据编码方式执行相应的插入操作</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ZIP_IS_STR(encoding)) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">memcpy</span>(p,s,slen);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        zipSaveInteger(p,value,encoding);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 长度加1</span></span><br><span class=\"line\">    ZIPLIST_INCR_LENGTH(zl,<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> zl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>估算内存</strong><br>curlen表示当前ziplist的占用字节数,curlen初始值11，保存”fieldkey”后变为21，保存”abcdefghijklmn”变成38，估计一个节点占用<strong>27字节</strong>。</p>\n<p><strong>注意：</strong>当在ziplist头部执行增加或删除操作时，如果节点长度过长（超过255），previous_entry_length要使用5个字节保存，这时会执行__ziplistCascadeUpdate()函数，可能触发连锁更新，最坏情况要更新每一个后继节点（previous_entry_length从一个字节变成5个字节后，所有节点长度都超过了255）。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p><strong>ziplist的优点</strong><br>内存占用少 容易被加载到CPU缓存<br>结构紧凑 减少内存碎片</p>\n<p><strong>ziplist的缺点</strong><br>连锁更新（头部插入 或 删除，对头部的操作主要是在用ziplist保存list类型对象时发送，保存hash对象不需要在头部更新。）<br>查询复杂度从O（1）变成O（N）（保存hash对象时）</p>\n<p>参考：<br><a href=\"http://blog.csdn.net/xiejingfa/article/details/51072326\" target=\"_blank\" rel=\"noopener\">Redis内置数据结构之压缩列表ziplist</a><br><a href=\"http://blog.csdn.net/Rongbo_J/article/details/45288223\" target=\"_blank\" rel=\"noopener\">vs2012调试redis</a><br><a href=\"http://www.duokan.com/book/53962\" target=\"_blank\" rel=\"noopener\">《redis设计与实现》</a></p>\n","site":{"data":{}},"excerpt":"<p><strong>环境准备:</strong><br>redis 2.8.19 单机模式<br>保存500万条用户信息数据，key是用户名 ，value是json格式字符串，包含邮箱等信息，内容如下:<br><code>userid:  &quot;tomcat125&quot;\ninfo:  &quot;[null,\\&quot;tomcat125@gmail.com\\&quot;,188XXXXXXXX,\\&quot;\\&quot;,null,null,\\&quot;\\xe9\\x9c\\x8d\\xe6\\xb3\\x13\\xx4\\xb8\\xs0\\&quot;,\\&quot;1\\&quot;,null,\\&quot;tom123321\\&quot;]&quot;</code></p>\n<p>redis和ziplist配置有关的有这几个，默认值如下：<br>","more":"</p>\n<p><code>config get *ziplist*</code></p>\n<blockquote>\n<p>1) “hash-max-ziplist-entries”<br> 2) “512”<br> 3) “hash-max-ziplist-value”<br> 4) “64”<br> 5) “list-max-ziplist-entries”<br> 6) “512”<br> 7) “list-max-ziplist-value”<br> 8) “64”<br> 9) “zset-max-ziplist-entries”<br>10) “128”<br>11) “zset-max-ziplist-value”<br>12) “64”</p>\n</blockquote>\n<p>-entries表示ziplsit对多保存数据项的个数，超出之后不能再使用ziplist<br>-value表示每个数据项的最大字节数，超出之后不能再使用ziplist</p>\n<h2 id=\"一-使用ziplist真的能节省内存吗？\"><a href=\"#一-使用ziplist真的能节省内存吗？\" class=\"headerlink\" title=\"一.使用ziplist真的能节省内存吗？\"></a>一.使用ziplist真的能节省内存吗？</h2><p>在这我用hash对象用户信息，对比一下使用ziplist前后的内存差异：<br>为了使用hash保存，对用户名做hash然后取模得到一个hashkey<br>然后保存时执行命令：<code>hset hashkey username info</code></p>\n<h3 id=\"使用hashtable保存：\"><a href=\"#使用hashtable保存：\" class=\"headerlink\" title=\"使用hashtable保存：\"></a>使用hashtable保存：</h3><p>ziplist设置：</p>\n<blockquote>\n<p>config get hash*<br>1) “hash-max-ziplist-entries”<br>2) “512”<br>3) “hash-max-ziplist-value”<br>4) “64”</p>\n</blockquote>\n<p>hash对象信息(hashtable保存)：</p>\n<blockquote>\n<p>“debug object nozip:3134”<br>Value at:0x7f4957621d40 refcount:1<br><strong>encoding</strong>:<strong>hashtable</strong><br><strong>serializedlength:39927</strong><br>lru:3356615 lru_seconds_idle:24</p>\n</blockquote>\n<p>内存占用：</p>\n<blockquote>\n<p>“dbsize”<br>(integer) 12000<br>info Memory<br># Memory<br>used_memory:1102326968<br><strong>used_memory_human:1.03G</strong><br>used_memory_rss:1150930944<br>used_memory_peak:1102463200<br>used_memory_peak_human:1.03G<br>used_memory_lua:35840<br>mem_fragmentation_ratio:1.04</p>\n</blockquote>\n<p>清理内存，重启redis<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt;flushall</span><br><span class=\"line\">systemctl stop redis.service</span><br><span class=\"line\">systemctl start redis.service</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"使用ziplist保存\"><a href=\"#使用ziplist保存\" class=\"headerlink\" title=\"使用ziplist保存:\"></a>使用ziplist保存:</h3><p>修改ziplist设置(json串平均长度150)：</p>\n<blockquote>\n<p>“config get hash*”<br>1) “hash-max-ziplist-entries”<br>2) “1000”<br>3) “hash-max-ziplist-value”<br>4) “250”</p>\n</blockquote>\n<p>hash对象信息（ziplist保存）：</p>\n<blockquote>\n<p>“debug object nozip:3134”<br>Value at:0x7f490d21c150 refcount:1<br><strong>encoding:ziplist</strong><br><strong>serializedlength:18713</strong><br>lru:3360532 lru_seconds_idle:93</p>\n</blockquote>\n<p>内存占用：</p>\n<blockquote>\n<p>“dbsize”<br>(integer) 12000<br>info Memory<br># Memory<br>used_memory:573333824<br><strong>used_memory_human:546.77M</strong><br>used_memory_rss:633442304<br>used_memory_peak:1102178520<br>used_memory_peak_human:1.03G<br>used_memory_lua:35840<br>mem_fragmentation_ratio:1.10</p>\n</blockquote>\n<p>在上面的例子中可以看到利用ziplist在保存12000个hash对象时，<strong>used_memory节省了近50%</strong><br>同一个key的serializedlength也差不多是原来的一半(39927-18731)，但是serializedLength表示的不是key的实际内存占用，而是保存到rdb文件之后key的占用字节数，小于key的实际内存占用。<br>（<a href=\"https://github.com/antirez/redis/blob/4082c38a60eedd524c78ef48c1b241105f4ddc50/src/debug.c#L337-L343\" target=\"_blank\" rel=\"noopener\">参考serializedLength源</a>）</p>\n<h2 id=\"二-ziplist为什么能节省内存？\"><a href=\"#二-ziplist为什么能节省内存？\" class=\"headerlink\" title=\"二.ziplist为什么能节省内存？\"></a>二.ziplist为什么能节省内存？</h2><p>从debug object的输出信息来看，两次分别是使用hashtable和ziplist保存的，为什么ziplist会比hashtable节省内存呢，这要从二者的数据结构说起。</p>\n<h3 id=\"1-hashtable结构：\"><a href=\"#1-hashtable结构：\" class=\"headerlink\" title=\"1.hashtable结构：\"></a>1.hashtable结构：</h3><p>hashtable使用字典保存，字典包含两个hashtable,hashtable由entry数组构成，数组中的节点包含一个next指针，形成一个单向链表。<br>redis字典定义：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//dict.h</span></span><br><span class=\"line\"><span class=\"comment\">//字典</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dict</span> &#123;</span></span><br><span class=\"line\">    dictType *type;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> *privdata;</span><br><span class=\"line\">    dictht ht[<span class=\"number\">2</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> rehashidx; <span class=\"comment\">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> iterators; <span class=\"comment\">/* number of iterators currently running */</span></span><br><span class=\"line\">&#125; dict;</span><br><span class=\"line\"><span class=\"comment\">//字典内部hashtable</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictht</span> &#123;</span></span><br><span class=\"line\">    dictEntry **table;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> size;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> sizemask;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> used;</span><br><span class=\"line\">&#125; dictht;</span><br><span class=\"line\"><span class=\"comment\">//hashtable节点</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictEntry</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *key;</span><br><span class=\"line\">    <span class=\"keyword\">union</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">void</span> *val;</span><br><span class=\"line\">        <span class=\"keyword\">uint64_t</span> u64;</span><br><span class=\"line\">        <span class=\"keyword\">int64_t</span> s64;</span><br><span class=\"line\">    &#125; v;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictEntry</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125; dictEntry;</span><br></pre></td></tr></table></figure></p>\n<p>下图展示了一个普通状态下的字典,数据保存在ht[0]，ht<a href=\"https://github.com/antirez/redis/blob/4082c38a60eedd524c78ef48c1b241105f4ddc50/src/debug.c#L337-L343\" target=\"_blank\" rel=\"noopener\">1</a>在扩容时使用：<br><img src=\"http://7xl4v5.com1.z0.glb.clouddn.com/ht.png\" alt=\"ht\"></p>\n<h3 id=\"2-ziplist结构：\"><a href=\"#2-ziplist结构：\" class=\"headerlink\" title=\"2.ziplist结构：\"></a>2.ziplist结构：</h3><p><strong>zlbytes</strong>：表示ziplist占用字节数，在执行resize操作时使用<br><strong>zltail</strong>：表示最后节点的偏移量，也是避免了整体遍历list<br><strong>zllen</strong>：表示ziplist节点个数（节点数超过65535,zllen字段值无效,需要遍历才能得到真实数量）<br><strong>zlend</strong>：表示ziplist结束的标识符</p>\n<p><strong>ziplist节点数据结构（抽象）：</strong><br>每个压缩列表节点都由previous_entry_length、encoding、content三个部分组成（不是指实际结构体的字段）<br><strong>previous_entry_length</strong>：前一个节点的长度，用来由后向前遍历，根据前一个节点的长度，可能需要一个或五个字节。<br><strong>encoding</strong>：记录节点保存的数据类型和数据长度。<br><strong>content</strong>：节点保存的数据内容。<br>ziplist节点结构体（和上面的有点不一样）:<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//ziplist.c</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zlentry</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> prevrawlensize, prevrawlen;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> lensize, len;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> headersize;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> encoding;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *p;</span><br><span class=\"line\">&#125; zlentry;</span><br></pre></td></tr></table></figure></p>\n<p>下图展示了一个ziplist的基本结构：<br><img src=\"http://7xl4v5.com1.z0.glb.clouddn.com/ziplist.png\" alt=\"ziplist\"></p>\n<p>可以看到，ziplist采用了一段连续的内存来存储数据，相比hashtable减少了内存碎片，和指针的内存占用。而且当节点较少时，ziplist更容易被加载到CPU缓存中。</p>\n<h2 id=\"三，调试源码\"><a href=\"#三，调试源码\" class=\"headerlink\" title=\"三，调试源码\"></a>三，调试源码</h2><p>眼见为实，现在通过vs2012启动redis server，调试redis源码对比hashtable和ziplist的处理过程。</p>\n<h3 id=\"调试hashtable保存hash对象\"><a href=\"#调试hashtable保存hash对象\" class=\"headerlink\" title=\"调试hashtable保存hash对象\"></a>调试hashtable保存hash对象</h3><p>server启动后，首先在t_hash.c 的hsetCommand函数打断点<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//t_hash.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">hsetCommand</span><span class=\"params\">(redisClient *c)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> update;</span><br><span class=\"line\">    robj *o;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((o = hashTypeLookupWriteOrCreate(c,c-&gt;argv[<span class=\"number\">1</span>])) == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    hashTypeTryConversion(o,c-&gt;argv,<span class=\"number\">2</span>,<span class=\"number\">3</span>);</span><br><span class=\"line\">    hashTypeTryObjectEncoding(o,&amp;c-&gt;argv[<span class=\"number\">2</span>], &amp;c-&gt;argv[<span class=\"number\">3</span>]);</span><br><span class=\"line\">    update = hashTypeSet(o,c-&gt;argv[<span class=\"number\">2</span>],c-&gt;argv[<span class=\"number\">3</span>]);</span><br><span class=\"line\">    addReply(c, update ? shared.czero : shared.cone);</span><br><span class=\"line\">    signalModifiedKey(c-&gt;db,c-&gt;argv[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    server.dirty++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在客户端执行命令,修改ziplist配置最大长度改成10，然后添加一个value长度超过10的hash对象：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; config set hash-max-ziplist-value 10</span><br><span class=\"line\">127.0.0.1:6379&gt; hset hash_key fieldkey abcdefghijklmn</span><br></pre></td></tr></table></figure></p>\n<p>进入t_hash.c文件的函数hashTypeSet,在这里redis判断对象编码为hashtable，使用字典保存:<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//t_hash.c</span></span><br><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (o-&gt;encoding == REDIS_ENCODING_HT) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dictReplace(o-&gt;ptr, field, value)) &#123; <span class=\"comment\">/* Insert */</span></span><br><span class=\"line\">            incrRefCount(field);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">/* Update */</span></span><br><span class=\"line\">            update = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        incrRefCount(value);</span><br></pre></td></tr></table></figure></p>\n<p>在dict.c文件dictAdd标记断点，开始分别保存key&amp;value到dict：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//dict.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dictAdd</span><span class=\"params\">(dict *d, <span class=\"keyword\">void</span> *key, <span class=\"keyword\">void</span> *val)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//往字典中添加一个只有key的dictEntry</span></span><br><span class=\"line\">    dictEntry *entry = dictAddRaw(d,key);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!entry) <span class=\"keyword\">return</span> DICT_ERR;</span><br><span class=\"line\">    <span class=\"comment\">//保存entry值的内容</span></span><br><span class=\"line\">    dictSetVal(d, entry, val);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> DICT_OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>首先redis调用函数dictAddRaw()保存hash key<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//dict.c</span></span><br><span class=\"line\"><span class=\"function\">dictEntry *<span class=\"title\">dictAddRaw</span><span class=\"params\">(dict *d, <span class=\"keyword\">void</span> *key)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> index;</span><br><span class=\"line\">    dictEntry *entry;</span><br><span class=\"line\">    dictht *ht;</span><br><span class=\"line\">    <span class=\"comment\">//因为redis采用渐进式rehash，首先要做rehash检查</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dictIsRehashing(d)) _dictRehashStep(d);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Get the index of the new element, or -1 if</span></span><br><span class=\"line\"><span class=\"comment\">     * the element already exists. */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((index = _dictKeyIndex(d, key)) == <span class=\"number\">-1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果字典正在rehash，则插入到新表ht[1]，否则到旧表ht[0]</span></span><br><span class=\"line\">    ht = dictIsRehashing(d) ? &amp;d-&gt;ht[<span class=\"number\">1</span>] : &amp;d-&gt;ht[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"comment\">/* 申请内存 保存新的entry节点*/</span></span><br><span class=\"line\">    entry = zmalloc(<span class=\"keyword\">sizeof</span>(*entry));</span><br><span class=\"line\">    entry-&gt;next = ht-&gt;table[index];</span><br><span class=\"line\">    ht-&gt;table[index] = entry;</span><br><span class=\"line\">    ht-&gt;used++;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* 保存entry key的内容 */</span></span><br><span class=\"line\">    dictSetKey(d, entry, key);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> entry;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>估算内存</strong><br>因为内存对齐的原因，sizeof(dictEntry)=24，为entry申请了24字节内存。估算一个节点的字节数 <strong>47byte</strong>(key 9bytes,val 14bytes,entry 24bytes)</p>\n<h3 id=\"调试ziplist保存hash对象\"><a href=\"#调试ziplist保存hash对象\" class=\"headerlink\" title=\"调试ziplist保存hash对象\"></a>调试ziplist保存hash对象</h3><p>首先清理数据，修改ziplist配置放宽value长度限制，保存同样内容：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; flushall</span><br><span class=\"line\">127.0.0.1:6379&gt; config set hash-max-ziplist-value 15</span><br><span class=\"line\">127.0.0.1:6379&gt; hset hash_key fieldkey abcdefghijklmn</span><br></pre></td></tr></table></figure></p>\n<p>此时还是在t_hash.c文件的函数hashTypeSet打断点,redis选择用ziplist编码保存hash对象<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//t_hash.c hashTypeSet()</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (o-&gt;encoding == REDIS_ENCODING_ZIPLIST) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *zl, *fptr, *vptr;</span><br><span class=\"line\"></span><br><span class=\"line\">        field = getDecodedObject(field);</span><br><span class=\"line\">        value = getDecodedObject(value);</span><br><span class=\"line\"></span><br><span class=\"line\">        zl = o-&gt;ptr;</span><br><span class=\"line\">        fptr = ziplistIndex(zl, ZIPLIST_HEAD);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (fptr != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//略</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!update) &#123;</span><br><span class=\"line\">            <span class=\"comment\">/* Push new field/value pair onto the tail of the ziplist */</span></span><br><span class=\"line\">            zl = ziplistPush(zl, field-&gt;ptr, (<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>)sdslen(field-&gt;ptr), ZIPLIST_TAIL);</span><br><span class=\"line\">            zl = ziplistPush(zl, value-&gt;ptr, (<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>)sdslen(value-&gt;ptr), ZIPLIST_TAIL);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        o-&gt;ptr = zl;</span><br><span class=\"line\">        <span class=\"comment\">//引用计数</span></span><br><span class=\"line\">        decrRefCount(field);</span><br><span class=\"line\">        decrRefCount(value);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*检查是否要换成hashtable编码*/</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (hashTypeLength(o) &gt; server.hash_max_ziplist_entries)</span><br><span class=\"line\">            hashTypeConvert(o, REDIS_ENCODING_HT);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>在ziplistPush内部调用了 ziplistInsert()函数，打开ziplist.c文件，在__ziplistInsert()函数打断点：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//ziplist.c</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *__ziplistInsert(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *zl, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *p, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *s, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> slen) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//当前ziplist的长度</span></span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), reqlen;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> prevlensize, prevlen = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> offset;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> nextdiff = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> encoding = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> value = <span class=\"number\">123456789</span>; </span><br><span class=\"line\">    zlentry tail;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p[<span class=\"number\">0</span>] != ZIP_END) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果p节点后面还有节点，取出p节点前一个节点的长度信息和存储该长度值所需要的字节数信息</span></span><br><span class=\"line\">        ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果p节点为ziplist结束标识，则取出尾节点，即最后一个节点</span></span><br><span class=\"line\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *ptail = ZIPLIST_ENTRY_TAIL(zl);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ptail[<span class=\"number\">0</span>] != ZIP_END) &#123;</span><br><span class=\"line\">            prevlen = zipRawEntryLength(ptail);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 尝试看能否将s保存为整数，如果可以则返回1，且value和encoding分别保存新值和编码信息</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (zipTryEncoding(s,slen,&amp;value,&amp;encoding)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果s可以保存为整数，则进一步计算保存该数值所需要的字节数</span></span><br><span class=\"line\">        reqlen = zipIntSize(encoding);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果s不能保存为整数，则直接使用其字符串长度</span></span><br><span class=\"line\">        reqlen = slen;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 计算编码prevlen所需要的字节数，prevlen用于保存前一个节点的长度</span></span><br><span class=\"line\">    reqlen += zipPrevEncodeLength(<span class=\"literal\">NULL</span>,prevlen);</span><br><span class=\"line\">    <span class=\"comment\">// 计算编码slen所需要的长度</span></span><br><span class=\"line\">    reqlen += zipEncodeLength(<span class=\"literal\">NULL</span>,encoding,slen);</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 当插入的位置不是ziplist尾部时，需要确保下一个节点（即p节点）的prevlen能够用来保存即将插入节点的长度</span></span><br><span class=\"line\">    <span class=\"comment\">// 这里计算两者差值</span></span><br><span class=\"line\">    nextdiff = (p[<span class=\"number\">0</span>] != ZIP_END) ? zipPrevLenByteDiff(p,reqlen) : <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ziplistResize操作会重新分配空间，需要事前记录p节点偏移量</span></span><br><span class=\"line\">    offset = p-zl;</span><br><span class=\"line\">    zl = ziplistResize(zl,curlen+reqlen+nextdiff);</span><br><span class=\"line\">    <span class=\"comment\">// 重新取得p节点</span></span><br><span class=\"line\">    p = zl+offset;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Apply memory move when necessary and update tail offset. */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p[<span class=\"number\">0</span>] != ZIP_END) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/* 将原来 p-nextdiff 开始的数据全部后移，中间出现reqlen个字节保存即将插入的数据 </span></span><br><span class=\"line\"><span class=\"comment\">            主要需要考虑一下几种情况：</span></span><br><span class=\"line\"><span class=\"comment\">            nextdiff == 0：p节点中用来存储原先前一个节点长度信息的数据区域正好保存待插入节点的长度</span></span><br><span class=\"line\"><span class=\"comment\">            nextdiff == 4：原先p节点只需要1个字节来存储上一个节点的长度，现在需要5个字节。那就将p-4后面的数据偏移到p+reqlen</span></span><br><span class=\"line\"><span class=\"comment\">            nextdiff == -4：原先p节点需要5个字节来存储上一个节点的长度，现在只需要1个字节。那就将p+4后面的数据偏移到p+reqlen</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">        memmove(p+reqlen,p-nextdiff,curlen-offset<span class=\"number\">-1</span>+nextdiff);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 为p节点的prevlen设置新值，即待插入节点的长度</span></span><br><span class=\"line\">        zipPrevEncodeLength(p+reqlen,reqlen);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 更新尾节点偏移量</span></span><br><span class=\"line\">        ZIPLIST_TAIL_OFFSET(zl) =</span><br><span class=\"line\">            intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+reqlen);</span><br><span class=\"line\"></span><br><span class=\"line\">        tail = zipEntry(p+reqlen);</span><br><span class=\"line\">        <span class=\"comment\">// 同样，如果p节点不是尾节点，尾节点的偏移量还需要加上nextdiff值</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p[reqlen+tail.headersize+tail.len] != ZIP_END) &#123;</span><br><span class=\"line\">            ZIPLIST_TAIL_OFFSET(zl) =</span><br><span class=\"line\">                intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+nextdiff);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果p节点指向zlend，更新zltail值，待添加节点为尾部节点</span></span><br><span class=\"line\">        ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(p-zl);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 同样，如果nextdiff的值不为0，说明原节点（此时的首地址为p+reqlen）的长度发生改变，需要执行级联更新操作</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nextdiff != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        offset = p-zl;</span><br><span class=\"line\">        <span class=\"comment\">//这里可能造成连锁更新</span></span><br><span class=\"line\">        zl = __ziplistCascadeUpdate(zl,p+reqlen);</span><br><span class=\"line\">        p = zl+offset;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 下面才是真正执行插入操作</span></span><br><span class=\"line\">    <span class=\"comment\">/* Write the entry */</span></span><br><span class=\"line\">    <span class=\"comment\">// 填写上一节点的长度</span></span><br><span class=\"line\">    p += zipPrevEncodeLength(p,prevlen);</span><br><span class=\"line\">    <span class=\"comment\">// 填写当前节点的长度</span></span><br><span class=\"line\">    p += zipEncodeLength(p,encoding,slen);</span><br><span class=\"line\">    <span class=\"comment\">// 根据编码方式执行相应的插入操作</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ZIP_IS_STR(encoding)) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">memcpy</span>(p,s,slen);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        zipSaveInteger(p,value,encoding);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 长度加1</span></span><br><span class=\"line\">    ZIPLIST_INCR_LENGTH(zl,<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> zl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>估算内存</strong><br>curlen表示当前ziplist的占用字节数,curlen初始值11，保存”fieldkey”后变为21，保存”abcdefghijklmn”变成38，估计一个节点占用<strong>27字节</strong>。</p>\n<p><strong>注意：</strong>当在ziplist头部执行增加或删除操作时，如果节点长度过长（超过255），previous_entry_length要使用5个字节保存，这时会执行__ziplistCascadeUpdate()函数，可能触发连锁更新，最坏情况要更新每一个后继节点（previous_entry_length从一个字节变成5个字节后，所有节点长度都超过了255）。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p><strong>ziplist的优点</strong><br>内存占用少 容易被加载到CPU缓存<br>结构紧凑 减少内存碎片</p>\n<p><strong>ziplist的缺点</strong><br>连锁更新（头部插入 或 删除，对头部的操作主要是在用ziplist保存list类型对象时发送，保存hash对象不需要在头部更新。）<br>查询复杂度从O（1）变成O（N）（保存hash对象时）</p>\n<p>参考：<br><a href=\"http://blog.csdn.net/xiejingfa/article/details/51072326\" target=\"_blank\" rel=\"noopener\">Redis内置数据结构之压缩列表ziplist</a><br><a href=\"http://blog.csdn.net/Rongbo_J/article/details/45288223\" target=\"_blank\" rel=\"noopener\">vs2012调试redis</a><br><a href=\"http://www.duokan.com/book/53962\" target=\"_blank\" rel=\"noopener\">《redis设计与实现》</a></p>"},{"title":"图解redis sentinel","date":"2017-11-21T15:15:46.000Z","_content":"\nredis sentinel是redis为支持自动failover的主从模式开发的功能，sentinel实际上也是一个redis实例，不过它只支持部分特有命令，通过`redis-server /path/to/sentinel.conf --sentinel`启动sentinel实例。\n<!--more-->\n\n### 整体视图\nsentinel服务由多个节点组成，当进行容灾操作时需要多数节点达成一致，因此sentinel节点之间需要建立通信（蓝色部分）。同时为了监控redis节点状态，每个sentinel节点都会和redis实例建立命令连接（图中虚线），sentinel节点还会通过publish命令向其他节点（包括master/slave/sentinel）发送\"hello msg\"(参考[^sentinelSendPeriodicCommands]）\n，通过redis的发布/订阅功能来交换信息。\n\n注意：sentinel接收publish命令时执行的是fake publish\n![overview][1]\n\n继续下面的内容前，需要了解sentinel的几个重要配置参数：\n\n>**monitor** master_name,master_ip,master_port,quorum\n (master信息客观下线需要的票数)\n**down-after-milliseconds** master_name XXms (失联多久被视为主观下线)\n**failover-timeout** master_name XXms (处理故障的超时时间)\n**parallel-syncs**  master_name number (执行故障转移时，可以同时从新的master同步数据的slave数量）\n\n### 发现新redis实例\n可以发现配置sentinel时不需要填写slave节点的信息，这是因为sentinel可以从它监视的master发送INFO命令获得对应的slave信息，然后再与slave建立连接。通过这种方式sentinel也能够发现新加入的slave节点，过程如图所示：\n![1][2]\n### 发现新sentinel实例\n类似地，一个sentinel实例也能够自主的发现其他sentinel实例，不过这是通过channel接收其他sentinel实例发送的消息实现的，每个sentinel实例会定时所有节点发送PUBLISH命令来向channel投递消息，内容主要是sentinel自己和信息和它保存的master的信息，格式如下：\n```\nPUBLISH __sentinel__:hello sentinel_ip,sentinel_port,sentinel_runid,current_epoch,\nmaster_name,master_ip,master_port,master_config_epoch.\n```\n消息会由redis实例的频道发送给所有监视实例的sentinel，其他sentinel收到信息后，如果自己没有保存消息中的sentinel会保存下来，同时epoch如果小于消息中epoch也会自我更新：\n![step2][3]\n\n### 判断节点下线过程\nsentinel会通过定时向监视的redis实例发送ping命令，检查redis的状态，当redis回复异常或者在超时时间内没有回复时sentinel会将节点设置为主观下线（subjectively down）。而且如果节点是master的话，sentinel需要判断节点是否能设置为客观下线（Objectively down）,过程如图所示：\n（1）节点回复不正常，sentinel把节点置为主观下线\n（2）给其他sentinel发送`is-master-down-by-addr`命令，格式如下`IS-MASTER-DOWN-BY-ADDR <master_ip> <master_port> <sentinel:current-epoch> <sentinel:runid>`\n（只有当发起投票时才会发送runid,此时runid内容为*）\n（3）收到`is-master-down-by-addr`的sentinel检查对应redis实例的状态（实际不会发送ping命令，只是检查保存的节点状态是不是主观下线）\n（4）发现节点下线回复消息，回复内容如下，后两个是投票时用到的`down state, leader, vote epoch`\n（5）当sentinel1 收到足够多的“节点下线”的回复后（大于配置的quorum），将master状态设置为客观下线，然后failover流程才开始进行。\n\n![s3][4]\n\n### failover第一步:选举leader\nfailover操作只能由一个sentinel节点来执行，因此开始failover首先要选举出一个Leader,sentinel的选举采用的是[Raft算法][5]中的领导人选举机制。在这里确认master客观下线的sentinel会成为候选人，等待failover_start_time（一个随机时间，为了避免候选人同时开始选举导致平票），然后开始向其他实例发起投票请求，依然是使用`is-master-down-by-addr`命令，投票时主要依据是epoch字段。具体流程如图所示：\n![s4][6]\n\n### failover第二步：执行故障转移\nLeader选举成功之后，会在slave中选择一个最优的，然后“提拔”这个slave作为新的master,然后其他redis实例会来同步新master的数据，具体过程如下：\n![dofailover][7]\n### sentinel的整体执行流程\n上面描述的行为都是通过redis定时任务来驱动的，特别的，sentinel中定义了一个状态机（switch-case代码块）来根据此时master的failover_state执行不同的操作，下面的图从外向内展示了sentinel主要功能的调用过程：\n>（1）servCron函数(在server.c)负责执行redis的定时任务，包括过期键，写AOF文件等等，同时包括执行sentinel定时任务\n（2）sentinelTimer(sentinel.c)是sentinel模式的定时任务，执行[TILT模式][8]的检查，执行脚本，还有就是处理RedisInstance（集群中所有的master/slave/sentinel实例）\n（3）在sentinelHandleRedisInstance函数中，会依次执行reconnect函数维护与其他实例的连接（命令连接和pub/sub）,定期发送命令（info/ping/hello）,判断主观下线\n（4）当实例是master时会执行客观下线的检查，在StartFailoverIfNeeded函数中，如果满足条件会开始failover的过程（master会变成SENTINEL_FAILOVER_STATE_WAIT_START，然后还会向其他sentinel确认master状态，使用force模式才会发送is-master-down命令，此时可能也会发起投票）\n（5）状态机逻辑的执行在StartFailoverIfNeeded执行之后（和上一步结果无关），状态机就是在每次定时任务循环中检查当前master的状态然后执行不同阶段的failover操作，最后会执行askOther的步骤，本次定时任务结束。\n\n\n![state][9]\n### 附录\n\n**1、完整的failoverstate**\n```c \n/* Failover machine different states. */\n#define SENTINEL_FAILOVER_STATE_NONE 0  /* No failover in progress. */\n#define SENTINEL_FAILOVER_STATE_WAIT_START 1  /* Wait for failover_start_time*/\n#define SENTINEL_FAILOVER_STATE_SELECT_SLAVE 2 /* Select slave to promote */\n#define SENTINEL_FAILOVER_STATE_SEND_SLAVEOF_NOONE 3 /* Slave -> Master */\n#define SENTINEL_FAILOVER_STATE_WAIT_PROMOTION 4 /* Wait slave to change role */\n#define SENTINEL_FAILOVER_STATE_RECONF_SLAVES 5 /* SLAVEOF newmaster */\n#define SENTINEL_FAILOVER_STATE_UPDATE_CONFIG 6 /* Monitor promoted slave.master配置更新为新的master */\n```\n**2、redis实例收到的sentinel消息**\n集群中一台slave的hello频道中传播的消息，此时master端口是6380：\n```\n127.0.0.1:6379> psubscribe *\n1) \"pmessage\"\n2) \"*\"\n3) \"__sentinel__:hello\"\n4) \"127.0.0.1,26380,299da3eb5862baf267d16e36306defe7517bab5b,3,mymaster,127.0.0.1,6380,3\"\n1) \"pmessage\"\n2) \"*\"\n3) \"__sentinel__:hello\"\n4) \"127.0.0.1,26381,bf3ac725160092d5db0fefdcc4814379003a75a8,3,mymaster,127.0.0.1,6380,3\"\n1) \"pmessage\"\n2) \"*\"\n3) \"__sentinel__:hello\"\n4) \"127.0.0.1,26379,9e47039b5fd9735296df2340e54a4c37caeabbb2,3,mymaster,127.0.0.1,6380,3\"\n```\n**3、一次failover的日志**\nmaster port:6380\nLeader port:26380\nLeader run_id:299da3eb5862baf267d16e36306defe7517bab5b\n**follower sentinel收到的消息:**\n```\n127.0.0.1:26379> psubscribe *\nReading messages... (press Ctrl-C to quit)\n1) \"psubscribe\"\n2) \"*\"\n3) (integer) 1\n1) \"pmessage\"\n2) \"*\"\n3) \"+new-epoch\"\n4) \"2\"\n1) \"pmessage\"\n2) \"*\"\n3) \"+vote-for-leader\"\n4) \"299da3eb5862baf267d16e36306defe7517bab5b 2\"\n1) \"pmessage\"\n2) \"*\"\n3) \"+sdown\"\n4) \"master mymaster 127.0.0.1 6380\"\n1) \"pmessage\"\n2) \"*\"\n3) \"+odown\"\n4) \"master mymaster 127.0.0.1 6380 #quorum 3/2\"\n1) \"pmessage\"\n2) \"*\"\n3) \"+config-update-from\"\n4) \"sentinel 127.0.0.1:26380 127.0.0.1 26380 @ mymaster 127.0.0.1 6380\"\n1) \"pmessage\"\n2) \"*\"\n3) \"+switch-master\"\n4) \"mymaster 127.0.0.1 6380 127.0.0.1 6381\"\n1) \"pmessage\"\n2) \"*\"\n3) \"+slave\"\n4) \"slave 127.0.0.1:6379 127.0.0.1 6379 @ mymaster 127.0.0.1 6381\"\n1) \"pmessage\"\n2) \"*\"\n3) \"+slave\"\n4) \"slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6381\"\n1) \"pmessage\"\n2) \"*\"\n3) \"+sdown\"\n4) \"slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6381\"\n1) \"pmessage\"\n2) \"*\"\n3) \"-role-change\"\n4) \"slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6381 new reported role is master\"\n1) \"pmessage\"\n2) \"*\"\n3) \"-sdown\"\n4) \"slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6381\"\n1) \"pmessage\"\n2) \"*\"\n3) \"+role-change\"\n4) \"slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6381 new reported role is slave\"\n\n```\nsentinel消息各种 + - 标识的含义:\n>+reset-master <instance details> -- The master was reset.\n    +slave <instance details> -- A new slave was detected and attached.\n    +failover-state-reconf-slaves <instance details> -- Failover state changed to reconf-slaves state.\n    +failover-detected <instance details> -- A failover started by another Sentinel or any other external entity was detected (An attached slave turned into a master).\n    +slave-reconf-sent <instance details> -- The leader sentinel sent the SLAVEOF command to this instance in order to reconfigure it for the new slave.\n    +slave-reconf-inprog <instance details> -- The slave being reconfigured showed to be a slave of the new master ip:port pair, but the synchronization process is not yet complete.\n    +slave-reconf-done <instance details> -- The slave is now synchronized with the new master.\n    -dup-sentinel <instance details> -- One or more sentinels for the specified master were removed as duplicated (this happens for instance when a Sentinel instance is restarted).\n    +sentinel <instance details> -- A new sentinel for this master was detected and attached.\n    +sdown <instance details> -- The specified instance is now in Subjectively Down state.\n    -sdown <instance details> -- The specified instance is no longer in Subjectively Down state.\n    +odown <instance details> -- The specified instance is now in Objectively Down state.\n    -odown <instance details> -- The specified instance is no longer in Objectively Down state.\n    +new-epoch <instance details> -- The current epoch was updated.\n    +try-failover <instance details> -- New failover in progress, waiting to be elected by the majority.\n    +elected-leader <instance details> -- Won the election for the specified epoch, can do the failover.\n    +failover-state-select-slave <instance details> -- New failover state is select-slave: we are trying to find a suitable slave for promotion.\n    no-good-slave <instance details> -- There is no good slave to promote. Currently we'll try after some time, but probably this will change and the state machine will abort the failover at all in this case.\n    selected-slave <instance details> -- We found the specified good slave to promote.\n    failover-state-send-slaveof-noone <instance details> -- We are trying to reconfigure the promoted slave as master, waiting for it to switch.\n    failover-end-for-timeout <instance details> -- The failover terminated for timeout, slaves will eventually be configured to replicate with the new master anyway.\n    failover-end <instance details> -- The failover terminated with success. All the slaves appears to be reconfigured to replicate with the new master.\n    switch-master <master name> <oldip> <oldport> <newip> <newport> -- The master new IP and address is the specified one after a configuration change. This is the message most external users are interested in.\n    +tilt -- Tilt mode entered.\n    -tilt -- Tilt mode exited.\n\n**leader 日志**\n```\n[30369] 13 Jan 20:21:06.701 # +sdown master mymaster 127.0.0.1 6380\n[30369] 13 Jan 20:21:06.768 # +odown master mymaster 127.0.0.1 6380 #quorum 2/2\n[30369] 13 Jan 20:21:06.768 # +new-epoch 2\n[30369] 13 Jan 20:21:06.768 # +try-failover master mymaster 127.0.0.1 6380\n[30369] 13 Jan 20:21:06.782 # +vote-for-leader 299da3eb5862baf267d16e36306defe7517bab5b 2\n[30369] 13 Jan 20:21:06.821 # 127.0.0.1:26381 voted for 299da3eb5862baf267d16e36306defe7517bab5b 2\n[30369] 13 Jan 20:21:06.821 # 127.0.0.1:26379 voted for 299da3eb5862baf267d16e36306defe7517bab5b 2\n[30369] 13 Jan 20:21:06.844 # +elected-leader master mymaster 127.0.0.1 6380\n[30369] 13 Jan 20:21:06.844 # +failover-state-select-slave master mymaster 127.0.0.1 6380\n[30369] 13 Jan 20:21:06.902 # +selected-slave slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6380\n[30369] 13 Jan 20:21:06.902 * +failover-state-send-slaveof-noone slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6380\n[30369] 13 Jan 20:21:06.965 * +failover-state-wait-promotion slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6380\n[30369] 13 Jan 20:21:07.830 # +promoted-slave slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6380\n[30369] 13 Jan 20:21:07.830 # +failover-state-reconf-slaves master mymaster 127.0.0.1 6380\n[30369] 13 Jan 20:21:07.872 * +slave-reconf-sent slave 127.0.0.1:6379 127.0.0.1 6379 @ mymaster 127.0.0.1 6380\n[30369] 13 Jan 20:21:08.852 * +slave-reconf-inprog slave 127.0.0.1:6379 127.0.0.1 6379 @ mymaster 127.0.0.1 6380\n[30369] 13 Jan 20:21:08.976 # -odown master mymaster 127.0.0.1 6380\n[30369] 13 Jan 20:22:53.198 * +reboot master mymaster 127.0.0.1 6380\n[30369] 13 Jan 20:22:53.249 # -sdown master mymaster 127.0.0.1 6380\n\n```\n**follower 日志**\n```\n[29838] 13 Jan 20:21:06.803 # +new-epoch 2\n[29838] 13 Jan 20:21:06.821 # +vote-for-leader 299da3eb5862baf267d16e36306defe7517bab5b 2\n[29838] 13 Jan 20:21:06.821 # +sdown master mymaster 127.0.0.1 6380\n[29838] 13 Jan 20:21:06.898 # +odown master mymaster 127.0.0.1 6380 #quorum 3/2\n[29838] 13 Jan 20:21:06.898 # Next failover delay: I will not start a failover before Sat Jan 13 20:27:07 2018\n[29838] 13 Jan 20:21:07.874 # +config-update-from sentinel 127.0.0.1:26380 127.0.0.1 26380 @ mymaster 127.0.0.1 6380\n[29838] 13 Jan 20:21:07.874 # +switch-master mymaster 127.0.0.1 6380 127.0.0.1 6381\n[29838] 13 Jan 20:21:07.874 * +slave slave 127.0.0.1:6379 127.0.0.1 6379 @ mymaster 127.0.0.1 6381\n[29838] 13 Jan 20:21:07.894 * +slave slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6381\n[29838] 13 Jan 20:21:37.913 # +sdown slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6381\n[29838] 13 Jan 20:22:53.322 # -sdown slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6381\n```\n[^sentinelSendPeriodicCommands]:https://github.com/antirez/redis/blob/3.0/src/sentinel.c sentinelSendPeriodicCommands()\n\n\n  [1]: http://7xl4v5.com1.z0.glb.clouddn.com/sentinel.png\n  [2]: http://7xl4v5.com1.z0.glb.clouddn.com/redis/sentinel/s1.png\n  [3]: http://7xl4v5.com1.z0.glb.clouddn.com/redis/sentinel/s2.png\n  [4]: http://7xl4v5.com1.z0.glb.clouddn.com/redis/sentinel/s3.png\n  [5]: http://www.infoq.com/cn/articles/raft-paper\n  [6]: http://7xl4v5.com1.z0.glb.clouddn.com/redis/sentinel/s4.png\n  [7]: http://7xl4v5.com1.z0.glb.clouddn.com/redis/sentinel/s5.png\n  [8]: http://doc.redisfans.com/topic/sentinel.html#tilt\n  [9]: http://7xl4v5.com1.z0.glb.clouddn.com/redis/sentinel/state.png","source":"_posts/图解redis sentinel.md","raw":"title: 图解redis sentinel\ndate: 2017-11-21 23:15:46\ncategories: redis进阶\ntags: [redis,nosql,源码]\n---\n\nredis sentinel是redis为支持自动failover的主从模式开发的功能，sentinel实际上也是一个redis实例，不过它只支持部分特有命令，通过`redis-server /path/to/sentinel.conf --sentinel`启动sentinel实例。\n<!--more-->\n\n### 整体视图\nsentinel服务由多个节点组成，当进行容灾操作时需要多数节点达成一致，因此sentinel节点之间需要建立通信（蓝色部分）。同时为了监控redis节点状态，每个sentinel节点都会和redis实例建立命令连接（图中虚线），sentinel节点还会通过publish命令向其他节点（包括master/slave/sentinel）发送\"hello msg\"(参考[^sentinelSendPeriodicCommands]）\n，通过redis的发布/订阅功能来交换信息。\n\n注意：sentinel接收publish命令时执行的是fake publish\n![overview][1]\n\n继续下面的内容前，需要了解sentinel的几个重要配置参数：\n\n>**monitor** master_name,master_ip,master_port,quorum\n (master信息客观下线需要的票数)\n**down-after-milliseconds** master_name XXms (失联多久被视为主观下线)\n**failover-timeout** master_name XXms (处理故障的超时时间)\n**parallel-syncs**  master_name number (执行故障转移时，可以同时从新的master同步数据的slave数量）\n\n### 发现新redis实例\n可以发现配置sentinel时不需要填写slave节点的信息，这是因为sentinel可以从它监视的master发送INFO命令获得对应的slave信息，然后再与slave建立连接。通过这种方式sentinel也能够发现新加入的slave节点，过程如图所示：\n![1][2]\n### 发现新sentinel实例\n类似地，一个sentinel实例也能够自主的发现其他sentinel实例，不过这是通过channel接收其他sentinel实例发送的消息实现的，每个sentinel实例会定时所有节点发送PUBLISH命令来向channel投递消息，内容主要是sentinel自己和信息和它保存的master的信息，格式如下：\n```\nPUBLISH __sentinel__:hello sentinel_ip,sentinel_port,sentinel_runid,current_epoch,\nmaster_name,master_ip,master_port,master_config_epoch.\n```\n消息会由redis实例的频道发送给所有监视实例的sentinel，其他sentinel收到信息后，如果自己没有保存消息中的sentinel会保存下来，同时epoch如果小于消息中epoch也会自我更新：\n![step2][3]\n\n### 判断节点下线过程\nsentinel会通过定时向监视的redis实例发送ping命令，检查redis的状态，当redis回复异常或者在超时时间内没有回复时sentinel会将节点设置为主观下线（subjectively down）。而且如果节点是master的话，sentinel需要判断节点是否能设置为客观下线（Objectively down）,过程如图所示：\n（1）节点回复不正常，sentinel把节点置为主观下线\n（2）给其他sentinel发送`is-master-down-by-addr`命令，格式如下`IS-MASTER-DOWN-BY-ADDR <master_ip> <master_port> <sentinel:current-epoch> <sentinel:runid>`\n（只有当发起投票时才会发送runid,此时runid内容为*）\n（3）收到`is-master-down-by-addr`的sentinel检查对应redis实例的状态（实际不会发送ping命令，只是检查保存的节点状态是不是主观下线）\n（4）发现节点下线回复消息，回复内容如下，后两个是投票时用到的`down state, leader, vote epoch`\n（5）当sentinel1 收到足够多的“节点下线”的回复后（大于配置的quorum），将master状态设置为客观下线，然后failover流程才开始进行。\n\n![s3][4]\n\n### failover第一步:选举leader\nfailover操作只能由一个sentinel节点来执行，因此开始failover首先要选举出一个Leader,sentinel的选举采用的是[Raft算法][5]中的领导人选举机制。在这里确认master客观下线的sentinel会成为候选人，等待failover_start_time（一个随机时间，为了避免候选人同时开始选举导致平票），然后开始向其他实例发起投票请求，依然是使用`is-master-down-by-addr`命令，投票时主要依据是epoch字段。具体流程如图所示：\n![s4][6]\n\n### failover第二步：执行故障转移\nLeader选举成功之后，会在slave中选择一个最优的，然后“提拔”这个slave作为新的master,然后其他redis实例会来同步新master的数据，具体过程如下：\n![dofailover][7]\n### sentinel的整体执行流程\n上面描述的行为都是通过redis定时任务来驱动的，特别的，sentinel中定义了一个状态机（switch-case代码块）来根据此时master的failover_state执行不同的操作，下面的图从外向内展示了sentinel主要功能的调用过程：\n>（1）servCron函数(在server.c)负责执行redis的定时任务，包括过期键，写AOF文件等等，同时包括执行sentinel定时任务\n（2）sentinelTimer(sentinel.c)是sentinel模式的定时任务，执行[TILT模式][8]的检查，执行脚本，还有就是处理RedisInstance（集群中所有的master/slave/sentinel实例）\n（3）在sentinelHandleRedisInstance函数中，会依次执行reconnect函数维护与其他实例的连接（命令连接和pub/sub）,定期发送命令（info/ping/hello）,判断主观下线\n（4）当实例是master时会执行客观下线的检查，在StartFailoverIfNeeded函数中，如果满足条件会开始failover的过程（master会变成SENTINEL_FAILOVER_STATE_WAIT_START，然后还会向其他sentinel确认master状态，使用force模式才会发送is-master-down命令，此时可能也会发起投票）\n（5）状态机逻辑的执行在StartFailoverIfNeeded执行之后（和上一步结果无关），状态机就是在每次定时任务循环中检查当前master的状态然后执行不同阶段的failover操作，最后会执行askOther的步骤，本次定时任务结束。\n\n\n![state][9]\n### 附录\n\n**1、完整的failoverstate**\n```c \n/* Failover machine different states. */\n#define SENTINEL_FAILOVER_STATE_NONE 0  /* No failover in progress. */\n#define SENTINEL_FAILOVER_STATE_WAIT_START 1  /* Wait for failover_start_time*/\n#define SENTINEL_FAILOVER_STATE_SELECT_SLAVE 2 /* Select slave to promote */\n#define SENTINEL_FAILOVER_STATE_SEND_SLAVEOF_NOONE 3 /* Slave -> Master */\n#define SENTINEL_FAILOVER_STATE_WAIT_PROMOTION 4 /* Wait slave to change role */\n#define SENTINEL_FAILOVER_STATE_RECONF_SLAVES 5 /* SLAVEOF newmaster */\n#define SENTINEL_FAILOVER_STATE_UPDATE_CONFIG 6 /* Monitor promoted slave.master配置更新为新的master */\n```\n**2、redis实例收到的sentinel消息**\n集群中一台slave的hello频道中传播的消息，此时master端口是6380：\n```\n127.0.0.1:6379> psubscribe *\n1) \"pmessage\"\n2) \"*\"\n3) \"__sentinel__:hello\"\n4) \"127.0.0.1,26380,299da3eb5862baf267d16e36306defe7517bab5b,3,mymaster,127.0.0.1,6380,3\"\n1) \"pmessage\"\n2) \"*\"\n3) \"__sentinel__:hello\"\n4) \"127.0.0.1,26381,bf3ac725160092d5db0fefdcc4814379003a75a8,3,mymaster,127.0.0.1,6380,3\"\n1) \"pmessage\"\n2) \"*\"\n3) \"__sentinel__:hello\"\n4) \"127.0.0.1,26379,9e47039b5fd9735296df2340e54a4c37caeabbb2,3,mymaster,127.0.0.1,6380,3\"\n```\n**3、一次failover的日志**\nmaster port:6380\nLeader port:26380\nLeader run_id:299da3eb5862baf267d16e36306defe7517bab5b\n**follower sentinel收到的消息:**\n```\n127.0.0.1:26379> psubscribe *\nReading messages... (press Ctrl-C to quit)\n1) \"psubscribe\"\n2) \"*\"\n3) (integer) 1\n1) \"pmessage\"\n2) \"*\"\n3) \"+new-epoch\"\n4) \"2\"\n1) \"pmessage\"\n2) \"*\"\n3) \"+vote-for-leader\"\n4) \"299da3eb5862baf267d16e36306defe7517bab5b 2\"\n1) \"pmessage\"\n2) \"*\"\n3) \"+sdown\"\n4) \"master mymaster 127.0.0.1 6380\"\n1) \"pmessage\"\n2) \"*\"\n3) \"+odown\"\n4) \"master mymaster 127.0.0.1 6380 #quorum 3/2\"\n1) \"pmessage\"\n2) \"*\"\n3) \"+config-update-from\"\n4) \"sentinel 127.0.0.1:26380 127.0.0.1 26380 @ mymaster 127.0.0.1 6380\"\n1) \"pmessage\"\n2) \"*\"\n3) \"+switch-master\"\n4) \"mymaster 127.0.0.1 6380 127.0.0.1 6381\"\n1) \"pmessage\"\n2) \"*\"\n3) \"+slave\"\n4) \"slave 127.0.0.1:6379 127.0.0.1 6379 @ mymaster 127.0.0.1 6381\"\n1) \"pmessage\"\n2) \"*\"\n3) \"+slave\"\n4) \"slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6381\"\n1) \"pmessage\"\n2) \"*\"\n3) \"+sdown\"\n4) \"slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6381\"\n1) \"pmessage\"\n2) \"*\"\n3) \"-role-change\"\n4) \"slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6381 new reported role is master\"\n1) \"pmessage\"\n2) \"*\"\n3) \"-sdown\"\n4) \"slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6381\"\n1) \"pmessage\"\n2) \"*\"\n3) \"+role-change\"\n4) \"slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6381 new reported role is slave\"\n\n```\nsentinel消息各种 + - 标识的含义:\n>+reset-master <instance details> -- The master was reset.\n    +slave <instance details> -- A new slave was detected and attached.\n    +failover-state-reconf-slaves <instance details> -- Failover state changed to reconf-slaves state.\n    +failover-detected <instance details> -- A failover started by another Sentinel or any other external entity was detected (An attached slave turned into a master).\n    +slave-reconf-sent <instance details> -- The leader sentinel sent the SLAVEOF command to this instance in order to reconfigure it for the new slave.\n    +slave-reconf-inprog <instance details> -- The slave being reconfigured showed to be a slave of the new master ip:port pair, but the synchronization process is not yet complete.\n    +slave-reconf-done <instance details> -- The slave is now synchronized with the new master.\n    -dup-sentinel <instance details> -- One or more sentinels for the specified master were removed as duplicated (this happens for instance when a Sentinel instance is restarted).\n    +sentinel <instance details> -- A new sentinel for this master was detected and attached.\n    +sdown <instance details> -- The specified instance is now in Subjectively Down state.\n    -sdown <instance details> -- The specified instance is no longer in Subjectively Down state.\n    +odown <instance details> -- The specified instance is now in Objectively Down state.\n    -odown <instance details> -- The specified instance is no longer in Objectively Down state.\n    +new-epoch <instance details> -- The current epoch was updated.\n    +try-failover <instance details> -- New failover in progress, waiting to be elected by the majority.\n    +elected-leader <instance details> -- Won the election for the specified epoch, can do the failover.\n    +failover-state-select-slave <instance details> -- New failover state is select-slave: we are trying to find a suitable slave for promotion.\n    no-good-slave <instance details> -- There is no good slave to promote. Currently we'll try after some time, but probably this will change and the state machine will abort the failover at all in this case.\n    selected-slave <instance details> -- We found the specified good slave to promote.\n    failover-state-send-slaveof-noone <instance details> -- We are trying to reconfigure the promoted slave as master, waiting for it to switch.\n    failover-end-for-timeout <instance details> -- The failover terminated for timeout, slaves will eventually be configured to replicate with the new master anyway.\n    failover-end <instance details> -- The failover terminated with success. All the slaves appears to be reconfigured to replicate with the new master.\n    switch-master <master name> <oldip> <oldport> <newip> <newport> -- The master new IP and address is the specified one after a configuration change. This is the message most external users are interested in.\n    +tilt -- Tilt mode entered.\n    -tilt -- Tilt mode exited.\n\n**leader 日志**\n```\n[30369] 13 Jan 20:21:06.701 # +sdown master mymaster 127.0.0.1 6380\n[30369] 13 Jan 20:21:06.768 # +odown master mymaster 127.0.0.1 6380 #quorum 2/2\n[30369] 13 Jan 20:21:06.768 # +new-epoch 2\n[30369] 13 Jan 20:21:06.768 # +try-failover master mymaster 127.0.0.1 6380\n[30369] 13 Jan 20:21:06.782 # +vote-for-leader 299da3eb5862baf267d16e36306defe7517bab5b 2\n[30369] 13 Jan 20:21:06.821 # 127.0.0.1:26381 voted for 299da3eb5862baf267d16e36306defe7517bab5b 2\n[30369] 13 Jan 20:21:06.821 # 127.0.0.1:26379 voted for 299da3eb5862baf267d16e36306defe7517bab5b 2\n[30369] 13 Jan 20:21:06.844 # +elected-leader master mymaster 127.0.0.1 6380\n[30369] 13 Jan 20:21:06.844 # +failover-state-select-slave master mymaster 127.0.0.1 6380\n[30369] 13 Jan 20:21:06.902 # +selected-slave slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6380\n[30369] 13 Jan 20:21:06.902 * +failover-state-send-slaveof-noone slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6380\n[30369] 13 Jan 20:21:06.965 * +failover-state-wait-promotion slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6380\n[30369] 13 Jan 20:21:07.830 # +promoted-slave slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6380\n[30369] 13 Jan 20:21:07.830 # +failover-state-reconf-slaves master mymaster 127.0.0.1 6380\n[30369] 13 Jan 20:21:07.872 * +slave-reconf-sent slave 127.0.0.1:6379 127.0.0.1 6379 @ mymaster 127.0.0.1 6380\n[30369] 13 Jan 20:21:08.852 * +slave-reconf-inprog slave 127.0.0.1:6379 127.0.0.1 6379 @ mymaster 127.0.0.1 6380\n[30369] 13 Jan 20:21:08.976 # -odown master mymaster 127.0.0.1 6380\n[30369] 13 Jan 20:22:53.198 * +reboot master mymaster 127.0.0.1 6380\n[30369] 13 Jan 20:22:53.249 # -sdown master mymaster 127.0.0.1 6380\n\n```\n**follower 日志**\n```\n[29838] 13 Jan 20:21:06.803 # +new-epoch 2\n[29838] 13 Jan 20:21:06.821 # +vote-for-leader 299da3eb5862baf267d16e36306defe7517bab5b 2\n[29838] 13 Jan 20:21:06.821 # +sdown master mymaster 127.0.0.1 6380\n[29838] 13 Jan 20:21:06.898 # +odown master mymaster 127.0.0.1 6380 #quorum 3/2\n[29838] 13 Jan 20:21:06.898 # Next failover delay: I will not start a failover before Sat Jan 13 20:27:07 2018\n[29838] 13 Jan 20:21:07.874 # +config-update-from sentinel 127.0.0.1:26380 127.0.0.1 26380 @ mymaster 127.0.0.1 6380\n[29838] 13 Jan 20:21:07.874 # +switch-master mymaster 127.0.0.1 6380 127.0.0.1 6381\n[29838] 13 Jan 20:21:07.874 * +slave slave 127.0.0.1:6379 127.0.0.1 6379 @ mymaster 127.0.0.1 6381\n[29838] 13 Jan 20:21:07.894 * +slave slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6381\n[29838] 13 Jan 20:21:37.913 # +sdown slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6381\n[29838] 13 Jan 20:22:53.322 # -sdown slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6381\n```\n[^sentinelSendPeriodicCommands]:https://github.com/antirez/redis/blob/3.0/src/sentinel.c sentinelSendPeriodicCommands()\n\n\n  [1]: http://7xl4v5.com1.z0.glb.clouddn.com/sentinel.png\n  [2]: http://7xl4v5.com1.z0.glb.clouddn.com/redis/sentinel/s1.png\n  [3]: http://7xl4v5.com1.z0.glb.clouddn.com/redis/sentinel/s2.png\n  [4]: http://7xl4v5.com1.z0.glb.clouddn.com/redis/sentinel/s3.png\n  [5]: http://www.infoq.com/cn/articles/raft-paper\n  [6]: http://7xl4v5.com1.z0.glb.clouddn.com/redis/sentinel/s4.png\n  [7]: http://7xl4v5.com1.z0.glb.clouddn.com/redis/sentinel/s5.png\n  [8]: http://doc.redisfans.com/topic/sentinel.html#tilt\n  [9]: http://7xl4v5.com1.z0.glb.clouddn.com/redis/sentinel/state.png","slug":"图解redis sentinel","published":1,"updated":"2018-11-21T16:34:46.273Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp57u41n001q2xpbw6v0jxhj","content":"<p>redis sentinel是redis为支持自动failover的主从模式开发的功能，sentinel实际上也是一个redis实例，不过它只支持部分特有命令，通过<code>redis-server /path/to/sentinel.conf --sentinel</code>启动sentinel实例。<br><a id=\"more\"></a></p>\n<h3 id=\"整体视图\"><a href=\"#整体视图\" class=\"headerlink\" title=\"整体视图\"></a>整体视图</h3><p>sentinel服务由多个节点组成，当进行容灾操作时需要多数节点达成一致，因此sentinel节点之间需要建立通信（蓝色部分）。同时为了监控redis节点状态，每个sentinel节点都会和redis实例建立命令连接（图中虚线），sentinel节点还会通过publish命令向其他节点（包括master/slave/sentinel）发送”hello msg”(参考[^sentinelSendPeriodicCommands]）<br>，通过redis的发布/订阅功能来交换信息。</p>\n<p>注意：sentinel接收publish命令时执行的是fake publish<br><img src=\"http://7xl4v5.com1.z0.glb.clouddn.com/sentinel.png\" alt=\"overview\"></p>\n<p>继续下面的内容前，需要了解sentinel的几个重要配置参数：</p>\n<blockquote>\n<p><strong>monitor</strong> master_name,master_ip,master_port,quorum<br> (master信息客观下线需要的票数)<br><strong>down-after-milliseconds</strong> master_name XXms (失联多久被视为主观下线)<br><strong>failover-timeout</strong> master_name XXms (处理故障的超时时间)<br><strong>parallel-syncs</strong>  master_name number (执行故障转移时，可以同时从新的master同步数据的slave数量）</p>\n</blockquote>\n<h3 id=\"发现新redis实例\"><a href=\"#发现新redis实例\" class=\"headerlink\" title=\"发现新redis实例\"></a>发现新redis实例</h3><p>可以发现配置sentinel时不需要填写slave节点的信息，这是因为sentinel可以从它监视的master发送INFO命令获得对应的slave信息，然后再与slave建立连接。通过这种方式sentinel也能够发现新加入的slave节点，过程如图所示：<br><img src=\"http://7xl4v5.com1.z0.glb.clouddn.com/redis/sentinel/s1.png\" alt=\"1\"></p>\n<h3 id=\"发现新sentinel实例\"><a href=\"#发现新sentinel实例\" class=\"headerlink\" title=\"发现新sentinel实例\"></a>发现新sentinel实例</h3><p>类似地，一个sentinel实例也能够自主的发现其他sentinel实例，不过这是通过channel接收其他sentinel实例发送的消息实现的，每个sentinel实例会定时所有节点发送PUBLISH命令来向channel投递消息，内容主要是sentinel自己和信息和它保存的master的信息，格式如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PUBLISH __sentinel__:hello sentinel_ip,sentinel_port,sentinel_runid,current_epoch,</span><br><span class=\"line\">master_name,master_ip,master_port,master_config_epoch.</span><br></pre></td></tr></table></figure></p>\n<p>消息会由redis实例的频道发送给所有监视实例的sentinel，其他sentinel收到信息后，如果自己没有保存消息中的sentinel会保存下来，同时epoch如果小于消息中epoch也会自我更新：<br><img src=\"http://7xl4v5.com1.z0.glb.clouddn.com/redis/sentinel/s2.png\" alt=\"step2\"></p>\n<h3 id=\"判断节点下线过程\"><a href=\"#判断节点下线过程\" class=\"headerlink\" title=\"判断节点下线过程\"></a>判断节点下线过程</h3><p>sentinel会通过定时向监视的redis实例发送ping命令，检查redis的状态，当redis回复异常或者在超时时间内没有回复时sentinel会将节点设置为主观下线（subjectively down）。而且如果节点是master的话，sentinel需要判断节点是否能设置为客观下线（Objectively down）,过程如图所示：<br>（1）节点回复不正常，sentinel把节点置为主观下线<br>（2）给其他sentinel发送<code>is-master-down-by-addr</code>命令，格式如下<code>IS-MASTER-DOWN-BY-ADDR &lt;master_ip&gt; &lt;master_port&gt; &lt;sentinel:current-epoch&gt; &lt;sentinel:runid&gt;</code><br>（只有当发起投票时才会发送runid,此时runid内容为*）<br>（3）收到<code>is-master-down-by-addr</code>的sentinel检查对应redis实例的状态（实际不会发送ping命令，只是检查保存的节点状态是不是主观下线）<br>（4）发现节点下线回复消息，回复内容如下，后两个是投票时用到的<code>down state, leader, vote epoch</code><br>（5）当sentinel1 收到足够多的“节点下线”的回复后（大于配置的quorum），将master状态设置为客观下线，然后failover流程才开始进行。</p>\n<p><img src=\"http://7xl4v5.com1.z0.glb.clouddn.com/redis/sentinel/s3.png\" alt=\"s3\"></p>\n<h3 id=\"failover第一步-选举leader\"><a href=\"#failover第一步-选举leader\" class=\"headerlink\" title=\"failover第一步:选举leader\"></a>failover第一步:选举leader</h3><p>failover操作只能由一个sentinel节点来执行，因此开始failover首先要选举出一个Leader,sentinel的选举采用的是<a href=\"http://www.infoq.com/cn/articles/raft-paper\" target=\"_blank\" rel=\"noopener\">Raft算法</a>中的领导人选举机制。在这里确认master客观下线的sentinel会成为候选人，等待failover_start_time（一个随机时间，为了避免候选人同时开始选举导致平票），然后开始向其他实例发起投票请求，依然是使用<code>is-master-down-by-addr</code>命令，投票时主要依据是epoch字段。具体流程如图所示：<br><img src=\"http://7xl4v5.com1.z0.glb.clouddn.com/redis/sentinel/s4.png\" alt=\"s4\"></p>\n<h3 id=\"failover第二步：执行故障转移\"><a href=\"#failover第二步：执行故障转移\" class=\"headerlink\" title=\"failover第二步：执行故障转移\"></a>failover第二步：执行故障转移</h3><p>Leader选举成功之后，会在slave中选择一个最优的，然后“提拔”这个slave作为新的master,然后其他redis实例会来同步新master的数据，具体过程如下：<br><img src=\"http://7xl4v5.com1.z0.glb.clouddn.com/redis/sentinel/s5.png\" alt=\"dofailover\"></p>\n<h3 id=\"sentinel的整体执行流程\"><a href=\"#sentinel的整体执行流程\" class=\"headerlink\" title=\"sentinel的整体执行流程\"></a>sentinel的整体执行流程</h3><p>上面描述的行为都是通过redis定时任务来驱动的，特别的，sentinel中定义了一个状态机（switch-case代码块）来根据此时master的failover_state执行不同的操作，下面的图从外向内展示了sentinel主要功能的调用过程：</p>\n<blockquote>\n<p>（1）servCron函数(在server.c)负责执行redis的定时任务，包括过期键，写AOF文件等等，同时包括执行sentinel定时任务<br>（2）sentinelTimer(sentinel.c)是sentinel模式的定时任务，执行<a href=\"http://doc.redisfans.com/topic/sentinel.html#tilt\" target=\"_blank\" rel=\"noopener\">TILT模式</a>的检查，执行脚本，还有就是处理RedisInstance（集群中所有的master/slave/sentinel实例）<br>（3）在sentinelHandleRedisInstance函数中，会依次执行reconnect函数维护与其他实例的连接（命令连接和pub/sub）,定期发送命令（info/ping/hello）,判断主观下线<br>（4）当实例是master时会执行客观下线的检查，在StartFailoverIfNeeded函数中，如果满足条件会开始failover的过程（master会变成SENTINEL_FAILOVER_STATE_WAIT_START，然后还会向其他sentinel确认master状态，使用force模式才会发送is-master-down命令，此时可能也会发起投票）<br>（5）状态机逻辑的执行在StartFailoverIfNeeded执行之后（和上一步结果无关），状态机就是在每次定时任务循环中检查当前master的状态然后执行不同阶段的failover操作，最后会执行askOther的步骤，本次定时任务结束。</p>\n</blockquote>\n<p><img src=\"http://7xl4v5.com1.z0.glb.clouddn.com/redis/sentinel/state.png\" alt=\"state\"></p>\n<h3 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h3><p><strong>1、完整的failoverstate</strong><br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Failover machine different states. */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SENTINEL_FAILOVER_STATE_NONE 0  <span class=\"comment\">/* No failover in progress. */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SENTINEL_FAILOVER_STATE_WAIT_START 1  <span class=\"comment\">/* Wait for failover_start_time*/</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SENTINEL_FAILOVER_STATE_SELECT_SLAVE 2 <span class=\"comment\">/* Select slave to promote */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SENTINEL_FAILOVER_STATE_SEND_SLAVEOF_NOONE 3 <span class=\"comment\">/* Slave -&gt; Master */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SENTINEL_FAILOVER_STATE_WAIT_PROMOTION 4 <span class=\"comment\">/* Wait slave to change role */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SENTINEL_FAILOVER_STATE_RECONF_SLAVES 5 <span class=\"comment\">/* SLAVEOF newmaster */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SENTINEL_FAILOVER_STATE_UPDATE_CONFIG 6 <span class=\"comment\">/* Monitor promoted slave.master配置更新为新的master */</span></span></span><br></pre></td></tr></table></figure></p>\n<p><strong>2、redis实例收到的sentinel消息</strong><br>集群中一台slave的hello频道中传播的消息，此时master端口是6380：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; psubscribe *</span><br><span class=\"line\">1) &quot;pmessage&quot;</span><br><span class=\"line\">2) &quot;*&quot;</span><br><span class=\"line\">3) &quot;__sentinel__:hello&quot;</span><br><span class=\"line\">4) &quot;127.0.0.1,26380,299da3eb5862baf267d16e36306defe7517bab5b,3,mymaster,127.0.0.1,6380,3&quot;</span><br><span class=\"line\">1) &quot;pmessage&quot;</span><br><span class=\"line\">2) &quot;*&quot;</span><br><span class=\"line\">3) &quot;__sentinel__:hello&quot;</span><br><span class=\"line\">4) &quot;127.0.0.1,26381,bf3ac725160092d5db0fefdcc4814379003a75a8,3,mymaster,127.0.0.1,6380,3&quot;</span><br><span class=\"line\">1) &quot;pmessage&quot;</span><br><span class=\"line\">2) &quot;*&quot;</span><br><span class=\"line\">3) &quot;__sentinel__:hello&quot;</span><br><span class=\"line\">4) &quot;127.0.0.1,26379,9e47039b5fd9735296df2340e54a4c37caeabbb2,3,mymaster,127.0.0.1,6380,3&quot;</span><br></pre></td></tr></table></figure></p>\n<p><strong>3、一次failover的日志</strong><br>master port:6380<br>Leader port:26380<br>Leader run_id:299da3eb5862baf267d16e36306defe7517bab5b<br><strong>follower sentinel收到的消息:</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:26379&gt; psubscribe *</span><br><span class=\"line\">Reading messages... (press Ctrl-C to quit)</span><br><span class=\"line\">1) &quot;psubscribe&quot;</span><br><span class=\"line\">2) &quot;*&quot;</span><br><span class=\"line\">3) (integer) 1</span><br><span class=\"line\">1) &quot;pmessage&quot;</span><br><span class=\"line\">2) &quot;*&quot;</span><br><span class=\"line\">3) &quot;+new-epoch&quot;</span><br><span class=\"line\">4) &quot;2&quot;</span><br><span class=\"line\">1) &quot;pmessage&quot;</span><br><span class=\"line\">2) &quot;*&quot;</span><br><span class=\"line\">3) &quot;+vote-for-leader&quot;</span><br><span class=\"line\">4) &quot;299da3eb5862baf267d16e36306defe7517bab5b 2&quot;</span><br><span class=\"line\">1) &quot;pmessage&quot;</span><br><span class=\"line\">2) &quot;*&quot;</span><br><span class=\"line\">3) &quot;+sdown&quot;</span><br><span class=\"line\">4) &quot;master mymaster 127.0.0.1 6380&quot;</span><br><span class=\"line\">1) &quot;pmessage&quot;</span><br><span class=\"line\">2) &quot;*&quot;</span><br><span class=\"line\">3) &quot;+odown&quot;</span><br><span class=\"line\">4) &quot;master mymaster 127.0.0.1 6380 #quorum 3/2&quot;</span><br><span class=\"line\">1) &quot;pmessage&quot;</span><br><span class=\"line\">2) &quot;*&quot;</span><br><span class=\"line\">3) &quot;+config-update-from&quot;</span><br><span class=\"line\">4) &quot;sentinel 127.0.0.1:26380 127.0.0.1 26380 @ mymaster 127.0.0.1 6380&quot;</span><br><span class=\"line\">1) &quot;pmessage&quot;</span><br><span class=\"line\">2) &quot;*&quot;</span><br><span class=\"line\">3) &quot;+switch-master&quot;</span><br><span class=\"line\">4) &quot;mymaster 127.0.0.1 6380 127.0.0.1 6381&quot;</span><br><span class=\"line\">1) &quot;pmessage&quot;</span><br><span class=\"line\">2) &quot;*&quot;</span><br><span class=\"line\">3) &quot;+slave&quot;</span><br><span class=\"line\">4) &quot;slave 127.0.0.1:6379 127.0.0.1 6379 @ mymaster 127.0.0.1 6381&quot;</span><br><span class=\"line\">1) &quot;pmessage&quot;</span><br><span class=\"line\">2) &quot;*&quot;</span><br><span class=\"line\">3) &quot;+slave&quot;</span><br><span class=\"line\">4) &quot;slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6381&quot;</span><br><span class=\"line\">1) &quot;pmessage&quot;</span><br><span class=\"line\">2) &quot;*&quot;</span><br><span class=\"line\">3) &quot;+sdown&quot;</span><br><span class=\"line\">4) &quot;slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6381&quot;</span><br><span class=\"line\">1) &quot;pmessage&quot;</span><br><span class=\"line\">2) &quot;*&quot;</span><br><span class=\"line\">3) &quot;-role-change&quot;</span><br><span class=\"line\">4) &quot;slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6381 new reported role is master&quot;</span><br><span class=\"line\">1) &quot;pmessage&quot;</span><br><span class=\"line\">2) &quot;*&quot;</span><br><span class=\"line\">3) &quot;-sdown&quot;</span><br><span class=\"line\">4) &quot;slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6381&quot;</span><br><span class=\"line\">1) &quot;pmessage&quot;</span><br><span class=\"line\">2) &quot;*&quot;</span><br><span class=\"line\">3) &quot;+role-change&quot;</span><br><span class=\"line\">4) &quot;slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6381 new reported role is slave&quot;</span><br></pre></td></tr></table></figure></p>\n<p>sentinel消息各种 + - 标识的含义:</p>\n<blockquote>\n<p>+reset-master <instance details=\"\"> – The master was reset.<br>    +slave <instance details=\"\"> – A new slave was detected and attached.<br>    +failover-state-reconf-slaves <instance details=\"\"> – Failover state changed to reconf-slaves state.<br>    +failover-detected <instance details=\"\"> – A failover started by another Sentinel or any other external entity was detected (An attached slave turned into a master).<br>    +slave-reconf-sent <instance details=\"\"> – The leader sentinel sent the SLAVEOF command to this instance in order to reconfigure it for the new slave.<br>    +slave-reconf-inprog <instance details=\"\"> – The slave being reconfigured showed to be a slave of the new master ip:port pair, but the synchronization process is not yet complete.<br>    +slave-reconf-done <instance details=\"\"> – The slave is now synchronized with the new master.<br>    -dup-sentinel <instance details=\"\"> – One or more sentinels for the specified master were removed as duplicated (this happens for instance when a Sentinel instance is restarted).<br>    +sentinel <instance details=\"\"> – A new sentinel for this master was detected and attached.<br>    +sdown <instance details=\"\"> – The specified instance is now in Subjectively Down state.<br>    -sdown <instance details=\"\"> – The specified instance is no longer in Subjectively Down state.<br>    +odown <instance details=\"\"> – The specified instance is now in Objectively Down state.<br>    -odown <instance details=\"\"> – The specified instance is no longer in Objectively Down state.<br>    +new-epoch <instance details=\"\"> – The current epoch was updated.<br>    +try-failover <instance details=\"\"> – New failover in progress, waiting to be elected by the majority.<br>    +elected-leader <instance details=\"\"> – Won the election for the specified epoch, can do the failover.<br>    +failover-state-select-slave <instance details=\"\"> – New failover state is select-slave: we are trying to find a suitable slave for promotion.<br>    no-good-slave <instance details=\"\"> – There is no good slave to promote. Currently we’ll try after some time, but probably this will change and the state machine will abort the failover at all in this case.<br>    selected-slave <instance details=\"\"> – We found the specified good slave to promote.<br>    failover-state-send-slaveof-noone <instance details=\"\"> – We are trying to reconfigure the promoted slave as master, waiting for it to switch.<br>    failover-end-for-timeout <instance details=\"\"> – The failover terminated for timeout, slaves will eventually be configured to replicate with the new master anyway.<br>    failover-end <instance details=\"\"> – The failover terminated with success. All the slaves appears to be reconfigured to replicate with the new master.<br>    switch-master <master name=\"\"> <oldip> <oldport> <newip> <newport> – The master new IP and address is the specified one after a configuration change. This is the message most external users are interested in.<br>    +tilt – Tilt mode entered.<br>    -tilt – Tilt mode exited.</newport></newip></oldport></oldip></master></instance></instance></instance></instance></instance></instance></instance></instance></instance></instance></instance></instance></instance></instance></instance></instance></instance></instance></instance></instance></instance></instance></p>\n</blockquote>\n<p><strong>leader 日志</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[30369] 13 Jan 20:21:06.701 # +sdown master mymaster 127.0.0.1 6380</span><br><span class=\"line\">[30369] 13 Jan 20:21:06.768 # +odown master mymaster 127.0.0.1 6380 #quorum 2/2</span><br><span class=\"line\">[30369] 13 Jan 20:21:06.768 # +new-epoch 2</span><br><span class=\"line\">[30369] 13 Jan 20:21:06.768 # +try-failover master mymaster 127.0.0.1 6380</span><br><span class=\"line\">[30369] 13 Jan 20:21:06.782 # +vote-for-leader 299da3eb5862baf267d16e36306defe7517bab5b 2</span><br><span class=\"line\">[30369] 13 Jan 20:21:06.821 # 127.0.0.1:26381 voted for 299da3eb5862baf267d16e36306defe7517bab5b 2</span><br><span class=\"line\">[30369] 13 Jan 20:21:06.821 # 127.0.0.1:26379 voted for 299da3eb5862baf267d16e36306defe7517bab5b 2</span><br><span class=\"line\">[30369] 13 Jan 20:21:06.844 # +elected-leader master mymaster 127.0.0.1 6380</span><br><span class=\"line\">[30369] 13 Jan 20:21:06.844 # +failover-state-select-slave master mymaster 127.0.0.1 6380</span><br><span class=\"line\">[30369] 13 Jan 20:21:06.902 # +selected-slave slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6380</span><br><span class=\"line\">[30369] 13 Jan 20:21:06.902 * +failover-state-send-slaveof-noone slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6380</span><br><span class=\"line\">[30369] 13 Jan 20:21:06.965 * +failover-state-wait-promotion slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6380</span><br><span class=\"line\">[30369] 13 Jan 20:21:07.830 # +promoted-slave slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6380</span><br><span class=\"line\">[30369] 13 Jan 20:21:07.830 # +failover-state-reconf-slaves master mymaster 127.0.0.1 6380</span><br><span class=\"line\">[30369] 13 Jan 20:21:07.872 * +slave-reconf-sent slave 127.0.0.1:6379 127.0.0.1 6379 @ mymaster 127.0.0.1 6380</span><br><span class=\"line\">[30369] 13 Jan 20:21:08.852 * +slave-reconf-inprog slave 127.0.0.1:6379 127.0.0.1 6379 @ mymaster 127.0.0.1 6380</span><br><span class=\"line\">[30369] 13 Jan 20:21:08.976 # -odown master mymaster 127.0.0.1 6380</span><br><span class=\"line\">[30369] 13 Jan 20:22:53.198 * +reboot master mymaster 127.0.0.1 6380</span><br><span class=\"line\">[30369] 13 Jan 20:22:53.249 # -sdown master mymaster 127.0.0.1 6380</span><br></pre></td></tr></table></figure></p>\n<p><strong>follower 日志</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[29838] 13 Jan 20:21:06.803 # +new-epoch 2</span><br><span class=\"line\">[29838] 13 Jan 20:21:06.821 # +vote-for-leader 299da3eb5862baf267d16e36306defe7517bab5b 2</span><br><span class=\"line\">[29838] 13 Jan 20:21:06.821 # +sdown master mymaster 127.0.0.1 6380</span><br><span class=\"line\">[29838] 13 Jan 20:21:06.898 # +odown master mymaster 127.0.0.1 6380 #quorum 3/2</span><br><span class=\"line\">[29838] 13 Jan 20:21:06.898 # Next failover delay: I will not start a failover before Sat Jan 13 20:27:07 2018</span><br><span class=\"line\">[29838] 13 Jan 20:21:07.874 # +config-update-from sentinel 127.0.0.1:26380 127.0.0.1 26380 @ mymaster 127.0.0.1 6380</span><br><span class=\"line\">[29838] 13 Jan 20:21:07.874 # +switch-master mymaster 127.0.0.1 6380 127.0.0.1 6381</span><br><span class=\"line\">[29838] 13 Jan 20:21:07.874 * +slave slave 127.0.0.1:6379 127.0.0.1 6379 @ mymaster 127.0.0.1 6381</span><br><span class=\"line\">[29838] 13 Jan 20:21:07.894 * +slave slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6381</span><br><span class=\"line\">[29838] 13 Jan 20:21:37.913 # +sdown slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6381</span><br><span class=\"line\">[29838] 13 Jan 20:22:53.322 # -sdown slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6381</span><br></pre></td></tr></table></figure></p>\n<p>[^sentinelSendPeriodicCommands]:<a href=\"https://github.com/antirez/redis/blob/3.0/src/sentinel.c\" target=\"_blank\" rel=\"noopener\">https://github.com/antirez/redis/blob/3.0/src/sentinel.c</a> sentinelSendPeriodicCommands()</p>\n","site":{"data":{}},"excerpt":"<p>redis sentinel是redis为支持自动failover的主从模式开发的功能，sentinel实际上也是一个redis实例，不过它只支持部分特有命令，通过<code>redis-server /path/to/sentinel.conf --sentinel</code>启动sentinel实例。<br>","more":"</p>\n<h3 id=\"整体视图\"><a href=\"#整体视图\" class=\"headerlink\" title=\"整体视图\"></a>整体视图</h3><p>sentinel服务由多个节点组成，当进行容灾操作时需要多数节点达成一致，因此sentinel节点之间需要建立通信（蓝色部分）。同时为了监控redis节点状态，每个sentinel节点都会和redis实例建立命令连接（图中虚线），sentinel节点还会通过publish命令向其他节点（包括master/slave/sentinel）发送”hello msg”(参考[^sentinelSendPeriodicCommands]）<br>，通过redis的发布/订阅功能来交换信息。</p>\n<p>注意：sentinel接收publish命令时执行的是fake publish<br><img src=\"http://7xl4v5.com1.z0.glb.clouddn.com/sentinel.png\" alt=\"overview\"></p>\n<p>继续下面的内容前，需要了解sentinel的几个重要配置参数：</p>\n<blockquote>\n<p><strong>monitor</strong> master_name,master_ip,master_port,quorum<br> (master信息客观下线需要的票数)<br><strong>down-after-milliseconds</strong> master_name XXms (失联多久被视为主观下线)<br><strong>failover-timeout</strong> master_name XXms (处理故障的超时时间)<br><strong>parallel-syncs</strong>  master_name number (执行故障转移时，可以同时从新的master同步数据的slave数量）</p>\n</blockquote>\n<h3 id=\"发现新redis实例\"><a href=\"#发现新redis实例\" class=\"headerlink\" title=\"发现新redis实例\"></a>发现新redis实例</h3><p>可以发现配置sentinel时不需要填写slave节点的信息，这是因为sentinel可以从它监视的master发送INFO命令获得对应的slave信息，然后再与slave建立连接。通过这种方式sentinel也能够发现新加入的slave节点，过程如图所示：<br><img src=\"http://7xl4v5.com1.z0.glb.clouddn.com/redis/sentinel/s1.png\" alt=\"1\"></p>\n<h3 id=\"发现新sentinel实例\"><a href=\"#发现新sentinel实例\" class=\"headerlink\" title=\"发现新sentinel实例\"></a>发现新sentinel实例</h3><p>类似地，一个sentinel实例也能够自主的发现其他sentinel实例，不过这是通过channel接收其他sentinel实例发送的消息实现的，每个sentinel实例会定时所有节点发送PUBLISH命令来向channel投递消息，内容主要是sentinel自己和信息和它保存的master的信息，格式如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PUBLISH __sentinel__:hello sentinel_ip,sentinel_port,sentinel_runid,current_epoch,</span><br><span class=\"line\">master_name,master_ip,master_port,master_config_epoch.</span><br></pre></td></tr></table></figure></p>\n<p>消息会由redis实例的频道发送给所有监视实例的sentinel，其他sentinel收到信息后，如果自己没有保存消息中的sentinel会保存下来，同时epoch如果小于消息中epoch也会自我更新：<br><img src=\"http://7xl4v5.com1.z0.glb.clouddn.com/redis/sentinel/s2.png\" alt=\"step2\"></p>\n<h3 id=\"判断节点下线过程\"><a href=\"#判断节点下线过程\" class=\"headerlink\" title=\"判断节点下线过程\"></a>判断节点下线过程</h3><p>sentinel会通过定时向监视的redis实例发送ping命令，检查redis的状态，当redis回复异常或者在超时时间内没有回复时sentinel会将节点设置为主观下线（subjectively down）。而且如果节点是master的话，sentinel需要判断节点是否能设置为客观下线（Objectively down）,过程如图所示：<br>（1）节点回复不正常，sentinel把节点置为主观下线<br>（2）给其他sentinel发送<code>is-master-down-by-addr</code>命令，格式如下<code>IS-MASTER-DOWN-BY-ADDR &lt;master_ip&gt; &lt;master_port&gt; &lt;sentinel:current-epoch&gt; &lt;sentinel:runid&gt;</code><br>（只有当发起投票时才会发送runid,此时runid内容为*）<br>（3）收到<code>is-master-down-by-addr</code>的sentinel检查对应redis实例的状态（实际不会发送ping命令，只是检查保存的节点状态是不是主观下线）<br>（4）发现节点下线回复消息，回复内容如下，后两个是投票时用到的<code>down state, leader, vote epoch</code><br>（5）当sentinel1 收到足够多的“节点下线”的回复后（大于配置的quorum），将master状态设置为客观下线，然后failover流程才开始进行。</p>\n<p><img src=\"http://7xl4v5.com1.z0.glb.clouddn.com/redis/sentinel/s3.png\" alt=\"s3\"></p>\n<h3 id=\"failover第一步-选举leader\"><a href=\"#failover第一步-选举leader\" class=\"headerlink\" title=\"failover第一步:选举leader\"></a>failover第一步:选举leader</h3><p>failover操作只能由一个sentinel节点来执行，因此开始failover首先要选举出一个Leader,sentinel的选举采用的是<a href=\"http://www.infoq.com/cn/articles/raft-paper\" target=\"_blank\" rel=\"noopener\">Raft算法</a>中的领导人选举机制。在这里确认master客观下线的sentinel会成为候选人，等待failover_start_time（一个随机时间，为了避免候选人同时开始选举导致平票），然后开始向其他实例发起投票请求，依然是使用<code>is-master-down-by-addr</code>命令，投票时主要依据是epoch字段。具体流程如图所示：<br><img src=\"http://7xl4v5.com1.z0.glb.clouddn.com/redis/sentinel/s4.png\" alt=\"s4\"></p>\n<h3 id=\"failover第二步：执行故障转移\"><a href=\"#failover第二步：执行故障转移\" class=\"headerlink\" title=\"failover第二步：执行故障转移\"></a>failover第二步：执行故障转移</h3><p>Leader选举成功之后，会在slave中选择一个最优的，然后“提拔”这个slave作为新的master,然后其他redis实例会来同步新master的数据，具体过程如下：<br><img src=\"http://7xl4v5.com1.z0.glb.clouddn.com/redis/sentinel/s5.png\" alt=\"dofailover\"></p>\n<h3 id=\"sentinel的整体执行流程\"><a href=\"#sentinel的整体执行流程\" class=\"headerlink\" title=\"sentinel的整体执行流程\"></a>sentinel的整体执行流程</h3><p>上面描述的行为都是通过redis定时任务来驱动的，特别的，sentinel中定义了一个状态机（switch-case代码块）来根据此时master的failover_state执行不同的操作，下面的图从外向内展示了sentinel主要功能的调用过程：</p>\n<blockquote>\n<p>（1）servCron函数(在server.c)负责执行redis的定时任务，包括过期键，写AOF文件等等，同时包括执行sentinel定时任务<br>（2）sentinelTimer(sentinel.c)是sentinel模式的定时任务，执行<a href=\"http://doc.redisfans.com/topic/sentinel.html#tilt\" target=\"_blank\" rel=\"noopener\">TILT模式</a>的检查，执行脚本，还有就是处理RedisInstance（集群中所有的master/slave/sentinel实例）<br>（3）在sentinelHandleRedisInstance函数中，会依次执行reconnect函数维护与其他实例的连接（命令连接和pub/sub）,定期发送命令（info/ping/hello）,判断主观下线<br>（4）当实例是master时会执行客观下线的检查，在StartFailoverIfNeeded函数中，如果满足条件会开始failover的过程（master会变成SENTINEL_FAILOVER_STATE_WAIT_START，然后还会向其他sentinel确认master状态，使用force模式才会发送is-master-down命令，此时可能也会发起投票）<br>（5）状态机逻辑的执行在StartFailoverIfNeeded执行之后（和上一步结果无关），状态机就是在每次定时任务循环中检查当前master的状态然后执行不同阶段的failover操作，最后会执行askOther的步骤，本次定时任务结束。</p>\n</blockquote>\n<p><img src=\"http://7xl4v5.com1.z0.glb.clouddn.com/redis/sentinel/state.png\" alt=\"state\"></p>\n<h3 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h3><p><strong>1、完整的failoverstate</strong><br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Failover machine different states. */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SENTINEL_FAILOVER_STATE_NONE 0  <span class=\"comment\">/* No failover in progress. */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SENTINEL_FAILOVER_STATE_WAIT_START 1  <span class=\"comment\">/* Wait for failover_start_time*/</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SENTINEL_FAILOVER_STATE_SELECT_SLAVE 2 <span class=\"comment\">/* Select slave to promote */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SENTINEL_FAILOVER_STATE_SEND_SLAVEOF_NOONE 3 <span class=\"comment\">/* Slave -&gt; Master */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SENTINEL_FAILOVER_STATE_WAIT_PROMOTION 4 <span class=\"comment\">/* Wait slave to change role */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SENTINEL_FAILOVER_STATE_RECONF_SLAVES 5 <span class=\"comment\">/* SLAVEOF newmaster */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SENTINEL_FAILOVER_STATE_UPDATE_CONFIG 6 <span class=\"comment\">/* Monitor promoted slave.master配置更新为新的master */</span></span></span><br></pre></td></tr></table></figure></p>\n<p><strong>2、redis实例收到的sentinel消息</strong><br>集群中一台slave的hello频道中传播的消息，此时master端口是6380：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; psubscribe *</span><br><span class=\"line\">1) &quot;pmessage&quot;</span><br><span class=\"line\">2) &quot;*&quot;</span><br><span class=\"line\">3) &quot;__sentinel__:hello&quot;</span><br><span class=\"line\">4) &quot;127.0.0.1,26380,299da3eb5862baf267d16e36306defe7517bab5b,3,mymaster,127.0.0.1,6380,3&quot;</span><br><span class=\"line\">1) &quot;pmessage&quot;</span><br><span class=\"line\">2) &quot;*&quot;</span><br><span class=\"line\">3) &quot;__sentinel__:hello&quot;</span><br><span class=\"line\">4) &quot;127.0.0.1,26381,bf3ac725160092d5db0fefdcc4814379003a75a8,3,mymaster,127.0.0.1,6380,3&quot;</span><br><span class=\"line\">1) &quot;pmessage&quot;</span><br><span class=\"line\">2) &quot;*&quot;</span><br><span class=\"line\">3) &quot;__sentinel__:hello&quot;</span><br><span class=\"line\">4) &quot;127.0.0.1,26379,9e47039b5fd9735296df2340e54a4c37caeabbb2,3,mymaster,127.0.0.1,6380,3&quot;</span><br></pre></td></tr></table></figure></p>\n<p><strong>3、一次failover的日志</strong><br>master port:6380<br>Leader port:26380<br>Leader run_id:299da3eb5862baf267d16e36306defe7517bab5b<br><strong>follower sentinel收到的消息:</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:26379&gt; psubscribe *</span><br><span class=\"line\">Reading messages... (press Ctrl-C to quit)</span><br><span class=\"line\">1) &quot;psubscribe&quot;</span><br><span class=\"line\">2) &quot;*&quot;</span><br><span class=\"line\">3) (integer) 1</span><br><span class=\"line\">1) &quot;pmessage&quot;</span><br><span class=\"line\">2) &quot;*&quot;</span><br><span class=\"line\">3) &quot;+new-epoch&quot;</span><br><span class=\"line\">4) &quot;2&quot;</span><br><span class=\"line\">1) &quot;pmessage&quot;</span><br><span class=\"line\">2) &quot;*&quot;</span><br><span class=\"line\">3) &quot;+vote-for-leader&quot;</span><br><span class=\"line\">4) &quot;299da3eb5862baf267d16e36306defe7517bab5b 2&quot;</span><br><span class=\"line\">1) &quot;pmessage&quot;</span><br><span class=\"line\">2) &quot;*&quot;</span><br><span class=\"line\">3) &quot;+sdown&quot;</span><br><span class=\"line\">4) &quot;master mymaster 127.0.0.1 6380&quot;</span><br><span class=\"line\">1) &quot;pmessage&quot;</span><br><span class=\"line\">2) &quot;*&quot;</span><br><span class=\"line\">3) &quot;+odown&quot;</span><br><span class=\"line\">4) &quot;master mymaster 127.0.0.1 6380 #quorum 3/2&quot;</span><br><span class=\"line\">1) &quot;pmessage&quot;</span><br><span class=\"line\">2) &quot;*&quot;</span><br><span class=\"line\">3) &quot;+config-update-from&quot;</span><br><span class=\"line\">4) &quot;sentinel 127.0.0.1:26380 127.0.0.1 26380 @ mymaster 127.0.0.1 6380&quot;</span><br><span class=\"line\">1) &quot;pmessage&quot;</span><br><span class=\"line\">2) &quot;*&quot;</span><br><span class=\"line\">3) &quot;+switch-master&quot;</span><br><span class=\"line\">4) &quot;mymaster 127.0.0.1 6380 127.0.0.1 6381&quot;</span><br><span class=\"line\">1) &quot;pmessage&quot;</span><br><span class=\"line\">2) &quot;*&quot;</span><br><span class=\"line\">3) &quot;+slave&quot;</span><br><span class=\"line\">4) &quot;slave 127.0.0.1:6379 127.0.0.1 6379 @ mymaster 127.0.0.1 6381&quot;</span><br><span class=\"line\">1) &quot;pmessage&quot;</span><br><span class=\"line\">2) &quot;*&quot;</span><br><span class=\"line\">3) &quot;+slave&quot;</span><br><span class=\"line\">4) &quot;slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6381&quot;</span><br><span class=\"line\">1) &quot;pmessage&quot;</span><br><span class=\"line\">2) &quot;*&quot;</span><br><span class=\"line\">3) &quot;+sdown&quot;</span><br><span class=\"line\">4) &quot;slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6381&quot;</span><br><span class=\"line\">1) &quot;pmessage&quot;</span><br><span class=\"line\">2) &quot;*&quot;</span><br><span class=\"line\">3) &quot;-role-change&quot;</span><br><span class=\"line\">4) &quot;slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6381 new reported role is master&quot;</span><br><span class=\"line\">1) &quot;pmessage&quot;</span><br><span class=\"line\">2) &quot;*&quot;</span><br><span class=\"line\">3) &quot;-sdown&quot;</span><br><span class=\"line\">4) &quot;slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6381&quot;</span><br><span class=\"line\">1) &quot;pmessage&quot;</span><br><span class=\"line\">2) &quot;*&quot;</span><br><span class=\"line\">3) &quot;+role-change&quot;</span><br><span class=\"line\">4) &quot;slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6381 new reported role is slave&quot;</span><br></pre></td></tr></table></figure></p>\n<p>sentinel消息各种 + - 标识的含义:</p>\n<blockquote>\n<p>+reset-master <instance details=\"\"> – The master was reset.<br>    +slave <instance details=\"\"> – A new slave was detected and attached.<br>    +failover-state-reconf-slaves <instance details=\"\"> – Failover state changed to reconf-slaves state.<br>    +failover-detected <instance details=\"\"> – A failover started by another Sentinel or any other external entity was detected (An attached slave turned into a master).<br>    +slave-reconf-sent <instance details=\"\"> – The leader sentinel sent the SLAVEOF command to this instance in order to reconfigure it for the new slave.<br>    +slave-reconf-inprog <instance details=\"\"> – The slave being reconfigured showed to be a slave of the new master ip:port pair, but the synchronization process is not yet complete.<br>    +slave-reconf-done <instance details=\"\"> – The slave is now synchronized with the new master.<br>    -dup-sentinel <instance details=\"\"> – One or more sentinels for the specified master were removed as duplicated (this happens for instance when a Sentinel instance is restarted).<br>    +sentinel <instance details=\"\"> – A new sentinel for this master was detected and attached.<br>    +sdown <instance details=\"\"> – The specified instance is now in Subjectively Down state.<br>    -sdown <instance details=\"\"> – The specified instance is no longer in Subjectively Down state.<br>    +odown <instance details=\"\"> – The specified instance is now in Objectively Down state.<br>    -odown <instance details=\"\"> – The specified instance is no longer in Objectively Down state.<br>    +new-epoch <instance details=\"\"> – The current epoch was updated.<br>    +try-failover <instance details=\"\"> – New failover in progress, waiting to be elected by the majority.<br>    +elected-leader <instance details=\"\"> – Won the election for the specified epoch, can do the failover.<br>    +failover-state-select-slave <instance details=\"\"> – New failover state is select-slave: we are trying to find a suitable slave for promotion.<br>    no-good-slave <instance details=\"\"> – There is no good slave to promote. Currently we’ll try after some time, but probably this will change and the state machine will abort the failover at all in this case.<br>    selected-slave <instance details=\"\"> – We found the specified good slave to promote.<br>    failover-state-send-slaveof-noone <instance details=\"\"> – We are trying to reconfigure the promoted slave as master, waiting for it to switch.<br>    failover-end-for-timeout <instance details=\"\"> – The failover terminated for timeout, slaves will eventually be configured to replicate with the new master anyway.<br>    failover-end <instance details=\"\"> – The failover terminated with success. All the slaves appears to be reconfigured to replicate with the new master.<br>    switch-master <master name=\"\"> <oldip> <oldport> <newip> <newport> – The master new IP and address is the specified one after a configuration change. This is the message most external users are interested in.<br>    +tilt – Tilt mode entered.<br>    -tilt – Tilt mode exited.</newport></newip></oldport></oldip></master></instance></instance></instance></instance></instance></instance></instance></instance></instance></instance></instance></instance></instance></instance></instance></instance></instance></instance></instance></instance></instance></instance></p>\n</blockquote>\n<p><strong>leader 日志</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[30369] 13 Jan 20:21:06.701 # +sdown master mymaster 127.0.0.1 6380</span><br><span class=\"line\">[30369] 13 Jan 20:21:06.768 # +odown master mymaster 127.0.0.1 6380 #quorum 2/2</span><br><span class=\"line\">[30369] 13 Jan 20:21:06.768 # +new-epoch 2</span><br><span class=\"line\">[30369] 13 Jan 20:21:06.768 # +try-failover master mymaster 127.0.0.1 6380</span><br><span class=\"line\">[30369] 13 Jan 20:21:06.782 # +vote-for-leader 299da3eb5862baf267d16e36306defe7517bab5b 2</span><br><span class=\"line\">[30369] 13 Jan 20:21:06.821 # 127.0.0.1:26381 voted for 299da3eb5862baf267d16e36306defe7517bab5b 2</span><br><span class=\"line\">[30369] 13 Jan 20:21:06.821 # 127.0.0.1:26379 voted for 299da3eb5862baf267d16e36306defe7517bab5b 2</span><br><span class=\"line\">[30369] 13 Jan 20:21:06.844 # +elected-leader master mymaster 127.0.0.1 6380</span><br><span class=\"line\">[30369] 13 Jan 20:21:06.844 # +failover-state-select-slave master mymaster 127.0.0.1 6380</span><br><span class=\"line\">[30369] 13 Jan 20:21:06.902 # +selected-slave slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6380</span><br><span class=\"line\">[30369] 13 Jan 20:21:06.902 * +failover-state-send-slaveof-noone slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6380</span><br><span class=\"line\">[30369] 13 Jan 20:21:06.965 * +failover-state-wait-promotion slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6380</span><br><span class=\"line\">[30369] 13 Jan 20:21:07.830 # +promoted-slave slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6380</span><br><span class=\"line\">[30369] 13 Jan 20:21:07.830 # +failover-state-reconf-slaves master mymaster 127.0.0.1 6380</span><br><span class=\"line\">[30369] 13 Jan 20:21:07.872 * +slave-reconf-sent slave 127.0.0.1:6379 127.0.0.1 6379 @ mymaster 127.0.0.1 6380</span><br><span class=\"line\">[30369] 13 Jan 20:21:08.852 * +slave-reconf-inprog slave 127.0.0.1:6379 127.0.0.1 6379 @ mymaster 127.0.0.1 6380</span><br><span class=\"line\">[30369] 13 Jan 20:21:08.976 # -odown master mymaster 127.0.0.1 6380</span><br><span class=\"line\">[30369] 13 Jan 20:22:53.198 * +reboot master mymaster 127.0.0.1 6380</span><br><span class=\"line\">[30369] 13 Jan 20:22:53.249 # -sdown master mymaster 127.0.0.1 6380</span><br></pre></td></tr></table></figure></p>\n<p><strong>follower 日志</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[29838] 13 Jan 20:21:06.803 # +new-epoch 2</span><br><span class=\"line\">[29838] 13 Jan 20:21:06.821 # +vote-for-leader 299da3eb5862baf267d16e36306defe7517bab5b 2</span><br><span class=\"line\">[29838] 13 Jan 20:21:06.821 # +sdown master mymaster 127.0.0.1 6380</span><br><span class=\"line\">[29838] 13 Jan 20:21:06.898 # +odown master mymaster 127.0.0.1 6380 #quorum 3/2</span><br><span class=\"line\">[29838] 13 Jan 20:21:06.898 # Next failover delay: I will not start a failover before Sat Jan 13 20:27:07 2018</span><br><span class=\"line\">[29838] 13 Jan 20:21:07.874 # +config-update-from sentinel 127.0.0.1:26380 127.0.0.1 26380 @ mymaster 127.0.0.1 6380</span><br><span class=\"line\">[29838] 13 Jan 20:21:07.874 # +switch-master mymaster 127.0.0.1 6380 127.0.0.1 6381</span><br><span class=\"line\">[29838] 13 Jan 20:21:07.874 * +slave slave 127.0.0.1:6379 127.0.0.1 6379 @ mymaster 127.0.0.1 6381</span><br><span class=\"line\">[29838] 13 Jan 20:21:07.894 * +slave slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6381</span><br><span class=\"line\">[29838] 13 Jan 20:21:37.913 # +sdown slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6381</span><br><span class=\"line\">[29838] 13 Jan 20:22:53.322 # -sdown slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6381</span><br></pre></td></tr></table></figure></p>\n<p>[^sentinelSendPeriodicCommands]:<a href=\"https://github.com/antirez/redis/blob/3.0/src/sentinel.c\" target=\"_blank\" rel=\"noopener\">https://github.com/antirez/redis/blob/3.0/src/sentinel.c</a> sentinelSendPeriodicCommands()</p>"},{"title":"如何设计一个连接池：commons-pool2源码分析","date":"2017-06-11T16:10:50.000Z","_content":"\n## 前言\n大家对连接池的概念应该都很熟悉了，[apache commons-pool](https://commons.apache.org/proper/commons-pool/)是apache基金会的一个开源对象池组件，我们常用的数据库连接池dpcp和redis的java客户端jedis都使用commons-pool来管理连接。现在我们通过阅读commons-pool的部分代码来看一看他们在编写连接池组件时采用了什么样的设计思路和技术。\n\n## 准备工作\n首先我们思考一下，连接池除应该具备哪些功能？\n\n 1. 连接池要能够管理不同类型的对象，同时作为一个服务组件不需要关心每种连接的创建细节。\n 2. 连接池中的连接当长时间空闲时可能会被服务端主动关闭，或者受网络影响断开，连接池要能够定时检查它的连接是否可用。\n 3. 支持并发操作,每个线程各种持有连接互不影响。\n\n带着这三个问题，下面我们一起看一下commons-pool的代码,\n它主要提供这个几种类型的对象池：\n<!--more-->\n![类图][1]\n从左至右看，SoftReferenceObjectPool是不用指定容量的对象池，ProxiedObject是使用代理模式来创建对象池的对象，在这篇文章主要介绍GenericObjectPool的实现。\n\n## 封装对象\ncommons-pool定义了一个接口PooledObject来封装池中的对象，添加了空闲时间，使用时间等信息和对象状态流转的行为。\nPooledbject的状态有这几种：\n|    状态     |    说明  |\n| --------   | -----  | \n| IDLE     | 空闲 |\n|ALLOCATED  |   使用中\n|INVALID |不可用 即将/已经被销毁\n|ABANDONED |被遗弃\n|RETURNING |返回对象池\n|EVICTION|  在队列中 正在被检查\n|EVICTION_RETURN_TO_HEAD| 检查结束要放回队列头部\n|VALIDATION| 在队列中 正在被检查\n|VALIDATION_PREALLOCATED |验证结束要被分配\n|VALIDATION_RETURN_TO_HEAD| 检查结束要放回队列头部\n\n表格中以RETURN_TO_HEAD结尾的状态是在当前的检查操作和对象借出操作同时进行时出现的，在检查结束后为了尽量保证借出成功这个对象要放回队头。\n在我们不需要自定义对象行为的情况下可以直接使用PooledObject的默认实现DefaultPooledObject，主要代码如下：\n``` java\nprivate final long createTime = System.currentTimeMillis();\nprivate volatile long lastBorrowTime = createTime;\nprivate volatile long lastUseTime = createTime;\nprivate volatile long lastReturnTime = createTime;\nprivate volatile long borrowedCount = 0;\n@Override\n    public synchronized boolean allocate() {\n        if (state == PooledObjectState.IDLE) {\n            state = PooledObjectState.ALLOCATED;\n            lastBorrowTime = System.currentTimeMillis();\n            lastUseTime = lastBorrowTime;\n            borrowedCount++;\n            if (logAbandoned) {\n                borrowedBy = new AbandonedObjectCreatedException();\n            }\n            return true;\n        } else if (state == PooledObjectState.EVICTION) {\n            state = PooledObjectState.EVICTION_RETURN_TO_HEAD;\n            return false;\n        }\n        return false;\n    }\n```\nallocate() 定义了对象分配时的状态变化，当对象在空闲状态时才能被分配；如果对象正在做驱逐检查时,会把这个对象标记为EVICTION_RETURN_TO_HEAD.\n```java\n@Override\n//返回值：对象是否当前未被使用\npublic synchronized boolean endEvictionTest(\n            Deque<PooledObject<T>> idleQueue) {\n        if (state == PooledObjectState.EVICTION) {\n            state = PooledObjectState.IDLE;\n            return true;\n        } else if (state == PooledObjectState.EVICTION_RETURN_TO_HEAD) {\n            //如果状态是EVICTION_RETURN_TO_HEAD表示当前这个对象试图被借出，返回false.\n            state = PooledObjectState.IDLE;\n            if (!idleQueue.offerFirst(this)) {\n                // TODO - Should never happen\n            }\n        }\n        return false;\n    }\n```\n\nendEvictionTest()定义了驱逐检查之后对象状态的变化，可以看到EVICTION_RETURN_TO_HEAD状态的对象被放到空闲队列队头。\n\nallocate()和borrowedCount等使用synchronized，violatile都做了线程安全的处理。\n\n \n## 定义对象工厂\ncommons-pool为了管理多种对象使用工厂模式来创建要管理的对象，使用工厂方法后使用者可以通过重写PooledObjectFactory定义对象的实现，销毁，验证的具体实现，而commons-pool不需要关心这些细节它只管理PooledObject对象即可。\n\n工厂接口：PooledObjectFactory\n``` java\npublic interface PooledObjectFactory<T> {\n  PooledObject<T> makeObject() throws Exception;\n  void destroyObject(PooledObject<T> p) throws Exception;\n  boolean validateObject(PooledObject<T> p);\n  void activateObject(PooledObject<T> p) throws Exception;\n  void passivateObject(PooledObject<T> p) throws Exception;\n}\n```\n工厂抽象类：BasePooledObjectFactory\n``` java\npublic abstract class BasePooledObjectFactory<T> implements PooledObjectFactory<T> {\n...\n    public abstract T create() throws Exception;\n    public abstract PooledObject<T> wrap(T obj);\n    @Override\n    public PooledObject<T> makeObject() throws Exception {\n        return wrap(create());\n    }\n    @Override\n    public boolean validateObject(PooledObject<T> p) {\n        return true;\n    }\n\n...\n}\n```\nBasePooledObjectFactory添加了create,wrap两个抽象方法，create可以返回我们要放在连接池的对象，然后使用wrap封装为PooledObject即可，注意validateObject默认返回true;\n\n## 对象池定义\n对象池是我们保存对象的地方，对象的获取，归还和定时检查都通过对象池来实现。以GenericObjectPool为例，对象池使用了线程安全的集合类来保存对象，LinkedBlockingDeque用于保存空闲的对象，ConcurrentHashMap保存全部对象（包括各种状态）。\n``` java\nprivate final LinkedBlockingDeque<PooledObject<T>> idleObjects = new LinkedBlockingDeque<PooledObject<T>>();\nprivate final Map<T, PooledObject<T>> allObjects = new ConcurrentHashMap<T, PooledObject<T>>();\n```\nborrowObject()从连接池获取对象：\n连接池借出对象时，经过Abandoned和validate两种检查，在连接池满时根据配置执行对应的等待策略，当没有可用对象时会抛出异常。\n\nAbandoned检查目标是连接池所有被借出的对象，主要防止对象借出之后长时间被占用，不能退还（或者使用者忘记return）到连接池导致连接被耗尽。超时时间由AbandonedConfig定义。\n\nvalidate检查目标是当前即将被借出的对象，目的是保证提供的对象是可用的，检查方式由对象工厂的validateObject方法定义。对象工厂还有activateObject方法来验证对象，不过这个方法是强制执行的。\n\n``` java\npublic T borrowObject(long borrowMaxWaitMillis) throws Exception {\n// getNumIdle() 表示当前空空闲对象数量，getNumActive() 表示当前非空闲的对象数量，getMaxTotal()表示连接池容量\n// 那么假设最大容量10个，非空闲8个 > 7 ，空闲对象只要少于2个，就需要开始Abandoned检查\n\n        AbandonedConfig ac = this.abandonedConfig;\n        if (ac != null && ac.getRemoveAbandonedOnBorrow() &&\n                (getNumIdle() < 2) &&\n                (getNumActive() > getMaxTotal() - 3) ) {\n            removeAbandoned(ac);\n        }\n\n        PooledObject<T> p = null;\n        \n        //拷贝了变量 blockWhenExhausted\n        //因为blockWhenExhausted的修改方法是public的，这样保证在并发情况下，方法执行周期内变量也不会变化\n        boolean blockWhenExhausted = getBlockWhenExhausted();\n\n        boolean create;\n        long waitTime = 0;\n\n        while (p == null) {\n            create = false;\n            // 设置了对象池耗尽时等待\n            if (blockWhenExhausted) {\n                //从空闲队列取对象\n                p = idleObjects.pollFirst();\n                if (p == null) {\n                    //没有空闲对象 新建一个\n                    create = true;\n                    p = create();\n                }\n                if (p == null) {\n                    if (borrowMaxWaitMillis < 0) {\n                        //注意：没配置等待时间，会一直阻塞\n                        p = idleObjects.takeFirst();\n                    } else {\n                        //按照配置的时间等待\n.....\n                        p = idleObjects.pollFirst(borrowMaxWaitMillis,\n                                TimeUnit.MILLISECONDS);\n.....\n                    }\n                }\n                 //等待之后还是没有空闲对象\n                if (p == null) {\n                    throw new NoSuchElementException(\n                            \"Timeout waiting for idle object\");\n                }\n                 //等待之后获得对象 尝试分配对象\n                 //这个方法由pooledobject实现\n                if (!p.allocate()) {\n                    p = null;\n                }\n            } else {\n                //没有配置blockWhenExhausted 不等待\n                p = idleObjects.pollFirst();\n                if (p == null) {\n                    create = true;\n                    p = create();\n                }\n                if (p == null) {\n                    throw new NoSuchElementException(\"Pool exhausted\");\n                }\n                if (!p.allocate()) {\n                    p = null;\n                }\n            }\n            //对象分配成功\n            if (p != null) {\n\n                try {\n                   //激活对象\n                    factory.activateObject(p);\n                } catch (Exception e) {\n                    try {\n                        destroy(p);\n                    } catch (Exception e1) {\n                    }\n                    p = null;\n                    .....\n                }\n                //如果配置了对象检查\n                if (p != null && (getTestOnBorrow() || create && getTestOnCreate())) {\n                    boolean validate = false;\n                    Throwable validationThrowable = null;\n                    try {\n                        validate = factory.validateObject(p);\n                    } catch (Throwable t) {\n                        PoolUtils.checkRethrow(t);\n                        validationThrowable = t;\n                    }\n                    if (!validate) {\n                    //验证失败 销毁对象\n                        try {\n                            destroy(p);\n                         destroyedByBorrowValidationCount.incrementAndGet();\n                        } catch (Exception e) {\n                        }\n                        p = null;\n                        .....\n                    }\n                }\n            }\n        }\n        //更新借出时间等信息\n        updateStatsBorrow(p, waitTime);\n\n        return p.getObject();\n    }\n```\nevict()驱逐对象：\n\nevict驱逐检查：上面介绍了两种对象的检查方式，evictor不同之处在于它由后台线程独立来完成，检查对象主要是连接池中的空闲连接，超时时间等可通过EvictionConfig配置。\n``` java\npublic void evict() throws Exception {\n        //确保连接池打开\n        assertOpen();\n\n        if (idleObjects.size() > 0) {\n\n            PooledObject<T> underTest = null;\n            \n            EvictionPolicy<T> evictionPolicy = getEvictionPolicy();\n\n            synchronized (evictionLock) {\n                ...\n                // 复制变量保证函数内值不改变，同上\n                boolean testWhileIdle = getTestWhileIdle();\n                //每次驱逐对象数可配置\n                for (int i = 0, m = getNumTests(); i < m; i++) {\n                    if (evictionIterator == null || !evictionIterator.hasNext()) {\n                        //驱逐检查的顺序和空闲队列出入顺序保持一致 \n                        if (getLifo()) {\n                            //后进先出(逆序遍历)\n                            evictionIterator = idleObjects.descendingIterator();\n                        } else {\n                            //先进先出\n                            evictionIterator = idleObjects.iterator();\n                        }\n                    }\n                    if (!evictionIterator.hasNext()) {\n                        // Pool exhausted, nothing to do here\n                        return;\n                    }\n\n                    try {\n                        underTest = evictionIterator.next();\n                    } catch (NoSuchElementException nsee) {\n                        //因为idleObjects.iterator()方法并没有做同步控制，可能被检查的空闲对象再检查期间已经被借出不在队列中了，在并发条件下要考虑这种情况。。\n                        // Object was borrowed in another thread\n                        // Don't count this as an eviction test so reduce i;\n                        i--;\n                        evictionIterator = null;\n                        continue;\n                    }\n                    //再次检查，对象在队列中但是要保证状态是空闲。。。\n                    if (!underTest.startEvictionTest()) {\n                        // Object was borrowed in another thread\n                        // Don't count this as an eviction test so reduce i;\n                        i--;\n                        continue;\n                    }\n                    //EvictionPolicy定义了驱逐对象的策略，默认实现是DefaultEvictionPolicy\n                    //调用ObjectPool的setEvictionPolicyClassName方法指定自定义策略\n                    if (evictionPolicy.evict(evictionConfig, underTest,\n                            idleObjects.size())) {\n                        destroy(underTest);\n                        destroyedByEvictorCount.incrementAndGet();\n                    } else {\n                        if (testWhileIdle) {\n                            ...\n                            //执行activateObject&validateObject的检查\n                            ...\n                        }\n                        ...\n                    }\n                }\n            }\n        }\n        //无处不在的Abandoned检查，可以配置连接池是否在evictor线程中执行removeAbandoned\n        AbandonedConfig ac = this.abandonedConfig;\n        if (ac != null && ac.getRemoveAbandonedOnMaintenance()) {\n            removeAbandoned(ac);\n        }\n    }\n```\n驱逐线程的调用：\n了解驱逐对象时要做的操作之后，我们来看一下后台的驱逐者线程是怎么定义&启动的\n``` java\n//GenericObjectPool.java\n//构造方法中启动驱逐者线程\npublic GenericObjectPool(PooledObjectFactory<T> factory,\n            GenericObjectPoolConfig config) {\n        ...\n        startEvictor(getTimeBetweenEvictionRunsMillis());\n        ...\n    }\n```\n驱逐线程的定义：\n驱逐者Evictor,在BaseGenericObjectPool中定义，本质是由java.util.TimerTask定义的定时任务\n```java\n//父类BaseGenericObjectPool.java\nfinal void startEvictor(long delay) {\n        //BaseGenericObjectPool的私有成员，final Object evictionLock = new Object();做对象锁\n        synchronized (evictionLock) {\n            if (null != evictor) {\n                //已存在evictor，取消驱逐者线程，所以也可以二次调用startEvictor来停止驱逐检查\n                EvictionTimer.cancel(evictor);\n                evictor = null;\n                evictionIterator = null;\n            }\n            if (delay > 0) {\n                evictor = new Evictor();\n                EvictionTimer.schedule(evictor, delay, delay);\n            }\n        }\n    }\n```\nEvitor定义：这里有一个比较有意思的问题，驱逐者线程Evictor被多个连接池共享,但是这些连接池可能属于不同的classloader,Evictor必须要保证它的所有行为在**当前这个连接池的classloader**下执行（这是开发者给commons-pool提交的bug,[详细描述请看这里](https://issues.apache.org/jira/browse/POOL-161)）\n```java\n//内部类Evictor\nclass Evictor extends TimerTask {\n    \n        @Override\n        public void run() {\n            ClassLoader savedClassLoader =\n                    Thread.currentThread().getContextClassLoader();\n            try {\n                // 切换到当前连接池的classLoader\n                Thread.currentThread().setContextClassLoader(\n                        factoryClassLoader);\n\n                // 执行上面的evict()方法\n                try {\n                    evict();\n                } catch(Exception e) {\n                    swallowException(e);\n                } catch(OutOfMemoryError oome) {\n                    // Log problem but give evictor thread a chance to continue\n                    // in case error is recoverable\n                    oome.printStackTrace(System.err);\n                }\n                // 驱逐之后还要保证空闲连接数量不能小于配置\n                try {\n                    ensureMinIdle();\n                } catch (Exception e) {\n                    swallowException(e);\n                }\n            } finally {\n                // 切换回之前的classLoader\n                Thread.currentThread().setContextClassLoader(savedClassLoader);\n            }\n        }\n    }\n```\n驱逐策略：\n在evict()方法中最后对象是否要被驱逐是调用了evictionPolicy.evict()的方法来判断的，commons-pool提供的驱逐策略如下：\n```java\n//DefaultEvictionPolicy.java\n\npublic class DefaultEvictionPolicy<T> implements EvictionPolicy<T> {\n    @Override\n    public boolean evict(EvictionConfig config, PooledObject<T> underTest,\n            int idleCount) {\n        //getIdleTimeMillis()空闲时间\n        //config.getIdleSoftEvictTime()空闲连接大于配置的最小值时的超时时间\n        //config.getIdleEvictTime()空闲连接超时时间与数量无关\n        if ((config.getIdleSoftEvictTime() < underTest.getIdleTimeMillis() &&\n                config.getMinIdle() < idleCount) ||\n                config.getIdleEvictTime() < underTest.getIdleTimeMillis()) {\n            return true;\n        }\n        return false;\n    }\n}\n\n```\n驱逐策略是支持自定义的，这里使用的是设计模式中的策略模式，我们只要实现EvictionPolicy接口，然后调用setEvictionPolicyClassName()方法既可以更换驱逐策略（实现类要尽可能简单，只描述一种算法即可）：\n```java\n//父类BaseGenericObjectPool.java\n public final void setEvictionPolicyClassName(\n            String evictionPolicyClassName) {\n        try {\n            //使用接口+反射实现的策略模式\n            Class<?> clazz = Class.forName(evictionPolicyClassName);\n            Object policy = clazz.newInstance();\n            if (policy instanceof EvictionPolicy<?>) {\n                @SuppressWarnings(\"unchecked\") \n                EvictionPolicy<T> evicPolicy = (EvictionPolicy<T>) policy;\n                this.evictionPolicy = evicPolicy;\n            }\n        } catch (ClassNotFoundException e) {\n            ...\n        } catch (InstantiationException e) {\n            ...\n        } catch (IllegalAccessException e) {\n            ...\n        }\n    }\n\n```\n通过阅读GenericObjectPool的部分代码，可以看出来并没有在每个获取&退还对象的方法都做同步控制，线程安全主要是由LinkedBlockingDeque，ConcurrentHashMap这两个并发集合保证的，因此开发者在编写非线程安全方法时也使用了局部变量复制可能被修改的值，多次检查对象状态之类的方法保证并发条件下程序正常的执行（没全部加锁能够提升性能，不过也会有这样的麻烦）。\n总结一下连接池中对象的声明周期大概如下图：\n![流程图][2]\n蓝色线是evictor执行时对象状态的变化，红线是abandon执行的过程，绿色线是正常使用中对象的变化。\n\n\n\n## 其他功能\n附上一份objectpool的配置选项\n```java\nGenericObjectPoolConfig poolConfig = new GenericObjectPoolConfig();\n\n基本配置：\n\n        //最大连接\n        poolConfig.setMaxTotal(100);\n        //最大空闲连接\n        poolConfig.setMaxIdle(5);\n        //最小空闲连接 \n        poolConfig.setMinIdle(5);\n        //连接满时最多等待时间\n        poolConfig.setMaxWaitMillis(5000L);\n\n高级功能：\n         //使用时检查对象（默认不检查）\n        poolConfig.setTestWhileIdle(true);\n        poolConfig.setTestOnCreate(true);\n        poolConfig.setTestOnBorrow(true);\n        poolConfig.setTestOnReturn(true);\n\n        //jmx启用 之后可以实时的查看线程池对象的状态\n        poolConfig.setJmxEnabled(false);\n        poolConfig.setJmxNameBase(\"namebase\");\n        poolConfig.setJmxNamePrefix(\"nameprefix\");\n\n         //驱逐线程每次检查对象个数\n        poolConfig.setNumTestsPerEvictionRun(2);\n        //空闲连接被驱逐前能够保留的时间\n        poolConfig.setMinEvictableIdleTimeMillis(10000L);\n        //当空闲线程大于minIdle 空闲连接能够保留时间，同时指定会被上面的覆盖\n        poolConfig.setSoftMinEvictableIdleTimeMillis(10000L);\n        //驱逐线程执行间隔时间\n        poolConfig.setTimeBetweenEvictionRunsMillis(200000L);\n\n        //放弃长时间占用连接的对象\n       AbandonedConfig abandonedConfig=new AbandonedConfig();\n       abandonedConfig.setLogAbandoned(true);\n       abandonedConfig.setUseUsageTracking(false);\n       abandonedConfig.setRemoveAbandonedOnBorrow(true);\n       abandonedConfig.setRemoveAbandonedOnMaintenance(true);\n       abandonedConfig.setRemoveAbandonedTimeout(20);//second\n```\n\n\n  [1]: https://www.throwsnew.com/img/GenericObjectPool.PNG\n  [2]: https://www.throwsnew.com/img/common-pool2.png\n","source":"_posts/commons-pool.md","raw":"title: 如何设计一个连接池：commons-pool2源码分析\ndate: 2017-06-12 00:10:50\ncategories: 开源框架\ntags: \n - 连接池\n - 源码\n - commons-pool\n---\n\n## 前言\n大家对连接池的概念应该都很熟悉了，[apache commons-pool](https://commons.apache.org/proper/commons-pool/)是apache基金会的一个开源对象池组件，我们常用的数据库连接池dpcp和redis的java客户端jedis都使用commons-pool来管理连接。现在我们通过阅读commons-pool的部分代码来看一看他们在编写连接池组件时采用了什么样的设计思路和技术。\n\n## 准备工作\n首先我们思考一下，连接池除应该具备哪些功能？\n\n 1. 连接池要能够管理不同类型的对象，同时作为一个服务组件不需要关心每种连接的创建细节。\n 2. 连接池中的连接当长时间空闲时可能会被服务端主动关闭，或者受网络影响断开，连接池要能够定时检查它的连接是否可用。\n 3. 支持并发操作,每个线程各种持有连接互不影响。\n\n带着这三个问题，下面我们一起看一下commons-pool的代码,\n它主要提供这个几种类型的对象池：\n<!--more-->\n![类图][1]\n从左至右看，SoftReferenceObjectPool是不用指定容量的对象池，ProxiedObject是使用代理模式来创建对象池的对象，在这篇文章主要介绍GenericObjectPool的实现。\n\n## 封装对象\ncommons-pool定义了一个接口PooledObject来封装池中的对象，添加了空闲时间，使用时间等信息和对象状态流转的行为。\nPooledbject的状态有这几种：\n|    状态     |    说明  |\n| --------   | -----  | \n| IDLE     | 空闲 |\n|ALLOCATED  |   使用中\n|INVALID |不可用 即将/已经被销毁\n|ABANDONED |被遗弃\n|RETURNING |返回对象池\n|EVICTION|  在队列中 正在被检查\n|EVICTION_RETURN_TO_HEAD| 检查结束要放回队列头部\n|VALIDATION| 在队列中 正在被检查\n|VALIDATION_PREALLOCATED |验证结束要被分配\n|VALIDATION_RETURN_TO_HEAD| 检查结束要放回队列头部\n\n表格中以RETURN_TO_HEAD结尾的状态是在当前的检查操作和对象借出操作同时进行时出现的，在检查结束后为了尽量保证借出成功这个对象要放回队头。\n在我们不需要自定义对象行为的情况下可以直接使用PooledObject的默认实现DefaultPooledObject，主要代码如下：\n``` java\nprivate final long createTime = System.currentTimeMillis();\nprivate volatile long lastBorrowTime = createTime;\nprivate volatile long lastUseTime = createTime;\nprivate volatile long lastReturnTime = createTime;\nprivate volatile long borrowedCount = 0;\n@Override\n    public synchronized boolean allocate() {\n        if (state == PooledObjectState.IDLE) {\n            state = PooledObjectState.ALLOCATED;\n            lastBorrowTime = System.currentTimeMillis();\n            lastUseTime = lastBorrowTime;\n            borrowedCount++;\n            if (logAbandoned) {\n                borrowedBy = new AbandonedObjectCreatedException();\n            }\n            return true;\n        } else if (state == PooledObjectState.EVICTION) {\n            state = PooledObjectState.EVICTION_RETURN_TO_HEAD;\n            return false;\n        }\n        return false;\n    }\n```\nallocate() 定义了对象分配时的状态变化，当对象在空闲状态时才能被分配；如果对象正在做驱逐检查时,会把这个对象标记为EVICTION_RETURN_TO_HEAD.\n```java\n@Override\n//返回值：对象是否当前未被使用\npublic synchronized boolean endEvictionTest(\n            Deque<PooledObject<T>> idleQueue) {\n        if (state == PooledObjectState.EVICTION) {\n            state = PooledObjectState.IDLE;\n            return true;\n        } else if (state == PooledObjectState.EVICTION_RETURN_TO_HEAD) {\n            //如果状态是EVICTION_RETURN_TO_HEAD表示当前这个对象试图被借出，返回false.\n            state = PooledObjectState.IDLE;\n            if (!idleQueue.offerFirst(this)) {\n                // TODO - Should never happen\n            }\n        }\n        return false;\n    }\n```\n\nendEvictionTest()定义了驱逐检查之后对象状态的变化，可以看到EVICTION_RETURN_TO_HEAD状态的对象被放到空闲队列队头。\n\nallocate()和borrowedCount等使用synchronized，violatile都做了线程安全的处理。\n\n \n## 定义对象工厂\ncommons-pool为了管理多种对象使用工厂模式来创建要管理的对象，使用工厂方法后使用者可以通过重写PooledObjectFactory定义对象的实现，销毁，验证的具体实现，而commons-pool不需要关心这些细节它只管理PooledObject对象即可。\n\n工厂接口：PooledObjectFactory\n``` java\npublic interface PooledObjectFactory<T> {\n  PooledObject<T> makeObject() throws Exception;\n  void destroyObject(PooledObject<T> p) throws Exception;\n  boolean validateObject(PooledObject<T> p);\n  void activateObject(PooledObject<T> p) throws Exception;\n  void passivateObject(PooledObject<T> p) throws Exception;\n}\n```\n工厂抽象类：BasePooledObjectFactory\n``` java\npublic abstract class BasePooledObjectFactory<T> implements PooledObjectFactory<T> {\n...\n    public abstract T create() throws Exception;\n    public abstract PooledObject<T> wrap(T obj);\n    @Override\n    public PooledObject<T> makeObject() throws Exception {\n        return wrap(create());\n    }\n    @Override\n    public boolean validateObject(PooledObject<T> p) {\n        return true;\n    }\n\n...\n}\n```\nBasePooledObjectFactory添加了create,wrap两个抽象方法，create可以返回我们要放在连接池的对象，然后使用wrap封装为PooledObject即可，注意validateObject默认返回true;\n\n## 对象池定义\n对象池是我们保存对象的地方，对象的获取，归还和定时检查都通过对象池来实现。以GenericObjectPool为例，对象池使用了线程安全的集合类来保存对象，LinkedBlockingDeque用于保存空闲的对象，ConcurrentHashMap保存全部对象（包括各种状态）。\n``` java\nprivate final LinkedBlockingDeque<PooledObject<T>> idleObjects = new LinkedBlockingDeque<PooledObject<T>>();\nprivate final Map<T, PooledObject<T>> allObjects = new ConcurrentHashMap<T, PooledObject<T>>();\n```\nborrowObject()从连接池获取对象：\n连接池借出对象时，经过Abandoned和validate两种检查，在连接池满时根据配置执行对应的等待策略，当没有可用对象时会抛出异常。\n\nAbandoned检查目标是连接池所有被借出的对象，主要防止对象借出之后长时间被占用，不能退还（或者使用者忘记return）到连接池导致连接被耗尽。超时时间由AbandonedConfig定义。\n\nvalidate检查目标是当前即将被借出的对象，目的是保证提供的对象是可用的，检查方式由对象工厂的validateObject方法定义。对象工厂还有activateObject方法来验证对象，不过这个方法是强制执行的。\n\n``` java\npublic T borrowObject(long borrowMaxWaitMillis) throws Exception {\n// getNumIdle() 表示当前空空闲对象数量，getNumActive() 表示当前非空闲的对象数量，getMaxTotal()表示连接池容量\n// 那么假设最大容量10个，非空闲8个 > 7 ，空闲对象只要少于2个，就需要开始Abandoned检查\n\n        AbandonedConfig ac = this.abandonedConfig;\n        if (ac != null && ac.getRemoveAbandonedOnBorrow() &&\n                (getNumIdle() < 2) &&\n                (getNumActive() > getMaxTotal() - 3) ) {\n            removeAbandoned(ac);\n        }\n\n        PooledObject<T> p = null;\n        \n        //拷贝了变量 blockWhenExhausted\n        //因为blockWhenExhausted的修改方法是public的，这样保证在并发情况下，方法执行周期内变量也不会变化\n        boolean blockWhenExhausted = getBlockWhenExhausted();\n\n        boolean create;\n        long waitTime = 0;\n\n        while (p == null) {\n            create = false;\n            // 设置了对象池耗尽时等待\n            if (blockWhenExhausted) {\n                //从空闲队列取对象\n                p = idleObjects.pollFirst();\n                if (p == null) {\n                    //没有空闲对象 新建一个\n                    create = true;\n                    p = create();\n                }\n                if (p == null) {\n                    if (borrowMaxWaitMillis < 0) {\n                        //注意：没配置等待时间，会一直阻塞\n                        p = idleObjects.takeFirst();\n                    } else {\n                        //按照配置的时间等待\n.....\n                        p = idleObjects.pollFirst(borrowMaxWaitMillis,\n                                TimeUnit.MILLISECONDS);\n.....\n                    }\n                }\n                 //等待之后还是没有空闲对象\n                if (p == null) {\n                    throw new NoSuchElementException(\n                            \"Timeout waiting for idle object\");\n                }\n                 //等待之后获得对象 尝试分配对象\n                 //这个方法由pooledobject实现\n                if (!p.allocate()) {\n                    p = null;\n                }\n            } else {\n                //没有配置blockWhenExhausted 不等待\n                p = idleObjects.pollFirst();\n                if (p == null) {\n                    create = true;\n                    p = create();\n                }\n                if (p == null) {\n                    throw new NoSuchElementException(\"Pool exhausted\");\n                }\n                if (!p.allocate()) {\n                    p = null;\n                }\n            }\n            //对象分配成功\n            if (p != null) {\n\n                try {\n                   //激活对象\n                    factory.activateObject(p);\n                } catch (Exception e) {\n                    try {\n                        destroy(p);\n                    } catch (Exception e1) {\n                    }\n                    p = null;\n                    .....\n                }\n                //如果配置了对象检查\n                if (p != null && (getTestOnBorrow() || create && getTestOnCreate())) {\n                    boolean validate = false;\n                    Throwable validationThrowable = null;\n                    try {\n                        validate = factory.validateObject(p);\n                    } catch (Throwable t) {\n                        PoolUtils.checkRethrow(t);\n                        validationThrowable = t;\n                    }\n                    if (!validate) {\n                    //验证失败 销毁对象\n                        try {\n                            destroy(p);\n                         destroyedByBorrowValidationCount.incrementAndGet();\n                        } catch (Exception e) {\n                        }\n                        p = null;\n                        .....\n                    }\n                }\n            }\n        }\n        //更新借出时间等信息\n        updateStatsBorrow(p, waitTime);\n\n        return p.getObject();\n    }\n```\nevict()驱逐对象：\n\nevict驱逐检查：上面介绍了两种对象的检查方式，evictor不同之处在于它由后台线程独立来完成，检查对象主要是连接池中的空闲连接，超时时间等可通过EvictionConfig配置。\n``` java\npublic void evict() throws Exception {\n        //确保连接池打开\n        assertOpen();\n\n        if (idleObjects.size() > 0) {\n\n            PooledObject<T> underTest = null;\n            \n            EvictionPolicy<T> evictionPolicy = getEvictionPolicy();\n\n            synchronized (evictionLock) {\n                ...\n                // 复制变量保证函数内值不改变，同上\n                boolean testWhileIdle = getTestWhileIdle();\n                //每次驱逐对象数可配置\n                for (int i = 0, m = getNumTests(); i < m; i++) {\n                    if (evictionIterator == null || !evictionIterator.hasNext()) {\n                        //驱逐检查的顺序和空闲队列出入顺序保持一致 \n                        if (getLifo()) {\n                            //后进先出(逆序遍历)\n                            evictionIterator = idleObjects.descendingIterator();\n                        } else {\n                            //先进先出\n                            evictionIterator = idleObjects.iterator();\n                        }\n                    }\n                    if (!evictionIterator.hasNext()) {\n                        // Pool exhausted, nothing to do here\n                        return;\n                    }\n\n                    try {\n                        underTest = evictionIterator.next();\n                    } catch (NoSuchElementException nsee) {\n                        //因为idleObjects.iterator()方法并没有做同步控制，可能被检查的空闲对象再检查期间已经被借出不在队列中了，在并发条件下要考虑这种情况。。\n                        // Object was borrowed in another thread\n                        // Don't count this as an eviction test so reduce i;\n                        i--;\n                        evictionIterator = null;\n                        continue;\n                    }\n                    //再次检查，对象在队列中但是要保证状态是空闲。。。\n                    if (!underTest.startEvictionTest()) {\n                        // Object was borrowed in another thread\n                        // Don't count this as an eviction test so reduce i;\n                        i--;\n                        continue;\n                    }\n                    //EvictionPolicy定义了驱逐对象的策略，默认实现是DefaultEvictionPolicy\n                    //调用ObjectPool的setEvictionPolicyClassName方法指定自定义策略\n                    if (evictionPolicy.evict(evictionConfig, underTest,\n                            idleObjects.size())) {\n                        destroy(underTest);\n                        destroyedByEvictorCount.incrementAndGet();\n                    } else {\n                        if (testWhileIdle) {\n                            ...\n                            //执行activateObject&validateObject的检查\n                            ...\n                        }\n                        ...\n                    }\n                }\n            }\n        }\n        //无处不在的Abandoned检查，可以配置连接池是否在evictor线程中执行removeAbandoned\n        AbandonedConfig ac = this.abandonedConfig;\n        if (ac != null && ac.getRemoveAbandonedOnMaintenance()) {\n            removeAbandoned(ac);\n        }\n    }\n```\n驱逐线程的调用：\n了解驱逐对象时要做的操作之后，我们来看一下后台的驱逐者线程是怎么定义&启动的\n``` java\n//GenericObjectPool.java\n//构造方法中启动驱逐者线程\npublic GenericObjectPool(PooledObjectFactory<T> factory,\n            GenericObjectPoolConfig config) {\n        ...\n        startEvictor(getTimeBetweenEvictionRunsMillis());\n        ...\n    }\n```\n驱逐线程的定义：\n驱逐者Evictor,在BaseGenericObjectPool中定义，本质是由java.util.TimerTask定义的定时任务\n```java\n//父类BaseGenericObjectPool.java\nfinal void startEvictor(long delay) {\n        //BaseGenericObjectPool的私有成员，final Object evictionLock = new Object();做对象锁\n        synchronized (evictionLock) {\n            if (null != evictor) {\n                //已存在evictor，取消驱逐者线程，所以也可以二次调用startEvictor来停止驱逐检查\n                EvictionTimer.cancel(evictor);\n                evictor = null;\n                evictionIterator = null;\n            }\n            if (delay > 0) {\n                evictor = new Evictor();\n                EvictionTimer.schedule(evictor, delay, delay);\n            }\n        }\n    }\n```\nEvitor定义：这里有一个比较有意思的问题，驱逐者线程Evictor被多个连接池共享,但是这些连接池可能属于不同的classloader,Evictor必须要保证它的所有行为在**当前这个连接池的classloader**下执行（这是开发者给commons-pool提交的bug,[详细描述请看这里](https://issues.apache.org/jira/browse/POOL-161)）\n```java\n//内部类Evictor\nclass Evictor extends TimerTask {\n    \n        @Override\n        public void run() {\n            ClassLoader savedClassLoader =\n                    Thread.currentThread().getContextClassLoader();\n            try {\n                // 切换到当前连接池的classLoader\n                Thread.currentThread().setContextClassLoader(\n                        factoryClassLoader);\n\n                // 执行上面的evict()方法\n                try {\n                    evict();\n                } catch(Exception e) {\n                    swallowException(e);\n                } catch(OutOfMemoryError oome) {\n                    // Log problem but give evictor thread a chance to continue\n                    // in case error is recoverable\n                    oome.printStackTrace(System.err);\n                }\n                // 驱逐之后还要保证空闲连接数量不能小于配置\n                try {\n                    ensureMinIdle();\n                } catch (Exception e) {\n                    swallowException(e);\n                }\n            } finally {\n                // 切换回之前的classLoader\n                Thread.currentThread().setContextClassLoader(savedClassLoader);\n            }\n        }\n    }\n```\n驱逐策略：\n在evict()方法中最后对象是否要被驱逐是调用了evictionPolicy.evict()的方法来判断的，commons-pool提供的驱逐策略如下：\n```java\n//DefaultEvictionPolicy.java\n\npublic class DefaultEvictionPolicy<T> implements EvictionPolicy<T> {\n    @Override\n    public boolean evict(EvictionConfig config, PooledObject<T> underTest,\n            int idleCount) {\n        //getIdleTimeMillis()空闲时间\n        //config.getIdleSoftEvictTime()空闲连接大于配置的最小值时的超时时间\n        //config.getIdleEvictTime()空闲连接超时时间与数量无关\n        if ((config.getIdleSoftEvictTime() < underTest.getIdleTimeMillis() &&\n                config.getMinIdle() < idleCount) ||\n                config.getIdleEvictTime() < underTest.getIdleTimeMillis()) {\n            return true;\n        }\n        return false;\n    }\n}\n\n```\n驱逐策略是支持自定义的，这里使用的是设计模式中的策略模式，我们只要实现EvictionPolicy接口，然后调用setEvictionPolicyClassName()方法既可以更换驱逐策略（实现类要尽可能简单，只描述一种算法即可）：\n```java\n//父类BaseGenericObjectPool.java\n public final void setEvictionPolicyClassName(\n            String evictionPolicyClassName) {\n        try {\n            //使用接口+反射实现的策略模式\n            Class<?> clazz = Class.forName(evictionPolicyClassName);\n            Object policy = clazz.newInstance();\n            if (policy instanceof EvictionPolicy<?>) {\n                @SuppressWarnings(\"unchecked\") \n                EvictionPolicy<T> evicPolicy = (EvictionPolicy<T>) policy;\n                this.evictionPolicy = evicPolicy;\n            }\n        } catch (ClassNotFoundException e) {\n            ...\n        } catch (InstantiationException e) {\n            ...\n        } catch (IllegalAccessException e) {\n            ...\n        }\n    }\n\n```\n通过阅读GenericObjectPool的部分代码，可以看出来并没有在每个获取&退还对象的方法都做同步控制，线程安全主要是由LinkedBlockingDeque，ConcurrentHashMap这两个并发集合保证的，因此开发者在编写非线程安全方法时也使用了局部变量复制可能被修改的值，多次检查对象状态之类的方法保证并发条件下程序正常的执行（没全部加锁能够提升性能，不过也会有这样的麻烦）。\n总结一下连接池中对象的声明周期大概如下图：\n![流程图][2]\n蓝色线是evictor执行时对象状态的变化，红线是abandon执行的过程，绿色线是正常使用中对象的变化。\n\n\n\n## 其他功能\n附上一份objectpool的配置选项\n```java\nGenericObjectPoolConfig poolConfig = new GenericObjectPoolConfig();\n\n基本配置：\n\n        //最大连接\n        poolConfig.setMaxTotal(100);\n        //最大空闲连接\n        poolConfig.setMaxIdle(5);\n        //最小空闲连接 \n        poolConfig.setMinIdle(5);\n        //连接满时最多等待时间\n        poolConfig.setMaxWaitMillis(5000L);\n\n高级功能：\n         //使用时检查对象（默认不检查）\n        poolConfig.setTestWhileIdle(true);\n        poolConfig.setTestOnCreate(true);\n        poolConfig.setTestOnBorrow(true);\n        poolConfig.setTestOnReturn(true);\n\n        //jmx启用 之后可以实时的查看线程池对象的状态\n        poolConfig.setJmxEnabled(false);\n        poolConfig.setJmxNameBase(\"namebase\");\n        poolConfig.setJmxNamePrefix(\"nameprefix\");\n\n         //驱逐线程每次检查对象个数\n        poolConfig.setNumTestsPerEvictionRun(2);\n        //空闲连接被驱逐前能够保留的时间\n        poolConfig.setMinEvictableIdleTimeMillis(10000L);\n        //当空闲线程大于minIdle 空闲连接能够保留时间，同时指定会被上面的覆盖\n        poolConfig.setSoftMinEvictableIdleTimeMillis(10000L);\n        //驱逐线程执行间隔时间\n        poolConfig.setTimeBetweenEvictionRunsMillis(200000L);\n\n        //放弃长时间占用连接的对象\n       AbandonedConfig abandonedConfig=new AbandonedConfig();\n       abandonedConfig.setLogAbandoned(true);\n       abandonedConfig.setUseUsageTracking(false);\n       abandonedConfig.setRemoveAbandonedOnBorrow(true);\n       abandonedConfig.setRemoveAbandonedOnMaintenance(true);\n       abandonedConfig.setRemoveAbandonedTimeout(20);//second\n```\n\n\n  [1]: https://www.throwsnew.com/img/GenericObjectPool.PNG\n  [2]: https://www.throwsnew.com/img/common-pool2.png\n","slug":"commons-pool","published":1,"updated":"2018-11-21T16:17:57.182Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp57u42d00252xpb2sljsrsv","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>大家对连接池的概念应该都很熟悉了，<a href=\"https://commons.apache.org/proper/commons-pool/\" target=\"_blank\" rel=\"noopener\">apache commons-pool</a>是apache基金会的一个开源对象池组件，我们常用的数据库连接池dpcp和redis的java客户端jedis都使用commons-pool来管理连接。现在我们通过阅读commons-pool的部分代码来看一看他们在编写连接池组件时采用了什么样的设计思路和技术。</p>\n<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><p>首先我们思考一下，连接池除应该具备哪些功能？</p>\n<ol>\n<li>连接池要能够管理不同类型的对象，同时作为一个服务组件不需要关心每种连接的创建细节。</li>\n<li>连接池中的连接当长时间空闲时可能会被服务端主动关闭，或者受网络影响断开，连接池要能够定时检查它的连接是否可用。</li>\n<li>支持并发操作,每个线程各种持有连接互不影响。</li>\n</ol>\n<p>带着这三个问题，下面我们一起看一下commons-pool的代码,<br>它主要提供这个几种类型的对象池：<br><a id=\"more\"></a><br><img src=\"https://www.throwsnew.com/img/GenericObjectPool.PNG\" alt=\"类图\"><br>从左至右看，SoftReferenceObjectPool是不用指定容量的对象池，ProxiedObject是使用代理模式来创建对象池的对象，在这篇文章主要介绍GenericObjectPool的实现。</p>\n<h2 id=\"封装对象\"><a href=\"#封装对象\" class=\"headerlink\" title=\"封装对象\"></a>封装对象</h2><p>commons-pool定义了一个接口PooledObject来封装池中的对象，添加了空闲时间，使用时间等信息和对象状态流转的行为。<br>Pooledbject的状态有这几种：<br>|    状态     |    说明  |<br>| ——–   | —–  |<br>| IDLE     | 空闲 |<br>|ALLOCATED  |   使用中<br>|INVALID |不可用 即将/已经被销毁<br>|ABANDONED |被遗弃<br>|RETURNING |返回对象池<br>|EVICTION|  在队列中 正在被检查<br>|EVICTION_RETURN_TO_HEAD| 检查结束要放回队列头部<br>|VALIDATION| 在队列中 正在被检查<br>|VALIDATION_PREALLOCATED |验证结束要被分配<br>|VALIDATION_RETURN_TO_HEAD| 检查结束要放回队列头部</p>\n<p>表格中以RETURN_TO_HEAD结尾的状态是在当前的检查操作和对象借出操作同时进行时出现的，在检查结束后为了尽量保证借出成功这个对象要放回队头。<br>在我们不需要自定义对象行为的情况下可以直接使用PooledObject的默认实现DefaultPooledObject，主要代码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> createTime = System.currentTimeMillis();</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">long</span> lastBorrowTime = createTime;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">long</span> lastUseTime = createTime;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">long</span> lastReturnTime = createTime;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">long</span> borrowedCount = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">boolean</span> <span class=\"title\">allocate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (state == PooledObjectState.IDLE) &#123;</span><br><span class=\"line\">            state = PooledObjectState.ALLOCATED;</span><br><span class=\"line\">            lastBorrowTime = System.currentTimeMillis();</span><br><span class=\"line\">            lastUseTime = lastBorrowTime;</span><br><span class=\"line\">            borrowedCount++;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (logAbandoned) &#123;</span><br><span class=\"line\">                borrowedBy = <span class=\"keyword\">new</span> AbandonedObjectCreatedException();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (state == PooledObjectState.EVICTION) &#123;</span><br><span class=\"line\">            state = PooledObjectState.EVICTION_RETURN_TO_HEAD;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>allocate() 定义了对象分配时的状态变化，当对象在空闲状态时才能被分配；如果对象正在做驱逐检查时,会把这个对象标记为EVICTION_RETURN_TO_HEAD.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"comment\">//返回值：对象是否当前未被使用</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">boolean</span> <span class=\"title\">endEvictionTest</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            Deque&lt;PooledObject&lt;T&gt;&gt; idleQueue)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (state == PooledObjectState.EVICTION) &#123;</span><br><span class=\"line\">            state = PooledObjectState.IDLE;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (state == PooledObjectState.EVICTION_RETURN_TO_HEAD) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//如果状态是EVICTION_RETURN_TO_HEAD表示当前这个对象试图被借出，返回false.</span></span><br><span class=\"line\">            state = PooledObjectState.IDLE;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!idleQueue.offerFirst(<span class=\"keyword\">this</span>)) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// TODO - Should never happen</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>endEvictionTest()定义了驱逐检查之后对象状态的变化，可以看到EVICTION_RETURN_TO_HEAD状态的对象被放到空闲队列队头。</p>\n<p>allocate()和borrowedCount等使用synchronized，violatile都做了线程安全的处理。</p>\n<h2 id=\"定义对象工厂\"><a href=\"#定义对象工厂\" class=\"headerlink\" title=\"定义对象工厂\"></a>定义对象工厂</h2><p>commons-pool为了管理多种对象使用工厂模式来创建要管理的对象，使用工厂方法后使用者可以通过重写PooledObjectFactory定义对象的实现，销毁，验证的具体实现，而commons-pool不需要关心这些细节它只管理PooledObject对象即可。</p>\n<p>工厂接口：PooledObjectFactory<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">PooledObjectFactory</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"function\">PooledObject&lt;T&gt; <span class=\"title\">makeObject</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">destroyObject</span><span class=\"params\">(PooledObject&lt;T&gt; p)</span> <span class=\"keyword\">throws</span> Exception</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">validateObject</span><span class=\"params\">(PooledObject&lt;T&gt; p)</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">activateObject</span><span class=\"params\">(PooledObject&lt;T&gt; p)</span> <span class=\"keyword\">throws</span> Exception</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">passivateObject</span><span class=\"params\">(PooledObject&lt;T&gt; p)</span> <span class=\"keyword\">throws</span> Exception</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>工厂抽象类：BasePooledObjectFactory<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BasePooledObjectFactory</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">PooledObjectFactory</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">...</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> T <span class=\"title\">create</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> PooledObject&lt;T&gt; <span class=\"title\">wrap</span><span class=\"params\">(T obj)</span></span>;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> PooledObject&lt;T&gt; <span class=\"title\">makeObject</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> wrap(create());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">validateObject</span><span class=\"params\">(PooledObject&lt;T&gt; p)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>BasePooledObjectFactory添加了create,wrap两个抽象方法，create可以返回我们要放在连接池的对象，然后使用wrap封装为PooledObject即可，注意validateObject默认返回true;</p>\n<h2 id=\"对象池定义\"><a href=\"#对象池定义\" class=\"headerlink\" title=\"对象池定义\"></a>对象池定义</h2><p>对象池是我们保存对象的地方，对象的获取，归还和定时检查都通过对象池来实现。以GenericObjectPool为例，对象池使用了线程安全的集合类来保存对象，LinkedBlockingDeque用于保存空闲的对象，ConcurrentHashMap保存全部对象（包括各种状态）。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> LinkedBlockingDeque&lt;PooledObject&lt;T&gt;&gt; idleObjects = <span class=\"keyword\">new</span> LinkedBlockingDeque&lt;PooledObject&lt;T&gt;&gt;();</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;T, PooledObject&lt;T&gt;&gt; allObjects = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;T, PooledObject&lt;T&gt;&gt;();</span><br></pre></td></tr></table></figure></p>\n<p>borrowObject()从连接池获取对象：<br>连接池借出对象时，经过Abandoned和validate两种检查，在连接池满时根据配置执行对应的等待策略，当没有可用对象时会抛出异常。</p>\n<p>Abandoned检查目标是连接池所有被借出的对象，主要防止对象借出之后长时间被占用，不能退还（或者使用者忘记return）到连接池导致连接被耗尽。超时时间由AbandonedConfig定义。</p>\n<p>validate检查目标是当前即将被借出的对象，目的是保证提供的对象是可用的，检查方式由对象工厂的validateObject方法定义。对象工厂还有activateObject方法来验证对象，不过这个方法是强制执行的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">borrowObject</span><span class=\"params\">(<span class=\"keyword\">long</span> borrowMaxWaitMillis)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">// getNumIdle() 表示当前空空闲对象数量，getNumActive() 表示当前非空闲的对象数量，getMaxTotal()表示连接池容量</span></span><br><span class=\"line\"><span class=\"comment\">// 那么假设最大容量10个，非空闲8个 &gt; 7 ，空闲对象只要少于2个，就需要开始Abandoned检查</span></span><br><span class=\"line\"></span><br><span class=\"line\">        AbandonedConfig ac = <span class=\"keyword\">this</span>.abandonedConfig;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ac != <span class=\"keyword\">null</span> &amp;&amp; ac.getRemoveAbandonedOnBorrow() &amp;&amp;</span><br><span class=\"line\">                (getNumIdle() &lt; <span class=\"number\">2</span>) &amp;&amp;</span><br><span class=\"line\">                (getNumActive() &gt; getMaxTotal() - <span class=\"number\">3</span>) ) &#123;</span><br><span class=\"line\">            removeAbandoned(ac);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        PooledObject&lt;T&gt; p = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//拷贝了变量 blockWhenExhausted</span></span><br><span class=\"line\">        <span class=\"comment\">//因为blockWhenExhausted的修改方法是public的，这样保证在并发情况下，方法执行周期内变量也不会变化</span></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> blockWhenExhausted = getBlockWhenExhausted();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> create;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> waitTime = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (p == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            create = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 设置了对象池耗尽时等待</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (blockWhenExhausted) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//从空闲队列取对象</span></span><br><span class=\"line\">                p = idleObjects.pollFirst();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//没有空闲对象 新建一个</span></span><br><span class=\"line\">                    create = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                    p = create();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (borrowMaxWaitMillis &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">//注意：没配置等待时间，会一直阻塞</span></span><br><span class=\"line\">                        p = idleObjects.takeFirst();</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"comment\">//按照配置的时间等待</span></span><br><span class=\"line\">.....</span><br><span class=\"line\">                        p = idleObjects.pollFirst(borrowMaxWaitMillis,</span><br><span class=\"line\">                                TimeUnit.MILLISECONDS);</span><br><span class=\"line\">.....</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                 <span class=\"comment\">//等待之后还是没有空闲对象</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NoSuchElementException(</span><br><span class=\"line\">                            <span class=\"string\">\"Timeout waiting for idle object\"</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                 <span class=\"comment\">//等待之后获得对象 尝试分配对象</span></span><br><span class=\"line\">                 <span class=\"comment\">//这个方法由pooledobject实现</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!p.allocate()) &#123;</span><br><span class=\"line\">                    p = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">//没有配置blockWhenExhausted 不等待</span></span><br><span class=\"line\">                p = idleObjects.pollFirst();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    create = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                    p = create();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NoSuchElementException(<span class=\"string\">\"Pool exhausted\"</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!p.allocate()) &#123;</span><br><span class=\"line\">                    p = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//对象分配成功</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                   <span class=\"comment\">//激活对象</span></span><br><span class=\"line\">                    factory.activateObject(p);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        destroy(p);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (Exception e1) &#123;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    p = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    .....</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">//如果配置了对象检查</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p != <span class=\"keyword\">null</span> &amp;&amp; (getTestOnBorrow() || create &amp;&amp; getTestOnCreate())) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">boolean</span> validate = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                    Throwable validationThrowable = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        validate = factory.validateObject(p);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">                        PoolUtils.checkRethrow(t);</span><br><span class=\"line\">                        validationThrowable = t;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (!validate) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//验证失败 销毁对象</span></span><br><span class=\"line\">                        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                            destroy(p);</span><br><span class=\"line\">                         destroyedByBorrowValidationCount.incrementAndGet();</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        p = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                        .....</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//更新借出时间等信息</span></span><br><span class=\"line\">        updateStatsBorrow(p, waitTime);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> p.getObject();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>evict()驱逐对象：</p>\n<p>evict驱逐检查：上面介绍了两种对象的检查方式，evictor不同之处在于它由后台线程独立来完成，检查对象主要是连接池中的空闲连接，超时时间等可通过EvictionConfig配置。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">evict</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//确保连接池打开</span></span><br><span class=\"line\">        assertOpen();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (idleObjects.size() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            PooledObject&lt;T&gt; underTest = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            </span><br><span class=\"line\">            EvictionPolicy&lt;T&gt; evictionPolicy = getEvictionPolicy();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (evictionLock) &#123;</span><br><span class=\"line\">                ...</span><br><span class=\"line\">                <span class=\"comment\">// 复制变量保证函数内值不改变，同上</span></span><br><span class=\"line\">                <span class=\"keyword\">boolean</span> testWhileIdle = getTestWhileIdle();</span><br><span class=\"line\">                <span class=\"comment\">//每次驱逐对象数可配置</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, m = getNumTests(); i &lt; m; i++) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (evictionIterator == <span class=\"keyword\">null</span> || !evictionIterator.hasNext()) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">//驱逐检查的顺序和空闲队列出入顺序保持一致 </span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (getLifo()) &#123;</span><br><span class=\"line\">                            <span class=\"comment\">//后进先出(逆序遍历)</span></span><br><span class=\"line\">                            evictionIterator = idleObjects.descendingIterator();</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                            <span class=\"comment\">//先进先出</span></span><br><span class=\"line\">                            evictionIterator = idleObjects.iterator();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (!evictionIterator.hasNext()) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// Pool exhausted, nothing to do here</span></span><br><span class=\"line\">                        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        underTest = evictionIterator.next();</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (NoSuchElementException nsee) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">//因为idleObjects.iterator()方法并没有做同步控制，可能被检查的空闲对象再检查期间已经被借出不在队列中了，在并发条件下要考虑这种情况。。</span></span><br><span class=\"line\">                        <span class=\"comment\">// Object was borrowed in another thread</span></span><br><span class=\"line\">                        <span class=\"comment\">// Don't count this as an eviction test so reduce i;</span></span><br><span class=\"line\">                        i--;</span><br><span class=\"line\">                        evictionIterator = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"comment\">//再次检查，对象在队列中但是要保证状态是空闲。。。</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (!underTest.startEvictionTest()) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// Object was borrowed in another thread</span></span><br><span class=\"line\">                        <span class=\"comment\">// Don't count this as an eviction test so reduce i;</span></span><br><span class=\"line\">                        i--;</span><br><span class=\"line\">                        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"comment\">//EvictionPolicy定义了驱逐对象的策略，默认实现是DefaultEvictionPolicy</span></span><br><span class=\"line\">                    <span class=\"comment\">//调用ObjectPool的setEvictionPolicyClassName方法指定自定义策略</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (evictionPolicy.evict(evictionConfig, underTest,</span><br><span class=\"line\">                            idleObjects.size())) &#123;</span><br><span class=\"line\">                        destroy(underTest);</span><br><span class=\"line\">                        destroyedByEvictorCount.incrementAndGet();</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (testWhileIdle) &#123;</span><br><span class=\"line\">                            ...</span><br><span class=\"line\">                            <span class=\"comment\">//执行activateObject&amp;validateObject的检查</span></span><br><span class=\"line\">                            ...</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        ...</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//无处不在的Abandoned检查，可以配置连接池是否在evictor线程中执行removeAbandoned</span></span><br><span class=\"line\">        AbandonedConfig ac = <span class=\"keyword\">this</span>.abandonedConfig;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ac != <span class=\"keyword\">null</span> &amp;&amp; ac.getRemoveAbandonedOnMaintenance()) &#123;</span><br><span class=\"line\">            removeAbandoned(ac);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>驱逐线程的调用：<br>了解驱逐对象时要做的操作之后，我们来看一下后台的驱逐者线程是怎么定义&amp;启动的<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//GenericObjectPool.java</span></span><br><span class=\"line\"><span class=\"comment\">//构造方法中启动驱逐者线程</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">GenericObjectPool</span><span class=\"params\">(PooledObjectFactory&lt;T&gt; factory,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            GenericObjectPoolConfig config)</span> </span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        startEvictor(getTimeBetweenEvictionRunsMillis());</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>驱逐线程的定义：<br>驱逐者Evictor,在BaseGenericObjectPool中定义，本质是由java.util.TimerTask定义的定时任务<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//父类BaseGenericObjectPool.java</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">startEvictor</span><span class=\"params\">(<span class=\"keyword\">long</span> delay)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//BaseGenericObjectPool的私有成员，final Object evictionLock = new Object();做对象锁</span></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (evictionLock) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> != evictor) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//已存在evictor，取消驱逐者线程，所以也可以二次调用startEvictor来停止驱逐检查</span></span><br><span class=\"line\">                EvictionTimer.cancel(evictor);</span><br><span class=\"line\">                evictor = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                evictionIterator = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (delay &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                evictor = <span class=\"keyword\">new</span> Evictor();</span><br><span class=\"line\">                EvictionTimer.schedule(evictor, delay, delay);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>Evitor定义：这里有一个比较有意思的问题，驱逐者线程Evictor被多个连接池共享,但是这些连接池可能属于不同的classloader,Evictor必须要保证它的所有行为在<strong>当前这个连接池的classloader</strong>下执行（这是开发者给commons-pool提交的bug,<a href=\"https://issues.apache.org/jira/browse/POOL-161\" target=\"_blank\" rel=\"noopener\">详细描述请看这里</a>）<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//内部类Evictor</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Evictor</span> <span class=\"keyword\">extends</span> <span class=\"title\">TimerTask</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            ClassLoader savedClassLoader =</span><br><span class=\"line\">                    Thread.currentThread().getContextClassLoader();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 切换到当前连接池的classLoader</span></span><br><span class=\"line\">                Thread.currentThread().setContextClassLoader(</span><br><span class=\"line\">                        factoryClassLoader);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 执行上面的evict()方法</span></span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    evict();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span>(Exception e) &#123;</span><br><span class=\"line\">                    swallowException(e);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span>(OutOfMemoryError oome) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// Log problem but give evictor thread a chance to continue</span></span><br><span class=\"line\">                    <span class=\"comment\">// in case error is recoverable</span></span><br><span class=\"line\">                    oome.printStackTrace(System.err);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 驱逐之后还要保证空闲连接数量不能小于配置</span></span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    ensureMinIdle();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                    swallowException(e);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 切换回之前的classLoader</span></span><br><span class=\"line\">                Thread.currentThread().setContextClassLoader(savedClassLoader);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>驱逐策略：<br>在evict()方法中最后对象是否要被驱逐是调用了evictionPolicy.evict()的方法来判断的，commons-pool提供的驱逐策略如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//DefaultEvictionPolicy.java</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DefaultEvictionPolicy</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">EvictionPolicy</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">evict</span><span class=\"params\">(EvictionConfig config, PooledObject&lt;T&gt; underTest,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">int</span> idleCount)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//getIdleTimeMillis()空闲时间</span></span><br><span class=\"line\">        <span class=\"comment\">//config.getIdleSoftEvictTime()空闲连接大于配置的最小值时的超时时间</span></span><br><span class=\"line\">        <span class=\"comment\">//config.getIdleEvictTime()空闲连接超时时间与数量无关</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((config.getIdleSoftEvictTime() &lt; underTest.getIdleTimeMillis() &amp;&amp;</span><br><span class=\"line\">                config.getMinIdle() &lt; idleCount) ||</span><br><span class=\"line\">                config.getIdleEvictTime() &lt; underTest.getIdleTimeMillis()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>驱逐策略是支持自定义的，这里使用的是设计模式中的策略模式，我们只要实现EvictionPolicy接口，然后调用setEvictionPolicyClassName()方法既可以更换驱逐策略（实现类要尽可能简单，只描述一种算法即可）：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//父类BaseGenericObjectPool.java</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">setEvictionPolicyClassName</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            String evictionPolicyClassName)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//使用接口+反射实现的策略模式</span></span><br><span class=\"line\">            Class&lt;?&gt; clazz = Class.forName(evictionPolicyClassName);</span><br><span class=\"line\">            Object policy = clazz.newInstance();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (policy <span class=\"keyword\">instanceof</span> EvictionPolicy&lt;?&gt;) &#123;</span><br><span class=\"line\">                <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>) </span><br><span class=\"line\">                EvictionPolicy&lt;T&gt; evicPolicy = (EvictionPolicy&lt;T&gt;) policy;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.evictionPolicy = evicPolicy;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException e) &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InstantiationException e) &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IllegalAccessException e) &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>通过阅读GenericObjectPool的部分代码，可以看出来并没有在每个获取&amp;退还对象的方法都做同步控制，线程安全主要是由LinkedBlockingDeque，ConcurrentHashMap这两个并发集合保证的，因此开发者在编写非线程安全方法时也使用了局部变量复制可能被修改的值，多次检查对象状态之类的方法保证并发条件下程序正常的执行（没全部加锁能够提升性能，不过也会有这样的麻烦）。<br>总结一下连接池中对象的声明周期大概如下图：<br><img src=\"https://www.throwsnew.com/img/common-pool2.png\" alt=\"流程图\"><br>蓝色线是evictor执行时对象状态的变化，红线是abandon执行的过程，绿色线是正常使用中对象的变化。</p>\n<h2 id=\"其他功能\"><a href=\"#其他功能\" class=\"headerlink\" title=\"其他功能\"></a>其他功能</h2><p>附上一份objectpool的配置选项<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GenericObjectPoolConfig poolConfig = <span class=\"keyword\">new</span> GenericObjectPoolConfig();</span><br><span class=\"line\"></span><br><span class=\"line\">基本配置：</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//最大连接</span></span><br><span class=\"line\">        poolConfig.setMaxTotal(<span class=\"number\">100</span>);</span><br><span class=\"line\">        <span class=\"comment\">//最大空闲连接</span></span><br><span class=\"line\">        poolConfig.setMaxIdle(<span class=\"number\">5</span>);</span><br><span class=\"line\">        <span class=\"comment\">//最小空闲连接 </span></span><br><span class=\"line\">        poolConfig.setMinIdle(<span class=\"number\">5</span>);</span><br><span class=\"line\">        <span class=\"comment\">//连接满时最多等待时间</span></span><br><span class=\"line\">        poolConfig.setMaxWaitMillis(<span class=\"number\">5000L</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">高级功能：</span><br><span class=\"line\">         <span class=\"comment\">//使用时检查对象（默认不检查）</span></span><br><span class=\"line\">        poolConfig.setTestWhileIdle(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        poolConfig.setTestOnCreate(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        poolConfig.setTestOnBorrow(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        poolConfig.setTestOnReturn(<span class=\"keyword\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//jmx启用 之后可以实时的查看线程池对象的状态</span></span><br><span class=\"line\">        poolConfig.setJmxEnabled(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">        poolConfig.setJmxNameBase(<span class=\"string\">\"namebase\"</span>);</span><br><span class=\"line\">        poolConfig.setJmxNamePrefix(<span class=\"string\">\"nameprefix\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"comment\">//驱逐线程每次检查对象个数</span></span><br><span class=\"line\">        poolConfig.setNumTestsPerEvictionRun(<span class=\"number\">2</span>);</span><br><span class=\"line\">        <span class=\"comment\">//空闲连接被驱逐前能够保留的时间</span></span><br><span class=\"line\">        poolConfig.setMinEvictableIdleTimeMillis(<span class=\"number\">10000L</span>);</span><br><span class=\"line\">        <span class=\"comment\">//当空闲线程大于minIdle 空闲连接能够保留时间，同时指定会被上面的覆盖</span></span><br><span class=\"line\">        poolConfig.setSoftMinEvictableIdleTimeMillis(<span class=\"number\">10000L</span>);</span><br><span class=\"line\">        <span class=\"comment\">//驱逐线程执行间隔时间</span></span><br><span class=\"line\">        poolConfig.setTimeBetweenEvictionRunsMillis(<span class=\"number\">200000L</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//放弃长时间占用连接的对象</span></span><br><span class=\"line\">       AbandonedConfig abandonedConfig=<span class=\"keyword\">new</span> AbandonedConfig();</span><br><span class=\"line\">       abandonedConfig.setLogAbandoned(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">       abandonedConfig.setUseUsageTracking(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">       abandonedConfig.setRemoveAbandonedOnBorrow(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">       abandonedConfig.setRemoveAbandonedOnMaintenance(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">       abandonedConfig.setRemoveAbandonedTimeout(<span class=\"number\">20</span>);<span class=\"comment\">//second</span></span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>大家对连接池的概念应该都很熟悉了，<a href=\"https://commons.apache.org/proper/commons-pool/\" target=\"_blank\" rel=\"noopener\">apache commons-pool</a>是apache基金会的一个开源对象池组件，我们常用的数据库连接池dpcp和redis的java客户端jedis都使用commons-pool来管理连接。现在我们通过阅读commons-pool的部分代码来看一看他们在编写连接池组件时采用了什么样的设计思路和技术。</p>\n<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><p>首先我们思考一下，连接池除应该具备哪些功能？</p>\n<ol>\n<li>连接池要能够管理不同类型的对象，同时作为一个服务组件不需要关心每种连接的创建细节。</li>\n<li>连接池中的连接当长时间空闲时可能会被服务端主动关闭，或者受网络影响断开，连接池要能够定时检查它的连接是否可用。</li>\n<li>支持并发操作,每个线程各种持有连接互不影响。</li>\n</ol>\n<p>带着这三个问题，下面我们一起看一下commons-pool的代码,<br>它主要提供这个几种类型的对象池：<br>","more":"<br><img src=\"https://www.throwsnew.com/img/GenericObjectPool.PNG\" alt=\"类图\"><br>从左至右看，SoftReferenceObjectPool是不用指定容量的对象池，ProxiedObject是使用代理模式来创建对象池的对象，在这篇文章主要介绍GenericObjectPool的实现。</p>\n<h2 id=\"封装对象\"><a href=\"#封装对象\" class=\"headerlink\" title=\"封装对象\"></a>封装对象</h2><p>commons-pool定义了一个接口PooledObject来封装池中的对象，添加了空闲时间，使用时间等信息和对象状态流转的行为。<br>Pooledbject的状态有这几种：<br>|    状态     |    说明  |<br>| ——–   | —–  |<br>| IDLE     | 空闲 |<br>|ALLOCATED  |   使用中<br>|INVALID |不可用 即将/已经被销毁<br>|ABANDONED |被遗弃<br>|RETURNING |返回对象池<br>|EVICTION|  在队列中 正在被检查<br>|EVICTION_RETURN_TO_HEAD| 检查结束要放回队列头部<br>|VALIDATION| 在队列中 正在被检查<br>|VALIDATION_PREALLOCATED |验证结束要被分配<br>|VALIDATION_RETURN_TO_HEAD| 检查结束要放回队列头部</p>\n<p>表格中以RETURN_TO_HEAD结尾的状态是在当前的检查操作和对象借出操作同时进行时出现的，在检查结束后为了尽量保证借出成功这个对象要放回队头。<br>在我们不需要自定义对象行为的情况下可以直接使用PooledObject的默认实现DefaultPooledObject，主要代码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> createTime = System.currentTimeMillis();</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">long</span> lastBorrowTime = createTime;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">long</span> lastUseTime = createTime;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">long</span> lastReturnTime = createTime;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">long</span> borrowedCount = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">boolean</span> <span class=\"title\">allocate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (state == PooledObjectState.IDLE) &#123;</span><br><span class=\"line\">            state = PooledObjectState.ALLOCATED;</span><br><span class=\"line\">            lastBorrowTime = System.currentTimeMillis();</span><br><span class=\"line\">            lastUseTime = lastBorrowTime;</span><br><span class=\"line\">            borrowedCount++;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (logAbandoned) &#123;</span><br><span class=\"line\">                borrowedBy = <span class=\"keyword\">new</span> AbandonedObjectCreatedException();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (state == PooledObjectState.EVICTION) &#123;</span><br><span class=\"line\">            state = PooledObjectState.EVICTION_RETURN_TO_HEAD;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>allocate() 定义了对象分配时的状态变化，当对象在空闲状态时才能被分配；如果对象正在做驱逐检查时,会把这个对象标记为EVICTION_RETURN_TO_HEAD.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"comment\">//返回值：对象是否当前未被使用</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">boolean</span> <span class=\"title\">endEvictionTest</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            Deque&lt;PooledObject&lt;T&gt;&gt; idleQueue)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (state == PooledObjectState.EVICTION) &#123;</span><br><span class=\"line\">            state = PooledObjectState.IDLE;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (state == PooledObjectState.EVICTION_RETURN_TO_HEAD) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//如果状态是EVICTION_RETURN_TO_HEAD表示当前这个对象试图被借出，返回false.</span></span><br><span class=\"line\">            state = PooledObjectState.IDLE;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!idleQueue.offerFirst(<span class=\"keyword\">this</span>)) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// TODO - Should never happen</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>endEvictionTest()定义了驱逐检查之后对象状态的变化，可以看到EVICTION_RETURN_TO_HEAD状态的对象被放到空闲队列队头。</p>\n<p>allocate()和borrowedCount等使用synchronized，violatile都做了线程安全的处理。</p>\n<h2 id=\"定义对象工厂\"><a href=\"#定义对象工厂\" class=\"headerlink\" title=\"定义对象工厂\"></a>定义对象工厂</h2><p>commons-pool为了管理多种对象使用工厂模式来创建要管理的对象，使用工厂方法后使用者可以通过重写PooledObjectFactory定义对象的实现，销毁，验证的具体实现，而commons-pool不需要关心这些细节它只管理PooledObject对象即可。</p>\n<p>工厂接口：PooledObjectFactory<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">PooledObjectFactory</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"function\">PooledObject&lt;T&gt; <span class=\"title\">makeObject</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">destroyObject</span><span class=\"params\">(PooledObject&lt;T&gt; p)</span> <span class=\"keyword\">throws</span> Exception</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">validateObject</span><span class=\"params\">(PooledObject&lt;T&gt; p)</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">activateObject</span><span class=\"params\">(PooledObject&lt;T&gt; p)</span> <span class=\"keyword\">throws</span> Exception</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">passivateObject</span><span class=\"params\">(PooledObject&lt;T&gt; p)</span> <span class=\"keyword\">throws</span> Exception</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>工厂抽象类：BasePooledObjectFactory<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BasePooledObjectFactory</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">PooledObjectFactory</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">...</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> T <span class=\"title\">create</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> PooledObject&lt;T&gt; <span class=\"title\">wrap</span><span class=\"params\">(T obj)</span></span>;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> PooledObject&lt;T&gt; <span class=\"title\">makeObject</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> wrap(create());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">validateObject</span><span class=\"params\">(PooledObject&lt;T&gt; p)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>BasePooledObjectFactory添加了create,wrap两个抽象方法，create可以返回我们要放在连接池的对象，然后使用wrap封装为PooledObject即可，注意validateObject默认返回true;</p>\n<h2 id=\"对象池定义\"><a href=\"#对象池定义\" class=\"headerlink\" title=\"对象池定义\"></a>对象池定义</h2><p>对象池是我们保存对象的地方，对象的获取，归还和定时检查都通过对象池来实现。以GenericObjectPool为例，对象池使用了线程安全的集合类来保存对象，LinkedBlockingDeque用于保存空闲的对象，ConcurrentHashMap保存全部对象（包括各种状态）。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> LinkedBlockingDeque&lt;PooledObject&lt;T&gt;&gt; idleObjects = <span class=\"keyword\">new</span> LinkedBlockingDeque&lt;PooledObject&lt;T&gt;&gt;();</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;T, PooledObject&lt;T&gt;&gt; allObjects = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;T, PooledObject&lt;T&gt;&gt;();</span><br></pre></td></tr></table></figure></p>\n<p>borrowObject()从连接池获取对象：<br>连接池借出对象时，经过Abandoned和validate两种检查，在连接池满时根据配置执行对应的等待策略，当没有可用对象时会抛出异常。</p>\n<p>Abandoned检查目标是连接池所有被借出的对象，主要防止对象借出之后长时间被占用，不能退还（或者使用者忘记return）到连接池导致连接被耗尽。超时时间由AbandonedConfig定义。</p>\n<p>validate检查目标是当前即将被借出的对象，目的是保证提供的对象是可用的，检查方式由对象工厂的validateObject方法定义。对象工厂还有activateObject方法来验证对象，不过这个方法是强制执行的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">borrowObject</span><span class=\"params\">(<span class=\"keyword\">long</span> borrowMaxWaitMillis)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">// getNumIdle() 表示当前空空闲对象数量，getNumActive() 表示当前非空闲的对象数量，getMaxTotal()表示连接池容量</span></span><br><span class=\"line\"><span class=\"comment\">// 那么假设最大容量10个，非空闲8个 &gt; 7 ，空闲对象只要少于2个，就需要开始Abandoned检查</span></span><br><span class=\"line\"></span><br><span class=\"line\">        AbandonedConfig ac = <span class=\"keyword\">this</span>.abandonedConfig;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ac != <span class=\"keyword\">null</span> &amp;&amp; ac.getRemoveAbandonedOnBorrow() &amp;&amp;</span><br><span class=\"line\">                (getNumIdle() &lt; <span class=\"number\">2</span>) &amp;&amp;</span><br><span class=\"line\">                (getNumActive() &gt; getMaxTotal() - <span class=\"number\">3</span>) ) &#123;</span><br><span class=\"line\">            removeAbandoned(ac);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        PooledObject&lt;T&gt; p = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//拷贝了变量 blockWhenExhausted</span></span><br><span class=\"line\">        <span class=\"comment\">//因为blockWhenExhausted的修改方法是public的，这样保证在并发情况下，方法执行周期内变量也不会变化</span></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> blockWhenExhausted = getBlockWhenExhausted();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> create;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> waitTime = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (p == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            create = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 设置了对象池耗尽时等待</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (blockWhenExhausted) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//从空闲队列取对象</span></span><br><span class=\"line\">                p = idleObjects.pollFirst();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//没有空闲对象 新建一个</span></span><br><span class=\"line\">                    create = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                    p = create();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (borrowMaxWaitMillis &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">//注意：没配置等待时间，会一直阻塞</span></span><br><span class=\"line\">                        p = idleObjects.takeFirst();</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"comment\">//按照配置的时间等待</span></span><br><span class=\"line\">.....</span><br><span class=\"line\">                        p = idleObjects.pollFirst(borrowMaxWaitMillis,</span><br><span class=\"line\">                                TimeUnit.MILLISECONDS);</span><br><span class=\"line\">.....</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                 <span class=\"comment\">//等待之后还是没有空闲对象</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NoSuchElementException(</span><br><span class=\"line\">                            <span class=\"string\">\"Timeout waiting for idle object\"</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                 <span class=\"comment\">//等待之后获得对象 尝试分配对象</span></span><br><span class=\"line\">                 <span class=\"comment\">//这个方法由pooledobject实现</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!p.allocate()) &#123;</span><br><span class=\"line\">                    p = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">//没有配置blockWhenExhausted 不等待</span></span><br><span class=\"line\">                p = idleObjects.pollFirst();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    create = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                    p = create();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NoSuchElementException(<span class=\"string\">\"Pool exhausted\"</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!p.allocate()) &#123;</span><br><span class=\"line\">                    p = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//对象分配成功</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                   <span class=\"comment\">//激活对象</span></span><br><span class=\"line\">                    factory.activateObject(p);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        destroy(p);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (Exception e1) &#123;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    p = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    .....</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">//如果配置了对象检查</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p != <span class=\"keyword\">null</span> &amp;&amp; (getTestOnBorrow() || create &amp;&amp; getTestOnCreate())) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">boolean</span> validate = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                    Throwable validationThrowable = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        validate = factory.validateObject(p);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">                        PoolUtils.checkRethrow(t);</span><br><span class=\"line\">                        validationThrowable = t;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (!validate) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//验证失败 销毁对象</span></span><br><span class=\"line\">                        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                            destroy(p);</span><br><span class=\"line\">                         destroyedByBorrowValidationCount.incrementAndGet();</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        p = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                        .....</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//更新借出时间等信息</span></span><br><span class=\"line\">        updateStatsBorrow(p, waitTime);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> p.getObject();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>evict()驱逐对象：</p>\n<p>evict驱逐检查：上面介绍了两种对象的检查方式，evictor不同之处在于它由后台线程独立来完成，检查对象主要是连接池中的空闲连接，超时时间等可通过EvictionConfig配置。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">evict</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//确保连接池打开</span></span><br><span class=\"line\">        assertOpen();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (idleObjects.size() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            PooledObject&lt;T&gt; underTest = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            </span><br><span class=\"line\">            EvictionPolicy&lt;T&gt; evictionPolicy = getEvictionPolicy();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (evictionLock) &#123;</span><br><span class=\"line\">                ...</span><br><span class=\"line\">                <span class=\"comment\">// 复制变量保证函数内值不改变，同上</span></span><br><span class=\"line\">                <span class=\"keyword\">boolean</span> testWhileIdle = getTestWhileIdle();</span><br><span class=\"line\">                <span class=\"comment\">//每次驱逐对象数可配置</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, m = getNumTests(); i &lt; m; i++) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (evictionIterator == <span class=\"keyword\">null</span> || !evictionIterator.hasNext()) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">//驱逐检查的顺序和空闲队列出入顺序保持一致 </span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (getLifo()) &#123;</span><br><span class=\"line\">                            <span class=\"comment\">//后进先出(逆序遍历)</span></span><br><span class=\"line\">                            evictionIterator = idleObjects.descendingIterator();</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                            <span class=\"comment\">//先进先出</span></span><br><span class=\"line\">                            evictionIterator = idleObjects.iterator();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (!evictionIterator.hasNext()) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// Pool exhausted, nothing to do here</span></span><br><span class=\"line\">                        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        underTest = evictionIterator.next();</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (NoSuchElementException nsee) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">//因为idleObjects.iterator()方法并没有做同步控制，可能被检查的空闲对象再检查期间已经被借出不在队列中了，在并发条件下要考虑这种情况。。</span></span><br><span class=\"line\">                        <span class=\"comment\">// Object was borrowed in another thread</span></span><br><span class=\"line\">                        <span class=\"comment\">// Don't count this as an eviction test so reduce i;</span></span><br><span class=\"line\">                        i--;</span><br><span class=\"line\">                        evictionIterator = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"comment\">//再次检查，对象在队列中但是要保证状态是空闲。。。</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (!underTest.startEvictionTest()) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// Object was borrowed in another thread</span></span><br><span class=\"line\">                        <span class=\"comment\">// Don't count this as an eviction test so reduce i;</span></span><br><span class=\"line\">                        i--;</span><br><span class=\"line\">                        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"comment\">//EvictionPolicy定义了驱逐对象的策略，默认实现是DefaultEvictionPolicy</span></span><br><span class=\"line\">                    <span class=\"comment\">//调用ObjectPool的setEvictionPolicyClassName方法指定自定义策略</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (evictionPolicy.evict(evictionConfig, underTest,</span><br><span class=\"line\">                            idleObjects.size())) &#123;</span><br><span class=\"line\">                        destroy(underTest);</span><br><span class=\"line\">                        destroyedByEvictorCount.incrementAndGet();</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (testWhileIdle) &#123;</span><br><span class=\"line\">                            ...</span><br><span class=\"line\">                            <span class=\"comment\">//执行activateObject&amp;validateObject的检查</span></span><br><span class=\"line\">                            ...</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        ...</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//无处不在的Abandoned检查，可以配置连接池是否在evictor线程中执行removeAbandoned</span></span><br><span class=\"line\">        AbandonedConfig ac = <span class=\"keyword\">this</span>.abandonedConfig;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ac != <span class=\"keyword\">null</span> &amp;&amp; ac.getRemoveAbandonedOnMaintenance()) &#123;</span><br><span class=\"line\">            removeAbandoned(ac);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>驱逐线程的调用：<br>了解驱逐对象时要做的操作之后，我们来看一下后台的驱逐者线程是怎么定义&amp;启动的<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//GenericObjectPool.java</span></span><br><span class=\"line\"><span class=\"comment\">//构造方法中启动驱逐者线程</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">GenericObjectPool</span><span class=\"params\">(PooledObjectFactory&lt;T&gt; factory,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            GenericObjectPoolConfig config)</span> </span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        startEvictor(getTimeBetweenEvictionRunsMillis());</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>驱逐线程的定义：<br>驱逐者Evictor,在BaseGenericObjectPool中定义，本质是由java.util.TimerTask定义的定时任务<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//父类BaseGenericObjectPool.java</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">startEvictor</span><span class=\"params\">(<span class=\"keyword\">long</span> delay)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//BaseGenericObjectPool的私有成员，final Object evictionLock = new Object();做对象锁</span></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (evictionLock) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> != evictor) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//已存在evictor，取消驱逐者线程，所以也可以二次调用startEvictor来停止驱逐检查</span></span><br><span class=\"line\">                EvictionTimer.cancel(evictor);</span><br><span class=\"line\">                evictor = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                evictionIterator = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (delay &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                evictor = <span class=\"keyword\">new</span> Evictor();</span><br><span class=\"line\">                EvictionTimer.schedule(evictor, delay, delay);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>Evitor定义：这里有一个比较有意思的问题，驱逐者线程Evictor被多个连接池共享,但是这些连接池可能属于不同的classloader,Evictor必须要保证它的所有行为在<strong>当前这个连接池的classloader</strong>下执行（这是开发者给commons-pool提交的bug,<a href=\"https://issues.apache.org/jira/browse/POOL-161\" target=\"_blank\" rel=\"noopener\">详细描述请看这里</a>）<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//内部类Evictor</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Evictor</span> <span class=\"keyword\">extends</span> <span class=\"title\">TimerTask</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            ClassLoader savedClassLoader =</span><br><span class=\"line\">                    Thread.currentThread().getContextClassLoader();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 切换到当前连接池的classLoader</span></span><br><span class=\"line\">                Thread.currentThread().setContextClassLoader(</span><br><span class=\"line\">                        factoryClassLoader);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 执行上面的evict()方法</span></span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    evict();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span>(Exception e) &#123;</span><br><span class=\"line\">                    swallowException(e);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span>(OutOfMemoryError oome) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// Log problem but give evictor thread a chance to continue</span></span><br><span class=\"line\">                    <span class=\"comment\">// in case error is recoverable</span></span><br><span class=\"line\">                    oome.printStackTrace(System.err);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 驱逐之后还要保证空闲连接数量不能小于配置</span></span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    ensureMinIdle();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                    swallowException(e);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 切换回之前的classLoader</span></span><br><span class=\"line\">                Thread.currentThread().setContextClassLoader(savedClassLoader);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>驱逐策略：<br>在evict()方法中最后对象是否要被驱逐是调用了evictionPolicy.evict()的方法来判断的，commons-pool提供的驱逐策略如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//DefaultEvictionPolicy.java</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DefaultEvictionPolicy</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">EvictionPolicy</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">evict</span><span class=\"params\">(EvictionConfig config, PooledObject&lt;T&gt; underTest,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">int</span> idleCount)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//getIdleTimeMillis()空闲时间</span></span><br><span class=\"line\">        <span class=\"comment\">//config.getIdleSoftEvictTime()空闲连接大于配置的最小值时的超时时间</span></span><br><span class=\"line\">        <span class=\"comment\">//config.getIdleEvictTime()空闲连接超时时间与数量无关</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((config.getIdleSoftEvictTime() &lt; underTest.getIdleTimeMillis() &amp;&amp;</span><br><span class=\"line\">                config.getMinIdle() &lt; idleCount) ||</span><br><span class=\"line\">                config.getIdleEvictTime() &lt; underTest.getIdleTimeMillis()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>驱逐策略是支持自定义的，这里使用的是设计模式中的策略模式，我们只要实现EvictionPolicy接口，然后调用setEvictionPolicyClassName()方法既可以更换驱逐策略（实现类要尽可能简单，只描述一种算法即可）：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//父类BaseGenericObjectPool.java</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">setEvictionPolicyClassName</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            String evictionPolicyClassName)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//使用接口+反射实现的策略模式</span></span><br><span class=\"line\">            Class&lt;?&gt; clazz = Class.forName(evictionPolicyClassName);</span><br><span class=\"line\">            Object policy = clazz.newInstance();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (policy <span class=\"keyword\">instanceof</span> EvictionPolicy&lt;?&gt;) &#123;</span><br><span class=\"line\">                <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>) </span><br><span class=\"line\">                EvictionPolicy&lt;T&gt; evicPolicy = (EvictionPolicy&lt;T&gt;) policy;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.evictionPolicy = evicPolicy;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException e) &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InstantiationException e) &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IllegalAccessException e) &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>通过阅读GenericObjectPool的部分代码，可以看出来并没有在每个获取&amp;退还对象的方法都做同步控制，线程安全主要是由LinkedBlockingDeque，ConcurrentHashMap这两个并发集合保证的，因此开发者在编写非线程安全方法时也使用了局部变量复制可能被修改的值，多次检查对象状态之类的方法保证并发条件下程序正常的执行（没全部加锁能够提升性能，不过也会有这样的麻烦）。<br>总结一下连接池中对象的声明周期大概如下图：<br><img src=\"https://www.throwsnew.com/img/common-pool2.png\" alt=\"流程图\"><br>蓝色线是evictor执行时对象状态的变化，红线是abandon执行的过程，绿色线是正常使用中对象的变化。</p>\n<h2 id=\"其他功能\"><a href=\"#其他功能\" class=\"headerlink\" title=\"其他功能\"></a>其他功能</h2><p>附上一份objectpool的配置选项<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GenericObjectPoolConfig poolConfig = <span class=\"keyword\">new</span> GenericObjectPoolConfig();</span><br><span class=\"line\"></span><br><span class=\"line\">基本配置：</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//最大连接</span></span><br><span class=\"line\">        poolConfig.setMaxTotal(<span class=\"number\">100</span>);</span><br><span class=\"line\">        <span class=\"comment\">//最大空闲连接</span></span><br><span class=\"line\">        poolConfig.setMaxIdle(<span class=\"number\">5</span>);</span><br><span class=\"line\">        <span class=\"comment\">//最小空闲连接 </span></span><br><span class=\"line\">        poolConfig.setMinIdle(<span class=\"number\">5</span>);</span><br><span class=\"line\">        <span class=\"comment\">//连接满时最多等待时间</span></span><br><span class=\"line\">        poolConfig.setMaxWaitMillis(<span class=\"number\">5000L</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">高级功能：</span><br><span class=\"line\">         <span class=\"comment\">//使用时检查对象（默认不检查）</span></span><br><span class=\"line\">        poolConfig.setTestWhileIdle(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        poolConfig.setTestOnCreate(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        poolConfig.setTestOnBorrow(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        poolConfig.setTestOnReturn(<span class=\"keyword\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//jmx启用 之后可以实时的查看线程池对象的状态</span></span><br><span class=\"line\">        poolConfig.setJmxEnabled(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">        poolConfig.setJmxNameBase(<span class=\"string\">\"namebase\"</span>);</span><br><span class=\"line\">        poolConfig.setJmxNamePrefix(<span class=\"string\">\"nameprefix\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"comment\">//驱逐线程每次检查对象个数</span></span><br><span class=\"line\">        poolConfig.setNumTestsPerEvictionRun(<span class=\"number\">2</span>);</span><br><span class=\"line\">        <span class=\"comment\">//空闲连接被驱逐前能够保留的时间</span></span><br><span class=\"line\">        poolConfig.setMinEvictableIdleTimeMillis(<span class=\"number\">10000L</span>);</span><br><span class=\"line\">        <span class=\"comment\">//当空闲线程大于minIdle 空闲连接能够保留时间，同时指定会被上面的覆盖</span></span><br><span class=\"line\">        poolConfig.setSoftMinEvictableIdleTimeMillis(<span class=\"number\">10000L</span>);</span><br><span class=\"line\">        <span class=\"comment\">//驱逐线程执行间隔时间</span></span><br><span class=\"line\">        poolConfig.setTimeBetweenEvictionRunsMillis(<span class=\"number\">200000L</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//放弃长时间占用连接的对象</span></span><br><span class=\"line\">       AbandonedConfig abandonedConfig=<span class=\"keyword\">new</span> AbandonedConfig();</span><br><span class=\"line\">       abandonedConfig.setLogAbandoned(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">       abandonedConfig.setUseUsageTracking(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">       abandonedConfig.setRemoveAbandonedOnBorrow(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">       abandonedConfig.setRemoveAbandonedOnMaintenance(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">       abandonedConfig.setRemoveAbandonedTimeout(<span class=\"number\">20</span>);<span class=\"comment\">//second</span></span><br></pre></td></tr></table></figure></p>"}],"PostAsset":[],"PostCategory":[{"post_id":"cjp57u3wl00022xpbgd96hojz","category_id":"cjp57u3ws00062xpbjt6dapxg","_id":"cjp57u3x2000g2xpbaj2l608q"},{"post_id":"cjp57u3wp00042xpbeybm9foe","category_id":"cjp57u3x0000c2xpb3fpil7pk","_id":"cjp57u3x5000n2xpbn4t6r7uc"},{"post_id":"cjp57u3wu00082xpbr6iatsb5","category_id":"cjp57u3x2000h2xpb3zj6cksp","_id":"cjp57u3x6000r2xpbm2lz4z7v"},{"post_id":"cjp57u3x4000l2xpb3hrui7hq","category_id":"cjp57u3x5000q2xpb8cnv7tjq","_id":"cjp57u3x6000v2xpbek63j0xn"},{"post_id":"cjp57u41k001m2xpb4ocn0uiz","category_id":"cjp57u3x0000c2xpb3fpil7pk","_id":"cjp57u41p001s2xpb8xly1moj"},{"post_id":"cjp57u41l001o2xpbjxas1hcu","category_id":"cjp57u3x5000q2xpb8cnv7tjq","_id":"cjp57u41p001u2xpbkzyytb30"},{"post_id":"cjp57u41n001q2xpbw6v0jxhj","category_id":"cjp57u3x5000q2xpb8cnv7tjq","_id":"cjp57u41q001x2xpbhht0him0"},{"post_id":"cjp57u42d00252xpb2sljsrsv","category_id":"cjp57u42f00262xpbrce0y0th","_id":"cjp57u42f00292xpbiuvc1c87"}],"PostTag":[{"post_id":"cjp57u3wl00022xpbgd96hojz","tag_id":"cjp57u3wt00072xpbj1ejkw1r","_id":"cjp57u3x4000k2xpb50vbfbep"},{"post_id":"cjp57u3wl00022xpbgd96hojz","tag_id":"cjp57u3x0000d2xpbnkz3me96","_id":"cjp57u3x5000m2xpbbnz6otvi"},{"post_id":"cjp57u3wp00042xpbeybm9foe","tag_id":"cjp57u3x2000i2xpbj0cvpsyk","_id":"cjp57u3x5000p2xpb12ejq2ft"},{"post_id":"cjp57u3wu00082xpbr6iatsb5","tag_id":"cjp57u3x5000o2xpbq5tt7hlv","_id":"cjp57u3x6000u2xpb5p2fc91z"},{"post_id":"cjp57u3wu00082xpbr6iatsb5","tag_id":"cjp57u3x6000s2xpbgjfztwpt","_id":"cjp57u3x6000w2xpbnoniwpmg"},{"post_id":"cjp57u3wx000a2xpblx1n0a55","tag_id":"cjp57u3x6000t2xpbe0o6nci5","_id":"cjp57u3x6000y2xpblpey25s1"},{"post_id":"cjp57u3wz000b2xpbde8ovrpi","tag_id":"cjp57u3wt00072xpbj1ejkw1r","_id":"cjp57u3x700112xpbb625u1r8"},{"post_id":"cjp57u3wz000b2xpbde8ovrpi","tag_id":"cjp57u3x6000x2xpb58irme8q","_id":"cjp57u3x700122xpb7f0v1i5s"},{"post_id":"cjp57u3wz000b2xpbde8ovrpi","tag_id":"cjp57u3x6000z2xpbhltsvvyz","_id":"cjp57u3x700142xpb1vsebd73"},{"post_id":"cjp57u3x0000e2xpbfi3qy8k7","tag_id":"cjp57u3x700102xpbwmet5jrf","_id":"cjp57u3x700152xpb0kyki0ow"},{"post_id":"cjp57u3x1000f2xpbzutr2qr4","tag_id":"cjp57u3x700132xpbje7lrdos","_id":"cjp57u3x800182xpbz7h5yjz5"},{"post_id":"cjp57u3x1000f2xpbzutr2qr4","tag_id":"cjp57u3x800162xpbbsi45wwg","_id":"cjp57u3x800192xpbfntn4gfn"},{"post_id":"cjp57u3x3000j2xpb3ratgcjk","tag_id":"cjp57u3x800172xpbvk41i634","_id":"cjp57u3x8001d2xpb7lsva29b"},{"post_id":"cjp57u3x3000j2xpb3ratgcjk","tag_id":"cjp57u3x8001a2xpbxd4qddcl","_id":"cjp57u3x9001e2xpb0uogweaz"},{"post_id":"cjp57u3x3000j2xpb3ratgcjk","tag_id":"cjp57u3x8001b2xpbkq9pyy09","_id":"cjp57u3x9001g2xpbys09tdp3"},{"post_id":"cjp57u3x4000l2xpb3hrui7hq","tag_id":"cjp57u3x8001c2xpbrhiutqf0","_id":"cjp57u3x9001i2xpbtwxqin1l"},{"post_id":"cjp57u3x4000l2xpb3hrui7hq","tag_id":"cjp57u3x9001f2xpbqeg8ax3t","_id":"cjp57u3x9001j2xpbp8gz15i9"},{"post_id":"cjp57u3x4000l2xpb3hrui7hq","tag_id":"cjp57u3x9001h2xpbnagn1y8r","_id":"cjp57u3x9001k2xpbfbdjlb7z"},{"post_id":"cjp57u41l001o2xpbjxas1hcu","tag_id":"cjp57u3x8001c2xpbrhiutqf0","_id":"cjp57u41p001r2xpbbwumywvi"},{"post_id":"cjp57u41l001o2xpbjxas1hcu","tag_id":"cjp57u3x9001h2xpbnagn1y8r","_id":"cjp57u41p001t2xpbvc8bbbtd"},{"post_id":"cjp57u41l001o2xpbjxas1hcu","tag_id":"cjp57u3x9001f2xpbqeg8ax3t","_id":"cjp57u41q001w2xpbk6w9q5ne"},{"post_id":"cjp57u41n001q2xpbw6v0jxhj","tag_id":"cjp57u3x8001c2xpbrhiutqf0","_id":"cjp57u41q001y2xpb8bk0e9hr"},{"post_id":"cjp57u41n001q2xpbw6v0jxhj","tag_id":"cjp57u3x9001f2xpbqeg8ax3t","_id":"cjp57u41q00202xpbuxu0tq72"},{"post_id":"cjp57u41n001q2xpbw6v0jxhj","tag_id":"cjp57u3x9001h2xpbnagn1y8r","_id":"cjp57u41q00212xpbglkfp5s6"},{"post_id":"cjp57u41k001m2xpb4ocn0uiz","tag_id":"cjp57u41n001p2xpbkeoo40fe","_id":"cjp57u41r00222xpbivg0f18z"},{"post_id":"cjp57u41k001m2xpb4ocn0uiz","tag_id":"cjp57u41p001v2xpbf8njlbk0","_id":"cjp57u41r00232xpb64vfc6xs"},{"post_id":"cjp57u41k001m2xpb4ocn0uiz","tag_id":"cjp57u41q001z2xpbpxza9c3y","_id":"cjp57u41r00242xpb2ea8jvmn"},{"post_id":"cjp57u42d00252xpb2sljsrsv","tag_id":"cjp57u42f00272xpbiw600a47","_id":"cjp57u42f002a2xpbpgrocc6t"},{"post_id":"cjp57u42d00252xpb2sljsrsv","tag_id":"cjp57u3x9001h2xpbnagn1y8r","_id":"cjp57u42f002b2xpbfn17cdyp"},{"post_id":"cjp57u42d00252xpb2sljsrsv","tag_id":"cjp57u42f00282xpbafkh7m14","_id":"cjp57u42f002c2xpbgibbo0cw"}],"Tag":[{"name":"java基础","_id":"cjp57u3wt00072xpbj1ejkw1r"},{"name":"并发","_id":"cjp57u3x0000d2xpbnkz3me96"},{"name":"mesos","_id":"cjp57u3x2000i2xpbj0cvpsyk"},{"name":"mysql","_id":"cjp57u3x5000o2xpbq5tt7hlv"},{"name":"数据库","_id":"cjp57u3x6000s2xpbgjfztwpt"},{"name":"Spring","_id":"cjp57u3x6000t2xpbe0o6nci5"},{"name":"注解","_id":"cjp57u3x6000x2xpb58irme8q"},{"name":"annotation","_id":"cjp57u3x6000z2xpbhltsvvyz"},{"name":"邮件","_id":"cjp57u3x700102xpbwmet5jrf"},{"name":"shell","_id":"cjp57u3x700132xpbje7lrdos"},{"name":"Linux","_id":"cjp57u3x800162xpbbsi45wwg"},{"name":"kafaka","_id":"cjp57u3x800172xpbvk41i634"},{"name":"zookeeper","_id":"cjp57u3x8001a2xpbxd4qddcl"},{"name":"集群","_id":"cjp57u3x8001b2xpbkq9pyy09"},{"name":"redis","_id":"cjp57u3x8001c2xpbrhiutqf0"},{"name":"nosql","_id":"cjp57u3x9001f2xpbqeg8ax3t"},{"name":"源码","_id":"cjp57u3x9001h2xpbnagn1y8r"},{"name":"jenkins","_id":"cjp57u41n001p2xpbkeoo40fe"},{"name":"docker","_id":"cjp57u41p001v2xpbf8njlbk0"},{"name":"kubernetes","_id":"cjp57u41q001z2xpbpxza9c3y"},{"name":"连接池","_id":"cjp57u42f00272xpbiw600a47"},{"name":"commons-pool","_id":"cjp57u42f00282xpbafkh7m14"}]}}